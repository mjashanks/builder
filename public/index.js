/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@nx-js/compiler-util/dist/es.es5.js":
/*!**********************************************************!*\
  !*** ./node_modules/@nx-js/compiler-util/dist/es.es5.js ***!
  \**********************************************************/
/*! exports provided: compileExpression, compileCode, compileRawExpression, compileRawCode, expose, hide, hideAll, filters, limiters, filter, limiter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compileExpression", function() { return compileExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compileCode", function() { return compileCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compileRawExpression", function() { return compileRawExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compileRawCode", function() { return compileRawCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expose", function() { return expose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hide", function() { return hide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hideAll", function() { return hideAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filters", function() { return filters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "limiters", function() { return limiters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "limiter", function() { return limiter; });
var filters = new Map();
var limiters = new Map();

function filter(name, handler) {
  if (typeof name !== 'string') {
    throw new TypeError('First argument must be a string.');
  }
  if (typeof handler !== 'function') {
    throw new TypeError('Second argument must be a function.');
  }
  if (filters.has(name)) {
    throw new Error(("A filter named " + name + " is already registered."));
  }
  filters.set(name, handler);
}

function limiter(name, handler) {
  if (typeof name !== 'string') {
    throw new TypeError('First argument must be a string.');
  }
  if (typeof handler !== 'function') {
    throw new TypeError('Second argument must be a function.');
  }
  if (limiters.has(name)) {
    throw new Error(("A limiter named " + name + " is already registered."));
  }
  limiters.set(name, handler);
}

function compileRawExpression(src) {
  return new Function('context', 'tempVars', // eslint-disable-line
  ("const sandbox = $nxCompileToSandbox(context, tempVars)\n    try { with (sandbox) { return " + src + " } } catch (err) {\n      if (!(err instanceof TypeError)) throw err\n    }\n    $nxClearSandbox()"));
}

function compileRawCode(src) {
  return new Function('context', 'tempVars', // eslint-disable-line
  ("const sandbox = $nxCompileToSandbox(context, tempVars)\n    with (sandbox) { " + src + " }\n    $nxClearSandbox()"));
}

var filterRegex = /(?:[^\|]|\|\|)+/g;
var limiterRegex = /(?:[^&]|&&)+/g;
var argsRegex = /\S+/g;

function parseExpression(src) {
  var tokens = src.match(filterRegex);
  if (tokens.length === 1) {
    return compileRawExpression(tokens[0]);
  }

  var expression = {
    exec: compileRawExpression(tokens[0]),
    filters: []
  };
  for (var i = 1; i < tokens.length; i++) {
    var filterTokens = tokens[i].match(argsRegex);
    var filterName = filterTokens.shift();
    var effect = filters.get(filterName);
    if (!effect) {
      throw new Error(("There is no filter named: " + filterName + "."));
    }
    expression.filters.push({ effect: effect, argExpressions: filterTokens.map(compileRawExpression) });
  }
  return expression;
}

function parseCode(src) {
  var tokens = src.match(limiterRegex);
  if (tokens.length === 1) {
    return compileRawCode(tokens[0]);
  }

  var code = {
    exec: compileRawCode(tokens[0]),
    limiters: []
  };
  for (var i = 1; i < tokens.length; i++) {
    var limiterTokens = tokens[i].match(argsRegex);
    var limiterName = limiterTokens.shift();
    var effect = limiters.get(limiterName);
    if (!effect) {
      throw new Error(("There is no limiter named: " + limiterName + "."));
    }
    code.limiters.push({ effect: effect, argExpressions: limiterTokens.map(compileRawExpression) });
  }
  return code;
}

var expressionCache = new Map();
var codeCache = new Map();

function compileExpression(src) {
  if (typeof src !== 'string') {
    throw new TypeError('First argument must be a string.');
  }
  var expression = expressionCache.get(src);
  if (!expression) {
    expression = parseExpression(src);
    expressionCache.set(src, expression);
  }

  if (typeof expression === 'function') {
    return expression;
  }

  return function evaluateExpression(context, tempVars) {
    var value = expression.exec(context, tempVars);
    for (var i = 0, list = expression.filters; i < list.length; i += 1) {
      var filter = list[i];

      var args = filter.argExpressions.map(evaluateArgExpression, context);
      value = filter.effect.apply(filter, [ value ].concat( args ));
    }
    return value;
  };
}

function compileCode(src) {
  if (typeof src !== 'string') {
    throw new TypeError('First argument must be a string.');
  }
  var code = codeCache.get(src);
  if (!code) {
    code = parseCode(src);
    codeCache.set(src, code);
  }

  if (typeof code === 'function') {
    return code;
  }

  var context = {};
  return function evaluateCode(state, tempVars) {
    var i = 0;
    function next() {
      Object.assign(context, tempVars);
      if (i < code.limiters.length) {
        var limiter = code.limiters[i++];
        var args = limiter.argExpressions.map(evaluateArgExpression, state);
        limiter.effect.apply(limiter, [ next, context ].concat( args ));
      } else {
        code.exec(state, tempVars);
      }
    }
    next();
  };
}

function evaluateArgExpression(argExpression) {
  return argExpression(this);
}

var hasHandler = { has: has };
var allHandlers = { has: has, get: get };
var globals = new Set();
var temp;

var globalObj;
if (typeof window !== 'undefined') { globalObj = window; } // eslint-disable-line
else if (typeof global !== 'undefined') { globalObj = global; } // eslint-disable-line
  else if (typeof self !== 'undefined') { globalObj = self; } // eslint-disable-line
globalObj.$nxCompileToSandbox = toSandbox;
globalObj.$nxClearSandbox = clearSandbox;

function expose() {
  var globalNames = [], len = arguments.length;
  while ( len-- ) globalNames[ len ] = arguments[ len ];

  for (var i = 0, list = globalNames; i < list.length; i += 1) {
    var globalName = list[i];

    globals.add(globalName);
  }
}

function hide() {
  var globalNames = [], len = arguments.length;
  while ( len-- ) globalNames[ len ] = arguments[ len ];

  for (var i = 0, list = globalNames; i < list.length; i += 1) {
    var globalName = list[i];

    globals.delete(globalName);
  }
}

function hideAll() {
  globals.clear();
}

function has(target, key) {
  return globals.has(key) ? key in target : true;
}

function get(target, key) {
  return key in temp ? temp[key] : target[key];
}

function toSandbox(obj, tempVars) {
  if (tempVars) {
    temp = tempVars;
    return new Proxy(obj, allHandlers);
  }
  return new Proxy(obj, hasHandler);
}

function clearSandbox() {
  temp = undefined;
}



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/budibase-core/budibase-core.umd.js":
/*!*********************************************************!*\
  !*** ./node_modules/budibase-core/budibase-core.umd.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(/*! lodash/fp */ "./node_modules/lodash/fp.js"), __webpack_require__(/*! shortid */ "./node_modules/shortid/index.js"), __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js"), __webpack_require__(/*! @nx-js/compiler-util */ "./node_modules/@nx-js/compiler-util/dist/es.es5.js"), __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js"), __webpack_require__(/*! string_decoder */ "./node_modules/string_decoder/lib/string_decoder.js"), __webpack_require__(/*! lunr */ "./node_modules/lunr/lunr.js"), __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js")) :
    undefined;
}(this, (function (exports,fp,shortid,_,compilerUtil,safeBuffer,string_decoder,lunr,path) { 'use strict';

    var ___default = 'default' in _ ? _['default'] : _;
    lunr = lunr && lunr.hasOwnProperty('default') ? lunr['default'] : lunr;

    const commonPlus = (extra) => 
        fp.union(["onBegin", "onComplete", "onError"])
        (extra);

    const common = () => commonPlus([]);

    const _events = {
        recordApi : {
            save: commonPlus([
                "onInvalid",
                "onRecordUpdated",
                "onRecordCreated"]),
            delete: common(),
            getContext: common(),
            getNew: common(),
            load: common(),
            validate: common(),
            uploadFile: common(),
            downloadFile: common()
        },
        indexApi : {
            buildIndex: common(),
            listItems: common(),
            delete: common(),
            aggregates: common(),
        },
        collectionApi: {
            getAllowedRecordTypes: common(),
            initialise: common(),
            delete: common()
        },
        authApi: {
            authenticate: common(),
            authenticateTemporaryAccess: common(),
            createTemporaryAccess: common(),
            createUser: common(),
            enableUser: common(),
            disableUser: common(),
            loadAccessLevels: common(),
            getNewAccessLevel: common(),
            getNewUser: common(),
            getNewUserAuth: common(),
            getUsers: common(),
            saveAccessLevels: common(),
            isAuthorized: common(),
            changeMyPassword: common(),
            setPasswordFromTemporaryCode: common(),
            scorePassword: common(),
            isValidPassword: common(),
            validateUser: common(),
            validateAccessLevels: common(),
            setUserAccessLevels: common()
        },
        templateApi: {
            saveApplicationHeirarchy: common(),
            saveActionsAndTriggers: common()
        },
        actionsApi: {
            execute: common()
        }
    };

    const _eventsList = [];

    const makeEvent = (area,  method, name) =>
        `${area}:${method}:${name}`;

    for(let areaKey in _events) {
        for(let methodKey in _events[areaKey]) {
            _events[areaKey][methodKey] = 
                fp.reduce((obj,s) => {
                    obj[s] = makeEvent(areaKey,methodKey,s);
                    return obj;
                }
                  ,{})
                (_events[areaKey][methodKey]);
        }
    }


    for(let areaKey in _events) {
        for(let methodKey in _events[areaKey]) {
            for(let name in _events[areaKey][methodKey]) {
                _eventsList.push(
                    _events[areaKey][methodKey][name]
                );
            }
        }
    }


    const events = _events;

    const eventsList = _eventsList;

    const apiWrapper = async (app, eventNamespace, isAuthorized, eventContext, func, ...params) => {

        pushCallStack(app,eventNamespace);

        if(!isAuthorized(app)) {
            handleNotAuthorized(app, eventContext, eventNamespace);
            return;
        }

        const startDate = Date.now();
        const elapsed = () => 
            (Date.now() - startDate);

        try {
            app.publish(
                eventNamespace.onBegin,
                eventContext
            ); 

            const result = await func(...params);
            
            publishComplete(app, eventContext, eventNamespace, elapsed, result);
            return result;

        } catch (error) {
            publishError(app, eventContext, eventNamespace, elapsed, error);
        }
    };

    const apiWrapperSync = (app, eventNamespace, isAuthorized, eventContext, func, ...params) => {

        pushCallStack(app,eventNamespace);

        if(!isAuthorized(app)) {
            handleNotAuthorized(app, eventContext, eventNamespace);
            return;
        }
        
        const startDate = Date.now();
        const elapsed = () => 
            (Date.now() - startDate);

        try {
            app.publish(
                eventNamespace.onBegin,
                eventContext
            ); 

            const result = func(...params);
            
            publishComplete(app, eventContext, eventNamespace, elapsed, result);
            return result;

        } catch (error) {
            publishError(app, eventContext, eventNamespace, elapsed, error);
        }
    };

    const handleNotAuthorized = (app, eventContext, eventNamespace) => {
        const err = new Error("Unauthorized");
        publishError(app, eventContext, eventNamespace, () => 0, err);
        throw err;
    };

    const pushCallStack = (app, eventNamespace, seedCallId) => {

        const callId = shortid.generate();

        const createCallStack = () => ({
            seedCallId: !fp.isUndefined(seedCallId) 
                        ? seedCallId
                        : callId,
            threadCallId:callId,
            stack: []
        });

        if(fp.isUndefined(app.calls)) {
            app.calls = createCallStack();
        }

        app.calls.stack.push({
            namespace:eventNamespace,
            callId
        });
    };

    const popCallStack = (app) => {
        app.calls.stack.pop();
        if(app.calls.stack.length === 0) {
            delete app.calls;
        }
    };

    const publishError = (app, eventContext, eventNamespace, elapsed, err) => {
        const ctx = fp.cloneDeep(eventContext);
        ctx.error = err;
        ctx.elapsed = elapsed();
        app.publish(
            eventNamespace.onError,
            ctx);
        popCallStack(app);
        throw err;
    };

    const publishComplete = (app, eventContext, eventNamespace, elapsed, result) => {
        const endcontext = fp.cloneDeep(eventContext);
        endcontext.result = result;
        endcontext.elapsed = elapsed();
        app.publish(
            eventNamespace.onComplete,
            endcontext);
        popCallStack(app);
        return result;
    };

    const lockOverlapMilliseconds = 10;

    const getLock$$1 = async (app, lockFile, timeoutMilliseconds, maxLockRetries, retryCount=0) => {
        try {
            const timeout = 
                (await app.getEpochTime())
                +
                timeoutMilliseconds;

            const lock = {
                timeout,
                key:lockFile,
                totalTimeout:timeoutMilliseconds
            };
            
            await app.datastore.createFile(
                lockFile, 
                getLockFileContent(
                    lock.totalTimeout, 
                    lock.timeout)
            );

            return lock;
        } catch(e) {

            if(retryCount == maxLockRetries)
                return NO_LOCK$$1;

            const lock = parseLockFileContent(
                lockFile,
                await app.datastore.loadFile(lockFile)
            );

            const currentEpochTime = await app.getEpochTime();

            if(currentEpochTime < lock.timeout) {
                return NO_LOCK$$1;
            }

            try {
                await app.datastore.deleteFile(lockFile);
            }
            catch(_$$1) {}        
            await sleepForRetry();

            return  await getLock$$1(
                app, lockFile, timeoutMilliseconds, 
                maxLockRetries, retryCount+1);        
        }

        return NO_LOCK$$1;
    };

    const getLockFileContent = (totalTimeout, epochTime) => 
        `${totalTimeout}:${epochTime.toString()}`;

    const parseLockFileContent = (key, content) =>  
        $(content, [
            fp.split(":"),
            parts => ({
                totalTimeout:new Number(parts[0]), 
                timeout:new Number(parts[1]),
                key
            })
        ]);

    const releaseLock$$1 = async (app,lock) => {

        const currentEpochTime = await app.getEpochTime();
        // only release if not timedout
        if(currentEpochTime < (lock.timeout - lockOverlapMilliseconds)) {
            try {
                await app.datastore.deleteFile(lock.key);
            }
            catch(_$$1) {}    } 
    };

    const NO_LOCK$$1 = "no lock";
    const isNolock$$1 = id => id === NO_LOCK$$1;

    const sleepForRetry = () =>
        new Promise(resolve => setTimeout(resolve, lockOverlapMilliseconds));

    // this is the combinator function
    const $$ = (...funcs) => arg =>
        _.flow(funcs)(arg);

    // this is the pipe function
    const $ = (arg, funcs) =>
        $$(...funcs)(arg);

    const keySep = "/";
    const trimKeySep = str => _.trim(str, keySep);
    const splitByKeySep = str => _.split(str, keySep);
    const safeKey = key => _.replace(`${keySep}${trimKeySep(key)}`, `${keySep}${keySep}`, keySep);
    const joinKey = (...strs) => {
        const paramsOrArray =
            strs.length === 1 & _.isArray(strs[0])
                ? strs[0] : strs;
        return safeKey(_.join(paramsOrArray, keySep));
    };
    const splitKey = $$(trimKeySep, splitByKeySep);
    const getDirFomKey = $$(splitKey, _.dropRight, (p) => joinKey(...p));
    const getFileFromKey = $$(splitKey, _.takeRight, _.head);

    const configFolder = keySep + ".config";
    const fieldDefinitions = joinKey(configFolder, "fields.json");
    const templateDefinitions = joinKey(configFolder, "templates.json");
    const appDefinitionFile = joinKey(configFolder, "appDefinition.json");
    const dirIndex = (folderPath) => joinKey(configFolder, "dir", ...splitKey(folderPath), "dir.idx");
    const getIndexKeyFromFileKey = $$(getDirFomKey, dirIndex);

    const ifExists = (val, exists, notExists) =>
        _.isUndefined(val)
            ? _.isUndefined(notExists) ? (() => { })() : notExists()
            : exists();

    const getOrDefault = (val, defaultVal) =>
        ifExists(val, () => val, () => defaultVal);

    const not = (func) => (val) => !func(val);
    const isDefined = not(_.isUndefined);
    const isNonNull = not(_.isNull);
    const isNotNaN = not(_.isNaN);

    const allTrue = (...funcArgs) => (val) =>
        _.reduce(funcArgs,
            (result, conditionFunc) =>
                (_.isNull(result) || result == true) && conditionFunc(val),
            null);

    const anyTrue = (...funcArgs) => (val) =>
        _.reduce(funcArgs,
            (result, conditionFunc) =>
                result == true || conditionFunc(val),
            null);

    const insensitiveEquals = (str1, str2) =>
        str1.trim().toLowerCase() === str2.trim().toLowerCase();

    const isSomething = allTrue(isDefined, isNonNull, isNotNaN);
    const isNothing = not(isSomething);
    const isNothingOrEmpty = v => isNothing(v) || _.isEmpty(v);
    const somethingOrGetDefault = getDefaultFunc => val =>
        isSomething(val) ? val : getDefaultFunc();
    const somethingOrDefault = (val, defaultVal) =>
        somethingOrGetDefault(_.constant(defaultVal))(val);

    const mapIfSomethingOrDefault = (mapFunc, defaultVal) =>
        (val) => isSomething(val) ? mapFunc(val) : defaultVal;

    const mapIfSomethingOrBlank = (mapFunc) =>
        mapIfSomethingOrDefault(mapFunc, "");

    const none = predicate => collection =>
        !fp.some(predicate)(collection);

    const all = predicate => collection =>
        none(v => !predicate(v))(collection);

    const isNotEmpty = ob => !_.isEmpty(ob);
    const isNonEmptyArray = allTrue(_.isArray, isNotEmpty);
    const isNonEmptyString = allTrue(_.isString, isNotEmpty);
    const tryOr = failFunc => (func, ...args) => {
        try {
            return func.apply(null, ...args);
        } catch (_$$1) {
            return failFunc();
        }
    };

    const tryAwaitOr = failFunc => async (func, ...args) => {
        try {
            return await func.apply(null, ...args);
        } catch (_$$1) {
            return await failFunc();
        }
    };

    const defineError = (func, errorPrefix) => {
        try {
            return func();
        } catch (err) {
            err.message = errorPrefix + " : " + err.message;
            throw err;
        }
    };

    const tryOrIgnore = tryOr(() => { });
    const tryAwaitOrIgnore = tryAwaitOr(async () => { });
    const causesException = func => {
        try {
            func();
            return false;
        } catch (e) {
            return true;
        }
    };

    const executesWithoutException = func =>
        !causesException(func);

    const handleErrorWith = returnValInError => tryOr(_.constant(returnValInError));

    const handleErrorWithUndefined = handleErrorWith(undefined);

    const switchCase = (...cases) => (value) => {

        const nextCase = () => _.head(cases)[0](value);
        const nextResult = () => _.head(cases)[1](value);

        if (_.isEmpty(cases)) return; // undefined
        if (nextCase() === true) return nextResult();
        return switchCase.apply(null, _.tail(cases))(value);
    };

    const isValue = val1 => val2 => (val1 === val2);
    const isOneOf = (...vals) => val => _.includes(vals, val);
    const defaultCase = _.constant(true);
    const memberMatches = (member, match) => obj => match(obj[member]);


    const StartsWith = (searchFor) => (searchIn) =>
        _.startsWith(searchIn, searchFor);

    const contains = val => array => (_.findIndex(array, v => v === val) > -1);

    const getHashCode = s => {
        let hash = 0, i, char, l;
        if (s.length == 0) return hash;
        for (i = 0, l = s.length; i < l; i++) {
            char = s.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash |= 0; // Convert to 32bit integer
        }

        // converting to string, but dont want a "-" prefixed
        if (hash < 0)
            return "n" + (hash * -1).toString();
        else
            return hash.toString();
    };

    // thanks to https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/
    const awEx = async promise => {
        try {
            const result = await promise;
            return [undefined, result];
        } catch (error) {
            return [error, undefined]
        }
    };

    const isSafeInteger = n =>
        _.isInteger(n)
        && n <= Number.MAX_SAFE_INTEGER
        && n >= 0 - Number.MAX_SAFE_INTEGER;

    const toDateOrNull = s => _.isNull(s) ? null
        : _.isDate(s) ? s : new Date(s);
    const toBoolOrNull = s => _.isNull(s) ? null
        : s === "true" || s === true;
    const toNumberOrNull = s => _.isNull(s) ? null
        : _.toNumber(s);

    const isArrayOfString = opts =>
        _.isArray(opts) && all(_.isString)(opts);

    const pause = async (duration) => new Promise(res => setTimeout(res, duration));

    const retry = async (fn, retries, delay, ...args) => {
        try {
            return await fn(...args);
        } catch (err) {
            if (retries > 1) {
                return await pause(delay).then(async () => await retry(fn, (retries - 1), delay, ...args));
            } else {
                throw err;
            }
        }
    };

    var index = {
        ifExists, getOrDefault, isDefined,
        isNonNull, isNotNaN, allTrue, isSomething,
        mapIfSomethingOrDefault, mapIfSomethingOrBlank,
        configFolder, fieldDefinitions, isNothing, not,
        switchCase, defaultCase, StartsWith, contains,
        templateDefinitions, handleErrorWith,
        handleErrorWithUndefined, tryOr, tryOrIgnore,
        tryAwaitOr, tryAwaitOrIgnore, dirIndex, keySep,
        $, $$, getDirFomKey, getFileFromKey, splitKey,
        somethingOrDefault, getIndexKeyFromFileKey, joinKey,
        somethingOrGetDefault, appDefinitionFile, isValue, all,
        isOneOf, memberMatches, defineError, anyTrue, isNonEmptyArray,
        causesException, executesWithoutException, none, getHashCode,
        awEx, apiWrapper, events, isNothingOrEmpty, isSafeInteger,
        toNumber: _.toNumber, toDate: toDateOrNull, toBool: toBoolOrNull,
        isArrayOfString, getLock: getLock$$1, NO_LOCK: NO_LOCK$$1, isNolock: isNolock$$1, insensitiveEquals, pause, retry
    };

    const stringNotEmpty = s => isSomething(s) && s.trim().length > 0;

    const makerule = (field, error, isValid) => ({field, error, isValid});

    const validationError = (rule, item) => ({...rule, item});

    const applyRuleSet = ruleSet => itemToValidate => 
        $(ruleSet, [
            fp.map(applyRule(itemToValidate)),
            fp.filter(isSomething)
        ]);

    const applyRule = itemTovalidate => rule => 
        rule.isValid(itemTovalidate) 
        ? null
        : validationError(rule, itemTovalidate);

    const filterEval = "FILTER_EVALUATE";
    const filterCompile = "FILTER_COMPILE";
    const mapEval= "MAP_EVALUATE";
    const mapCompile = "MAP_COMPILE";


    const getEvaluateResult = () =>  ({
        isError: false,
        passedFilter: true,
        result: null
    });

    const compileFilter = index$$1 => 
        compilerUtil.compileExpression(index$$1.filter);

    const compileMap = index$$1 => 
        compilerUtil.compileCode(index$$1.map);

    const passesFilter = (record, index$$1) => {
        const context = {record};
        if(!index$$1.filter) return true;

        const compiledFilter = defineError(
            () => compileFilter(index$$1),
            filterCompile);

        return defineError(
                () => compiledFilter(context),
                filterEval);
    };

    const mapRecord = (record, index$$1) => {
        const recordClone = _.clone(record);
        const context = {record:recordClone};

        const map = index$$1.map ? index$$1.map : "return {...record};";
        
        const compiledMap = defineError(
            () => compilerUtil.compileCode(map),
            mapCompile);

        const mapped = defineError(
            () => compiledMap(context),
            mapEval);    

        const mappedKeys = _.keys(mapped);
        for(let i = 0; i < mappedKeys.length; i++) {
            const key = mappedKeys[i];
            mapped[key] = _.isUndefined(mapped[key]) ? null : mapped[key];
            if(_.isFunction(mapped[key])) {
                delete mapped[key];
            }
        }

        mapped.key = record.key;
        mapped.sortKey = index$$1.getSortKey 
                         ? compilerUtil.compileCode(index$$1.getSortKey)(context) 
                         : record.id;

        return mapped;
    };

    const evaluate = record => index$$1 => {
        const result = getEvaluateResult();

        try {
            result.passedFilter = passesFilter(record, index$$1);
        } catch(err) {
            result.isError = true;
            result.passedFilter = false;
            result.result = err.message;
        }

        if(!result.passedFilter) return result;

        try {
            result.result = mapRecord(record, index$$1);
        } catch(err) {
            result.isError = true;
            result.result = err.message;
        }   
        
        return result;
    };

    const indexTypes = { reference: "reference", ancestor: "ancestor" };

    const indexRuleSet = [
        makerule("map", "index has no map function",
            index$$1 => isNonEmptyString(index$$1.map)),
        makerule("map", "index's map function does not compile",
            index$$1 => !isNonEmptyString(index$$1.map)
                    || executesWithoutException(() => compileMap(index$$1))),
        makerule("filter", "index's filter function does not compile",
            index$$1 => !isNonEmptyString(index$$1.filter)
                    ||  executesWithoutException(() => compileFilter(index$$1))),
        makerule("name", "must declare a name for index",
            index$$1 => isNonEmptyString(index$$1.name)),
        makerule("name", "there is a duplicate named index on this node",
            index$$1 => fp.isEmpty(index$$1.name)  
                    || fp.countBy('name')
                       (index$$1.parent().indexes)[index$$1.name] === 1) ,
        makerule("indexType", `reference index may only exist on a record node`,
            index$$1 =>  isRecord(index$$1.parent()) 
                      || index$$1.indexType !== indexTypes.reference),
        makerule("indexType", `index type must be one of: ${_.join(", ", _.keys(indexTypes))}`,
            index$$1 =>  fp.includes(index$$1.indexType)(_.keys(indexTypes)))
    ];

    const getFlattenedHierarchy = (appHeirarchy, useCached=true) => {

        if(isSomething(appHeirarchy.getFlattenedHeirarchy) && useCached)
            return appHeirarchy.getFlattenedHeirarchy();

        const flattenHeirarchy = (currentNode, flattened) => {
            flattened.push(currentNode);
            if((!currentNode.children 
                || currentNode.children.length === 0)
                && 
                (!currentNode.indexes
                || currentNode.indexes.length === 0)
                && 
                (!currentNode.aggregateGroups
                || currentNode.aggregateGroups.length === 0)){
                return flattened;
            }

            const unionIfAny = l2 => l1 =>
                fp.union(l1)(!l2 ? [] : l2);

            const children = $([], [
                unionIfAny(currentNode.children),
                unionIfAny(currentNode.indexes),
                unionIfAny(currentNode.aggregateGroups)
            ]);

            for(let child of children) {
                flattenHeirarchy(child, flattened);
            }
            return flattened;
        };

        appHeirarchy.getFlattenedHeirarchy = () => flattenHeirarchy(appHeirarchy, []);
        return appHeirarchy.getFlattenedHeirarchy();

    };

    const getLastPartInKey = key => 
        fp.last(splitKey(key));

    const getNodesInPath = appHeirarchy => key => 
        $(appHeirarchy, [
            getFlattenedHierarchy,
            fp.filter(n => new RegExp(`${n.pathRegx()}`).test(key))
        ]);

    const getExactNodeForPath = appHeirarchy => key => 
        $(appHeirarchy, [
            getFlattenedHierarchy,
            fp.find(n => new RegExp(`${n.pathRegx()}$`).test(key))
        ]);

    const getNodeForCollectionPath = appHeirarchy => collectionKey => 
        $(appHeirarchy, [
            getFlattenedHierarchy,
            fp.find(n => (isCollectionRecord(n) 
                       && new RegExp(`${n.collectionPathRegx()}$`).test(collectionKey)))
        ]);

    const hasMatchingAncestor = ancestorPredicate => decendantNode =>
        switchCase(
            
            [node => isNothing(node.parent()), 
            fp.constant(false)],

            [node => ancestorPredicate(node.parent()), 
            fp.constant(true)],

            [defaultCase, 
            node => hasMatchingAncestor(ancestorPredicate)(node.parent())]

        )(decendantNode);

    const getNode = (appHeirarchy, nodeKey) => 
        $(appHeirarchy, [
            getFlattenedHierarchy,
            fp.find(n => n.nodeKey() === nodeKey
                      || (isCollectionRecord(n)
                          && n.collectionNodeKey() === nodeKey))
        ]);

    const getCollectionNode = (appHeirarchy, nodeKey) => 
        $(appHeirarchy, [
            getFlattenedHierarchy,
            fp.find(n => (isCollectionRecord(n)
                        && n.collectionNodeKey() === nodeKey))
        ]);

    const getNodeByKeyOrNodeKey = (appHeirarchy, keyOrNodeKey) => {
        const nodeByKey = getExactNodeForPath(appHeirarchy)(keyOrNodeKey);
        return isNothing(nodeByKey)
               ? getNode(appHeirarchy, keyOrNodeKey)
               : nodeByKey;
    };

    const getCollectionNodeByKeyOrNodeKey = (appHeirarchy, keyOrNodeKey) => {
        const nodeByKey = getNodeForCollectionPath(appHeirarchy)(keyOrNodeKey);
        return isNothing(nodeByKey)
               ? getCollectionNode(appHeirarchy, keyOrNodeKey)
               : nodeByKey;
    };


    const isNode = (appHeirarchy, key) => 
        isSomething(getExactNodeForPath(appHeirarchy)(key));

    const getActualKeyOfParent = (parentNodeKey, actualChildKey) => 
        $(actualChildKey, [
            splitKey,
            fp.take(splitKey(parentNodeKey).length),
            ks => joinKey(...ks)
        ]);

    const getParentKey = key => {
        const split = splitKey(key);
        const taken = fp.take(splitKey(key).length - 1)(split);
        const joined = joinKey(...taken);
        return $(key, [
            splitKey,
            fp.take(splitKey(key).length - 1),
            joinKey
        ]);
    };

    const isKeyAncestorOf = ancestorKey => decendantNode =>
        hasMatchingAncestor(p => p.nodeKey() === ancestorKey)(decendantNode);

    const hasNoMatchingAncestors = parentPredicate => node => 
        !hasMatchingAncestor(parentPredicate)(node);
        
    const findField = (recordNode, fieldName) => 
        fp.find(f => f.name == fieldName)(recordNode.fields);

    const isAncestor = decendant => ancestor =>
        isKeyAncestorOf(ancestor.nodeKey())(decendant);
        
    const isDecendant = ancestor => decendant =>
        isAncestor(decendant)(ancestor);

    const getRecordNodeId = recordKey =>
        $(recordKey, [
            splitKey,
            fp.last,
            getRecordNodeIdFromId
        ]);

    const getRecordNodeIdFromId = recordId =>
        $(recordId, [fp.split("-"), fp.first, parseInt]);

    const getRecordNodeById = (heirarchy, recordId) => 
        $(heirarchy, [
            getFlattenedHierarchy,
            fp.find(n => isRecord(n) 
                        && n.nodeId === getRecordNodeIdFromId(recordId))
        ]);

    const recordNodeIdIsAllowed = (indexNode) => (nodeId) =>
        indexNode.allowedRecordNodeIds.length === 0
        || fp.includes(nodeId)(indexNode.allowedRecordNodeIds);

    const recordNodeIsAllowed = (indexNode) => (recordNode) =>
        recordNodeIdIsAllowed(indexNode)(recordNode.nodeId);

    const getAllowedRecordNodesForIndex = (appHeirarchy, indexNode) => {
        const recordNodes = $(appHeirarchy, [
            getFlattenedHierarchy,
            fp.filter(isRecord)
        ]);


        if(isGlobalIndex(indexNode)) {
            return $(recordNodes, [
                fp.filter(recordNodeIsAllowed(indexNode))
            ]);
        }

        if(isAncestorIndex(indexNode)) {
            return $(recordNodes, [
                fp.filter(isDecendant(indexNode.parent())),
                fp.filter(recordNodeIsAllowed(indexNode))
            ]);
        }

        if(isReferenceIndex(indexNode)) {
            return $(recordNodes, [
                fp.filter(n => fp.some(fieldReversesReferenceToIndex(indexNode))
                            (n.fields))
            ]);
        }

    };

    const getNodeFromNodeKeyHash = heirarchy => hash =>
        $(heirarchy, [
            getFlattenedHierarchy,
            fp.find(n => getHashCode(n.nodeKey()) === hash)
        ]);
        
    const isRecord = node => isSomething(node) && node.type === "record";
    const isSingleRecord = node => isRecord(node) && node.isSingle;
    const isCollectionRecord = node => isRecord(node) && !node.isSingle;
    const isIndex = node => isSomething(node) && node.type === "index";
    const isaggregateGroup = node => isSomething(node) && node.type === "aggregateGroup";
    const isShardedIndex = node => isIndex(node) && isNonEmptyString(node.getShardName);
    const isRoot = node => isSomething(node) && node.isRoot();
    const isDecendantOfARecord = hasMatchingAncestor(isRecord);
    const isGlobalIndex = node => 
        isIndex(node) && isRoot(node.parent()); 
    const isReferenceIndex = node =>
        isIndex(node) && node.indexType === indexTypes.reference;
    const isAncestorIndex = node => 
        isIndex(node) && node.indexType === indexTypes.ancestor;

    const fieldReversesReferenceToNode = node => field => 
        field.type === "reference"
        && fp.intersection(field.typeOptions.reverseIndexNodeKeys)
                       (fp.map(i => i.nodeKey())(node.indexes))
                       .length > 0;

    const fieldReversesReferenceToIndex = indexNode => field => 
        field.type === "reference"
        && fp.intersection(field.typeOptions.reverseIndexNodeKeys)
            ([indexNode.nodeKey()])
            .length > 0;
                
    var heirarchy = {
        getLastPartInKey, getNodesInPath, getExactNodeForPath, 
        hasMatchingAncestor, getNode, getNodeByKeyOrNodeKey, isNode,
        getActualKeyOfParent, getParentKey, isKeyAncestorOf, hasNoMatchingAncestors,
        findField, isAncestor, isDecendant, getRecordNodeId, getRecordNodeIdFromId,
        getRecordNodeById, recordNodeIdIsAllowed, recordNodeIsAllowed, 
        getAllowedRecordNodesForIndex, getNodeFromNodeKeyHash, isRecord,
        isCollectionRecord, isIndex, isaggregateGroup, isShardedIndex, isRoot,
        isDecendantOfARecord, isGlobalIndex, isReferenceIndex, isAncestorIndex,
        fieldReversesReferenceToNode, fieldReversesReferenceToIndex,
        getFlattenedHierarchy,
    };

    const getSafeFieldParser = (tryParse, defaultValueFunctions) => (field, record) => {
        if(_.has(record, field.name)) {
            return getSafeValueParser(tryParse, defaultValueFunctions)
                                     (record[field.name]);
                            
        } else {
            return defaultValueFunctions[field.getUndefinedValue]();
        }
    };

    const getSafeValueParser = (tryParse, defaultValueFunctions) => value => {
        const parsed = tryParse(value);
        if(parsed.success) {
            return parsed.value;
        } else {
            return defaultValueFunctions["default"]();
        }
    };

    const getNewValue = (tryParse, defaultValueFunctions) => field => {
        const getInitialValue = fp.isUndefined(field) || fp.isUndefined(field.getInitialValue) 
                                ? "default" 
                                : field.getInitialValue;

        return _.has(defaultValueFunctions, getInitialValue)
               ? defaultValueFunctions[getInitialValue]()
               : getSafeValueParser(tryParse, defaultValueFunctions)(getInitialValue);
    };

    const typeFunctions = specificFunctions => 
        _.merge({
            value: fp.constant,
            null: fp.constant(null)
        }, specificFunctions);

    const validateTypeConstraints = (validationRules) => 
    async (field, record, context) => {
        const fieldValue = record[field.name];
        const validateRule = async r => 
            ! await r.isValid(fieldValue, field.typeOptions, context) 
            ? r.getMessage(fieldValue, field.typeOptions) 
            : "";

        const errors = [];
        for(let r of validationRules) {
            const err = await validateRule(r);
            if(isNotEmpty(err)) errors.push(err);
        }

        return errors;
    };

    const getDefaultOptions = fp.mapValues(v => v.defaultValue);

    const makerule$1 = (isValid, getMessage) => ({isValid, getMessage});
    const parsedFailed = val => ({success:false, value:val});
    const parsedSuccess = val => ({success:true, value:val});
    const getDefaultExport = (name, tryParse, functions, options, validationRules, sampleValue, stringify) => ({
        getNew : getNewValue(tryParse, functions), 
        safeParseField: getSafeFieldParser(tryParse, functions), 
        safeParseValue: getSafeValueParser(tryParse, functions),
        tryParse, 
        name,
        getDefaultOptions : () => getDefaultOptions(fp.cloneDeep(options)), 
        optionDefinitions: options,
        validateTypeConstraints : validateTypeConstraints(validationRules),
        sampleValue,
        stringify: val => val === null || val === undefined 
                          ? "" : stringify(val),
        getDefaultValue: functions.default
    });

    const stringFunctions = typeFunctions({
        default: _.constant(null)
    });

    const stringTryParse = 
        switchCase(
            [_.isString, parsedSuccess],
            [_.isNull, parsedSuccess],
            [defaultCase, v => parsedSuccess(v.toString())]
        );

    const options = {
        maxLength: {
            defaultValue: null, 
            isValid: n => n === null || isSafeInteger(n) && n > 0,
            requirementDescription: "max length must be null (no limit) or a greater than zero integer",
            parse: toNumberOrNull
        },
        values: {
            defaultValue: null,
            isValid: v => v === null || (isArrayOfString(v) && v.length > 0 && v.length < 10000),
            requirementDescription: "'values' must be null (no values) or an arry of at least one string",
            parse: s=>s
        },
        allowDeclaredValuesOnly: {
            defaultValue: false,
            isValid: _.isBoolean,
            requirementDescription: "allowDeclaredValuesOnly must be true or false",
            parse: toBoolOrNull
        }
    };

    const typeConstraints = [
        makerule$1(async (val,opts) => val === null || opts.maxLength === null || val.length <= opts.maxLength, 
                 (val,opts) => `value exceeds maximum length of ${opts.maxLength}`),
        makerule$1(async (val, opts) => val === null  
                               || opts.allowDeclaredValuesOnly === false 
                               || _.includes(opts.values, val),
                 (val,opts) => `"${val}" does not exist in the list of allowed values`) 
    ]; 

    var string = getDefaultExport(
        "string", 
        stringTryParse, 
        stringFunctions,
        options, 
        typeConstraints,
        "abcde",
        str => str);

    const boolFunctions = typeFunctions({
        default: _.constant(null),
    });

    const boolTryParse = 
        switchCase(
            [_.isBoolean, parsedSuccess],
            [_.isNull, parsedSuccess],
            [isOneOf("true", "1", "yes", "on"), v => parsedSuccess(true)],
            [isOneOf("false", "0", "no", "off"), v => parsedSuccess(false)],
            [defaultCase, parsedFailed]
        );

    const options$1 = {
        allowNulls: {
            defaultValue: true, 
            isValid: _.isBoolean,
            requirementDescription: "must be a true or false",
            parse: toBoolOrNull
        }
    };

    const typeConstraints$1 = [
        makerule$1(async (val,opts) => opts.allowNulls === true || val !== null, 
                 (val,opts) => "field cannot be null")
    ]; 

    var bool = getDefaultExport(
        "bool", boolTryParse, boolFunctions, 
        options$1, typeConstraints$1, true, JSON.stringify);

    const numberFunctions = typeFunctions({
        default: _.constant(null)
    });

    const parseStringtoNumberOrNull = s => {
        const num = Number(s);
        return isNaN(num) ? parsedFailed(s) : parsedSuccess(num); 
    };

    const numberTryParse = 
        switchCase(
            [_.isNumber, parsedSuccess],
            [_.isString, parseStringtoNumberOrNull],
            [_.isNull, parsedSuccess],
            [defaultCase, parsedFailed]
        );

    const options$2 = {
        maxValue: {
            defaultValue: Number.MAX_SAFE_INTEGER,
            isValid: isSafeInteger,
            requirementDescription: "must be a valid integer",
            parse: toNumberOrNull
        },
        minValue: {
            defaultValue: 0-Number.MAX_SAFE_INTEGER,
            isValid: isSafeInteger,
            requirementDescription: "must be a valid integer",
            parse: toNumberOrNull
        },
        decimalPlaces: {
            defaultValue: 0,
            isValid: n => isSafeInteger(n) && n >= 0,
            requirementDescription: "must be a positive integer",
            parse: toNumberOrNull
        }
    };

    const getDecimalPlaces = val => {
        var splitDecimal = val.toString().split(".");
        if(splitDecimal.length === 1) return 0;
        return splitDecimal[1].length;
    };

    const typeConstraints$2 = [
        makerule$1(async (val,opts) => val === null || opts.minValue === null || val >= opts.minValue,
                 (val,opts) => `value (${val.toString()}) must be greater than or equal to ${opts.minValue}`),
        makerule$1(async (val,opts) => val === null || opts.maxValue === null || val <= opts.maxValue, 
                 (val,opts) => `value (${val.toString()}) must be less than or equal to ${opts.minValue} options`),
        makerule$1(async (val,opts) => val === null || opts.decimalPlaces >= getDecimalPlaces(val),
                 (val,opts) => `value (${val.toString()}) must have ${opts.decimalPlaces} decimal places or less`)
    ];

    var number = getDefaultExport(
        "number", 
        numberTryParse, 
        numberFunctions, 
        options$2, 
        typeConstraints$2,
        1,
        num => num.toString());

    const dateFunctions = typeFunctions({
        default: _.constant(null),
        now: () => new Date()
    });

    const isValidDate = d => 
        d instanceof Date && !isNaN(d);

    const parseStringToDate = s => 
        switchCase(
            [isValidDate, parsedSuccess],
            [defaultCase, parsedFailed]
        )(new Date(s));
        

    const dateTryParse = 
        switchCase(
            [_.isDate, parsedSuccess],
            [_.isString, parseStringToDate],
            [_.isNull, parsedSuccess],
            [defaultCase, parsedFailed]
        );

    const options$3 = {
        maxValue: {
            defaultValue: new Date(32503680000000),
            isValid: _.isDate,
            requirementDescription: "must be a valid date",
            parse: toDateOrNull
        },
        minValue: {
            defaultValue: new Date(-8520336000000), 
            isValid: _.isDate,
            requirementDescription: "must be a valid date",
            parse: toDateOrNull
        }
    };

    const typeConstraints$3 = [
        makerule$1(async (val,opts) => val === null || opts.minValue === null || val >= opts.minValue,
                 (val,opts) => `value (${val.toString()}) must be greater than or equal to ${opts.minValue}`),
        makerule$1(async (val,opts) => val === null || opts.maxValue === null || val <= opts.maxValue, 
                 (val,opts) => `value (${val.toString()}) must be less than or equal to ${opts.minValue} options`)
    ];

    var datetime = getDefaultExport(
        "datetime", 
        dateTryParse, 
        dateFunctions,
        options$3, 
        typeConstraints$3,
        new Date(1984,4,1),
        date => JSON.stringify(date).replace(new RegExp("\"", 'g'), ""));

    const arrayFunctions = type => typeFunctions({
       default: _.constant([])
    });

    const mapToParsedArrary = type => $$(
        fp.map(i => type.safeParseValue(i)),
        parsedSuccess
    );

    const arrayTryParse = type =>
       switchCase(
           [_.isArray, mapToParsedArrary(type)],
           [defaultCase, parsedFailed]
       );

    const typeName = type => `array<${type}>`;


    const options$4 = {
        maxLength: {
            defaultValue: 10000,
            isValid: isSafeInteger,
            requirementDescription: "must be a positive integer",
            parse: toNumberOrNull
        },
        minLength: {
            defaultValue: 0,
            isValid : n => isSafeInteger(n) && n >= 0,
            requirementDescription: "must be a positive integer",
            parse: toNumberOrNull
        }
    };

    const typeConstraints$4 = [
        makerule$1(async (val,opts) => val === null || val.length >= opts.minLength, 
                 (val,opts) => `must choose ${opts.minLength} or more options`),
        makerule$1(async (val,opts) => val === null || val.length <= opts.maxLength, 
                 (val,opts) => `cannot choose more than ${opts.maxLength} options`)
    ]; 

    var array = type => 
        getDefaultExport(
            typeName(type.name),
            arrayTryParse(type), 
            arrayFunctions(type),
            options$4,
            typeConstraints$4,
            [type.sampleValue],
            JSON.stringify
            );

    const referenceNothing = () => ({key:""});

    const referenceFunctions = typeFunctions({
        default: referenceNothing 
    });

    const hasStringValue = (ob, path$$1) => 
        _.has(ob, path$$1) 
        && _.isString(ob[path$$1]);

    const isObjectWithKey = v => 
        _.isObjectLike(v) 
        && hasStringValue(v, "key");

    const referenceTryParse = v =>
        switchCase(
            [isObjectWithKey, parsedSuccess],
            [_.isNull, () => parsedSuccess(referenceNothing())],
            [defaultCase, parsedFailed]
        )(v);

    const options$5 = {
        indexNodeKey: {
            defaultValue: null,
            isValid : isNonEmptyString ,
            requirementDescription: "must be a non-empty string",
            parse: s=>s
        },
        displayValue: {
            defaultValue: "", 
            isValid : isNonEmptyString,
            requirementDescription: "must be a non-empty string",
            parse: s=>s
        },
        reverseIndexNodeKeys: {
            defaultValue: null,
            isValid : v => isArrayOfString(v) && v.length > 0,
            requirementDescription: "must be a non-empty array of strings",
            parse: s=>s
        }
    };

    const isEmptyString = s => 
        _.isString(s) && _.isEmpty(s);

    const ensureReferenceExists = async (val, opts, context) => 
        isEmptyString(val.key) 
        || await context.referenceExists(opts, val.key);

    const typeConstraints$5 = [
        makerule$1(
            ensureReferenceExists,
            (val,opts) => `"${val[opts.displayValue]}" does not exist in options list (key: ${val.key})`)
    ]; 

    var reference = getDefaultExport(
        "reference", 
        referenceTryParse, 
        referenceFunctions,
        options$5, 
        typeConstraints$5,
        {key:"key", value:"value"},
        JSON.stringify);

    const illegalCharacters = "*?\\/:<>|\0\b\f\v";

    const isLegalFilename = filePath => {
        const fn = fileName(filePath);
        return fn.length <= 255
        && fp.intersection(fn.split(""))
                        (illegalCharacters.split("")).length === 0
        && none(f => f === "..")(splitKey(filePath));
    };

    const fileNothing = () => ({relativePath:"",size:0});

    const fileFunctions = typeFunctions({
        default: fileNothing
    });

    const fileTryParse = v =>
        switchCase(
            [isValidFile, parsedSuccess],
            [fp.isNull, () => parsedSuccess(fileNothing())],
            [defaultCase, parsedFailed]
        )(v);

    const fileName = filePath => 
        $(filePath, [
            splitKey,
            fp.last
        ]);

    const isValidFile = f => {
        return !fp.isNull(f)
        && fp.has("relativePath")(f) && fp.has("size")(f)
        && fp.isNumber(f.size)
        && fp.isString(f.relativePath) 
        && isLegalFilename(f.relativePath)
    };

    const options$6 = {};

    const typeConstraints$6 = []; 

    var file = getDefaultExport(
        "file", 
        fileTryParse, 
        fileFunctions,
        options$6, 
        typeConstraints$6,
        {relativePath:"some_file.jpg", size:1000},
        JSON.stringify);

    const allTypes = () => {
        const basicTypes = {
            string, number, datetime, bool, reference, file
        };        

        const arrays = $(basicTypes, [
            _.keys,
            fp.map(k => {
                const kvType = {};
                const concreteArray = array(basicTypes[k]);
                kvType[concreteArray.name] = concreteArray;
                return kvType;
            }),
            types => _.assign({}, ...types) 
        ]);
        
        return _.merge({}, basicTypes, arrays);
    }; 


    const all$1 = allTypes();

    const getType = typeName =>  {
        if(!_.has(all$1, typeName)) throw new Error("Do not recognise type " + typeName);
        return all$1[typeName];
    };

    const getSampleFieldValue = field =>
        getType(field.type).sampleValue;

    const getNewFieldValue = field => 
        getType(field.type).getNew(field);

    const safeParseField = (field, record) => 
        getType(field.type).safeParseField(field, record);

    const validateFieldParse = (field, record) => 
        _.has(record, field.name) 
        ? getType(field.type).tryParse(record[field.name])
        : parsedSuccess(undefined); // fields may be undefined by default

    const getDefaultOptions$1 = type => 
        getType(type).getDefaultOptions();

    const validateTypeConstraints$1 = async (field, record, context) => 
        await getType(field.type).validateTypeConstraints(field, record, context);

    const detectType = value => {
        if(fp.isString(value)) return string;
        if(fp.isBoolean(value)) return bool;
        if(fp.isNumber(value)) return number;
        if(fp.isDate(value)) return datetime;
        if(fp.isArray(value)) return array(detectType(value[0]));
        if(fp.isObject(value) 
           && _.has(value, "key")
           && _.has(value, "value")) return reference;
        if(fp.isObject(value)
            && _.has(value, "relativePath")
            && _.has(value, "size")) return file;
        
        throw new Error("cannot determine type: " + JSON.stringify(value));
    };

    // 5 minutes
    const tempCodeExpiryLength = 5 * 60 * 60;

    const AUTH_FOLDER = "/.auth";
    const USERS_LIST_FILE = joinKey(AUTH_FOLDER, "users.json");
    const userAuthFile= username => joinKey(AUTH_FOLDER, `auth_${username}.json`);
    const USERS_LOCK_FILE = joinKey(AUTH_FOLDER, "users_lock");
    const ACCESS_LEVELS_FILE = joinKey(AUTH_FOLDER, "access_levels.json");
    const ACCESS_LEVELS_LOCK_FILE = joinKey(AUTH_FOLDER, "access_levels_lock");

    const permissionTypes = {
        CREATE_RECORD : "create record",
        UPDATE_RECORD : "update record",
        READ_RECORD : "read record",
        DELETE_RECORD : "delete record",
        READ_INDEX : "read index",
        MANAGE_INDEX : "manage index",
        MANAGE_COLLECTION : "manage collection",
        WRITE_TEMPLATES : "write templates",
        CREATE_USER : "create user",
        SET_PASSWORD : "set password",
        CREATE_TEMPORARY_ACCESS : "create temporary access",
        ENABLE_DISABLE_USER : "enable or disable user",
        WRITE_ACCESS_LEVELS : "write access levels",
        LIST_USERS : "list users",
        LIST_ACCESS_LEVELS : "list access levels",
        EXECUTE_ACTION : "execute action",
        SET_USER_ACCESS_LEVELS: "set user access levels"
    };

    const getUserByName = (users, name) => $(users, [
        fp.find(u => u.name.toLowerCase() === name.toLowerCase())
    ]);

    const stripUserOfSensitiveStuff = user => {
        const stripped = fp.clone(user);
        delete stripped.tempCode;
        return stripped;
    };

    const parseTemporaryCode = fullCode => 
        $(fullCode, [
            fp.split(":"),
            parts => ({
                id:parts[1],
                code:parts[2]
            })
        ]);

    const isAuthorized = (app) => (permissionType, resourceKey) => 
        apiWrapperSync(
            app,
            events.authApi.isAuthorized, 
            alwaysAuthorized,
            {resourceKey, permissionType},
            _isAuthorized, app, permissionType, resourceKey);

    const _isAuthorized =  (app, permissionType, resourceKey) => {
        
        if(!app.user) {
            return false;
        }

        const validType = $(permissionTypes, [
            fp.values,
            fp.includes(permissionType)
        ]);

        if(!validType) {
            return false;
        }

        const permMatchesResource = userperm => {

            const nodeKey = isNothing(resourceKey) 
                            ? null
                            : isNode(app.heirarchy, resourceKey)
                            ? getNodeByKeyOrNodeKey(
                                app.heirarchy, resourceKey).nodeKey()
                            : resourceKey;

            return (userperm.type === permissionType)
            &&
            (
                isNothing(resourceKey)
                ||
                nodeKey === userperm.nodeKey
            );    
        };

        return $(app.user.permissions, [
            fp.some(permMatchesResource)
        ]);
        
    };

    const nodePermission = (type) => ({
        add : (nodeKey, accessLevel) => accessLevel.permissions.push({type, nodeKey}),
        isAuthorized: resourceKey => app => isAuthorized(app)(type, resourceKey),
        isNode:true,
        get: nodeKey => ({type, nodeKey})
    });

    const staticPermission = (type) => ({
        add : accessLevel => accessLevel.permissions.push({type}),
        isAuthorized: app => isAuthorized(app)(type),
        isNode:false,
        get: () => ({type})
    });

    const createRecord = nodePermission(permissionTypes.CREATE_RECORD);

    const updateRecord = nodePermission(permissionTypes.UPDATE_RECORD);

    const deleteRecord = nodePermission(permissionTypes.DELETE_RECORD);

    const readRecord = nodePermission(permissionTypes.READ_RECORD);

    const writeTemplates = staticPermission(permissionTypes.WRITE_TEMPLATES);

    const createUser = staticPermission(permissionTypes.CREATE_USER);

    const setPassword = staticPermission(permissionTypes.SET_PASSWORD);

    const readIndex = nodePermission(permissionTypes.READ_INDEX);

    const manageIndex = staticPermission(permissionTypes.MANAGE_INDEX);

    const manageCollection = staticPermission(permissionTypes.MANAGE_COLLECTION);

    const createTemporaryAccess = staticPermission(permissionTypes.CREATE_TEMPORARY_ACCESS);

    const enableDisableUser = staticPermission(permissionTypes.ENABLE_DISABLE_USER);

    const writeAccessLevels = staticPermission(permissionTypes.WRITE_ACCESS_LEVELS);

    const listUsers = staticPermission(permissionTypes.LIST_USERS);

    const listAccessLevels = staticPermission(permissionTypes.LIST_ACCESS_LEVELS);

    const setUserAccessLevels = staticPermission(permissionTypes.SET_USER_ACCESS_LEVELS);

    const executeAction = nodePermission(permissionTypes.EXECUTE_ACTION);

    const alwaysAuthorized = () => true;

    const permission = {
        createRecord, updateRecord, deleteRecord,
        readRecord, writeTemplates, createUser,
        setPassword, readIndex, createTemporaryAccess,
        enableDisableUser, writeAccessLevels, listUsers,
        listAccessLevels, manageIndex, manageCollection,
        executeAction, setUserAccessLevels
    };

    const getNew = app => (collectionKey, recordTypeName) => {
        const recordNode = getRecordNode(app, collectionKey, recordTypeName);
        return apiWrapperSync(
            app,
            events.recordApi.getNew, 
            permission.createRecord.isAuthorized(recordNode.nodeKey()),
            {collectionKey, recordTypeName},
            _getNew, recordNode, collectionKey);
    };

    const _getNew = (recordNode, collectionKey) => 
        constructRecord(recordNode, getNewFieldValue, collectionKey);

    const getRecordNode = (app, collectionKey, recordTypeName) => {
        collectionKey = safeKey(collectionKey);
        return getNodeForCollectionPath(app.heirarchy)(collectionKey);
    };

    const getNewChild = (app) => 
            (recordKey, collectionName, recordTypeName) => 
        getNew(app)(joinKey(recordKey, collectionName), recordTypeName);

    const constructRecord = (recordNode, getFieldValue, collectionKey) => {
        const record = $(recordNode.fields, [
            fp.keyBy("name"),
            fp.mapValues(getFieldValue)
        ]);

        record.id = `${recordNode.nodeId}-${shortid.generate()}`;
        record.key = joinKey(collectionKey, record.id);
        record.isNew = true;
        record.type = recordNode.name;
        return record;
    };

    const getRecordFileName = key => 
        joinKey(key, "record.json");

    const load = (app) => async key => 
        apiWrapper(
            app,
            events.recordApi.load, 
            permission.readRecord.isAuthorized(key),
            {key},
            _load, app, key);

    const _load = async (app, key, keyStack=[]) => {
        key = safeKey(key);
        const recordNode = getExactNodeForPath(app.heirarchy)(key);
        const storedData = await app.datastore.loadJson(
            getRecordFileName(key)
        );

        const loadedRecord = $(recordNode.fields, [
            fp.keyBy("name"),
            fp.mapValues(f => safeParseField(f, storedData))
        ]);

        const newKeyStack = [...keyStack, key];

        const references = $(recordNode.fields, [
            fp.filter(f => f.type === "reference" 
                        && isNonEmptyString(loadedRecord[f.name].key)
                        && !fp.includes(loadedRecord[f.name].key)(newKeyStack)),
            fp.map(f => ({
                promise:_load(app, loadedRecord[f.name].key, newKeyStack),
                index: getExactNodeForPath(app.heirarchy)(f.typeOptions.indexNodeKey),
                field: f
            }))
        ]);

        if(references.length > 0) {
            const refRecords = await Promise.all(
                fp.map(p => p.promise)(references)
            );

            for(let ref of references) {
                loadedRecord[ref.field.name] = mapRecord(
                    refRecords[references.indexOf(ref)], 
                    ref.index
                );
            }
        }

        loadedRecord.transactionId = storedData.transactionId;
        loadedRecord.isNew = false;
        loadedRecord.key = key;
        loadedRecord.id = $(key, [splitKey, fp.last]);
        loadedRecord.type = recordNode.name;
        return loadedRecord;
    };

    const getIndexedDataKey = (indexNode, indexKey, record) => {

        const getShardName = (indexNode, record) => 
            compilerUtil.compileCode(indexNode.getShardName)({record});
        
        const shardName = isNonEmptyString(indexNode.getShardName)
                          ? `${getShardName(indexNode, record)}.csv`
                          : "index.csv";
            
        return joinKey(indexKey, shardName);    
    };

    const getShardKeysInRange = async (app, indexKey, startRecord=null, endRecord=null) => {

        const indexNode = getExactNodeForPath(app.heirarchy)
                                             (indexKey);

        const startShardName = !startRecord 
                               ? null 
                               : shardNameFromKey(
                                    getIndexedDataKey(
                                        indexNode, 
                                        indexKey, 
                                        startRecord)
                                 );

        const endShardName = !endRecord 
                             ? null 
                             : shardNameFromKey(
                                getIndexedDataKey(
                                    indexNode, 
                                    indexKey, 
                                    endRecord)
                               );

        return $(await getShardMap(app.datastore, indexKey),[
            fp.filter(k => (startRecord === null || k >= startShardName) 
                        && (endRecord === null || k <= endShardName)),
            fp.map(k => joinKey(indexKey, k + ".csv"))
        ]);
    };

    const ensureShardNameIsInShardMap = async (store, indexKey, indexedDataKey) => {
        const map = await getShardMap(store, indexKey);
        const shardName = shardNameFromKey(indexedDataKey);
        if(!fp.includes(shardName)(map)) {
            map.push(shardName);
            await writeShardMap(store, indexKey, map);
        }
    };

    const getShardMap = async (datastore, indexKey) => {
        const shardMapKey = getShardMapKey(indexKey);
        try {
            return await datastore.loadJson(shardMapKey);
        } catch(_$$1) {
            await datastore.createJson(shardMapKey, []);
            return [];
        }
    };

    const writeShardMap = async (datastore, indexKey, shardMap) => 
        await datastore.updateJson(
            getShardMapKey(indexKey),
            shardMap
        );

    const getAllShardKeys = async (app, indexKey) => 
        await getShardKeysInRange(app, indexKey);

    const getShardMapKey = indexKey => 
        joinKey(indexKey, "shardMap.json");
        
    const getUnshardedIndexDataKey = indexKey =>
        joinKey(indexKey, "index.csv");

    const createIndexFile = async (datastore, indexedDataKey, index$$1) => {
        if(isShardedIndex(index$$1)) {
            const indexKey = getParentKey(indexedDataKey);
            const shardMap = await getShardMap(datastore, indexKey);
            shardMap.push(
                shardNameFromKey(indexedDataKey)
            );
            await writeShardMap(datastore, indexKey, shardMap);
        }
        await datastore.createFile(indexedDataKey, "");
    };

    const shardNameFromKey = key => 
        $(key,[
            splitKey,
            fp.last
        ]).replace(".csv","");

    const getIndexKey_BasedOnDecendant = (decendantKey, indexNode) => {

        if(isGlobalIndex(indexNode))
            return `${indexNode.nodeKey()}`

        const indexedDataParentKey = 
                getActualKeyOfParent(
                    indexNode.parent().nodeKey()    
                    ,decendantKey);

        return joinKey(
            indexedDataParentKey,
            indexNode.name
        );
    };

    const generateSchema = (heirarchy$$1, indexNode) => {

        const recordNodes = getAllowedRecordNodesForIndex(heirarchy$$1, indexNode);
        const mappedRecords = $(recordNodes, [
            fp.map(n => mapRecord(createSampleRecord(n), indexNode)),
        ]);

        // always has record key and sort key
        const schema = {
            sortKey:all$1.string,
            key: all$1.string,
        };

        const fieldsHas = fp.has(schema);
        const setField = (fieldName, value) => {
            if(value === null || value === undefined)
                return;
                
            const thisType = detectType(value);
            if(fieldsHas(fieldName)) {
                if(schema[fieldName] !== thisType) {
                    schema[fieldName] = all$1.string;
                }
            } else {
                schema[fieldName] = thisType;
            }
        };

        for(let mappedRec of mappedRecords) {
            for(let f in mappedRec) {
                setField(f, mappedRec[f]);
            }
        }

        // returing an array of {name, type}
        return $(schema, [
            fp.keys,
            fp.map(k => ({name:k, type:schema[k].name})),
            fp.filter(s => s.name !== "sortKey"), 
            fp.orderBy("name", ["desc"]), // reverse aplha
            fp.concat([{name:"sortKey",type:all$1.string.name}]), // sortKey on end
            fp.reverse // sortKey first, then rest are alphabetical
        ]);

    };

    const createSampleRecord = recordNode => 
        constructRecord(
            recordNode, 
            getSampleFieldValue, 
            recordNode.parent().nodeKey());

    const BUFFER_MAX_BYTES = 524288; // 0.5Mb

    const CONTINUE_READING_RECORDS = "CONTINUE_READING";
    const READ_REMAINING_TEXT = "READ_REMAINING";
    const CANCEL_READ = "CANCEL";

    const getIndexWriter = (heirarchy, indexNode, getNextInputBytes, flushOutputBuffer) => {
        const schema = generateSchema(heirarchy, indexNode);

        return ({
            read: read(getNextInputBytes, schema),
            updateIndex: updateIndex(getNextInputBytes, flushOutputBuffer, schema)
        });
    };

    const getIndexReader = (heirarchy, indexNode, getNextInputBytes) => 
        read(
            getNextInputBytes, 
            generateSchema(heirarchy, indexNode)
        );

    const updateIndex = (getNextInputBytes, flushOutputBuffer, schema) => (itemsToWrite, keysToRemove) => {
        const write = newOutputWriter(BUFFER_MAX_BYTES, flushOutputBuffer);
        const writtenItems = []; 
        read(getNextInputBytes, schema)(
            indexedItem => {
                const updated = fp.find(i => indexedItem.key === i.key)(itemsToWrite);
                const removed = fp.find(k => indexedItem.key === k)(keysToRemove);
                
                if(isSomething(removed)) 
                    return CONTINUE_READING_RECORDS;

                if(isSomething(updated)) {
                    const serializedItem =  serializeItem(schema, updated);
                    write(serializedItem);
                    writtenItems.push(updated);
                } else {
                    write(
                        serializeItem(schema, indexedItem)
                    );
                } 

                return CONTINUE_READING_RECORDS;

            },
            text => write(text)
        );

        if(writtenItems.length !== itemsToWrite.length) {
            const toAdd = fp.difference(itemsToWrite, writtenItems);
            for(let added of toAdd) {
                write(
                    serializeItem(schema, added)
                );
            }
        } else if(writtenItems.length === 0) {
            // potentially are no records
            write("");
        }

        write();
    };

    const read = (getNextInputBytes, schema) => (onGetItem, onGetText) => {
        const readInput = newInputReader(getNextInputBytes);
        let text = readInput();
        let status = CONTINUE_READING_RECORDS;
        while(text.length > 0) {

            if(status === READ_REMAINING_TEXT) {
                onGetText(text);
                hasContent = true;
                continue;
            }

            if(status === CANCEL_READ) {
                return;
            }

            let rowText = "";
            let currentCharIndex=0;
            for(let currentChar of text) {
                rowText += currentChar;
                if(currentChar === "\r") {
                    status = onGetItem(
                        deserializeRow(schema, rowText)
                    );
                    rowText = "";
                    if(status === READ_REMAINING_TEXT) {
                        break;
                    }
                }
                currentCharIndex++;
            }

            if(currentCharIndex < text.length -1) {
                onGetText(text.substring(currentCharIndex + 1));
            }

            text = readInput();
        }
    };

    const newOutputWriter = (flushBoundary, flush) => {
        
        let currentBuffer = null;

        return (text) => {

            if(fp.isString(text) && currentBuffer === null)
                currentBuffer = safeBuffer.Buffer.from(text, "utf8");
            else if(fp.isString(text))
                currentBuffer = safeBuffer.Buffer.concat([
                    currentBuffer,
                    safeBuffer.Buffer.from(text, "utf8")
                ]);
            
            if(currentBuffer !== null &&
                (currentBuffer.length > flushBoundary
                 || !fp.isString(text))) {

                flush(currentBuffer);
                currentBuffer = null;
            }
        }
    };

    const newInputReader = (getNextInputBytes) => {

        const decoder = new string_decoder.StringDecoder('utf8');
        let remainingBytes = [];

        return () => {
            const nextBytes = getNextInputBytes();
            const frombytes = [...remainingBytes, ...(!nextBytes ? [] : nextBytes)];
            if(frombytes.length === remainingBytes.length)
                return "";
            const buffer = safeBuffer.Buffer.from(frombytes);
            const text = decoder.write(buffer);
            remainingBytes = decoder.end(buffer);
            return text;
        };
    };

    const deserializeRow = (schema, rowText) => {
        let currentPropIndex = 0;
        let currentCharIndex = 0;
        let currentValueText = "";
        let isEscaped = false;
        const item = {};

        const setCurrentProp = () => {
            const currentProp = schema[currentPropIndex];
            const type = getType(currentProp.type);
            const value = currentValueText === ""
                          ? type.getDefaultValue()
                          : type.safeParseValue(
                              currentValueText);
            item[currentProp.name] = value;
        };
        
        while(currentPropIndex < schema.length) {

            if(currentCharIndex < rowText.length) {
                const currentChar = rowText[currentCharIndex];
                if(isEscaped) {
                    if(currentChar === "r") {
                        currentValueText += "\r";
                    } else {
                        currentValueText += currentChar;
                    }
                    isEscaped = false;
                } else {
                    if(currentChar === ",") {
                        setCurrentProp();
                        currentValueText = "";
                        currentPropIndex++;
                    } else if(currentChar === "\\") {
                        isEscaped = true;
                    } else {
                        currentValueText += currentChar;
                    }
                }
                currentCharIndex++; 
            } else {
                currentValueText = "";
                setCurrentProp();
                currentPropIndex++;
            }
        }

        return item;
    };

    const serializeItem = (schema, item)  => {

        let rowText = "";

        for(let prop of schema) {
            const type = getType(prop.type);
            const value = fp.has(prop.name)(item)
                          ? item[prop.name]
                          : type.getDefaultValue();
            
            const valStr = type.stringify(value);

            for(let i = 0; i < valStr.length; i++) {
                const currentChar = valStr[i];
                if(currentChar === "," 
                   || currentChar === "\r" 
                   || currentChar === "\\") {
                    rowText += "\\";
                }

                if(currentChar === "\r") {
                    rowText += "r";
                } else {
                    rowText += currentChar;
                }
            }

            rowText += ",";
        }

        rowText += "\r";
        return rowText;
    };

    const readIndex$1 = async (heirarchy$$1, datastore, index$$1, indexedDataKey) => {
        const records = [];
        const doRead = iterateIndex(
            item => {
                records.push(item);
                return CONTINUE_READING_RECORDS;
            },
            () => records
        );

        return await doRead(heirarchy$$1, datastore, index$$1, indexedDataKey);
    };

    const searchIndex = async (heirarchy$$1, datastore, index$$1, indexedDataKey, searchPhrase) => {
        const records = [];
        const schema = generateSchema(heirarchy$$1, index$$1);
        const doRead = iterateIndex(
            item => {
                const idx = lunr(function () {
                    this.ref('key');
                    for(let field of schema) {
                        this.field(field.name);
                    } 
                    this.add(item);
                });
                const searchResults = idx.search(searchPhrase);
                if(searchResults.length === 1) {
                    item._searchResult = searchResults[0];
                    records.push(item);
                }
                return CONTINUE_READING_RECORDS;
            },
            () => records
        );

        return await doRead(heirarchy$$1, datastore, index$$1, indexedDataKey);
    };

    const iterateIndex = (onGetItem, getFinalResult) => async (heirarchy$$1, datastore, index$$1, indexedDataKey) => {
        try {
            const readableStream = await datastore.readableFileStream(indexedDataKey);
            const read = getIndexReader(heirarchy$$1, index$$1, () => readableStream.read());
            read(onGetItem);
            return getFinalResult();
        } catch(e) {
            if(await datastore.exists(indexedDataKey)) {
                throw e;
            } else {
                await createIndexFile(
                    datastore,
                    indexedDataKey, 
                    index$$1
                );
            }
            return [];
        }
    };

    const listItems = app => async (indexKey, options) => 
        apiWrapper(
            app,
            events.indexApi.listItems, 
            permission.readIndex.isAuthorized(indexKey),
            {indexKey, options},
            _listItems, app, indexKey, options);

    const defaultOptions = {rangeStartParams:null, rangeEndParams:null, searchPhrase:null};

    const _listItems = async (app, indexKey, options=defaultOptions) => { 
        
        let {searchPhrase, rangeStartParams, rangeEndParams}= 
            $({}, [
                fp.merge(options),
                fp.merge(defaultOptions)
            ]);

        const getItems = async (key) =>
             isNonEmptyString(searchPhrase)
             ? await searchIndex(
                 app.heirarchy, 
                 app.datastore, 
                 indexNode, 
                 key, 
                 searchPhrase)
             : await readIndex$1(
                 app.heirarchy, 
                 app.datastore, 
                 indexNode, 
                 key);

        indexKey = safeKey(indexKey);
        const indexNode = getExactNodeForPath(app.heirarchy)(indexKey);

        if(!isIndex(indexNode))
            throw new Error("supplied key is not an index");

        if(isShardedIndex(indexNode)) {
            const shardKeys = await getShardKeysInRange(
                app, indexKey, rangeStartParams, rangeEndParams
            );
            const items = [];
            for(let k of shardKeys) {
                items.push(await getItems(k));
            }
            return fp.flatten(items);
        } else {
            return await getItems(
                getUnshardedIndexDataKey(indexKey)
            );
        }    
    };

    const getContext = app => recordKey => 
        apiWrapperSync(
            app,
            events.recordApi.getContext, 
            permission.readRecord.isAuthorized(recordKey),
            {recordKey},
            _getContext, app, recordKey);

    const _getContext = (app, recordKey) => {

        const recordNode = getExactNodeForPath(app.heirarchy)(recordKey);    

        const cachedReferenceIndexes = {};

        const lazyLoadReferenceIndex = async typeOptions => {

            if(!_.has(cachedReferenceIndexes, typeOptions.indexNodeKey)) {
                cachedReferenceIndexes[typeOptions.indexNodeKey] = {
                    typeOptions: typeOptions,
                    data: await readReferenceIndex(
                            app, recordKey, typeOptions)
                };
                        
            }

            return cachedReferenceIndexes[typeOptions.indexNodeKey];
        };

        const getTypeOptions = typeOptions_or_fieldName => 
            fp.isString(typeOptions_or_fieldName)
            ? findField(recordNode, typeOptions_or_fieldName)
                .typeOptions
            : typeOptions_or_fieldName;

        return {
            referenceExists : async (typeOptions_or_fieldName, key) => {
                const typeOptions = getTypeOptions(typeOptions_or_fieldName);
                const {data} = await lazyLoadReferenceIndex(typeOptions);
                return _.some(data, i => i.key === key);
            },
            referenceOptions: async (typeOptions_or_fieldName) => {
                const typeOptions = getTypeOptions(typeOptions_or_fieldName);
                const {data} = await lazyLoadReferenceIndex(typeOptions);
                return data;
            },
            recordNode
        };
    };

    const readReferenceIndex = async (app, recordKey,typeOptions) => {
        const indexNode = getNode(app.heirarchy, typeOptions.indexNodeKey);
        const indexKey = isGlobalIndex(indexNode)
                         ? indexNode.nodeKey()
                         : getIndexKey_BasedOnDecendant(
                                recordKey, indexNode
                            );

        const items = await listItems(app)(indexKey);
        return $(items, [
            fp.map(i => ({
                key: i.key,
                value: i[typeOptions.displayValue]
            }))
        ]);
     };

    const fieldParseError = (fieldName, value) => 
        ({fields:[fieldName], 
        message: `Could not parse field ${fieldName}:${value}`});

    const validateAllFieldParse = (record, recordNode) => 
        $(recordNode.fields, [
            fp.map(f => ({name:f.name, parseResult:validateFieldParse(f, record)})),
            fp.reduce((errors, f) => {
                if(f.parseResult.success) return errors;
                errors.push(
                    fieldParseError(f.name, f.parseResult.value));
                return errors;
            }, [])
        ]);

    const validateAllTypeConstraints = async (record, recordNode, context) => {
        const errors = [];
        for(let field of recordNode.fields) {
            $(await validateTypeConstraints$1(field, record, context), [
                fp.filter(isNonEmptyString),
                fp.map(m => ({message:m, fields:[field.name]})),
                fp.each(e => errors.push(e))
            ]);
        }
        return errors;
    };

    const runRecordValidationRules = (record, recordNode) => {

        const runValidationRule = rule => {
            const isValid = compilerUtil.compileExpression(rule.expressionWhenValid);
            const expressionContext = {record, _: ___default};
            return (isValid(expressionContext)
                ? {valid:true}
                : ({valid:false, 
                    fields: rule.invalidFields, 
                    message:rule.messageWhenInvalid}));
        };

        return $(recordNode.validationRules, [
            fp.map(runValidationRule),
            fp.flatten,
            fp.filter(r => r.valid === false),
            fp.map(r => ({fields:r.fields, message:r.message}))
        ]);
    };

    const validate = app => async (record, context) => {
        context = isNothing(context) 
                  ? _getContext(app, record.key)
                  : context;

        const recordNode = getExactNodeForPath(app.heirarchy)(record.key);
        const fieldParseFails =  validateAllFieldParse(record, recordNode);
        
        // non parsing would cause further issues - exit here
        if(!fp.isEmpty(fieldParseFails))
            return ({isValid:false, errors:fieldParseFails});

        const recordValidationRuleFails = runRecordValidationRules(record, recordNode);
        const typeContraintFails = await validateAllTypeConstraints(record, recordNode, context);

        if(fp.isEmpty(fieldParseFails) 
           && fp.isEmpty(recordValidationRuleFails)
           && fp.isEmpty(typeContraintFails)) {
               return ({isValid:true, errors:[]});
        }
        
        return ({
            isValid:false, 
            errors: ___default.union(fieldParseFails, typeContraintFails, recordValidationRuleFails)});
    };

    const ensureCollectionIsInitialised = async (datastore, node, parentKey) => {

        if(!await datastore.exists(parentKey)) {
            await datastore.createFolder(parentKey);
            await datastore.createFolder(
                joinKey(parentKey,"allids")
            );
            await datastore.createFolder(
                joinKey(
                    parentKey,
                    "allids",
                    node.nodeId.toString())
            );
            
        }   
    };

    const initialiseRootCollections = async (datastore, heirarchy$$1) => {

        const rootCollectionRecord = 
            allTrue(
                n => isRoot(n.parent()), 
                isCollectionRecord
            );

        const flatheirarchy = getFlattenedHierarchy(heirarchy$$1);

        const collectionRecords = $(flatheirarchy, [
            fp.filter(rootCollectionRecord)
        ]);
        
        for(let col of collectionRecords) {
            await ensureCollectionIsInitialised(
                    datastore, 
                    col, 
                    col.collectionPathRegx());
        }   

    };

    const initialiseChildCollections = async (app, recordKey) => {
        const childCollectionRecords = $(recordKey, [
            getExactNodeForPath(app.heirarchy),
            n => n.children,
            fp.filter(isCollectionRecord)
        ]);

        for(let child of childCollectionRecords) {
            await ensureCollectionIsInitialised(
                app.datastore,
                child,
                joinKey(recordKey, child.collectionName)
            );
        }
    };

    const allIdChars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";

    const allIdsStringsForFactor = collectionNode => {
        const factor = collectionNode.allidsShardFactor;
        const charRangePerShard = 64 / factor;
        const allIdStrings = [];
        let index$$1 = 0;
        let currentIdsShard = "";
        while(index$$1 < 64) {
            currentIdsShard = currentIdsShard 
                              + allIdChars[index$$1];
            if((index$$1 + 1) % charRangePerShard === 0) {
                allIdStrings.push(currentIdsShard);
                currentIdsShard = "";
            } 
            index$$1++;
        }

        return allIdStrings;
    };

    const getAllIdsShardNames = (appHeirarchy, collectionKey) => {
        const collectionRecordNode = getNodeForCollectionPath(appHeirarchy)
                                                  (collectionKey);
        return $(collectionRecordNode,[
            c => [c.nodeId],
            fp.map(i => 
                fp.map(c => _allIdsShardKey(collectionKey, i, c))
                    (allIdsStringsForFactor(collectionRecordNode))
            ),
            fp.flatten
        ]);
    };

    const _allIdsShardKey = (collectionKey, childNo, shardKey) => 
        joinKey(
            collectionKey,
            "allids",
            childNo,
            shardKey
        );

    const getAllIdsShardKey = (appHeirarchy, collectionKey, recordId) => {  
        const indexOfFirstDash = recordId.indexOf("-");

        const collectionNode = getNodeForCollectionPath(appHeirarchy)
                                                        (collectionKey);

        const idFirstChar = recordId[indexOfFirstDash + 1];
        const allIdsShardId = $(collectionNode, [
            allIdsStringsForFactor,
            fp.find(i => i.includes(idFirstChar))
        ]);

        return _allIdsShardKey(
            collectionKey, 
            recordId.slice(0, indexOfFirstDash), 
            allIdsShardId)
            
    };

    const getOrCreateShardFile = async (datastore, allIdsKey) => {
        try {
            return await datastore.loadFile(allIdsKey);
        } catch(eLoad) {
            try {
                await datastore.createFile(allIdsKey, "");
                return "";
            } catch (eCreate) {
                throw new Error(
                    "Error loading, then creating allIds " + allIdsKey 
                    + " : LOAD : " + eLoad.message 
                    + " : CREATE : " + eCreate);
            }
        }
    };

    const getShardFile = async (datastore, allIdsKey) => {
        try {
            return await datastore.loadFile(allIdsKey);
        } catch(eLoad) {
            return "";
        }
    };

    const addToAllIds = (appHeirarchy, datastore) => async record => {
        const allIdsKey = getAllIdsShardKey(
            appHeirarchy,
            getParentKey(record.key),
            record.id
        );

        let allIds = await getOrCreateShardFile(datastore, allIdsKey);    

        allIds += `${allIds.length > 0 ? "," : ""}${record.id}`;

        await datastore.updateFile(allIdsKey, allIds);    
    };

    const getAllIdsIterator = (app) => async (collection_Key_or_NodeKey) => {

        collection_Key_or_NodeKey = safeKey(collection_Key_or_NodeKey);
        const targetNode = getCollectionNodeByKeyOrNodeKey(
            app.heirarchy,
            collection_Key_or_NodeKey);

        const getAllIdsIteratorForCollectionKey = async (collectionKey) => { 

            const all_allIdsKeys = getAllIdsShardNames(app.heirarchy, collectionKey);
            let shardIndex = 0;
            
            const allIdsFromShardIterator = async () => {

                if(shardIndex === all_allIdsKeys.length)
                    return ({done:true, result:{ids:[], collectionKey}});

                const shardKey = all_allIdsKeys[shardIndex];

                const allIds = await getAllIdsFromShard(app.datastore, shardKey);
            
                shardIndex++;
                
                return ({ 
                    result: {
                        ids: allIds,
                        collectionKey
                    }, 
                    done: false });
            };

            return allIdsFromShardIterator;
        };    
        
        const ancestors = $(getFlattenedHierarchy(app.heirarchy), [
            fp.filter(isCollectionRecord),
            fp.filter(n => isAncestor(targetNode)(n) 
                        || n.nodeKey() === targetNode.nodeKey()),
            fp.orderBy([n => n.nodeKey().length], ["asc"])
        ]); // parents first

        const traverseForIteraterators = async (parentRecordKey = "", currentNodeIndex = 0) => {
            const currentNode = ancestors[currentNodeIndex];
            const currentCollectionKey = joinKey(
                parentRecordKey,
                currentNode.collectionName
            );
            if(currentNode.nodeKey() === targetNode.nodeKey()) {
                return [
                    await getAllIdsIteratorForCollectionKey(
                        currentCollectionKey)];
            }
            const allIterators = [];
            const currentIterator = await getAllIdsIteratorForCollectionKey(
                currentCollectionKey
            );
            
            let ids = await currentIterator();
            while(ids.done === false) {

                for(let id of ids.result.ids) {
                    allIterators.push(
                        await traverseForIteraterators(
                            joinKey(currentCollectionKey, id),
                            currentNodeIndex + 1  
                        )
                    );
                }
                
                ids = await currentIterator();
            }

            return fp.flatten(allIterators);
        };

        const iteratorsArray = await traverseForIteraterators();
        let currentIteratorIndex = 0;
        return async () => {
            if(iteratorsArray.length === 0)
                return {done:true, result:[]}; 
            const innerResult = await iteratorsArray[currentIteratorIndex]();
            if(!innerResult.done) 
                return innerResult;
            if(currentIteratorIndex == iteratorsArray.length - 1){
                return {done:true, result: innerResult.result};
            }
            currentIteratorIndex++;
            return {done:false, result:innerResult.result};
        };
    };

    const getAllIdsFromShard = async (datastore, shardKey) => {
        
        const allIdsStr = await getShardFile(datastore, shardKey);

        const allIds = [];
        let currentId = "";
        for (var i = 0; i < allIdsStr.length; i++) {
            let currentChar = allIdsStr.charAt(i);
            const isLast = (i === allIdsStr.length - 1);
            if(currentChar === "," || isLast) {
                if(isLast) currentId += currentChar;
                allIds.push(currentId);
                currentId = "";
            } else {
                currentId += currentChar;
            }
        }
        return allIds;
    };

    const removeFromAllIds = (appHeirarchy,datastore) => 
                                    async (record) => {
        const shardKey = getAllIdsShardKey(
            appHeirarchy,
            getParentKey(record.key),
            record.id
        );
        const allIds = await getAllIdsFromShard(datastore, shardKey);
        
        const newIds = $(allIds, [
            fp.pull(record.id),
            fp.join(",")
        ]);

        await datastore.updateFile(shardKey, newIds);
    };

    const TRANSACTIONS_FOLDER = keySep + ".transactions";
    const LOCK_FILENAME = "lock";
    const LOCK_FILE_KEY = joinKey(
        TRANSACTIONS_FOLDER, LOCK_FILENAME);
    const idSep = "$";


    const isOfType = typ => trans => 
        trans.transactionType === typ;

    const CREATE_RECORD_TRANSACTION = "create";
    const UPDATE_RECORD_TRANSACTION = "update";
    const DELETE_RECORD_TRANSACTION = "delete";
    const BUILD_INDEX_TRANSACTION = "build";

    const isUpdate = isOfType(UPDATE_RECORD_TRANSACTION);
    const isDelete = isOfType(DELETE_RECORD_TRANSACTION);
    const isCreate = isOfType(CREATE_RECORD_TRANSACTION);
    const isBuildIndex = isOfType(BUILD_INDEX_TRANSACTION);

    const keyToFolderName = nodeKey => getHashCode(nodeKey);

    const getTransactionId = (recordId, transactionType, uniqueId) => 
        `${recordId}${idSep}${transactionType}${idSep}${uniqueId}`;

    const buildIndexFolder = ".BUILD-";
    const nodeKeyHashFromBuildFolder = folder =>
        folder.replace(buildIndexFolder, "");

    const isBuildIndexFolder = key => 
        getLastPartInKey(key).startsWith(buildIndexFolder);

    const IndexNodeKeyFolder = indexNodeKey => 
        joinKey(
            TRANSACTIONS_FOLDER, 
            buildIndexFolder + keyToFolderName(indexNodeKey));

    const IndexNodeKeyBatchFolder = (indexNodeKey, count) => 
        joinKey(IndexNodeKeyFolder(indexNodeKey), Math.floor(count/BUILDINDEX_BATCH_COUNT).toString());

    const BUILDINDEX_BATCH_COUNT = 1000;
    const timeoutMilliseconds$1 =  30 * 1000; // 30 secs
    const maxLockRetries = 1;

    const transactionForCreateRecord = async (app, record) => 
        await transaction(
            app.datastore, CREATE_RECORD_TRANSACTION, 
            record.key, {record},
            getTransactionKey_Records);

    const transactionForUpdateRecord = async (app, oldRecord, newRecord) => 
        await transaction(
            app.datastore, UPDATE_RECORD_TRANSACTION, 
            newRecord.key, {oldRecord, record:newRecord},
            getTransactionKey_Records);

    const transactionForDeleteRecord = async (app, record) => 
        await transaction(
            app.datastore, DELETE_RECORD_TRANSACTION, 
            record.key, {record},
            getTransactionKey_Records);

    const transactionForBuildIndex = async (app, indexNodeKey, recordKey, count) => {
        
        const transactionFolder =  IndexNodeKeyBatchFolder(indexNodeKey, count);
        if(count % BUILDINDEX_BATCH_COUNT === 0) {
            await app.datastore.createFolder(transactionFolder);
        }

        return await transaction(
                app.datastore, BUILD_INDEX_TRANSACTION,
                recordKey, {recordKey},
                id => joinKey(transactionFolder, id));
    };

    const createBuildIndexFolder = async(datastore, indexNodeKey) =>
        await datastore.createFolder(
            IndexNodeKeyFolder(indexNodeKey));

    const getTransactionKey_Records = id => joinKey(TRANSACTIONS_FOLDER, id);

    const transaction = async (datastore, transactionType, recordKey, data, getTransactionKey) => {

        const recordId = getLastPartInKey(recordKey);
        const uniqueId = shortid.generate();
        const id = getTransactionId(
            recordId, transactionType, uniqueId
        );

        const key = getTransactionKey(id);

        const trans = {
            transactionType,
            recordKey,
            ...data,
            id
        };

        await datastore.createJson(
            key, trans
        );

        return trans;
    };

    const initialiseIndex = async (datastore, parentKey, index$$1) => {
        const indexKey = joinKey(parentKey, index$$1.name);

        await datastore.createFolder(indexKey);

        if(isShardedIndex(index$$1)) {
            await datastore.createFile(
                getShardMapKey(indexKey),
                "[]"
            );
        } else {
            await createIndexFile(
                datastore,
                getUnshardedIndexDataKey(indexKey), 
                index$$1
            );
        }
    };

    const save = (app) => async (record, context) => 
        apiWrapper(
            app,
            events.recordApi.save, 
            record.isNew 
            ? permission.createRecord.isAuthorized(record.key)
            : permission.updateRecord.isAuthorized(record.key),
            {record},
            _save, app, record, context, false);


    const _save = async (app, record, context, skipValidation=false) => {
        const recordClone = fp.cloneDeep(record);
        if(!skipValidation) {
            const validationResult = await validate(app)
                                            (recordClone, context);
            if(!validationResult.isValid) {
                app.publish(events.recordApi.save.onInvalid, 
                            {record,validationResult});
                throw new Error("Save : Record Invalid : " 
                        + JSON.stringify(validationResult.errors));
            }
        }

        if(recordClone.isNew) {
            await addToAllIds(app.heirarchy, app.datastore)(recordClone);
            const transaction = await transactionForCreateRecord(
                app, recordClone);
            recordClone.transactionId = transaction.id;
            await app.datastore.createFolder(recordClone.key);
            await app.datastore.createFolder(
                joinKey(recordClone.key, "files"));
            await app.datastore.createJson(
                getRecordFileName(recordClone.key), 
                recordClone
            );
            await initialiseReverseReferenceIndexes(app, record);
            await initialiseAncestorIndexes(app, record);
            await initialiseChildCollections(app, recordClone.key);
            app.publish(events.recordApi.save.onRecordCreated, {
                record:recordClone
            });
        }
        else {
            const oldRecord = await _load(app, recordClone.key);
            const transaction = await transactionForUpdateRecord(
                app, oldRecord, recordClone);
            recordClone.transactionId = transaction.id;
            await app.datastore.updateJson(
                getRecordFileName(recordClone.key), 
                recordClone);
            
            app.publish(events.recordApi.save.onRecordUpdated, {
                old:oldRecord,
                new:recordClone
            });
        }

        await app.cleanupTransactions();
       
        const returnedClone = fp.cloneDeep(recordClone);
        returnedClone.isNew = false;
        return returnedClone;
    };

    const initialiseAncestorIndexes = async (app, record) => {
        const recordNode = getExactNodeForPath(app.heirarchy)
                                              (record.key);

        for(let index$$1 of recordNode.indexes) {
            const indexKey = joinKey(record.key, index$$1.name);
            if(!await app.datastore.exists(indexKey))
                await initialiseIndex(app.datastore, record.key, index$$1);
        } 
    };

    const initialiseReverseReferenceIndexes = async (app, record) => {

        const recordNode = getExactNodeForPath(app.heirarchy)
                                              (record.key);

        const indexNodes = 
            $(fieldsThatReferenceThisRecord(app, recordNode), [
                fp.map(f => $(f.typeOptions.reverseIndexNodeKeys, [
                            fp.map(n => getNode(
                                        app.heirarchy,
                                        n))
                        ])
                ),
                fp.flatten
            ]);

        for(let indexNode of indexNodes) {
            await initialiseIndex(
                app.datastore, record.key, indexNode
            );
        }
    };

    const fieldsThatReferenceThisRecord = (app, recordNode) =>
        $(app.heirarchy, [
            getFlattenedHierarchy,
            fp.filter(isRecord),
            fp.map(n => n.fields),
            fp.flatten,
            fp.filter(fieldReversesReferenceToNode(recordNode))
        ]);

    const _deleteIndex = async (app, indexKey, includeFolder) => {
        const indexNode = getExactNodeForPath(app.heirarchy)(indexKey);
        
        if(!isIndex(indexNode))
            throw new Error("Supplied key is not an index");
        
        if(isShardedIndex(indexNode)) {
            const shardKeys = await getAllShardKeys(app, indexKey);
            for(let k of shardKeys) {
                await tryAwaitOrIgnore(
                    app.datastore.deleteFile(k)
                );
            }
            tryAwaitOrIgnore(
                await app.datastore.deleteFile(
                    getShardMapKey(indexKey)
                )
            );
        } else {
            await tryAwaitOrIgnore(
                app.datastore.deleteFile(
                    getUnshardedIndexDataKey(indexKey)
                )
            );
        }

        if(includeFolder) {
            tryAwaitOrIgnore(
                await app.datastore.deleteFolder(indexKey)
            );
        }
    };

    const deleteCollection = (app, disableCleanup=false) => async key => 
        apiWrapper(
            app,
            events.collectionApi.delete, 
            permission.manageCollection.isAuthorized,
            {key},
            _deleteCollection, app, key, disableCleanup);


    const _deleteCollection = async (app, key, disableCleanup) => {
        key = safeKey(key);
        const node = getNodeForCollectionPath(app.heirarchy)(key);
        
        await deleteRecords(app, key);
        await deleteAllIdsFolders(app, node, key);
        await deleteCollectionFolder(app, key);
        if(!disableCleanup)
            await app.cleanupTransactions();
    };

    const deleteCollectionFolder = async (app, key) =>
        await app.datastore.deleteFolder(key);


    const deleteAllIdsFolders = async (app, node, key) => {
            
        await app.datastore.deleteFolder(
            joinKey(
                key, "allids", 
                node.nodeId
            )
        );    

        await app.datastore.deleteFolder(
            joinKey(key, "allids")
        );
    };

    const deleteRecords = async (app, key) => {


        const deletedAllIdsShards = [];
        const deleteAllIdsShard = async recordId => {
            
            const shardKey = getAllIdsShardKey(
                app.heirarchy, key, recordId);

            if(fp.includes(shardKey)(deletedAllIdsShards)) {
                return;
            }

            deletedAllIdsShards.push(shardKey);

            await app.datastore.deleteFile(shardKey);
        };

        const iterate = await getAllIdsIterator(app)(key);

        let ids = await iterate();
        while(!ids.done) {

            if(ids.result.collectionKey === key) {
                for(let id of ids.result.ids) {
                    await _deleteRecord(
                        app, 
                        joinKey(key, id), 
                        true);
                    await deleteAllIdsShard(id);
                }       
            }

            ids = await iterate();
        }



    };

    const deleteRecord$1 = (app, disableCleanup=false) => async (key) => 
        apiWrapper(
            app,
            events.recordApi.delete, 
            permission.deleteRecord.isAuthorized(key),
            {key},
            _deleteRecord, app, key, disableCleanup);

    // called deleteRecord because delete is a keyword
    const _deleteRecord = async (app, key, disableCleanup) => { 
        key = safeKey(key);
        const node = getExactNodeForPath(app.heirarchy)(key);
        
        const record = await _load(app, key);
        await transactionForDeleteRecord(app, record);

        
        for(let collectionRecord of node.children) {
            const collectionKey = joinKey(
                key, collectionRecord.collectionName
            );
            await _deleteCollection(app, collectionKey, true);
        }

        
        await app.datastore.deleteFile(
            getRecordFileName(key));

        await deleteFiles(app, key);

        await removeFromAllIds(app.heirarchy, app.datastore)(record);
        
        if(!disableCleanup)
            await app.cleanupTransactions();
            
        await app.datastore.deleteFolder(key);
        await deleteIndexes(app, key);
    };

    const deleteIndexes = async (app, key) => {
        const node = getExactNodeForPath(app.heirarchy)
                                        (key);
        /*const reverseIndexKeys = $(app.heirarchy, [
            getFlattenedHierarchy,
            map(n => n.fields),
            flatten,
            filter(isSomething),
            filter(fieldReversesReferenceToNode(node)),
            map(f => $(f.typeOptions.reverseIndexNodeKeys, [
                        map(n => getNode(
                                    app.heirarchy,
                                    n))
                    ])
            ),
            flatten,
            map(n => joinKey(key, n.name))
        ]);

        for(let i of reverseIndexKeys) {
            await _deleteIndex(app, i, true);
        }*/

        for(let index$$1 of node.indexes) {
            const indexKey = joinKey(key, index$$1.name);
            await _deleteIndex(app, indexKey, true);
        }
    };

    const deleteFiles = async (app, key) => {
        
        const filesFolder = joinKey(key, "files");
        const allFiles = await app.datastore.getFolderContents(
            filesFolder
        );

        for(let file of allFiles) {
            await app.datastore.deleteFile(file);
        }
        
        await app.datastore.deleteFolder(
            joinKey(key, "files")
        );
    };

    const uploadFile = (app) => async (recordKey, readableStream, relativePath) => 
        apiWrapper(
            app,
            events.recordApi.uploadFile, 
            permission.updateRecord.isAuthorized(recordKey),
            {recordKey, readableStream, relativePath},
            _uploadFile, app, recordKey, readableStream, relativePath);


    const _uploadFile = async (app, recordKey, readableStream, relativePath) => {
        
        if(isNothing(recordKey))
            throw new Error("Record Key not supplied");
        if(isNothing(relativePath))
            throw new Error("file path not supplied");
        if(!isLegalFilename(relativePath))
            throw new Error("Illegal filename");


        const record = await _load(app, recordKey);
        
        const fullFilePath = safeGetFullFilePath(
            recordKey, relativePath);

        const tempFilePath = `${fullFilePath}_${shortid.generate()}.temp`;

        const fileStream = await app.datastore.writableFileStream(
            tempFilePath);

        readableStream.pipe(fileStream);    

        await new Promise(fulfill => fileStream.on("finish", fulfill));

        const isExpectedFileSize = checkFileSizeAgainstFields(
            app,
            record, relativePath, 
            await app.datastore.getFileSize(tempFilePath));

        if(!isExpectedFileSize)
            throw new Error("Fields for " + relativeFilePath + " do not have expected size: " + path.join(",")(incorrectFields));
        
        await tryAwaitOrIgnore(app.datastore.deleteFile, fullFilePath);

        await app.datastore.renameFile(tempFilePath, fullFilePath);
    };

    const checkFileSizeAgainstFields = (app, record, relativeFilePath, expectedSize) => {
        const recordNode = getExactNodeForPath(app.heirarchy)(record.key);

        const incorrectFileFields = $(recordNode.fields, [
            fp.filter(f => f.type === "file"
                        && record[f.name].relativePath === relativeFilePath
                        && record[f.name].size !== expectedSize),
            fp.map(f => f.name)
        ]);

        const incorrectFileArrayFields = $(recordNode.fields, [
            fp.filter(a => a.type === "array<file>" &&
                        $(record[a.name], [
                            fp.some(f => record[f.name].relativePath === relativeFilePath
                                      && record[f.name].size !== expectedSize)
                        ])
            ),
            fp.map(f => f.name)
        ]);

        const incorrectFields = [
            ...incorrectFileFields,
            ...incorrectFileArrayFields
        ];

        if(incorrectFields.length > 0) {
            return false;
        }

        return true;
    };

    const safeGetFullFilePath = (recordKey, relativePath) => {
       
        const naughtyUser = () => { throw new Error("naughty naughty"); };

        if(relativePath.startsWith("..")) naughtyUser();

        const pathParts = splitKey(relativePath);

        if(fp.includes("..")(pathParts)) naughtyUser();

        const recordKeyParts = splitKey(recordKey);

        const fullPathParts = [
            ...recordKeyParts,
            "files", 
            ...fp.filter(p => p !== ".")(pathParts)
        ];

        return joinKey(fullPathParts);

    };

    const downloadFile = (app) => async (recordKey, relativePath) => 
        apiWrapper(
            app,
            events.recordApi.uploadFile, 
            permission.readRecord.isAuthorized(recordKey),
            {recordKey, recordKey, relativePath},
            _downloadFile, app, recordKey, relativePath);


    const _downloadFile = async (app, recordKey, relativePath) => {
        
        if(isNothing(recordKey))
            throw new Error("Record Key not supplied");
        if(isNothing(relativePath))
            throw new Error("file path not supplied");

        return await app.datastore.readableFileStream(
            safeGetFullFilePath(
                recordKey, relativePath)
        );
    };

    const api = app => {
        return ({
            getNew : getNew(app), 
            getNewChild: getNewChild(app),
            save: save(app), 
            load: load(app), 
            delete: deleteRecord$1(app, false),
            validate: validate(app),
            getContext: getContext(app),
            uploadFile: uploadFile(app),
            downloadFile: downloadFile(app)
        });
    };


    const getRecordApi = (app) => 
        api(app);

    const getAllowedRecordTypes = (app) => (key) => 
        apiWrapperSync(
            app,
            events.collectionApi.getAllowedRecordTypes, 
            alwaysAuthorized,
            {key},
            _getAllowedRecordTypes, app, key);


    const _getAllowedRecordTypes = (app, key) => {
        key = safeKey(key);
        const node = getNodeForCollectionPath(app.heirarchy)(key);
        return isNothing(node) ? [] : [node.name];
    };

    const getCollectionApi = app => ({
        getAllowedRecordTypes : getAllowedRecordTypes(app),
        getAllIdsIterator : getAllIdsIterator(app),
        delete: deleteCollection(app)
    });

    /** rebuilds an index
     * @param {object} app - the application container
     * @param {string} indexNodeKey - node key of the index, which the index belongs to 
     */
    const buildIndex = app => async (indexNodeKey) => 
        apiWrapper(
            app,
            events.indexApi.buildIndex, 
            permission.manageIndex.isAuthorized,
            {indexNodeKey},
            _buildIndex, app, indexNodeKey);

    const _buildIndex = async (app, indexNodeKey) => {
        const indexNode = getNode(app.heirarchy, indexNodeKey);

        await createBuildIndexFolder(app.datastore, indexNodeKey);

        if(!isIndex(indexNode)) 
            throw new Error("BuildIndex: must supply a indexnode");

        if(indexNode.indexType === "reference") {
            await buildReverseReferenceIndex(
                app, indexNode
            );
        } else {
            await buildHeirarchalIndex(
                app, indexNode
            );
        }

        await app.cleanupTransactions();
    };

    const buildReverseReferenceIndex = async (app, indexNode) => {

        // Iterate through all referencING records, 
        // and update referenced index for each record
        let recordCount = 0;
        const referencingNodes = $(app.heirarchy, [
            getFlattenedHierarchy,
            fp.filter(n => isRecord(n)
                        && fp.some(fieldReversesReferenceToIndex(indexNode))
                               (n.fields))
        ]);

        const createTransactionsForReferencingNode = async referencingNode => {

            const iterateReferencingNodes = 
                await getAllIdsIterator(app)
                        (referencingNode.collectionNodeKey());

            let referencingIdIterator = await iterateReferencingNodes();
            while(!referencingIdIterator.done) {
                const {result} = referencingIdIterator;
                for(let id of result.ids) {
                    const recordKey = joinKey(result.collectionKey, id);
                    await transactionForBuildIndex(app, indexNode.nodeKey(), recordKey, recordCount);
                    recordCount++;
                }
                referencingIdIterator = await iterateReferencingNodes();
            }

        };

        for(let referencingNode of referencingNodes) {
            await createTransactionsForReferencingNode(referencingNode);
        }
    };

    const buildHeirarchalIndex = async (app, indexNode) => {

        let recordCount = 0;

        const createTransactionsForIds = async (collectionKey, ids) => {

            for(let recordId of ids) {
                const recordKey = joinKey(collectionKey, recordId);

                const recordNode = getRecordNodeById(
                    app.heirarchy,
                    recordId
                );

                if(recordNodeApplies(indexNode)(recordNode)) {
                    await transactionForBuildIndex(
                        app, indexNode.nodeKey(), 
                        recordKey, recordCount);
                    recordCount++;
                }
            }
        };

        
        const collectionRecords = getAllowedRecordNodesForIndex(app.heirarchy, indexNode);

        for(let targetCollectionRecordNode of collectionRecords) {
            const allIdsIterator = await  getAllIdsIterator(app)
                                            (targetCollectionRecordNode.collectionNodeKey());
            
            let allIds = await allIdsIterator();
            while(allIds.done === false) {
                await createTransactionsForIds(
                    allIds.result.collectionKey,
                    allIds.result.ids);
                allIds = await allIdsIterator();
            }

        }

        return recordCount;
    };

    const recordNodeApplies = indexNode => recordNode => 
        fp.includes(recordNode.nodeId)(indexNode.allowedRecordNodeIds);

    const aggregates = app => async (indexKey, rangeStartParams=null, rangeEndParams=null) => 
        apiWrapper(
            app,
            events.indexApi.aggregates, 
            permission.readIndex.isAuthorized(indexKey),
            {indexKey, rangeStartParams, rangeEndParams},
            _aggregates, app, indexKey, rangeStartParams, rangeEndParams);

    const _aggregates = async (app, indexKey, rangeStartParams, rangeEndParams) => {
        indexKey = safeKey(indexKey);
        const indexNode = getExactNodeForPath(app.heirarchy)(indexKey);

        if(!isIndex(indexNode))
            throw new Error("supplied key is not an index");

        if(isShardedIndex(indexNode)) {
            const shardKeys = await getShardKeysInRange(
                app, indexKey, rangeStartParams, rangeEndParams
            );
            let aggregateResult = null;
            for(let k of shardKeys) {
                const shardResult = await getAggregates(app.heirarchy, app.datastore, indexNode, k);
                if(aggregateResult === null) {
                    aggregateResult = shardResult;
                } else {
                    aggregateResult = mergeShardAggregate(
                        aggregateResult,
                        shardResult
                    );
                }

            }
            return aggregateResult;
        } else {
            return await getAggregates(
                app.heirarchy,
                app.datastore, 
                indexNode,
                getUnshardedIndexDataKey(indexKey)
            );
        }    
    };

    const mergeShardAggregate = (totals, shard) => {

        const mergeGrouping = (tot, shr) => {
            tot.count = tot.count + shr.count;
            for(let aggName in tot) {
                if(aggName === "count") continue;
                const totagg = tot[aggName];
                const shragg = shr[aggName];
                totagg.sum = totagg.sum + shragg.sum;  
                totagg.max = totagg.max > shragg.max
                             ? totagg.max
                             : shragg.max;
                totagg.min = totagg.min < shragg.min
                             ? totagg.min
                             : shragg.min;
                totagg.mean = totagg.sum / tot.count;
            }
            return tot;
        };

        for(let aggGroupDef in totals) {
            for(let grouping in shard[aggGroupDef]) {
                const groupingTotal = totals[aggGroupDef][grouping];
                totals[aggGroupDef][grouping] = 
                    fp.isUndefined(groupingTotal)
                    ? shard[aggGroupDef][grouping]
                    : mergeGrouping(
                        totals[aggGroupDef][grouping],
                        shard[aggGroupDef][grouping]
                    );
            }
        }

        return totals;
    };

    const getAggregates = async (heirarchy$$1, datastore, index$$1, indexedDataKey) => {
        const aggregateResult = {};
        const doRead = iterateIndex(
            item => {
                applyItemToAggregateResult(
                    index$$1, aggregateResult, item
                );
                return CONTINUE_READING_RECORDS;
            },
            () => aggregateResult
        );

        return await doRead(heirarchy$$1, datastore, index$$1, indexedDataKey);
    };


    const applyItemToAggregateResult = (indexNode, result, item) => {
        
        const getInitialAggregateResult = () => ({
            sum: 0, mean: null, max: null, min: null
        });

        const applyAggregateResult = (agg, existing, count) => {
            const value = compilerUtil.compileCode(agg.aggregatedValue)
                                     ({record:item});
            
            if(!fp.isNumber(value)) return existing;

            existing.sum = existing.sum + value;
            existing.max = value > existing.max || existing.max === null
                           ? value 
                           : existing.max;
            existing.min = value < existing.min || existing.min === null
                           ? value
                           : existing.min;
            existing.mean = existing.sum / count;
            return existing;
        };

        for(let aggGroup of indexNode.aggregateGroups) {  

            if(!fp.has(aggGroup.name)(result)) {
                result[aggGroup.name] = {};
            }
            const thisGroupResult = result[aggGroup.name];

            if(isNonEmptyString(aggGroup.condition)) {
                if(!compilerUtil.compileExpression(aggGroup.condition)
                                     ({record:item})) {
                    continue;
                }
            }

            let group = isNonEmptyString(aggGroup.groupBy)
                          ? compilerUtil.compileCode(aggGroup.groupBy)
                                       ({record:item})
                          : "all";
            if(!isNonEmptyString(group)) {
                group = "(none)";
            }
            
            if(!fp.has(group)(thisGroupResult)) {
                thisGroupResult[group] = {count:0};
                for(let agg of aggGroup.aggregates) {
                    thisGroupResult[group][agg.name] = 
                        getInitialAggregateResult();
                } 
            }

            thisGroupResult[group].count++;

            for(let agg of aggGroup.aggregates) {
                const existingValues = thisGroupResult[group][agg.name];
                thisGroupResult[group][agg.name] = 
                    applyAggregateResult(
                        agg, existingValues,
                        thisGroupResult[group].count);
            }
        }
    };

    const getIndexApi = app => ({
        listItems : listItems(app), 
        buildIndex: buildIndex(app),
        aggregates: aggregates(app)
    });

    const createNodeErrors = {
        indexCannotBeParent : "Index template cannot be a parent",
        allNonRootNodesMustHaveParent: "Only the root node may have no parent",
        indexParentMustBeRecordOrRoot: "An index may only have a record or root as a parent",
        aggregateParentMustBeAnIndex: "aggregateGroup parent must be an index"
    };

    const pathRegxMaker = (node) => () => 
      node.nodeKey().replace(/{id}/g, "[a-zA-Z0-9_\-]+");

    const nodeKeyMaker = (node) => () => 
        switchCase(

            [n => isRecord(n) && !isSingleRecord(n),
             n => joinKey(
                    node.parent().nodeKey(),
                    node.collectionName,
                    n.nodeId + "-{id}")],
            
            [isRoot,
             _.constant("/")],

            [defaultCase,
                n => joinKey(node.parent().nodeKey(), n.name)]
             
        )(node);


    const validate$1 = parent => node => {

        if(isIndex(node) 
            && isSomething(parent) 
            && !isRoot(parent)
            && !isRecord(parent)) {
            throw new Error(createNodeErrors.indexParentMustBeRecordOrRoot);
        }

        if(isaggregateGroup(node) 
            && isSomething(parent) 
            && !isIndex(parent)) {
            throw new Error(createNodeErrors.aggregateParentMustBeAnIndex);
        }

        if(isNothing(parent) && !isRoot(node))
            throw new Error(createNodeErrors.allNonRootNodesMustHaveParent);
        
        return node;
    };

    const construct = (parent) => (node) => {
        
        node.nodeKey = nodeKeyMaker(node);
        node.pathRegx = pathRegxMaker(node);    
        node.parent = _.constant(parent);
        node.isRoot = () => isNothing(parent) 
                            && node.name === "root"
                            && node.type === "root";
        if(isCollectionRecord(node)) {
            node.collectionNodeKey = () => joinKey(
                parent.nodeKey(), node.collectionName
            );
            node.collectionPathRegx = () => joinKey(
                parent.pathRegx(), node.collectionName
            );
        }
        return node;
    };

    const addToParent = obj => {
        const parent = obj.parent();
        if(isSomething(parent)) {
            if(isIndex(obj))
                // Q: why are indexes not children ?
                // A: because they cannot have children of their own.
                parent.indexes.push(obj);
            else if(isaggregateGroup(obj))
                parent.aggregateGroups.push(obj);
            else
                parent.children.push(obj);

            if(isRecord(obj)) {
                const defaultIndex = _.find(
                    parent.indexes, 
                    i => i.name === parent.name + "_index");
                if(!!defaultIndex) {
                    defaultIndex.allowedRecordNodeIds.push(obj.nodeId);
                } 
            }
        }
        return obj;
    };

    const constructNode = (parent, obj) =>
        $(obj, [
            construct(parent),
            validate$1(parent),
            addToParent
        ]);

    const getNodeId = (parentNode) => {
        // this case is handled better elsewhere 
        if(!parentNode) return null;
        const findRoot = n => isRoot(n) ? n : findRoot(n.parent());
        const root = findRoot(parentNode);
        
        return getFlattenedHierarchy(root).length;    
    };

    const constructHeirarchy = (node, parent) => {
        construct(parent)(node);
        if(node.indexes) {
            _.each(node.indexes, 
                child => constructHeirarchy(child, node));
        }
        if(node.aggregateGroups) {
            _.each(node.aggregateGroups, 
                child => constructHeirarchy(child, node));
        }
        if(node.children && node.children.length > 0) {
            _.each(node.children, 
                child => constructHeirarchy(child, node));
        }
        if(node.fields) {
            _.each(node.fields, 
                f => _.each(f.typeOptions, (val, key) => {
                        const def = all$1[f.type].optionDefinitions[key];
                        if(!def) {
                            // unknown typeOption
                            delete f.typeOptions[key];
                        } else {
                            f.typeOptions[key] = def.parse(val);
                        }
                })
            );
        }
        return node;
    };


    const getNewRootLevel = () => 
        construct()({
            name:"root",
            type:"root",
            children:[],
            pathMaps:[],
            indexes:[],
            nodeId: 0,
        });

    const _getNewRecordTemplate = (parent, name, createDefaultIndex, isSingle) => {
        const node = constructNode(parent, {
            name:name, 
            type: "record",
            fields:[], 
            children:[],  
            validationRules:[],
            nodeId: getNodeId(parent),
            indexes: [],
            allidsShardFactor: isRecord(parent) ? 1 : 64,
            collectionName: "",
            isSingle
        });

        if(createDefaultIndex) {
            const defaultIndex = getNewIndexTemplate(parent);
            defaultIndex.name = name + "_index";
            defaultIndex.allowedRecordNodeIds.push(node.nodeId);
        }

        return node;
    };

    const getNewRecordTemplate = (parent, name="", createDefaultIndex=true) =>
        _getNewRecordTemplate(parent, name, createDefaultIndex, false);

    const getNewSingleRecordTemplate = (parent) => 
        _getNewRecordTemplate(parent, "", false, true);

    const getNewIndexTemplate = (parent, type="ancestor") => 
        constructNode(parent, {
            name:"",
            type:"index",
            map:"return {...record};",
            filter:"",
            indexType: type,
            getShardName: "",
            getSortKey: "record.id",
            aggregateGroups: [],
            allowedRecordNodeIds: [],
            nodeId: getNodeId(parent)
        });

    const getNewAggregateGroupTemplate = index$$1 => 
        constructNode(index$$1, {
            name: "",
            type:"aggregateGroup",
            groupBy: "",
            aggregates: [],
            condition: "",
            nodeId: getNodeId(index$$1)
        });

    const getNewAggregateTemplate = set => {
        const aggregatedValue = {
            name: "",
            aggregatedValue: ""
        };
        set.aggregates.push(aggregatedValue);
        return aggregatedValue;
    };

    const fieldErrors = {
        AddFieldValidationFailed : "Add field validation: "
    };

    const allowedTypes = () => fp.keys(all$1); 

    const getNewField = type => ({
        name: "",  // how field is referenced internally
        type: type,
        typeOptions: getDefaultOptions$1(type), 
        label: "", // how field is displayed
        getInitialValue : "default", // function that gets value when initially created
        getUndefinedValue : "default", // function that gets value when field undefined on record
    });

    const fieldRules = (allFields) => [
        makerule("name", "field name is not set",
                f => isNonEmptyString(f.name)),
        makerule("type", "field type is not set",
            f => isNonEmptyString(f.type)),
        makerule("label", "field label is not set",
            f => isNonEmptyString(f.label)),
        makerule("getInitialValue", "getInitialValue function is not set",
            f => isNonEmptyString(f.getInitialValue)),
        makerule("getUndefinedValue", "getUndefinedValue function is not set",
            f => isNonEmptyString(f.getUndefinedValue)),
        makerule("name", "field name is duplicated",
            f => isNothingOrEmpty(f.name) || 
                 fp.countBy("name")(allFields)[f.name] === 1),
        makerule("type", "type is unknown",
            f => isNothingOrEmpty(f.type) 
                 || fp.some(t => f.type === t)(allowedTypes())),
    ];

    const typeOptionsRules = field => {
        const type = all$1[field.type];
        if(isNothing(type)) return [];

        const def = optName => 
            type.optionDefinitions[optName];

        return $(field.typeOptions, [
            fp.keys,
            fp.filter(o => isSomething(def(o)) 
                        && isSomething(def(o).isValid)),
            fp.map(o => makerule(
                `typeOptions.${o}`,
                `${def(o).requirementDescription}`,
                field => def(o).isValid(field.typeOptions[o])
            ))
        ]);
    };

    const validateField = (allFields) => (field) => {
        const everySingleField = fp.includes(field)(allFields) ? allFields : [...allFields, field];
        return applyRuleSet([...fieldRules(everySingleField), ...typeOptionsRules(field)])(field);
    };

    const validateAllFields = (recordNode) => 
        $(recordNode.fields, [
            fp.map(validateField(recordNode.fields)),
            fp.flatten
        ]);

    const addField = (recordTemplate, field) => {
        if(isNothingOrEmpty(field.label)) {
            field.label = field.name;
        }
        const validationMessages = validateField([...recordTemplate.fields, field])(field);
        if(validationMessages.length > 0) {
            const errors = fp.map(m => m.error)(validationMessages);
            throw new Error(fieldErrors.AddFieldValidationFailed + " " + errors.join(", ")); 
        }
        recordTemplate.fields.push(field);
    };

    const getNewRecordValidationRule = 
                (invalidFields, 
                messageWhenInvalid, 
                expressionWhenValid) => 
        ({
            invalidFields, messageWhenInvalid, expressionWhenValid
        });

    const getStaticValue = switchCase(
        [fp.isNumber, v => v.toString()],
        [fp.isBoolean, v => v.toString()],
        [fp.defaultCase, v => `'${v}'`]
    );

    const commonRecordValidationRules = ({ 

        fieldNotEmpty : (fieldName) => 
            getNewRecordValidationRule(
                [fieldName], 
                `${fieldName} is empty`, 
                `!_.isEmpty(record['${fieldName}'])`),

        fieldBetween : (fieldName, min, max) => 
            getNewRecordValidationRule(
                [fieldName],
                `${fieldName} must be between ${min.toString()} and ${max.toString()}`,
                `record['${fieldName}'] >= ${getStaticValue(min)} &&  record['${fieldName}'] <= ${getStaticValue(max)} `),
        
        fieldGreaterThan : (fieldName, min) =>
            getNewRecordValidationRule(
                [fieldName],
                `${fieldName} must be greater than ${min.toString()} and ${max.toString()}`,
                `record['\gvfieldName}'] >= ${getStaticValue(min)}  `)
    }); 

    const addRecordValidationRule = recordNode => rule => 
        recordNode.validationRules.push(rule);

    const createTrigger = () => ({
        actionName: "",
        eventName: "",
        // function, has access to event context, 
        // returns object that is used as parameter to action
        // only used if triggered by event
        optionsCreator: "",
        // action runs if true, 
        // has access to event context 
        condition: "" 
    });

    const createAction = () => ({
        name: "", 
        behaviourSource: "", 
        // name of function in actionSource
        behaviourName: "",
        // parameter passed into behaviour. 
        // any other parms passed at runtime e.g.
        // by trigger, or manually, will be merged into this
        initialOptions: {}
    });

    const aggregateRules = [
        makerule("name", "choose a name for the aggregate",
            a => isNonEmptyString(a.name)),
        makerule("aggregatedValue", "aggregatedValue does not compile",
            a => _.isEmpty(a.aggregatedValue)
                || executesWithoutException(
                    () => compilerUtil.compileCode(a.aggregatedValue)))
    ];

    const validateAggregate = (aggregate) => 
        applyRuleSet(aggregateRules)(aggregate);

    const validateAllAggregates = all$$1 => 
        $(all$$1, [
            fp.map(validateAggregate),
            fp.flatten
        ]);

    const ruleSet = (...sets) => 
        fp.constant(fp.flatten([...sets]));

    const commonRules = [
        makerule("name", "node name is not set", 
             node => stringNotEmpty(node.name)),
        makerule("type", "node type not recognised",
            anyTrue(isRecord, isRoot, isIndex, isaggregateGroup ))
    ];

    const recordRules = [
        makerule("fields", "no fields have been added to the record",
            node => isNonEmptyArray(node.fields)),
        makerule("validationRules", "validation rule is missing a 'messageWhenValid' member",
            node => fp.every(r => _.has(r, "messageWhenInvalid"))
                    (node.validationRules)),
        makerule("validationRules", "validation rule is missing a 'expressionWhenValid' member",
            node => fp.every(r => _.has(r, "expressionWhenValid"))
                    (node.validationRules)),
    ];


    const aggregateGroupRules = [
        makerule("condition", "condition does not compile",
            a => fp.isEmpty(a.condition)
                 || executesWithoutException(
                        () => compilerUtil.compileExpression(a.condition))),
    ];

    const getRuleSet = node => 
        switchCase(

            [isRecord, ruleSet(
                        commonRules, 
                        recordRules)],

            [isIndex, ruleSet(
                          commonRules, 
                          indexRuleSet)],

            [isaggregateGroup, ruleSet(
                                commonRules,
                                aggregateGroupRules)],

            [defaultCase, ruleSet(commonRules, [])]
        )(node);

    const validateNode = node => 
        applyRuleSet(getRuleSet(node))(node);

    const validateAll = appHeirarchy => {
        
        var flattened = getFlattenedHierarchy(
            appHeirarchy
        );

        const duplicateNameRule = makerule(
            "name", "node names must be unique under shared parent",
            n => fp.filter(f => f.parent() === n.parent()
                              && f.name === n.name) 
                        (flattened).length === 1
        );

        const duplicateNodeKeyErrors = $(flattened, [
            fp.map(n => applyRuleSet([duplicateNameRule])(n)),
            fp.filter(isSomething),
            fp.flatten
        ]);

        const fieldErrors$$1 = $(flattened, [
            fp.filter(isRecord),
            fp.map(validateAllFields),
            fp.flatten
        ]);

        const aggregateErrors = $(flattened, [
            fp.filter(isaggregateGroup),
            fp.map(s => validateAllAggregates(
                        s.aggregates)),
            fp.flatten
        ]);

        return $(flattened, [
            fp.map(validateNode),
            fp.flatten,
            fp.union(duplicateNodeKeyErrors),
            fp.union(fieldErrors$$1),
            fp.union(aggregateErrors)
        ]);
    };

    const actionRules = [
        makerule("name", "action must have a name", 
            a => isNonEmptyString(a.name)),
        makerule("behaviourName", "must supply a behaviour name to the action",
            a => isNonEmptyString(a.behaviourName)),
        makerule("behaviourSource", "must supply a behaviour source for the action",
            a => isNonEmptyString(a.behaviourSource)),
    ];

    const duplicateActionRule = 
        makerule("", "action name must be unique", () =>{});

    const validateAction = action => 
        applyRuleSet(actionRules)(action);


    const validateActions = (allActions) => {
        
        const duplicateActions = $(allActions, [
            fp.filter(a => fp.filter(a2 => a2.name === a.name)
                              (allActions).length > 1),
            fp.map(a => validationError(duplicateActionRule, a))
        ]);
        
        const errors = $(allActions, [
            fp.map(validateAction),
            fp.flatten,
            fp.union(duplicateActions),
            fp.uniqBy("name")
        ]);

        return errors;
    };

    const triggerRules = actions => ([
        makerule("actionName", "must specify an action", 
            t => isNonEmptyString(t.actionName)),
        makerule("eventName", "must specify and event",
            t => isNonEmptyString(t.eventName)),
        makerule("actionName", "specified action not supplied",
            t => !t.actionName 
                 || fp.some(a => a.name === t.actionName)(actions)),
        makerule("eventName", "invalid Event Name",
            t => !t.eventName 
                 || fp.includes(t.eventName)(eventsList)),
        makerule("optionsCreator", "Options Creator does not compile - check your expression",
            t => {
                if(!t.optionsCreator) return true;
                try { 
                    compilerUtil.compileCode(t.optionsCreator);
                    return true;
                } catch(_$$1) { return false; }
            }),
        makerule("condition", "Trigger condition does not compile - check your expression",
            t => {
                if(!t.condition) return true;
                try { 
                    compilerUtil.compileExpression(t.condition);
                    return true;
                } catch(_$$1) { return false; }
            })
    ]);

    const validateTrigger = (trigger, allActions) => {

        const errors = applyRuleSet(triggerRules(allActions))(trigger);

        return errors;
    };

    const validateTriggers = (triggers, allActions) => 
        $(triggers, [
            fp.map(t => validateTrigger(t, allActions)),
            fp.flatten
        ]);

    const getApplicationDefinition = (datastore) => async () => {
        const exists = await datastore.exists(appDefinitionFile);

        if(!exists) throw new Error("Application definition does not exist");

        const appDefinition = await datastore.loadJson(appDefinitionFile);
        appDefinition.heirarchy = constructHeirarchy(
            appDefinition.heirarchy            
        );
        return appDefinition;
    };

    const saveApplicationHeirarchy = app => async heirarchy => 
        apiWrapper(
            app,  
            events.templateApi.saveApplicationHeirarchy,
            permission.writeTemplates.isAuthorized,
            {heirarchy},
            _saveApplicationHeirarchy, app.datastore, heirarchy
        );


    const _saveApplicationHeirarchy = async (datastore, heirarchy) =>{

        const validationErrors = await validateAll(heirarchy);
        if(validationErrors.length > 0) {
            throw new Error("Heirarchy is invalid: " + _.join(
                validationErrors.map(e => `${e.item.nodeKey ? e.item.nodeKey() : ""} : ${e.error}`),
                ","
            ));
        } 

        if(await datastore.exists(appDefinitionFile)){
            const appDefinition = await datastore.loadJson(appDefinitionFile);
            appDefinition.heirarchy = heirarchy;
            await datastore.updateJson(appDefinitionFile, appDefinition);
        }
        else {
            await datastore.createFolder("/.config");
            const appDefinition = {actions:[], triggers:[], heirarchy};
            await datastore.createJson(appDefinitionFile, appDefinition);
        }
    };

    const saveActionsAndTriggers = app => async (actions, triggers) => 
        apiWrapper(
            app,  
            events.templateApi.saveActionsAndTriggers,
            permission.writeTemplates.isAuthorized,
            {actions, triggers},
            _saveActionsAndTriggers, app.datastore, actions, triggers
        );

    const _saveActionsAndTriggers = async (datastore, actions, triggers) => {
        if(await datastore.exists(appDefinitionFile)){
            const appDefinition = await datastore.loadJson(appDefinitionFile);
            appDefinition.actions = actions;
            appDefinition.triggers = triggers;

            const actionValidErrs = fp.map(e => e.error)
                                    (validateActions(actions));
            
            if(actionValidErrs.length > 0) {
                throw new Error("Actions are in valid: " + _.join(actionValidErrs,", "));
            }

            const triggerValidErrs = fp.map(e => e.error)
                                    (validateTriggers(triggers, actions));
            
            if(triggerValidErrs.length > 0) {
                throw new Error("Triggers are in valid: " + _.join(triggerValidErrs,", "));
            }

            await datastore.updateJson(appDefinitionFile, appDefinition);
        }
        else {
            throw new Error("Cannot save actions: Application definition does not exist");
        }
    };

    const api$1 = app => ({
        
        getApplicationDefinition : getApplicationDefinition(app.datastore),
        saveApplicationHeirarchy : saveApplicationHeirarchy(app),
        saveActionsAndTriggers : saveActionsAndTriggers(app),
        getBehaviourSources: () => getBehaviourSources(app.datastore),
        getNewRootLevel, constructNode,
        getNewIndexTemplate, getNewRecordTemplate,
        getNewField, validateField, addField, fieldErrors,
        getNewRecordValidationRule, commonRecordValidationRules, 
        addRecordValidationRule, createAction, createTrigger, validateActions,
        validateTrigger, getNewAggregateGroupTemplate,
        getNewAggregateTemplate, constructHeirarchy, getNewSingleRecordTemplate,
        allTypes:all$1, validateNode, validateAll, validateTriggers
    });


    const getTemplateApi = app => api$1(app);

    const getUsers = app => async () => 
        apiWrapper(
            app,
            events.authApi.getUsers, 
            permission.listUsers.isAuthorized,
            {},
            _getUsers, app);

    const _getUsers = async app => 
        $(await app.datastore.loadJson(USERS_LIST_FILE), [
            fp.map(stripUserOfSensitiveStuff)
        ]);

    const loadAccessLevels = app => async () => 
        apiWrapper(
            app,
            events.authApi.loadAccessLevels, 
            permission.listAccessLevels.isAuthorized,
            {},
            _loadAccessLevels, app);

    const _loadAccessLevels = async app  => 
        await app.datastore.loadJson(ACCESS_LEVELS_FILE);

    const dummyHash = "$argon2i$v=19$m=4096,t=3,p=1$UZRo409UYBGjHJS3CV6Uxw$rU84qUqPeORFzKYmYY0ceBLDaPO+JWSH4PfNiKXfIKk";

    const authenticate = app => async (username, password) => 
        apiWrapper(
            app,
            events.authApi.authenticate, 
            alwaysAuthorized,
            {username, password},
            _authenticate, app, username, password);

    const _authenticate = async (app, username, password) => {

        if(isNothingOrEmpty(username) || isNothingOrEmpty(password))
            return null;

        const allUsers = await getUsers(app)();
        let user = getUserByName(
                        allUsers,
                        username
                    );
                 
        const notAUser = "not-a-user";
        // continue with non-user - so time to verify remains consistent
        // with verification of a valid user
        if(!user || !user.enabled) 
            user = notAUser; 

        let userAuth;
        try {
            userAuth = await app.datastore.loadJson(
                userAuthFile(username)
            );
        } catch(_$$1) {
            userAuth = {accessLevels:[], passwordHash:dummyHash};
        }

        const permissions = await buildUserPermissions(app, user.accessLevels);

        const verified = await app.crypto.verify(
            userAuth.passwordHash, 
            password);

        if(user === notAUser)
            return null;

        return verified
               ? {...user, permissions, temp:false, isUser:true}
               : null;
    };

    const authenticateTemporaryAccess = app => async (tempAccessCode) => {

        if(isNothingOrEmpty(tempAccessCode))
            return null;

        const temp = parseTemporaryCode(tempAccessCode);
        let user = $(await getUsers(app)(),[
            fp.find(u => u.temporaryAccessId === temp.id)
        ]);

        const notAUser = "not-a-user";
        if(!user || !user.enabled) 
            user = notAUser;

        let userAuth;
        try {
            userAuth = await app.datastore.loadJson(
                userAuthFile(user.name)
            );
        } catch(e) {
            userAuth = {
                temporaryAccessHash:dummyHash,
                temporaryAccessExpiryEpoch:(await app.getEpochTime() + 10000)
            };
        }

        if(userAuth.temporaryAccessExpiryEpoch < await app.getEpochTime()) 
            user = notAUser;

        const tempCode = !temp.code ? shortid.generate() : temp.code;
        const verified =  await app.crypto.verify(
            userAuth.temporaryAccessHash, 
            tempCode); 

        if(user === notAUser) 
            return null;
        
        return verified
               ? {
                   ...user, 
                   permissions: [], 
                   temp:true,
                   isUser:true
                }
               : null;
    };

    const buildUserPermissions = async (app, userAccessLevels) => {
        const allAccessLevels = await loadAccessLevels(app)();

        return $(allAccessLevels.levels, [
            fp.filter(l => fp.some(ua => l.name === ua)(userAccessLevels)),
            fp.map(l => l.permissions),
            fp.flatten
        ]);
    };

    const createTemporaryAccess$1 = app => async (userName) => 
        apiWrapper(
            app,
            events.authApi.createTemporaryAccess, 
            alwaysAuthorized,
            {userName},
            _createTemporaryAccess, app, userName);

    const _createTemporaryAccess = async (app, userName) =>  {

        const tempCode = await getTemporaryCode(app);

        const lock = await getLock$$1(
            app, USERS_LOCK_FILE, 1000, 2
        );

        if(isNolock$$1(lock))
            throw new Error("Unable to create temporary access, could not get lock - try again");
            
        try {
            const users = await app.datastore.loadJson(USERS_LIST_FILE);

            const user = getUserByName(users, userName);
            user.temporaryAccessId = tempCode.temporaryAccessId;    

            await app.datastore.updateJson(
                USERS_LIST_FILE, 
                users
            );

        } finally {
            await releaseLock$$1(app, lock);
        }
        
        const userAuth = await app.datastore.loadJson(
            userAuthFile(userName)
        );
        userAuth.temporaryAccessHash = 
            tempCode.temporaryAccessHash;

        userAuth.temporaryAccessExpiryEpoch = 
            tempCode.temporaryAccessExpiryEpoch; 

        await app.datastore.updateJson(
            userAuthFile(userName),
            userAuth
        );

        return tempCode.tempCode;
    };

    const getTemporaryCode = async app => {
        const tempCode = 
            shortid.generate() + 
            shortid.generate() + 
            shortid.generate() + 
            shortid.generate();

        const tempId = shortid.generate();

        return {
            temporaryAccessHash: await app.crypto.hash(
                tempCode,
            ),
            temporaryAccessExpiryEpoch: 
                (await app.getEpochTime()) + tempCodeExpiryLength,
            tempCode: `tmp:${tempId}:${tempCode}`,
            temporaryAccessId: tempId
        };
    };

    const userRules = allUsers => [
        makerule("name", "username must be set",
            u => isNonEmptyString(u.name)),
        makerule("accessLevels", "user must have at least one access level",
            u => u.accessLevels.length > 0),
        makerule("name", "username must be unique",
            u => fp.filter(u2 => insensitiveEquals(u2.name,u.name))
                       (allUsers).length === 1),
        makerule("accessLevels", "access levels must only contain stings",
            u => all(isNonEmptyString)(u.accessLevels))
    ];

    const validateUser = () => (allusers, user) => 
        applyRuleSet(userRules(allusers))(user);

    const getNewUser = app => () => 
        apiWrapperSync(
            app,
            events.authApi.getNewUser, 
            permission.createUser.isAuthorized,
            {},
            _getNewUser, app);

    const _getNewUser = app => ({
        name: "",
        accessLevels: [],
        enabled: true,
        temporaryAccessId: ""
    });

    const getNewUserAuth = app => () => 
        apiWrapperSync(
            app,
            events.authApi.getNewUserAuth, 
            permission.createUser.isAuthorized,
            {},
            _getNewUserAuth, app);

    const _getNewUserAuth = app => ({
        passwordHash: "",
        temporaryAccessHash: "",
        temporaryAccessExpiryEpoch: 0
    });

    const isValidPassword = app => (password) => 
        apiWrapperSync(
            app,
            events.authApi.isValidPassword, 
            alwaysAuthorized,
            {password},
            _isValidPassword, app, password);

    const _isValidPassword = (app, password) => {
        return scorePassword(password).score > 30;
    };

    const changeMyPassword = app => async (currentPw, newpassword) => 
        apiWrapper(
            app,
            events.authApi.changeMyPassword, 
            alwaysAuthorized,
            {currentPw, newpassword},
            _changeMyPassword, app, currentPw, newpassword);

    const _changeMyPassword = async (app, currentPw, newpassword) => {
        const existingAuth = await app.datastore.loadJson(
            userAuthFile(app.user.name)
        );

        if(isSomething(existingAuth.passwordHash)) {
            
            const verified = await app.crypto.verify(
                existingAuth.passwordHash, 
                currentPw);

            if(verified) {
                await await doSet(
                    app, existingAuth, 
                    app.user.name, newpassword);
                return true;
            }
        }
        
        return false;
    };

    const setPasswordFromTemporaryCode = app => async (tempCode, newpassword) => 
        apiWrapper(
            app,
            events.authApi.setPasswordFromTemporaryCode,
            alwaysAuthorized, 
            {tempCode, newpassword},
            _setPasswordFromTemporaryCode, app, tempCode, newpassword);


    const _setPasswordFromTemporaryCode = async (app, tempCode, newpassword) => {

        const currentTime = await app.getEpochTime();

        const temp = parseTemporaryCode(tempCode);

        const user = $(await getUsers(app)(), [
            fp.find(u => u.temporaryAccessId === temp.id)
        ]);

        if(!user)
            return false;

        const existingAuth = await app.datastore.loadJson(
            userAuthFile(user.name)
        );

        if(isSomething(existingAuth.temporaryAccessHash)
           && existingAuth.temporaryAccessExpiryEpoch > currentTime) {

            const verified = await app.crypto.verify(
                existingAuth.temporaryAccessHash, 
                temp.code);

            if(verified) {
                await doSet(
                    app, existingAuth, 
                    user.name, newpassword);
                return true;
            }
        }
        
        return false;
    };

    const doSet = async (app, auth, username, newpassword) => {
        auth.temporaryAccessHash = "";
        auth.temporaryAccessExpiryEpoch = 0;
        auth.passwordHash = await app.crypto.hash(
            newpassword
        );
        await app.datastore.updateJson(
            userAuthFile(username),
            auth
        );
    };

    const scorePassword =  (password) => 
        apiWrapperSync(
            app,
            events.authApi.scorePassword, 
            alwaysAuthorized,
            {password},
            _scorePassword, password);

    const _scorePassword = (password) => {

        // from https://stackoverflow.com/questions/948172/password-strength-meter
        // thank you https://stackoverflow.com/users/46617/tm-lv

        let score = 0;
        if (!password)
            return score;

        // award every unique letter until 5 repetitions
        let letters = new Object();
        for (let i=0; i<password.length; i++) {
            letters[password[i]] = (letters[password[i]] || 0) + 1;
            score += 5.0 / letters[password[i]];
        }

        // bonus points for mixing it up
        const variations = {
            digits: /\d/.test(password),
            lower: /[a-z]/.test(password),
            upper: /[A-Z]/.test(password),
            nonWords: /\W/.test(password),
        };

        let variationCount = 0;
        for (let check in variations) {
            variationCount += (variations[check] == true) ? 1 : 0;
        }
        score += (variationCount - 1) * 10;

        const strengthText =
            score > 80 
            ? "strong"
            : score > 60
            ? "good"
            : score >= 30
            ? "weak"
            : "very weak";

        return {
            score: parseInt(score), 
            strengthText
        };
    };

    const createUser$1 = app => async (user, password=null) => 
        apiWrapper(
            app,
            events.authApi.createUser, 
            permission.createUser.isAuthorized,
            {user, password},
            _createUser, app, user, password);

    const _createUser = async (app, user, password=null) => {

        const lock = await getLock$$1(
            app, USERS_LOCK_FILE, 1000, 2
        );

        if(isNolock$$1(lock))
            throw new Error("Unable to create user, could not get lock - try again");
            
        const users = await app.datastore.loadJson(USERS_LIST_FILE);

        const userErrors = validateUser(app)([...users,user], user);
        if(userErrors.length > 0)
            throw new Error("User is invalid. " + fp.join("; ")(userErrors));

        const {auth, tempCode, temporaryAccessId} = await getAccess(
            app, password);
        user.tempCode = tempCode;
        user.temporaryAccessId = temporaryAccessId;
        
        if(fp.some(u => insensitiveEquals(u.name, user.name))(users))
            throw new Error("User already exists");

        users.push(
            stripUserOfSensitiveStuff(user)
        );

        await app.datastore.updateJson(
            USERS_LIST_FILE, 
            users
        );
        
        try {
            await app.datastore.createJson(
                userAuthFile(user.name),
                auth
            );
        } catch(_$$1) {
            await app.datastore.updateJson(
                userAuthFile(user.name),
                auth
            );
        }

        await releaseLock$$1(app, lock);

        return user;
    };

    const getAccess = async (app, password) => {

        const auth = getNewUserAuth(app)();

        if(isNonEmptyString(password)) {
            if(isValidPassword(password)) {
                auth.passwordHash = await app.crypto.hash(password);
                auth.temporaryAccessHash = "";
                auth.temporaryAccessId = "";
                auth.temporaryAccessExpiryEpoch = 0;
                return {auth};
            } else {
                throw new Error("Password does not meet requirements");
            }
        } else {
            const tempAccess = await getTemporaryCode(app);
            auth.temporaryAccessHash = tempAccess.temporaryAccessHash;
            auth.temporaryAccessExpiryEpoch = tempAccess.temporaryAccessExpiryEpoch;
            auth.passwordHash = "";
            return ({
                auth, 
                tempCode: tempAccess.tempCode, 
                temporaryAccessId:tempAccess.temporaryAccessId
            });
        }
    };

    const enableUser = app => async username =>
        apiWrapper(
            app,
            events.authApi.enableUser, 
            permission.enableDisableUser.isAuthorized,
            {app, username},
            _enableUser, app, username);

    const disableUser = app => async username =>
        apiWrapper(
            app,
            events.authApi.disableUser, 
            permission.enableDisableUser.isAuthorized,
            {username},
            _disableUser, app, username);

    const _enableUser = async (app, username) => 
        await toggleUser(app, username, true);

    const _disableUser = async (app, username) => 
        await toggleUser(app, username, false);

    const toggleUser = async (app, username, enabled) => {
        const lock = await getLock$$1(app, USERS_LOCK_FILE, 1000, 1, 0);

        const actionName = enabled ? "enable" : "disable";

        if(isNolock$$1(lock))
            throw new Error(`Could not ${actionName} user - cannot get lock`);

        try {
            const users = await app.datastore.loadJson(USERS_LIST_FILE);
            const user = getUserByName(users, username);
            if(!user)
                throw new Error(`Could not find user to ${actionName}`);

            if(user.enabled === !enabled) {
                user.enabled = enabled;
                await app.datastore.updateJson(USERS_LIST_FILE, users);
            }
        }
        finally {
            releaseLock$$1(app, lock);
        }
    };

    const getNewAccessLevel = app => () => 
        apiWrapperSync(
            app,
            events.authApi.getNewAccessLevel, 
            permission.writeAccessLevels.isAuthorized,
            {},
            _getNewAccessLevel, app);

    const _getNewAccessLevel = () => ({
        name:"",
        permissions: []
    });

    const isAllowedType = t => 
        $(permissionTypes, [
            fp.values, 
            fp.includes(t)
        ]);

    const isRecordOrIndexType = t => 
        fp.includes("record")(t) ||
        fp.includes("index")(t);


    const permissionRules = app => ([
        makerule("type", "type must be one of allowed types",
            p => isAllowedType(p.type)),
        makerule("nodeKey", "record and index permissions must include a valid nodeKey",
            p => (!isRecordOrIndexType(p.type)) 
                 ||  isSomething(getNode(app.heirarchy, p.nodeKey)))
    ]);

    const applyPermissionRules = app => 
        applyRuleSet(permissionRules(app));

    const accessLevelRules = allLevels => ([
        makerule("name", "name must be set",
            l => isNonEmptyString(l.name)),
        makerule("name", "access level names must be unique",
            l => fp.isEmpty(l.name) 
                 || fp.filter(a => insensitiveEquals(l.name, a.name))(allLevels).length === 1)
    ]);

    const applyLevelRules = allLevels =>
        applyRuleSet(accessLevelRules(allLevels));

    const validateAccessLevel = app => (allLevels, level) => {

        const errs = $(level.permissions, [
            fp.map(applyPermissionRules(app)),
            fp.flatten,
            fp.concat(
                applyLevelRules(allLevels)(level)
            )
        ]);

        return errs;

    };

    const validateAccessLevels = app => allLevels => 
        apiWrapperSync(
            app,
            events.authApi.validateAccessLevels, 
            alwaysAuthorized,
            {allLevels},
            _validateAccessLevels, app, allLevels);

    const _validateAccessLevels = (app, allLevels) => 
        $(allLevels, [
            fp.map(l => validateAccessLevel(app)(allLevels, l)),
            fp.flatten,
            fp.uniqWith((x,y) => x.field === y.field
                            && x.item === y.item
                            && x.error === y.error)
        ]);

    const saveAccessLevels = app => async (accessLevels) => 
        apiWrapper(
            app,
            events.authApi.saveAccessLevels, 
            permission.writeAccessLevels.isAuthorized,
            {accessLevels},
            _saveAccessLevels, app, accessLevels);

    const _saveAccessLevels = async (app, accessLevels) => {
        
        const validationErrors = validateAccessLevels(app)(accessLevels.levels);
        if(validationErrors.length > 0) {
            var errs = $(validationErrors, [
                fp.map(e => e.error),
                fp.join(", ")
            ]);
            throw new Error(
                "Access Levels Invalid: " + errs
            );
        } 
        
        const lock = await getLock$$1(
            app, ACCESS_LEVELS_LOCK_FILE, 2000, 2);

        if(isNolock$$1(lock))
            throw new Error("Could not get lock to save access levels");

        try{
            const existing = await app.datastore.loadJson(ACCESS_LEVELS_FILE);
            if(existing.version !== accessLevels.version)
                throw new Error("Access levels have already been updated, since you loaded");
            
            accessLevels.version++;

            app.datastore.updateJson(ACCESS_LEVELS_FILE, accessLevels);
        }
        finally {
            await releaseLock$$1(app, lock);
        }        
    };

    const generateFullPermissions = app => {

        const allNodes = getFlattenedHierarchy(app.heirarchy);
        const accessLevel = {permissions:[]};

        const recordNodes = $(allNodes, [
            fp.filter(isRecord)
        ]);

        for(let n of recordNodes) {
            permission.createRecord.add(n.nodeKey(), accessLevel);
            permission.updateRecord.add(n.nodeKey(), accessLevel);
            permission.deleteRecord.add(n.nodeKey(), accessLevel);
            permission.readRecord.add(n.nodeKey(), accessLevel);
        }

        const indexNodes = $(allNodes, [
            fp.filter(isIndex)
        ]);

        for(let n of indexNodes) {
            permission.readIndex.add(n.nodeKey(), accessLevel);
        }

        for(let a of fp.keys(app.actions)) {
            permission.executeAction.add(a, accessLevel);
        }

        $(permission, [
            fp.values,
            fp.filter(p => !p.isNode),
            fp.each(p => p.add(accessLevel))
        ]);

        return accessLevel.permissions;
    };

    const setUserAccessLevels$1 = app => async (userName, accessLevels) => 
        apiWrapper(
            app,
            events.authApi.setUserAccessLevels, 
            permission.setUserAccessLevels.isAuthorized,
            {userName, accessLevels},
            _setUserAccessLevels, app, userName, accessLevels);

    const _setUserAccessLevels = async (app, username, accessLevels) => {
        const lock = await getLock$$1(app, USERS_LOCK_FILE, 1000, 1, 0);

        const actualAccessLevels = $(
            await app.datastore.loadJson(ACCESS_LEVELS_FILE),
            [
                l => l.levels,
                fp.map(l => l.name)
            ]);

        const missing = fp.difference(accessLevels)(actualAccessLevels);
        if(missing.length > 0) {
            throw new Error("Invalid access levels supplied: " + fp.join(", ", missing));
        }

        if(isNolock$$1(lock))
            throw new Error(`Could set user access levels cannot get lock`);

        try {
            const users = await app.datastore.loadJson(USERS_LIST_FILE);
            const user = getUserByName(users, username);
            if(!user)
                throw new Error(`Could not find user to ${actionName}`);

            user.accessLevels = accessLevels;
            await app.datastore.updateJson(USERS_LIST_FILE, users);
        }
        finally {
            releaseLock$$1(app, lock);
        }
    };

    const getAuthApi = app => ({
        authenticate: authenticate(app),
        authenticateTemporaryAccess: authenticateTemporaryAccess(app),
        createTemporaryAccess: createTemporaryAccess$1(app),
        createUser: createUser$1(app),
        loadAccessLevels: loadAccessLevels(app),
        enableUser: enableUser(app),
        disableUser: disableUser(app),
        getNewAccessLevel: getNewAccessLevel(app),
        getNewUser: getNewUser(app),
        getNewUserAuth: getNewUserAuth(app),
        getUsers: getUsers(app),
        saveAccessLevels: saveAccessLevels(app),
        isAuthorized: isAuthorized(app),
        changeMyPassword: changeMyPassword(app),
        setPasswordFromTemporaryCode: setPasswordFromTemporaryCode(app),
        scorePassword,
        isValidPassword: isValidPassword(app),
        validateUser: validateUser(app),
        validateAccessLevels: validateAccessLevels(app),
        generateFullPermissions: () => generateFullPermissions(app),
        setUserAccessLevels: setUserAccessLevels$1(app)
    });

    const executeAction$1 = app => (actionName, options) => {
        apiWrapperSync(
            app, 
            events.actionsApi.execute,
            permission.executeAction.isAuthorized(actionName),
            {actionName, options},
            app.actions[actionName], options
        );
    };

    const _executeAction = (behaviourSources, action, options) => 
        behaviourSources[action.behaviourSource][action.behaviourName](options);

    const getActionsApi = app => ({
        execute: executeAction$1(app)
    });

    const publish = handlers => (eventName, context = {}) => {
        if(!_.has(handlers, eventName)) return;

        for(let handler of handlers[eventName]) {
            handler(eventName, context);
        }
    };

    const subscribe = handlers => (eventName, handler) => {
        if(!_.has(handlers, eventName)) {
            handlers[eventName] = [];
        }
        handlers[eventName].push(handler);
    };

    const createEventAggregator = () => {
        const handlers = {};
        const eventAggregator = ({
            publish: publish(handlers),
            subscribe: subscribe(handlers)
        });
        return eventAggregator;
    };

    const loadJson = datastore => async (key, retries = 5, delay = 500) =>
        await retry(JSON.parse, retries, delay, await datastore.loadFile(key));

    const createJson = originalCreateFile => async (key, obj, retries = 5, delay = 500) =>
        await retry(originalCreateFile, retries, delay, key, JSON.stringify(obj));

    const updateJson = datastore => async (key, obj, retries = 5, delay = 500) =>
        await retry( datastore.updateFile, retries, delay, key, JSON.stringify(obj));

    const createNewFile = originalCreateFile => async (path$$1, content, retries = 5, delay = 500) =>
        await retry(originalCreateFile, retries, delay, path$$1, content);

    const setupDatastore = (datastore) => {
        const originalCreateFile = datastore.createFile;
        datastore.loadJson = loadJson(datastore);
        datastore.createJson = createJson(originalCreateFile);
        datastore.updateJson = updateJson(datastore);
        datastore.createFile = createNewFile(originalCreateFile);
        if (datastore.createEmptyDb)
            delete datastore.createEmptyDb;
        return datastore;
    };

    const initialiseActions = (subscribe, behaviourSources, actions, triggers) => {
        
        validateSources(behaviourSources, actions);
        subscribeTriggers(subscribe, behaviourSources, actions, triggers);
        return createActionsCollection(behaviourSources, actions);

    };

    const createActionsCollection = (behaviourSources, actions) =>
        $(actions,[
            fp.reduce((all$$1,a) => {
                all$$1[a.name] = opts => _executeAction(behaviourSources, a, opts);
                return all$$1;
            }, {})
        ]);

    const subscribeTriggers = (subscribe, behaviourSources, actions, triggers) => {

        const createOptions = (optionsCreator, eventContext) => {
            if(!optionsCreator) return {};
            const create = compilerUtil.compileCode(optionsCreator);
            return create({context:eventContext});
        };

        const shouldRunTrigger = (trigger, eventContext) => {
            if(!trigger.condition) return true;
            const shouldRun = compilerUtil.compileExpression(trigger.condition);
            return shouldRun({context:eventContext});
        };

        for(let trig of triggers) {
            subscribe(trig.eventName, (ev, ctx) => {
                if(shouldRunTrigger(trig, ctx)) {
                    _executeAction(
                        behaviourSources, 
                        fp.find(a => a.name === trig.actionName)(actions),
                        createOptions(trig.optionsCreator, ctx));
                }
            });
        }

    };

    const validateSources = (behaviourSources, actions) => {

        const declaredSources = $(actions, [
            fp.uniqBy(a => a.behaviourSource),
            fp.map(a => a.behaviourSource)
        ]);

        const suppliedSources = fp.keys(behaviourSources);

        const missingSources = fp.difference(
            declaredSources, suppliedSources
        );

        if(missingSources.length > 0) {
            throw new Error("Declared behaviour sources are not supplied: " + fp.join(", ", missingSources));
        }

        const missingBehaviours = $(actions, [
            fp.filter(a => !fp.isFunction(behaviourSources[a.behaviourSource][a.behaviourName])),
            fp.map(a => `Action: ${a.name} : ${a.behaviourSource}.${a.behaviourName}`)
        ]);

        if(missingBehaviours.length > 0) {
            throw new Error("Missing behaviours: could not behaviour functions: " + fp.join(", ", missingBehaviours));
        }
    };

    const retrieve = async app => {
        
        const transactionFiles = await app.datastore.getFolderContents(
            TRANSACTIONS_FOLDER
        );

        let transactions = [];

        if(fp.some(isBuildIndexFolder)(transactionFiles)) {
            const buildIndexFolder$$1 = fp.find(isBuildIndexFolder)(transactionFiles);

            transactions = await retrieveBuildIndexTransactions(
                app, 
                joinKey(TRANSACTIONS_FOLDER,buildIndexFolder$$1)
            );
        }

        if(transactions.length > 0) return transactions;
        
        return await retrieveStandardTransactions(
            app, transactionFiles
        );  

    };

    const retrieveBuildIndexTransactions = async (app, buildIndexFolder$$1) => {

        const childFolders = await app.datastore.getFolderContents(buildIndexFolder$$1);
        if(childFolders.length === 0) {
            // cleanup
            await app.datastore.deleteFolder(buildIndexFolder$$1);
            return [];    
        }

        const getTransactionFiles = async (childFolderIndex=0) => {
            if(childFolderIndex >= childFolders.length) return [];

            const childFolderKey = joinKey(buildIndexFolder$$1, childFolders[childFolderIndex]);
            const files = await app.datastore.getFolderContents(
                childFolderKey
            );

            if(files.length === 0) {
                await app.datastore.deleteFolder(childFolderKey);
                return await getTransactionFiles(childFolderIndex+1);
            }

            return {childFolderKey, files};        
        };

        const transactionFiles = await getTransactionFiles();

        if(transactionFiles.files.length === 0) return [];

        const transactions = $(transactionFiles.files, [
            fp.map(parseTransactionId)
        ]);

        for(let t of transactions) {
            const transactionContent = await app.datastore.loadJson(
                joinKey(
                    transactionFiles.childFolderKey, 
                    t.fullId)
            );
            t.record = await _load(app, transactionContent.recordKey);
        }

        transactions.indexNode = $(buildIndexFolder$$1, [
            getLastPartInKey,
            nodeKeyHashFromBuildFolder,
            getNodeFromNodeKeyHash(app.heirarchy)
        ]);

        transactions.folderKey = transactionFiles.childFolderKey;

        return transactions;
    };

    const retrieveStandardTransactions = async (app, transactionFiles) => {
        

        const transactionIds = $(transactionFiles, [
            fp.filter(f => f !== LOCK_FILENAME 
                        && !isBuildIndexFolder(f)),
            fp.map(parseTransactionId),
        ]);

        const transactionIdsByRecord = $(transactionIds, [
            fp.groupBy("recordId")
        ]);

        const dedupedTransactions = [];

        const verify = async t => {
            
            if(t.verified === true) return t;
            
            const id = getTransactionId(
                t.recordId,
                t.transactionType,
                t.uniqueId);
            
            const transaction = await app.datastore.loadJson(
                joinKey(TRANSACTIONS_FOLDER, id)
            );

            if(isDelete(t)) {
                t.record = transaction.record;
                t.verified = true;
                return t;
            }
            
            const rec = await _load(
                app,
                transaction.recordKey
            );
            if(rec.transactionId === id) {
                t.record = rec;
                if(!!transaction.oldRecord) 
                    t.oldRecord = transaction.oldRecord;
                t.verified = true;
            } else {
                t.verified = false;
            }

            return t;
        };

        const pickOne = async (trans, forType) => {
            const transForType = fp.filter(forType)(trans);
            if(transForType.length === 1) {
                const t = await verify(transForType[0]);
                return (t.verified === true ? t : null);
            } else {
                for(let t of transForType) {
                    t = await verify(t);
                    if(t.verified === true)
                        return t;
                }
            }
            return null;
        };

        for(let recordId in transactionIdsByRecord) {
            const transIdsForRecord = transactionIdsByRecord[recordId];
            if(transIdsForRecord.length === 1) {
                const t = await verify(transIdsForRecord[0]);
                if(t.verified)
                    dedupedTransactions.push(t);
                continue;
            }
            if(fp.some(isDelete)(transIdsForRecord)) {
                const t = await verify(fp.find(isDelete)(transIdsForRecord));
                if(t.verified)
                    dedupedTransactions.push(t);
                continue;
            }
            if(fp.some(isUpdate)(transIdsForRecord)) {
                const upd = await pickOne(transIdsForRecord, isUpdate);
                if(isSomething(upd) && upd.verified)
                    dedupedTransactions.push(upd);
                continue;
            }
            if(fp.some(isCreate)(transIdsForRecord)) {
                const cre = await pickOne(transIdsForRecord, isCreate);
                if(isSomething(cre))
                    dedupedTransactions.push(cre);
                continue;
            }
        }

        const duplicates = $(transactionIds, [
            fp.filter(t => none(ddt => ddt.uniqueId === t.uniqueId)
                        (dedupedTransactions))
        ]);

        

        const deletePromises = 
            fp.map(t => app.datastore.deleteFile(
                        joinKey(
                            TRANSACTIONS_FOLDER,
                            getTransactionId(
                                t.recordId,
                                t.transactionType,
                                t.uniqueId)
                        )
                )
            )(duplicates);

        await Promise.all(deletePromises);
        
        return dedupedTransactions;
    };

    const parseTransactionId = id => {
        const splitId = fp.split(idSep)(id);
        return ({
            recordId: splitId[0],
            transactionType: splitId[1],
            uniqueId: splitId[2],
            fullId: id
        });
    };

    const getRelevantAncestorIndexes = (appHeirarchy, record) => {

        const key = record.key;
        const keyParts = splitKey(key);
        const nodeId = getRecordNodeId(key);

        const flatHeirarchy = 
            _.orderBy(getFlattenedHierarchy(appHeirarchy),
                    [node => node.pathRegx().length],
                    ["desc"]);

        const makeindexNodeAndKey_ForAncestorIndex = (indexNode, indexKey) => 
            makeIndexNodeAndKey(indexNode, joinKey(indexKey, indexNode.name));

        const traverseAncestorIndexesInPath = () => 
            fp.reduce((acc, part) => {
                const currentIndexKey = joinKey(acc.lastIndexKey, part);
                acc.lastIndexKey = currentIndexKey;
                const testPathRegx = p => 
                    new RegExp(`${p.pathRegx()}$`).test(currentIndexKey);
                const nodeMatch = fp.find(testPathRegx)(flatHeirarchy);               

                if(isNothing(nodeMatch)) 
                    return acc;
                
                if(!isRecord(nodeMatch) 
                    || nodeMatch.indexes.length === 0)
                    return acc;
                
                const indexes = $(nodeMatch.indexes, [
                    fp.filter(i => i.indexType === indexTypes.ancestor && 
                            (i.allowedRecordNodeIds.length === 0
                             || fp.includes(nodeId)(i.allowedRecordNodeIds)))
                ]);

                fp.each(v => 
                    acc.nodesAndKeys.push(
                        makeindexNodeAndKey_ForAncestorIndex(v, currentIndexKey)))
                (indexes);

                return acc;             
            }, {lastIndexKey:"", nodesAndKeys:[]})
            (keyParts).nodesAndKeys;
        
        const rootIndexes = $(flatHeirarchy, [
            fp.filter(n => isGlobalIndex(n) && recordNodeIdIsAllowed(n)(nodeId)),
            fp.map(i => makeIndexNodeAndKey(i, i.nodeKey()))
        ]);

        return fp.union(traverseAncestorIndexesInPath())(rootIndexes);
    };

    const getRelevantReverseReferenceIndexes = (appHeirarchy, record) => 
        $(record.key, [
            getExactNodeForPath(appHeirarchy),
            n => n.fields,
            fp.filter(f => f.type === "reference"
                        && isSomething(record[f.name])
                        && isNonEmptyString(record[f.name].key)),
            fp.map(f => $(f.typeOptions.reverseIndexNodeKeys,[
                        fp.map(n => ({recordNode: getNode(appHeirarchy,n),
                                 field:f}))
                     ])),
            fp.flatten,
            fp.map(n => makeIndexNodeAndKey(
                n.recordNode, 
                joinKey(record[n.field.name].key, n.recordNode.name))),
        ]);

    const makeIndexNodeAndKey = (indexNode, indexKey) => ({indexNode, indexKey});

    const applyToShard = async (heirarchy$$1, store, indexKey, 
            indexNode, indexShardKey, recordsToWrite, keysToRemove) => {

        const createIfNotExists = recordsToWrite.length > 0; 
        const writer = await getWriter(heirarchy$$1, store, indexKey, indexShardKey, indexNode, createIfNotExists);
        if(writer === SHARD_DELETED) return;
        
        writer.updateIndex(recordsToWrite, keysToRemove);
        await swapTempFileIn(store, indexShardKey); 

    };

    const SHARD_DELETED = "SHARD_DELETED";
    const getWriter = async (heirarchy$$1, store, indexKey, indexedDataKey, indexNode, createIfNotExists) => {

        let readableStream = null;
        try {
            readableStream = await store.readableFileStream(indexedDataKey);
        } catch(e) {
            if(await store.exists(indexedDataKey)) {
                throw e;
            } else {
                if(createIfNotExists)
                    await store.createFile(indexedDataKey, "");
                else
                    return SHARD_DELETED;
                readableStream = await store.readableFileStream(indexedDataKey);
            }
        }

        if(isShardedIndex(indexNode)) {
            await ensureShardNameIsInShardMap(store, indexKey, indexedDataKey);
        }

        const writableStream = await store.writableFileStream(indexedDataKey + ".temp");
        
        return getIndexWriter(
            heirarchy$$1, indexNode, 
            () => readableStream.read(),
            (buffer) => writableStream.write(buffer)
        );
    };

    const swapTempFileIn = async (store, indexedDataKey, isRetry=false) => {
        const tempFile = indexedDataKey + ".temp";
        try {
            await store.deleteFile(indexedDataKey);
        } catch(e) {
            // ignore failure, incase it has not been created yet
        }
        try {
            await store.renameFile(tempFile, indexedDataKey);
        } catch(e) {
            // retrying in case delete failure was for some other reason
            if(!isRetry) {
                await swapTempFileIn(store, indexedDataKey, true);
            }

        }
    } ;

    const executeTransactions =  app => async transactions => {
        const recordsByShard = mappedRecordsByIndexShard(app.heirarchy, transactions);         

        for(let shard of fp.keys(recordsByShard)) {
            await applyToShard(
                app.heirarchy, app.datastore,
                recordsByShard[shard].indexKey,
                recordsByShard[shard].indexNode,
                shard,
                recordsByShard[shard].writes,
                recordsByShard[shard].removes
            );
        }
    };

    const mappedRecordsByIndexShard = (heirarchy$$1, transactions) => {

        const updates = getUpdateTransactionsByShard(
            heirarchy$$1, transactions
        );

        const created = getCreateTransactionsByShard(
            heirarchy$$1, transactions
        );
        const deletes = getDeleteTransactionsByShard(
            heirarchy$$1, transactions
        );

        const indexBuild = getBuildIndexTransactionsByShard(
            heirarchy$$1,
            transactions
        );
        
        const toRemove = [
            ...deletes,
            ...updates.toRemove
        ];

        const toWrite = [
            ...created,
            ...updates.toWrite,
            ...indexBuild
        ];

        const transByShard = {};

        const initialiseShard = t => {
            if(fp.isUndefined(transByShard[t.indexShardKey]))
                transByShard[t.indexShardKey] = {
                    writes:[], 
                    removes:[],
                    indexKey:t.indexKey,
                    indexNodeKey:t.indexNodeKey,
                    indexNode:t.indexNode
                };
        };

        for(let trans of toWrite) {
            initialiseShard(trans);        
            transByShard[trans.indexShardKey].writes.push(
                trans.mappedRecord.result);
        }

        for(let trans of toRemove) {
            initialiseShard(trans);        
            transByShard[trans.indexShardKey].removes.push(
                trans.mappedRecord.result.key);
        }

        return transByShard;
    };  

    const getUpdateTransactionsByShard = (heirarchy$$1, transactions) => {
        const updateTransactions = $(transactions, [fp.filter(isUpdate)]);

        const evaluateIndex = (record, indexNodeAndPath) => {
            const mappedRecord = evaluate(record)(indexNodeAndPath.indexNode);
            return ({mappedRecord:mappedRecord, 
            indexNode:indexNodeAndPath.indexNode, 
            indexKey:indexNodeAndPath.indexKey,
            indexShardKey:getIndexedDataKey(
                indexNodeAndPath.indexNode,
                indexNodeAndPath.indexKey,
                mappedRecord.result)
            });
        };

        const getIndexNodesToApply = (indexFilter) => (t,indexes) => 
            $(indexes, [
                fp.map(n => ({
                    old:evaluateIndex(t.oldRecord, n),
                    new:evaluateIndex(t.record, n)})),
                fp.filter(indexFilter)
            ]);

        const toRemoveFilter = (n, isUnreferenced) => 
            n.old.mappedRecord.passedFilter === true
            && (n.new.mappedRecord.passedFilter === false
                || isUnreferenced);

        const toAddFilter = (n, isNewlyReferenced) => 
            (n.old.mappedRecord.passedFilter === false
            || isNewlyReferenced)
            && n.new.mappedRecord.passedFilter === true;

        const toUpdateFilter = n => 
            n.new.mappedRecord.passedFilter === true
            && n.old.mappedRecord.passedFilter === true
            && !fp.isEqual(n.old.mappedRecord.result, 
                        n.new.mappedRecord.result);

        const toRemove = [];
        const toWrite = [];

        for(let t of updateTransactions) {
            const ancestorIdxs = getRelevantAncestorIndexes(
                heirarchy$$1, t.record);

            const referenceChanges = diffReverseRefForUpdate(
                heirarchy$$1, t.oldRecord, t.record);

            // old records to remove (filtered out)
            const filteredOut_toRemove =
                _.union(
                    getIndexNodesToApply(toRemoveFilter)(t, ancestorIdxs),
                    // still referenced - check filter
                    getIndexNodesToApply(toRemoveFilter)(t, referenceChanges.notChanged),
                    // un referenced - remove if in there already
                    getIndexNodesToApply(n => toRemoveFilter(n,true))
                                        (t, referenceChanges.unReferenced)
                );

            // new records to add (filtered in)
            const filteredIn_toAdd =
                _.union(
                    getIndexNodesToApply(toAddFilter)(t, ancestorIdxs),
                    // newly referenced - check filter
                    getIndexNodesToApply(n => toAddFilter(n,true))
                                        (t, referenceChanges.newlyReferenced),
                    // reference unchanged - rerun filter in case something else changed
                    getIndexNodesToApply(toAddFilter)(t, referenceChanges.notChanged),
                );

            const changed = 
                _.union(
                    getIndexNodesToApply(toUpdateFilter)(t, ancestorIdxs),
                    // still referenced - recheck filter
                    getIndexNodesToApply(toUpdateFilter)(t, referenceChanges.notChanged),
                );
            
            const shardKeyChanged = $(changed,[
                fp.filter(c => c.old.indexShardKey !== c.new.indexShardKey)
            ]);

            const changedInSameShard = $(shardKeyChanged, [
                fp.difference(changed)
            ]);

            for(let res of shardKeyChanged) {
                fp.pull(res)(changed);
                filteredOut_toRemove.push(res);
                filteredIn_toAdd.push(res);
            }

            toRemove.push(
                $(filteredOut_toRemove,[
                    fp.map(i => i.old)
                ])
            );

            toWrite.push(
                $(filteredIn_toAdd, [
                    fp.map(i => i.new)
                ])
            );

            toWrite.push(
                $(changedInSameShard, [
                    fp.map(i => i.new)
                ])
            );
        }

        return ({
            toRemove: fp.flatten(toRemove),
            toWrite: fp.flatten(toWrite)
        });
        
    };

    const getBuildIndexTransactionsByShard =  (heirarchy$$1, transactions) => {
        const buildTransactions = $(transactions, [fp.filter(isBuildIndex)]);
        if(!isNonEmptyArray(buildTransactions)) return [];
        const indexNode = transactions.indexNode;

        const getIndexKeys = (t) => {
            if(isGlobalIndex(indexNode)) {
                return [indexNode.nodeKey()];
            } 

            if(isReferenceIndex(indexNode)) {
                const recordNode = getExactNodeForPath
                                        (heirarchy$$1)
                                        (t.record.key);
                const refFields = $(recordNode.fields, [
                    fp.filter(fieldReversesReferenceToIndex(indexNode))
                ]);
                const indexKeys = [];
                for(let refField of refFields) {
                    const refValue = t.record[refField.name];
                    if(isSomething(refValue) 
                       && isNonEmptyString(refValue.key)) {
                        const indexKey = joinKey(
                            refValue.key,
                            indexNode.name
                        );

                        if(!fp.includes(indexKey)(indexKeys))
                            indexKeys.push(indexKey);
                    }
                }
                return indexKeys;
            }

            return [joinKey(
                getActualKeyOfParent(
                    indexNode.parent().nodeKey(),
                    t.record.key
                ),
                indexNode.name
            )];
        };

        return $(buildTransactions, [
            fp.map(t => {
                const mappedRecord = evaluate(t.record)(indexNode);
                if(!mappedRecord.passedFilter) return null;
                const indexKeys = getIndexKeys(t);
                return $(indexKeys, [
                    fp.map(indexKey => ({mappedRecord, 
                    indexNode:indexNode, 
                    indexKey:indexKey,
                    indexShardKey:getIndexedDataKey(
                        indexNode,
                        indexKey,
                        mappedRecord.result)
                    }))
                ]);
            }),
            fp.flatten,
            fp.filter(isSomething)
        ]);
    };

    const get_Create_Delete_TransactionsByShard = pred => (heirarchy$$1, transactions) => {
        const createTransactions = $(transactions, [fp.filter(pred)]);

        const getIndexNodesToApply = (t,indexes) => 
            $(indexes, [
                fp.map(n => { 
                    const mappedRecord = evaluate(t.record)(n.indexNode);
                    return ({mappedRecord, 
                            indexNode:n.indexNode, 
                            indexKey:n.indexKey,
                            indexShardKey:getIndexedDataKey(
                                n.indexNode,
                                n.indexKey,
                                mappedRecord.result)
                        });
                    }),
                fp.filter(n => n.mappedRecord.passedFilter)
            ]);

        const allToApply = [];

        for(let t of createTransactions) {
            const ancestorIdxs = 
                getRelevantAncestorIndexes(heirarchy$$1, t.record);
            const reverseRef = 
                getRelevantReverseReferenceIndexes(heirarchy$$1, t.record);
            
            allToApply.push(
                getIndexNodesToApply(t, ancestorIdxs)
            );
            allToApply.push(
                getIndexNodesToApply(t, reverseRef)
            );
        }

        return fp.flatten(allToApply);
    };

    const getDeleteTransactionsByShard = 
        get_Create_Delete_TransactionsByShard(isDelete);

    const getCreateTransactionsByShard = 
        get_Create_Delete_TransactionsByShard(isCreate);

    const diffReverseRefForUpdate = (appHeirarchy, oldRecord, newRecord) => {
        const oldIndexes = getRelevantReverseReferenceIndexes(
            appHeirarchy, oldRecord
        );
        const newIndexes = getRelevantReverseReferenceIndexes(
            appHeirarchy, newRecord
        );

        const unReferenced = fp.differenceBy(
            i => i.indexKey,
            oldIndexes, newIndexes
        );

        const newlyReferenced = fp.differenceBy(
            i => i.indexKey,
            newIndexes, oldIndexes
        );

        const notChanged =  fp.intersectionBy(
            i => i.indexKey,
            newIndexes, oldIndexes
        );

        return  {
            unReferenced,
            newlyReferenced,
            notChanged
        };
    };

    const cleanup = async app => {

        const lock = await getTransactionLock(app);
        if(isNolock$$1(lock)) return;

        try {
            const transactions = await retrieve(app);
            if(transactions.length > 0) {
                await executeTransactions(app)(transactions);
                
                const folder = transactions.folderKey 
                               ? transactions.folderKey 
                               : TRANSACTIONS_FOLDER;

                const deleteFiles = $(transactions, [
                    fp.map(t => joinKey(
                        folder,
                        getTransactionId(
                        t.recordId, t.transactionType,
                        t.uniqueId)
                    )),
                    fp.map(app.datastore.deleteFile)
                ]);

                await Promise.all(deleteFiles);
            }
        }
        finally {
            await releaseLock$$1(app, lock);
        }
        
    };

    const getTransactionLock = async app => 
        await getLock$$1(
            app, LOCK_FILE_KEY,
            timeoutMilliseconds$1, maxLockRetries
        );

    const getBehaviourSources$1 = async datastore => 
        await datastore.loadFile("/.config/behaviourSources.js");

    const initialiseData = async (datastore, applicationDefinition) => {
        await datastore.createFolder(configFolder);
        await datastore.createJson(appDefinitionFile, applicationDefinition);

        await initialiseRootCollections(datastore, applicationDefinition.heirarchy);
        await initialiseRootIndexes(datastore, applicationDefinition.heirarchy);
        await datastore.createFolder(TRANSACTIONS_FOLDER);

        await datastore.createFolder(AUTH_FOLDER);

        await datastore.createJson(USERS_LIST_FILE, []);

        await datastore.createJson(ACCESS_LEVELS_FILE, {version:0,levels:[]});
    };

    const initialiseRootIndexes = async (datastore, heirarchy$$1) => {

        const flatheirarchy = getFlattenedHierarchy(heirarchy$$1);
        const globalIndexes = $(flatheirarchy, [
            fp.filter(isGlobalIndex)
        ]);

        for(let index$$1 of globalIndexes) {
            if(!await datastore.exists(index$$1.nodeKey()))
                await initialiseIndex(datastore, "", index$$1);
        } 
    };

    const getDatabaseManager = databaseManager => ({
        createEmptyMasterDb: createEmptyMasterDb(databaseManager),
        createEmptyProductSetDb: createEmptyProductSetDb(databaseManager),
        createEmptyProductInstanceDb: createEmptyProductInstanceDb(databaseManager),
        getProductSetDbRootConfig: databaseManager.getProductSetDbRootConfig,
        getProductInstanceDbRootConfig: databaseManager.getProductInstanceDbRootConfig,
        masterDatastoreConfig: getMasterDatastoreConfig(databaseManager),
        getProductSetDatastoreConfig: getProductSetDatastoreConfig(databaseManager),
        getProductInstanceDatastoreConfig: getProductInstanceDatastoreConfig(databaseManager)
    });

    const getMasterDatastoreConfig = databaseManager => 
        databaseManager.getDatastoreConfig(
            databaseManager.getMasterDbRootConfig,
            "master"
        );

    const getProductSetDatastoreConfig = databaseManager => 
                                        (dbRootConfig, productSetId) => 
        databaseManager.getDatastoreConfig(
            dbRootConfig, "productset", productSetId
        );

    const getProductInstanceDatastoreConfig = databaseManager => 
                                (dbRootConfig, productSetId, productId, productInstanceId) => 
        databaseManager.getDatastoreConfig(
            dbRootConfig, "productinstance",
            productSetId, productId, productInstanceId
        );

    const createEmptyMasterDb = databaseManager => async () =>  
        await databaseManager.createEmptyDb(
            databaseManager.getMasterDbRootConfig(),
            "master"
        );


    const createEmptyProductSetDb = databaseManager => async (productSetId) => {
        
        if(isNothing(productSetId))
            throw new Error("CreateDb: Product Set Id not supplied");
        
        return await databaseManager.createEmptyDb(
            databaseManager.getProductSetDbRootConfig(productSetId), 
            "productset", productSetId);
    };


    const createEmptyProductInstanceDb = databaseManager => async (productSetId, productId, productInstanceId) => {
        
        if(isNothing(productSetId))
            throw new Error("CreateDb: Product Set Id not supplied");
        if(isNothing(productId))
            throw new Error("CreateDb: Product Id not supplied");
        if(isNothing(productInstanceId))
            throw new Error("CreateDb: Product Instance Id not supplied");

        return await databaseManager.createEmptyDb(
            databaseManager.getProductInstanceDbRootConfig(productSetId, productId, productInstanceId), 
            "productinstance", 
            productSetId, productId, productInstanceId);
    };

    const getAppApis = async (store, behaviourSources = null, 
                                    cleanupTransactions = null, 
                                    getEpochTime = null,
                                    crypto = null,
                                    appDefinition = null) => {

        store = setupDatastore(store);
        
        if(!appDefinition)
            appDefinition = await getApplicationDefinition(store)();

        if(!behaviourSources)
            behaviourSources = await getBehaviourSources$1(store);

        const eventAggregator = createEventAggregator();

        const app = {
            datastore:store,
            crypto,
            publish:eventAggregator.publish,
            heirarchy:appDefinition.heirarchy,
            actions:appDefinition.actions
        };

        const templateApi = getTemplateApi(app);    

        const actions = initialiseActions(
            eventAggregator.subscribe,
            behaviourSources,
            appDefinition.actions,
            appDefinition.triggers);

        app.cleanupTransactions = isSomething(cleanupTransactions) 
                                  ? cleanupTransactions
                                  : async () => cleanup(app);

        app.getEpochTime = isSomething(getEpochTime)
                           ? getEpochTime
                           : async () => (new Date()).getTime();

        const recordApi = getRecordApi(app);
        const collectionApi = getCollectionApi(app);
        const indexApi = getIndexApi(app);
        const authApi = getAuthApi(app);
        const actionsApi = getActionsApi(app);

        const authenticateAs = async (username, password) => {
            app.user = await authApi.authenticate(username, password);
        };

        const withFullAccess = () => {
            app.user = {
                name: "app",
                permissions : generateFullPermissions(app),
                isUser:false,
                temp:false
            };
        };

        const asUser = (user) => {
            app.user = user;
        };

        return ({
            recordApi, 
            templateApi,
            collectionApi,
            indexApi,
            authApi,
            actionsApi,
            subscribe: eventAggregator.subscribe,
            actions,
            authenticateAs,
            withFullAccess,
            asUser
        });
    };

    exports.getAppApis = getAppApis;
    exports.hierarchy = heirarchy;
    exports.common = index;
    exports.default = getAppApis;
    exports.events = events;
    exports.eventsList = eventsList;
    exports.getTemplateApi = getTemplateApi;
    exports.getRecordApi = getRecordApi;
    exports.getCollectionApi = getCollectionApi;
    exports.getIndexApi = getIndexApi;
    exports.setupDatastore = setupDatastore;
    exports.getActionsApi = getActionsApi;
    exports.initialiseData = initialiseData;
    exports.getDatabaseManager = getDatabaseManager;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVkaWJhc2UtY29yZS51bWQuanMiLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21tb24vZXZlbnRzLmpzIiwiLi4vc3JjL2NvbW1vbi9hcGlXcmFwcGVyLmpzIiwiLi4vc3JjL2NvbW1vbi9sb2NrLmpzIiwiLi4vc3JjL2NvbW1vbi9pbmRleC5qcyIsIi4uL3NyYy9jb21tb24vdmFsaWRhdGlvbkNvbW1vbi5qcyIsIi4uL3NyYy9pbmRleGluZy9ldmFsdWF0ZS5qcyIsIi4uL3NyYy90ZW1wbGF0ZUFwaS9pbmRleGVzLmpzIiwiLi4vc3JjL3RlbXBsYXRlQXBpL2hlaXJhcmNoeS5qcyIsIi4uL3NyYy90eXBlcy90eXBlSGVscGVycy5qcyIsIi4uL3NyYy90eXBlcy9zdHJpbmcuanMiLCIuLi9zcmMvdHlwZXMvYm9vbC5qcyIsIi4uL3NyYy90eXBlcy9udW1iZXIuanMiLCIuLi9zcmMvdHlwZXMvZGF0ZXRpbWUuanMiLCIuLi9zcmMvdHlwZXMvYXJyYXkuanMiLCIuLi9zcmMvdHlwZXMvcmVmZXJlbmNlLmpzIiwiLi4vc3JjL3R5cGVzL2ZpbGUuanMiLCIuLi9zcmMvdHlwZXMvaW5kZXguanMiLCIuLi9zcmMvYXV0aEFwaS9hdXRoQ29tbW9uLmpzIiwiLi4vc3JjL2F1dGhBcGkvaXNBdXRob3JpemVkLmpzIiwiLi4vc3JjL2F1dGhBcGkvcGVybWlzc2lvbnMuanMiLCIuLi9zcmMvcmVjb3JkQXBpL2dldE5ldy5qcyIsIi4uL3NyYy9yZWNvcmRBcGkvbG9hZC5qcyIsIi4uL3NyYy9pbmRleGluZy9zaGFyZGluZy5qcyIsIi4uL3NyYy9pbmRleGluZy9pbmRleFNjaGVtYUNyZWF0b3IuanMiLCIuLi9zcmMvaW5kZXhpbmcvc2VyaWFsaXplci5qcyIsIi4uL3NyYy9pbmRleGluZy9yZWFkLmpzIiwiLi4vc3JjL2luZGV4QXBpL2xpc3RJdGVtcy5qcyIsIi4uL3NyYy9yZWNvcmRBcGkvZ2V0Q29udGV4dC5qcyIsIi4uL3NyYy9yZWNvcmRBcGkvdmFsaWRhdGUuanMiLCIuLi9zcmMvY29sbGVjdGlvbkFwaS9pbml0aWFsaXNlLmpzIiwiLi4vc3JjL2luZGV4aW5nL2FsbElkcy5qcyIsIi4uL3NyYy90cmFuc2FjdGlvbnMvdHJhbnNhY3Rpb25zQ29tbW9uLmpzIiwiLi4vc3JjL3RyYW5zYWN0aW9ucy9jcmVhdGUuanMiLCIuLi9zcmMvaW5kZXhpbmcvaW5pdGlhbGlzZUluZGV4LmpzIiwiLi4vc3JjL3JlY29yZEFwaS9zYXZlLmpzIiwiLi4vc3JjL2luZGV4QXBpL2RlbGV0ZS5qcyIsIi4uL3NyYy9jb2xsZWN0aW9uQXBpL2RlbGV0ZS5qcyIsIi4uL3NyYy9yZWNvcmRBcGkvZGVsZXRlLmpzIiwiLi4vc3JjL3JlY29yZEFwaS91cGxvYWRGaWxlLmpzIiwiLi4vc3JjL3JlY29yZEFwaS9kb3dubG9hZEZpbGUuanMiLCIuLi9zcmMvcmVjb3JkQXBpL2luZGV4LmpzIiwiLi4vc3JjL2NvbGxlY3Rpb25BcGkvZ2V0QWxsb3dlZFJlY29yZFR5cGVzLmpzIiwiLi4vc3JjL2NvbGxlY3Rpb25BcGkvaW5kZXguanMiLCIuLi9zcmMvaW5kZXhBcGkvYnVpbGRJbmRleC5qcyIsIi4uL3NyYy9pbmRleEFwaS9hZ2dyZWdhdGVzLmpzIiwiLi4vc3JjL2luZGV4QXBpL2luZGV4LmpzIiwiLi4vc3JjL3RlbXBsYXRlQXBpL2NyZWF0ZU5vZGVzLmpzIiwiLi4vc3JjL3RlbXBsYXRlQXBpL2ZpZWxkcy5qcyIsIi4uL3NyYy90ZW1wbGF0ZUFwaS9yZWNvcmRWYWxpZGF0aW9uUnVsZXMuanMiLCIuLi9zcmMvdGVtcGxhdGVBcGkvY3JlYXRlQWN0aW9ucy5qcyIsIi4uL3NyYy90ZW1wbGF0ZUFwaS92YWxpZGF0ZUFnZ3JlZ2F0ZS5qcyIsIi4uL3NyYy90ZW1wbGF0ZUFwaS92YWxpZGF0ZS5qcyIsIi4uL3NyYy90ZW1wbGF0ZUFwaS9nZXRBcHBsaWNhdGlvbkRlZmluaXRpb24uanMiLCIuLi9zcmMvdGVtcGxhdGVBcGkvc2F2ZUFwcGxpY2F0aW9uSGVpcmFyY2h5LmpzIiwiLi4vc3JjL3RlbXBsYXRlQXBpL3NhdmVBY3Rpb25zQW5kVHJpZ2dlcnMuanMiLCIuLi9zcmMvdGVtcGxhdGVBcGkvaW5kZXguanMiLCIuLi9zcmMvYXV0aEFwaS9nZXRVc2Vycy5qcyIsIi4uL3NyYy9hdXRoQXBpL2xvYWRBY2Nlc3NMZXZlbHMuanMiLCIuLi9zcmMvYXV0aEFwaS9hdXRoZW50aWNhdGUuanMiLCIuLi9zcmMvYXV0aEFwaS9jcmVhdGVUZW1wb3JhcnlBY2Nlc3MuanMiLCIuLi9zcmMvYXV0aEFwaS92YWxpZGF0ZVVzZXIuanMiLCIuLi9zcmMvYXV0aEFwaS9nZXROZXdVc2VyLmpzIiwiLi4vc3JjL2F1dGhBcGkvc2V0UGFzc3dvcmQuanMiLCIuLi9zcmMvYXV0aEFwaS9jcmVhdGVVc2VyLmpzIiwiLi4vc3JjL2F1dGhBcGkvZW5hYmxlVXNlci5qcyIsIi4uL3NyYy9hdXRoQXBpL2dldE5ld0FjY2Vzc0xldmVsLmpzIiwiLi4vc3JjL2F1dGhBcGkvdmFsaWRhdGVBY2Nlc3NMZXZlbHMuanMiLCIuLi9zcmMvYXV0aEFwaS9zYXZlQWNjZXNzTGV2ZWxzLmpzIiwiLi4vc3JjL2F1dGhBcGkvZ2VuZXJhdGVGdWxsUGVybWlzc2lvbnMuanMiLCIuLi9zcmMvYXV0aEFwaS9zZXRVc2VyQWNjZXNzTGV2ZWxzLmpzIiwiLi4vc3JjL2F1dGhBcGkvaW5kZXguanMiLCIuLi9zcmMvYWN0aW9uc0FwaS9leGVjdXRlLmpzIiwiLi4vc3JjL2FjdGlvbnNBcGkvaW5kZXguanMiLCIuLi9zcmMvYXBwSW5pdGlhbGlzZS9ldmVudEFnZ3JlZ2F0b3IuanMiLCIuLi9zcmMvYXBwSW5pdGlhbGlzZS9pbmRleC5qcyIsIi4uL3NyYy9hY3Rpb25zQXBpL2luaXRpYWxpc2UuanMiLCIuLi9zcmMvdHJhbnNhY3Rpb25zL3JldHJpZXZlLmpzIiwiLi4vc3JjL2luZGV4aW5nL3JlbGV2YW50LmpzIiwiLi4vc3JjL2luZGV4aW5nL2FwcGx5LmpzIiwiLi4vc3JjL3RyYW5zYWN0aW9ucy9leGVjdXRlLmpzIiwiLi4vc3JjL3RyYW5zYWN0aW9ucy9jbGVhbnVwLmpzIiwiLi4vc3JjL3RlbXBsYXRlQXBpL2dldEJlaGF2aW91clNvdXJjZXMuanMiLCIuLi9zcmMvYXBwSW5pdGlhbGlzZS9pbml0aWFsaXNlRGF0YS5qcyIsIi4uL3NyYy9hcHBJbml0aWFsaXNlL2RhdGFiYXNlTWFuYWdlci5qcyIsIi4uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VuaW9uLCByZWR1Y2V9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuXHJcbmNvbnN0IGNvbW1vblBsdXMgPSAoZXh0cmEpID0+IFxyXG4gICAgdW5pb24oW1wib25CZWdpblwiLCBcIm9uQ29tcGxldGVcIiwgXCJvbkVycm9yXCJdKVxyXG4gICAgKGV4dHJhKTtcclxuXHJcbmNvbnN0IGNvbW1vbiA9ICgpID0+IGNvbW1vblBsdXMoW10pO1xyXG5cclxuY29uc3QgX2V2ZW50cyA9IHtcclxuICAgIHJlY29yZEFwaSA6IHtcclxuICAgICAgICBzYXZlOiBjb21tb25QbHVzKFtcclxuICAgICAgICAgICAgXCJvbkludmFsaWRcIixcclxuICAgICAgICAgICAgXCJvblJlY29yZFVwZGF0ZWRcIixcclxuICAgICAgICAgICAgXCJvblJlY29yZENyZWF0ZWRcIl0pLFxyXG4gICAgICAgIGRlbGV0ZTogY29tbW9uKCksXHJcbiAgICAgICAgZ2V0Q29udGV4dDogY29tbW9uKCksXHJcbiAgICAgICAgZ2V0TmV3OiBjb21tb24oKSxcclxuICAgICAgICBsb2FkOiBjb21tb24oKSxcclxuICAgICAgICB2YWxpZGF0ZTogY29tbW9uKCksXHJcbiAgICAgICAgdXBsb2FkRmlsZTogY29tbW9uKCksXHJcbiAgICAgICAgZG93bmxvYWRGaWxlOiBjb21tb24oKVxyXG4gICAgfSxcclxuICAgIGluZGV4QXBpIDoge1xyXG4gICAgICAgIGJ1aWxkSW5kZXg6IGNvbW1vbigpLFxyXG4gICAgICAgIGxpc3RJdGVtczogY29tbW9uKCksXHJcbiAgICAgICAgZGVsZXRlOiBjb21tb24oKSxcclxuICAgICAgICBhZ2dyZWdhdGVzOiBjb21tb24oKSxcclxuICAgIH0sXHJcbiAgICBjb2xsZWN0aW9uQXBpOiB7XHJcbiAgICAgICAgZ2V0QWxsb3dlZFJlY29yZFR5cGVzOiBjb21tb24oKSxcclxuICAgICAgICBpbml0aWFsaXNlOiBjb21tb24oKSxcclxuICAgICAgICBkZWxldGU6IGNvbW1vbigpXHJcbiAgICB9LFxyXG4gICAgYXV0aEFwaToge1xyXG4gICAgICAgIGF1dGhlbnRpY2F0ZTogY29tbW9uKCksXHJcbiAgICAgICAgYXV0aGVudGljYXRlVGVtcG9yYXJ5QWNjZXNzOiBjb21tb24oKSxcclxuICAgICAgICBjcmVhdGVUZW1wb3JhcnlBY2Nlc3M6IGNvbW1vbigpLFxyXG4gICAgICAgIGNyZWF0ZVVzZXI6IGNvbW1vbigpLFxyXG4gICAgICAgIGVuYWJsZVVzZXI6IGNvbW1vbigpLFxyXG4gICAgICAgIGRpc2FibGVVc2VyOiBjb21tb24oKSxcclxuICAgICAgICBsb2FkQWNjZXNzTGV2ZWxzOiBjb21tb24oKSxcclxuICAgICAgICBnZXROZXdBY2Nlc3NMZXZlbDogY29tbW9uKCksXHJcbiAgICAgICAgZ2V0TmV3VXNlcjogY29tbW9uKCksXHJcbiAgICAgICAgZ2V0TmV3VXNlckF1dGg6IGNvbW1vbigpLFxyXG4gICAgICAgIGdldFVzZXJzOiBjb21tb24oKSxcclxuICAgICAgICBzYXZlQWNjZXNzTGV2ZWxzOiBjb21tb24oKSxcclxuICAgICAgICBpc0F1dGhvcml6ZWQ6IGNvbW1vbigpLFxyXG4gICAgICAgIGNoYW5nZU15UGFzc3dvcmQ6IGNvbW1vbigpLFxyXG4gICAgICAgIHNldFBhc3N3b3JkRnJvbVRlbXBvcmFyeUNvZGU6IGNvbW1vbigpLFxyXG4gICAgICAgIHNjb3JlUGFzc3dvcmQ6IGNvbW1vbigpLFxyXG4gICAgICAgIGlzVmFsaWRQYXNzd29yZDogY29tbW9uKCksXHJcbiAgICAgICAgdmFsaWRhdGVVc2VyOiBjb21tb24oKSxcclxuICAgICAgICB2YWxpZGF0ZUFjY2Vzc0xldmVsczogY29tbW9uKCksXHJcbiAgICAgICAgc2V0VXNlckFjY2Vzc0xldmVsczogY29tbW9uKClcclxuICAgIH0sXHJcbiAgICB0ZW1wbGF0ZUFwaToge1xyXG4gICAgICAgIHNhdmVBcHBsaWNhdGlvbkhlaXJhcmNoeTogY29tbW9uKCksXHJcbiAgICAgICAgc2F2ZUFjdGlvbnNBbmRUcmlnZ2VyczogY29tbW9uKClcclxuICAgIH0sXHJcbiAgICBhY3Rpb25zQXBpOiB7XHJcbiAgICAgICAgZXhlY3V0ZTogY29tbW9uKClcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgX2V2ZW50c0xpc3QgPSBbXTtcclxuXHJcbmNvbnN0IG1ha2VFdmVudCA9IChhcmVhLCAgbWV0aG9kLCBuYW1lKSA9PlxyXG4gICAgYCR7YXJlYX06JHttZXRob2R9OiR7bmFtZX1gO1xyXG5cclxuZm9yKGxldCBhcmVhS2V5IGluIF9ldmVudHMpIHtcclxuICAgIGZvcihsZXQgbWV0aG9kS2V5IGluIF9ldmVudHNbYXJlYUtleV0pIHtcclxuICAgICAgICBfZXZlbnRzW2FyZWFLZXldW21ldGhvZEtleV0gPSBcclxuICAgICAgICAgICAgcmVkdWNlKChvYmoscykgPT4ge1xyXG4gICAgICAgICAgICAgICAgb2JqW3NdID0gbWFrZUV2ZW50KGFyZWFLZXksbWV0aG9kS2V5LHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICx7fSlcclxuICAgICAgICAgICAgKF9ldmVudHNbYXJlYUtleV1bbWV0aG9kS2V5XSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5mb3IobGV0IGFyZWFLZXkgaW4gX2V2ZW50cykge1xyXG4gICAgZm9yKGxldCBtZXRob2RLZXkgaW4gX2V2ZW50c1thcmVhS2V5XSkge1xyXG4gICAgICAgIGZvcihsZXQgbmFtZSBpbiBfZXZlbnRzW2FyZWFLZXldW21ldGhvZEtleV0pIHtcclxuICAgICAgICAgICAgX2V2ZW50c0xpc3QucHVzaChcclxuICAgICAgICAgICAgICAgIF9ldmVudHNbYXJlYUtleV1bbWV0aG9kS2V5XVtuYW1lXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBldmVudHMgPSBfZXZlbnRzO1xyXG5cclxuZXhwb3J0IGNvbnN0IGV2ZW50c0xpc3QgPSBfZXZlbnRzTGlzdDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtldmVudHM6X2V2ZW50cywgZXZlbnRzTGlzdDpfZXZlbnRzTGlzdH07IiwiaW1wb3J0IHtjbG9uZURlZXAsIGlzVW5kZWZpbmVkfSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcbmltcG9ydCB7Z2VuZXJhdGV9IGZyb20gXCJzaG9ydGlkXCI7XHJcblxyXG5leHBvcnQgY29uc3QgYXBpV3JhcHBlciA9IGFzeW5jIChhcHAsIGV2ZW50TmFtZXNwYWNlLCBpc0F1dGhvcml6ZWQsIGV2ZW50Q29udGV4dCwgZnVuYywgLi4ucGFyYW1zKSA9PiB7XHJcblxyXG4gICAgcHVzaENhbGxTdGFjayhhcHAsZXZlbnROYW1lc3BhY2UpO1xyXG5cclxuICAgIGlmKCFpc0F1dGhvcml6ZWQoYXBwKSkge1xyXG4gICAgICAgIGhhbmRsZU5vdEF1dGhvcml6ZWQoYXBwLCBldmVudENvbnRleHQsIGV2ZW50TmFtZXNwYWNlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RhcnREYXRlID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IGVsYXBzZWQgPSAoKSA9PiBcclxuICAgICAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0RGF0ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBhcHAucHVibGlzaChcclxuICAgICAgICAgICAgZXZlbnROYW1lc3BhY2Uub25CZWdpbixcclxuICAgICAgICAgICAgZXZlbnRDb250ZXh0XHJcbiAgICAgICAgKTsgXHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZ1bmMoLi4ucGFyYW1zKTtcclxuICAgICAgICBcclxuICAgICAgICBwdWJsaXNoQ29tcGxldGUoYXBwLCBldmVudENvbnRleHQsIGV2ZW50TmFtZXNwYWNlLCBlbGFwc2VkLCByZXN1bHQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBwdWJsaXNoRXJyb3IoYXBwLCBldmVudENvbnRleHQsIGV2ZW50TmFtZXNwYWNlLCBlbGFwc2VkLCBlcnJvcilcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGFwaVdyYXBwZXJTeW5jID0gKGFwcCwgZXZlbnROYW1lc3BhY2UsIGlzQXV0aG9yaXplZCwgZXZlbnRDb250ZXh0LCBmdW5jLCAuLi5wYXJhbXMpID0+IHtcclxuXHJcbiAgICBwdXNoQ2FsbFN0YWNrKGFwcCxldmVudE5hbWVzcGFjZSk7XHJcblxyXG4gICAgaWYoIWlzQXV0aG9yaXplZChhcHApKSB7XHJcbiAgICAgICAgaGFuZGxlTm90QXV0aG9yaXplZChhcHAsIGV2ZW50Q29udGV4dCwgZXZlbnROYW1lc3BhY2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3Qgc3RhcnREYXRlID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IGVsYXBzZWQgPSAoKSA9PiBcclxuICAgICAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0RGF0ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBhcHAucHVibGlzaChcclxuICAgICAgICAgICAgZXZlbnROYW1lc3BhY2Uub25CZWdpbixcclxuICAgICAgICAgICAgZXZlbnRDb250ZXh0XHJcbiAgICAgICAgKTsgXHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMoLi4ucGFyYW1zKTtcclxuICAgICAgICBcclxuICAgICAgICBwdWJsaXNoQ29tcGxldGUoYXBwLCBldmVudENvbnRleHQsIGV2ZW50TmFtZXNwYWNlLCBlbGFwc2VkLCByZXN1bHQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBwdWJsaXNoRXJyb3IoYXBwLCBldmVudENvbnRleHQsIGV2ZW50TmFtZXNwYWNlLCBlbGFwc2VkLCBlcnJvcilcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgaGFuZGxlTm90QXV0aG9yaXplZCA9IChhcHAsIGV2ZW50Q29udGV4dCwgZXZlbnROYW1lc3BhY2UpID0+IHtcclxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIlVuYXV0aG9yaXplZFwiKTtcclxuICAgIHB1Ymxpc2hFcnJvcihhcHAsIGV2ZW50Q29udGV4dCwgZXZlbnROYW1lc3BhY2UsICgpID0+IDAsIGVycik7XHJcbiAgICB0aHJvdyBlcnI7XHJcbn07XHJcblxyXG5jb25zdCBwdXNoQ2FsbFN0YWNrID0gKGFwcCwgZXZlbnROYW1lc3BhY2UsIHNlZWRDYWxsSWQpID0+IHtcclxuXHJcbiAgICBjb25zdCBjYWxsSWQgPSBnZW5lcmF0ZSgpO1xyXG5cclxuICAgIGNvbnN0IGNyZWF0ZUNhbGxTdGFjayA9ICgpID0+ICh7XHJcbiAgICAgICAgc2VlZENhbGxJZDogIWlzVW5kZWZpbmVkKHNlZWRDYWxsSWQpIFxyXG4gICAgICAgICAgICAgICAgICAgID8gc2VlZENhbGxJZFxyXG4gICAgICAgICAgICAgICAgICAgIDogY2FsbElkLFxyXG4gICAgICAgIHRocmVhZENhbGxJZDpjYWxsSWQsXHJcbiAgICAgICAgc3RhY2s6IFtdXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZihpc1VuZGVmaW5lZChhcHAuY2FsbHMpKSB7XHJcbiAgICAgICAgYXBwLmNhbGxzID0gY3JlYXRlQ2FsbFN0YWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXBwLmNhbGxzLnN0YWNrLnB1c2goe1xyXG4gICAgICAgIG5hbWVzcGFjZTpldmVudE5hbWVzcGFjZSxcclxuICAgICAgICBjYWxsSWRcclxuICAgIH0pO1xyXG59XHJcblxyXG5jb25zdCBwb3BDYWxsU3RhY2sgPSAoYXBwKSA9PiB7XHJcbiAgICBhcHAuY2FsbHMuc3RhY2sucG9wKCk7XHJcbiAgICBpZihhcHAuY2FsbHMuc3RhY2subGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgZGVsZXRlIGFwcC5jYWxscztcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgcHVibGlzaEVycm9yID0gKGFwcCwgZXZlbnRDb250ZXh0LCBldmVudE5hbWVzcGFjZSwgZWxhcHNlZCwgZXJyKSA9PiB7XHJcbiAgICBjb25zdCBjdHggPSBjbG9uZURlZXAoZXZlbnRDb250ZXh0KTtcclxuICAgIGN0eC5lcnJvciA9IGVycjtcclxuICAgIGN0eC5lbGFwc2VkID0gZWxhcHNlZCgpO1xyXG4gICAgYXBwLnB1Ymxpc2goXHJcbiAgICAgICAgZXZlbnROYW1lc3BhY2Uub25FcnJvcixcclxuICAgICAgICBjdHgpO1xyXG4gICAgcG9wQ2FsbFN0YWNrKGFwcCk7XHJcbiAgICB0aHJvdyBlcnI7XHJcbn07XHJcblxyXG5jb25zdCBwdWJsaXNoQ29tcGxldGUgPSAoYXBwLCBldmVudENvbnRleHQsIGV2ZW50TmFtZXNwYWNlLCBlbGFwc2VkLCByZXN1bHQpID0+IHtcclxuICAgIGNvbnN0IGVuZGNvbnRleHQgPSBjbG9uZURlZXAoZXZlbnRDb250ZXh0KTtcclxuICAgIGVuZGNvbnRleHQucmVzdWx0ID0gcmVzdWx0O1xyXG4gICAgZW5kY29udGV4dC5lbGFwc2VkID0gZWxhcHNlZCgpO1xyXG4gICAgYXBwLnB1Ymxpc2goXHJcbiAgICAgICAgZXZlbnROYW1lc3BhY2Uub25Db21wbGV0ZSxcclxuICAgICAgICBlbmRjb250ZXh0KTtcclxuICAgIHBvcENhbGxTdGFjayhhcHApO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFwaVdyYXBwZXI7IiwiaW1wb3J0IHskfSBmcm9tIFwiLi9pbmRleFwiO1xyXG5pbXBvcnQge3NwbGl0fSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcblxyXG5jb25zdCBsb2NrT3ZlcmxhcE1pbGxpc2Vjb25kcyA9IDEwO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldExvY2sgPSBhc3luYyAoYXBwLCBsb2NrRmlsZSwgdGltZW91dE1pbGxpc2Vjb25kcywgbWF4TG9ja1JldHJpZXMsIHJldHJ5Q291bnQ9MCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gXHJcbiAgICAgICAgICAgIChhd2FpdCBhcHAuZ2V0RXBvY2hUaW1lKCkpXHJcbiAgICAgICAgICAgICtcclxuICAgICAgICAgICAgdGltZW91dE1pbGxpc2Vjb25kcztcclxuXHJcbiAgICAgICAgY29uc3QgbG9jayA9IHtcclxuICAgICAgICAgICAgdGltZW91dCxcclxuICAgICAgICAgICAga2V5OmxvY2tGaWxlLFxyXG4gICAgICAgICAgICB0b3RhbFRpbWVvdXQ6dGltZW91dE1pbGxpc2Vjb25kc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgYXdhaXQgYXBwLmRhdGFzdG9yZS5jcmVhdGVGaWxlKFxyXG4gICAgICAgICAgICBsb2NrRmlsZSwgXHJcbiAgICAgICAgICAgIGdldExvY2tGaWxlQ29udGVudChcclxuICAgICAgICAgICAgICAgIGxvY2sudG90YWxUaW1lb3V0LCBcclxuICAgICAgICAgICAgICAgIGxvY2sudGltZW91dClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gbG9jaztcclxuICAgIH0gY2F0Y2goZSkge1xyXG5cclxuICAgICAgICBpZihyZXRyeUNvdW50ID09IG1heExvY2tSZXRyaWVzKVxyXG4gICAgICAgICAgICByZXR1cm4gTk9fTE9DSztcclxuXHJcbiAgICAgICAgY29uc3QgbG9jayA9IHBhcnNlTG9ja0ZpbGVDb250ZW50KFxyXG4gICAgICAgICAgICBsb2NrRmlsZSxcclxuICAgICAgICAgICAgYXdhaXQgYXBwLmRhdGFzdG9yZS5sb2FkRmlsZShsb2NrRmlsZSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50RXBvY2hUaW1lID0gYXdhaXQgYXBwLmdldEVwb2NoVGltZSgpO1xyXG5cclxuICAgICAgICBpZihjdXJyZW50RXBvY2hUaW1lIDwgbG9jay50aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOT19MT0NLO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgYXBwLmRhdGFzdG9yZS5kZWxldGVGaWxlKGxvY2tGaWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2goXykge307IFxyXG4gICAgICAgIFxyXG4gICAgICAgIGF3YWl0IHNsZWVwRm9yUmV0cnkoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICBhd2FpdCBnZXRMb2NrKFxyXG4gICAgICAgICAgICBhcHAsIGxvY2tGaWxlLCB0aW1lb3V0TWlsbGlzZWNvbmRzLCBcclxuICAgICAgICAgICAgbWF4TG9ja1JldHJpZXMsIHJldHJ5Q291bnQrMSk7ICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTk9fTE9DSztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRMb2NrRmlsZUNvbnRlbnQgPSAodG90YWxUaW1lb3V0LCBlcG9jaFRpbWUpID0+IFxyXG4gICAgYCR7dG90YWxUaW1lb3V0fToke2Vwb2NoVGltZS50b1N0cmluZygpfWA7XHJcblxyXG5jb25zdCBwYXJzZUxvY2tGaWxlQ29udGVudCA9IChrZXksIGNvbnRlbnQpID0+ICBcclxuICAgICQoY29udGVudCwgW1xyXG4gICAgICAgIHNwbGl0KFwiOlwiKSxcclxuICAgICAgICBwYXJ0cyA9PiAoe1xyXG4gICAgICAgICAgICB0b3RhbFRpbWVvdXQ6bmV3IE51bWJlcihwYXJ0c1swXSksIFxyXG4gICAgICAgICAgICB0aW1lb3V0Om5ldyBOdW1iZXIocGFydHNbMV0pLFxyXG4gICAgICAgICAgICBrZXlcclxuICAgICAgICB9KVxyXG4gICAgXSk7XHJcblxyXG5leHBvcnQgY29uc3QgcmVsZWFzZUxvY2sgPSBhc3luYyAoYXBwLGxvY2spID0+IHtcclxuXHJcbiAgICBjb25zdCBjdXJyZW50RXBvY2hUaW1lID0gYXdhaXQgYXBwLmdldEVwb2NoVGltZSgpO1xyXG4gICAgLy8gb25seSByZWxlYXNlIGlmIG5vdCB0aW1lZG91dFxyXG4gICAgaWYoY3VycmVudEVwb2NoVGltZSA8IChsb2NrLnRpbWVvdXQgLSBsb2NrT3ZlcmxhcE1pbGxpc2Vjb25kcykpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLmRlbGV0ZUZpbGUobG9jay5rZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaChfKSB7fTtcclxuICAgIH0gXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBleHRlbmRMb2NrID0gYXN5bmMgKGFwcCwgbG9jaykgPT4ge1xyXG4gICAgY29uc3QgY3VycmVudEVwb2NoVGltZSA9IGF3YWl0IGFwcC5nZXRFcG9jaFRpbWUoKTtcclxuICAgIC8vIG9ubHkgcmVsZWFzZSBpZiBub3QgdGltZWRvdXRcclxuICAgIGlmKGN1cnJlbnRFcG9jaFRpbWUgPCAobG9jay50aW1lb3V0IC0gbG9ja092ZXJsYXBNaWxsaXNlY29uZHMpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbG9jay50aW1lb3V0ID0gY3VycmVudEVwb2NoVGltZSArIHRpbWVvdXRNaWxsaXNlY29uZHM7XHJcbiAgICAgICAgICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUudXBkYXRlRmlsZShcclxuICAgICAgICAgICAgICAgIGxvY2sua2V5LCBcclxuICAgICAgICAgICAgICAgIGdldExvY2tGaWxlQ29udGVudChsb2NrLnRvdGFsVGltZW91dCwgdGltZW91dClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxvY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKF8pIHt9O1xyXG4gICAgfSBcclxuICAgIHJldHVybiBOT19MT0NLO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgTk9fTE9DSyA9IFwibm8gbG9ja1wiO1xyXG5leHBvcnQgY29uc3QgaXNOb2xvY2sgPSBpZCA9PiBpZCA9PT0gTk9fTE9DSztcclxuXHJcbmNvbnN0IHNsZWVwRm9yUmV0cnkgPSAoKSA9PlxyXG4gICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGxvY2tPdmVybGFwTWlsbGlzZWNvbmRzKSk7IiwiaW1wb3J0IHtcclxuICAgIGlzVW5kZWZpbmVkLCBpc05hTiwgaXNOdWxsLFxyXG4gICAgcmVkdWNlLCBjb25zdGFudCwgaGVhZCwgaXNFbXB0eSxcclxuICAgIHRhaWwsIGZpbmRJbmRleCwgc3RhcnRzV2l0aCwgam9pbixcclxuICAgIGRyb3BSaWdodCwgZmxvdywgdGFrZVJpZ2h0LCB0cmltLFxyXG4gICAgc3BsaXQsIGluY2x1ZGVzLCByZXBsYWNlLCBpc0FycmF5LFxyXG4gICAgaXNTdHJpbmcsIGlzSW50ZWdlciwgaXNEYXRlLCB0b051bWJlclxyXG59IGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHsgZXZlbnRzIH0gZnJvbSBcIi4vZXZlbnRzXCI7XHJcbmltcG9ydCB7IGFwaVdyYXBwZXIgfSBmcm9tIFwiLi9hcGlXcmFwcGVyXCI7XHJcbmltcG9ydCB7IHNvbWUgfSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRMb2NrLCBOT19MT0NLLFxyXG4gICAgaXNOb2xvY2ssIHJlbGVhc2VMb2NrLCBleHRlbmRMb2NrXHJcbn0gZnJvbSBcIi4vbG9ja1wiO1xyXG5cclxuLy8gdGhpcyBpcyB0aGUgY29tYmluYXRvciBmdW5jdGlvblxyXG5leHBvcnQgY29uc3QgJCQgPSAoLi4uZnVuY3MpID0+IGFyZyA9PlxyXG4gICAgZmxvdyhmdW5jcykoYXJnKVxyXG5cclxuLy8gdGhpcyBpcyB0aGUgcGlwZSBmdW5jdGlvblxyXG5leHBvcnQgY29uc3QgJCA9IChhcmcsIGZ1bmNzKSA9PlxyXG4gICAgJCQoLi4uZnVuY3MpKGFyZylcclxuXHJcbmV4cG9ydCBjb25zdCBrZXlTZXAgPSBcIi9cIjtcclxuY29uc3QgdHJpbUtleVNlcCA9IHN0ciA9PiB0cmltKHN0ciwga2V5U2VwKTtcclxuY29uc3Qgc3BsaXRCeUtleVNlcCA9IHN0ciA9PiBzcGxpdChzdHIsIGtleVNlcCk7XHJcbmV4cG9ydCBjb25zdCBzYWZlS2V5ID0ga2V5ID0+IHJlcGxhY2UoYCR7a2V5U2VwfSR7dHJpbUtleVNlcChrZXkpfWAsIGAke2tleVNlcH0ke2tleVNlcH1gLCBrZXlTZXApO1xyXG5leHBvcnQgY29uc3Qgam9pbktleSA9ICguLi5zdHJzKSA9PiB7XHJcbiAgICBjb25zdCBwYXJhbXNPckFycmF5ID1cclxuICAgICAgICBzdHJzLmxlbmd0aCA9PT0gMSAmIGlzQXJyYXkoc3Ryc1swXSlcclxuICAgICAgICAgICAgPyBzdHJzWzBdIDogc3RycztcclxuICAgIHJldHVybiBzYWZlS2V5KGpvaW4ocGFyYW1zT3JBcnJheSwga2V5U2VwKSk7XHJcbn1cclxuZXhwb3J0IGNvbnN0IHNwbGl0S2V5ID0gJCQodHJpbUtleVNlcCwgc3BsaXRCeUtleVNlcCk7XHJcbmV4cG9ydCBjb25zdCBnZXREaXJGb21LZXkgPSAkJChzcGxpdEtleSwgZHJvcFJpZ2h0LCAocCkgPT4gam9pbktleSguLi5wKSk7XHJcbmV4cG9ydCBjb25zdCBnZXRGaWxlRnJvbUtleSA9ICQkKHNwbGl0S2V5LCB0YWtlUmlnaHQsIGhlYWQpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbmZpZ0ZvbGRlciA9IGtleVNlcCArIFwiLmNvbmZpZ1wiO1xyXG5leHBvcnQgY29uc3QgZmllbGREZWZpbml0aW9ucyA9IGpvaW5LZXkoY29uZmlnRm9sZGVyLCBcImZpZWxkcy5qc29uXCIpO1xyXG5leHBvcnQgY29uc3QgdGVtcGxhdGVEZWZpbml0aW9ucyA9IGpvaW5LZXkoY29uZmlnRm9sZGVyLCBcInRlbXBsYXRlcy5qc29uXCIpO1xyXG5leHBvcnQgY29uc3QgYXBwRGVmaW5pdGlvbkZpbGUgPSBqb2luS2V5KGNvbmZpZ0ZvbGRlciwgXCJhcHBEZWZpbml0aW9uLmpzb25cIik7XHJcbmV4cG9ydCBjb25zdCBkaXJJbmRleCA9IChmb2xkZXJQYXRoKSA9PiBqb2luS2V5KGNvbmZpZ0ZvbGRlciwgXCJkaXJcIiwgLi4uc3BsaXRLZXkoZm9sZGVyUGF0aCksIFwiZGlyLmlkeFwiKTtcclxuZXhwb3J0IGNvbnN0IGdldEluZGV4S2V5RnJvbUZpbGVLZXkgPSAkJChnZXREaXJGb21LZXksIGRpckluZGV4KTtcclxuXHJcbmV4cG9ydCBjb25zdCBpZkV4aXN0cyA9ICh2YWwsIGV4aXN0cywgbm90RXhpc3RzKSA9PlxyXG4gICAgaXNVbmRlZmluZWQodmFsKVxyXG4gICAgICAgID8gaXNVbmRlZmluZWQobm90RXhpc3RzKSA/ICgoKSA9PiB7IH0pKCkgOiBub3RFeGlzdHMoKVxyXG4gICAgICAgIDogZXhpc3RzKCk7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0T3JEZWZhdWx0ID0gKHZhbCwgZGVmYXVsdFZhbCkgPT5cclxuICAgIGlmRXhpc3RzKHZhbCwgKCkgPT4gdmFsLCAoKSA9PiBkZWZhdWx0VmFsKTtcclxuXHJcbmV4cG9ydCBjb25zdCBub3QgPSAoZnVuYykgPT4gKHZhbCkgPT4gIWZ1bmModmFsKTtcclxuZXhwb3J0IGNvbnN0IGlzRGVmaW5lZCA9IG5vdChpc1VuZGVmaW5lZCk7XHJcbmV4cG9ydCBjb25zdCBpc05vbk51bGwgPSBub3QoaXNOdWxsKTtcclxuZXhwb3J0IGNvbnN0IGlzTm90TmFOID0gbm90KGlzTmFOKTtcclxuXHJcbmV4cG9ydCBjb25zdCBhbGxUcnVlID0gKC4uLmZ1bmNBcmdzKSA9PiAodmFsKSA9PlxyXG4gICAgcmVkdWNlKGZ1bmNBcmdzLFxyXG4gICAgICAgIChyZXN1bHQsIGNvbmRpdGlvbkZ1bmMpID0+XHJcbiAgICAgICAgICAgIChpc051bGwocmVzdWx0KSB8fCByZXN1bHQgPT0gdHJ1ZSkgJiYgY29uZGl0aW9uRnVuYyh2YWwpLFxyXG4gICAgICAgIG51bGwpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGFueVRydWUgPSAoLi4uZnVuY0FyZ3MpID0+ICh2YWwpID0+XHJcbiAgICByZWR1Y2UoZnVuY0FyZ3MsXHJcbiAgICAgICAgKHJlc3VsdCwgY29uZGl0aW9uRnVuYykgPT5cclxuICAgICAgICAgICAgcmVzdWx0ID09IHRydWUgfHwgY29uZGl0aW9uRnVuYyh2YWwpLFxyXG4gICAgICAgIG51bGwpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGluc2Vuc2l0aXZlRXF1YWxzID0gKHN0cjEsIHN0cjIpID0+XHJcbiAgICBzdHIxLnRyaW0oKS50b0xvd2VyQ2FzZSgpID09PSBzdHIyLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzU29tZXRoaW5nID0gYWxsVHJ1ZShpc0RlZmluZWQsIGlzTm9uTnVsbCwgaXNOb3ROYU4pO1xyXG5leHBvcnQgY29uc3QgaXNOb3RoaW5nID0gbm90KGlzU29tZXRoaW5nKTtcclxuZXhwb3J0IGNvbnN0IGlzTm90aGluZ09yRW1wdHkgPSB2ID0+IGlzTm90aGluZyh2KSB8fCBpc0VtcHR5KHYpO1xyXG5leHBvcnQgY29uc3Qgc29tZXRoaW5nT3JHZXREZWZhdWx0ID0gZ2V0RGVmYXVsdEZ1bmMgPT4gdmFsID0+XHJcbiAgICBpc1NvbWV0aGluZyh2YWwpID8gdmFsIDogZ2V0RGVmYXVsdEZ1bmMoKTtcclxuZXhwb3J0IGNvbnN0IHNvbWV0aGluZ09yRGVmYXVsdCA9ICh2YWwsIGRlZmF1bHRWYWwpID0+XHJcbiAgICBzb21ldGhpbmdPckdldERlZmF1bHQoY29uc3RhbnQoZGVmYXVsdFZhbCkpKHZhbCk7XHJcblxyXG5leHBvcnQgY29uc3QgbWFwSWZTb21ldGhpbmdPckRlZmF1bHQgPSAobWFwRnVuYywgZGVmYXVsdFZhbCkgPT5cclxuICAgICh2YWwpID0+IGlzU29tZXRoaW5nKHZhbCkgPyBtYXBGdW5jKHZhbCkgOiBkZWZhdWx0VmFsO1xyXG5cclxuZXhwb3J0IGNvbnN0IG1hcElmU29tZXRoaW5nT3JCbGFuayA9IChtYXBGdW5jKSA9PlxyXG4gICAgbWFwSWZTb21ldGhpbmdPckRlZmF1bHQobWFwRnVuYywgXCJcIik7XHJcblxyXG5leHBvcnQgY29uc3Qgbm9uZSA9IHByZWRpY2F0ZSA9PiBjb2xsZWN0aW9uID0+XHJcbiAgICAhc29tZShwcmVkaWNhdGUpKGNvbGxlY3Rpb24pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGFsbCA9IHByZWRpY2F0ZSA9PiBjb2xsZWN0aW9uID0+XHJcbiAgICBub25lKHYgPT4gIXByZWRpY2F0ZSh2KSkoY29sbGVjdGlvbik7XHJcblxyXG5leHBvcnQgY29uc3QgaXNOb3RFbXB0eSA9IG9iID0+ICFpc0VtcHR5KG9iKTtcclxuZXhwb3J0IGNvbnN0IGlzQXN5bmMgPSAoZm4pID0+IGZuLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBc3luY0Z1bmN0aW9uJztcclxuZXhwb3J0IGNvbnN0IGlzTm9uRW1wdHlBcnJheSA9IGFsbFRydWUoaXNBcnJheSwgaXNOb3RFbXB0eSk7XHJcbmV4cG9ydCBjb25zdCBpc05vbkVtcHR5U3RyaW5nID0gYWxsVHJ1ZShpc1N0cmluZywgaXNOb3RFbXB0eSk7XHJcbmV4cG9ydCBjb25zdCB0cnlPciA9IGZhaWxGdW5jID0+IChmdW5jLCAuLi5hcmdzKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIC4uLmFyZ3MpO1xyXG4gICAgfSBjYXRjaCAoXykge1xyXG4gICAgICAgIHJldHVybiBmYWlsRnVuYygpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdHJ5QXdhaXRPciA9IGZhaWxGdW5jID0+IGFzeW5jIChmdW5jLCAuLi5hcmdzKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBmdW5jLmFwcGx5KG51bGwsIC4uLmFyZ3MpO1xyXG4gICAgfSBjYXRjaCAoXykge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBmYWlsRnVuYygpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZGVmaW5lRXJyb3IgPSAoZnVuYywgZXJyb3JQcmVmaXgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmMoKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyb3JQcmVmaXggKyBcIiA6IFwiICsgZXJyLm1lc3NhZ2U7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdHJ5T3JJZ25vcmUgPSB0cnlPcigoKSA9PiB7IH0pO1xyXG5leHBvcnQgY29uc3QgdHJ5QXdhaXRPcklnbm9yZSA9IHRyeUF3YWl0T3IoYXN5bmMgKCkgPT4geyB9KTtcclxuZXhwb3J0IGNvbnN0IGNhdXNlc0V4Y2VwdGlvbiA9IGZ1bmMgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBmdW5jKCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGV4ZWN1dGVzV2l0aG91dEV4Y2VwdGlvbiA9IGZ1bmMgPT5cclxuICAgICFjYXVzZXNFeGNlcHRpb24oZnVuYyk7XHJcblxyXG5leHBvcnQgY29uc3QgaGFuZGxlRXJyb3JXaXRoID0gcmV0dXJuVmFsSW5FcnJvciA9PiB0cnlPcihjb25zdGFudChyZXR1cm5WYWxJbkVycm9yKSk7XHJcblxyXG5leHBvcnQgY29uc3QgaGFuZGxlRXJyb3JXaXRoVW5kZWZpbmVkID0gaGFuZGxlRXJyb3JXaXRoKHVuZGVmaW5lZCk7XHJcblxyXG5leHBvcnQgY29uc3Qgc3dpdGNoQ2FzZSA9ICguLi5jYXNlcykgPT4gKHZhbHVlKSA9PiB7XHJcblxyXG4gICAgY29uc3QgbmV4dENhc2UgPSAoKSA9PiBoZWFkKGNhc2VzKVswXSh2YWx1ZSk7XHJcbiAgICBjb25zdCBuZXh0UmVzdWx0ID0gKCkgPT4gaGVhZChjYXNlcylbMV0odmFsdWUpO1xyXG5cclxuICAgIGlmIChpc0VtcHR5KGNhc2VzKSkgcmV0dXJuOyAvLyB1bmRlZmluZWRcclxuICAgIGlmIChuZXh0Q2FzZSgpID09PSB0cnVlKSByZXR1cm4gbmV4dFJlc3VsdCgpO1xyXG4gICAgcmV0dXJuIHN3aXRjaENhc2UuYXBwbHkobnVsbCwgdGFpbChjYXNlcykpKHZhbHVlKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBpc1ZhbHVlID0gdmFsMSA9PiB2YWwyID0+ICh2YWwxID09PSB2YWwyKTtcclxuZXhwb3J0IGNvbnN0IGlzT25lT2YgPSAoLi4udmFscykgPT4gdmFsID0+IGluY2x1ZGVzKHZhbHMsIHZhbCk7XHJcbmV4cG9ydCBjb25zdCBkZWZhdWx0Q2FzZSA9IGNvbnN0YW50KHRydWUpO1xyXG5leHBvcnQgY29uc3QgbWVtYmVyTWF0Y2hlcyA9IChtZW1iZXIsIG1hdGNoKSA9PiBvYmogPT4gbWF0Y2gob2JqW21lbWJlcl0pO1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBTdGFydHNXaXRoID0gKHNlYXJjaEZvcikgPT4gKHNlYXJjaEluKSA9PlxyXG4gICAgc3RhcnRzV2l0aChzZWFyY2hJbiwgc2VhcmNoRm9yKTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb250YWlucyA9IHZhbCA9PiBhcnJheSA9PiAoZmluZEluZGV4KGFycmF5LCB2ID0+IHYgPT09IHZhbCkgPiAtMSk7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0SGFzaENvZGUgPSBzID0+IHtcclxuICAgIGxldCBoYXNoID0gMCwgaSwgY2hhciwgbDtcclxuICAgIGlmIChzLmxlbmd0aCA9PSAwKSByZXR1cm4gaGFzaDtcclxuICAgIGZvciAoaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGNoYXIgPSBzLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hhcjtcclxuICAgICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnZlcnRpbmcgdG8gc3RyaW5nLCBidXQgZG9udCB3YW50IGEgXCItXCIgcHJlZml4ZWRcclxuICAgIGlmIChoYXNoIDwgMClcclxuICAgICAgICByZXR1cm4gXCJuXCIgKyAoaGFzaCAqIC0xKS50b1N0cmluZygpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBoYXNoLnRvU3RyaW5nKCk7XHJcbn07XHJcblxyXG4vLyB0aGFua3MgdG8gaHR0cHM6Ly9ibG9nLmdyb3NzbWFuLmlvL2hvdy10by13cml0ZS1hc3luYy1hd2FpdC13aXRob3V0LXRyeS1jYXRjaC1ibG9ja3MtaW4tamF2YXNjcmlwdC9cclxuZXhwb3J0IGNvbnN0IGF3RXggPSBhc3luYyBwcm9taXNlID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcclxuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgcmVzdWx0XTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIFtlcnJvciwgdW5kZWZpbmVkXVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgaXNTYWZlSW50ZWdlciA9IG4gPT5cclxuICAgIGlzSW50ZWdlcihuKVxyXG4gICAgJiYgbiA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxyXG4gICAgJiYgbiA+PSAwIC0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcblxyXG5leHBvcnQgY29uc3QgdG9EYXRlT3JOdWxsID0gcyA9PiBpc051bGwocykgPyBudWxsXHJcbiAgICA6IGlzRGF0ZShzKSA/IHMgOiBuZXcgRGF0ZShzKTtcclxuZXhwb3J0IGNvbnN0IHRvQm9vbE9yTnVsbCA9IHMgPT4gaXNOdWxsKHMpID8gbnVsbFxyXG4gICAgOiBzID09PSBcInRydWVcIiB8fCBzID09PSB0cnVlO1xyXG5leHBvcnQgY29uc3QgdG9OdW1iZXJPck51bGwgPSBzID0+IGlzTnVsbChzKSA/IG51bGxcclxuICAgIDogdG9OdW1iZXIocyk7XHJcblxyXG5leHBvcnQgY29uc3QgaXNBcnJheU9mU3RyaW5nID0gb3B0cyA9PlxyXG4gICAgaXNBcnJheShvcHRzKSAmJiBhbGwoaXNTdHJpbmcpKG9wdHMpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhdXNlID0gYXN5bmMgKGR1cmF0aW9uKSA9PiBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIGR1cmF0aW9uKSk7XHJcblxyXG5leHBvcnQgY29uc3QgcmV0cnkgPSBhc3luYyAoZm4sIHJldHJpZXMsIGRlbGF5LCAuLi5hcmdzKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBmbiguLi5hcmdzKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGlmIChyZXRyaWVzID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcGF1c2UoZGVsYXkpLnRoZW4oYXN5bmMgKCkgPT4gYXdhaXQgcmV0cnkoZm4sIChyZXRyaWVzIC0gMSksIGRlbGF5LCAuLi5hcmdzKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCB7IGV2ZW50cyB9IGZyb20gXCIuL2V2ZW50c1wiO1xyXG5leHBvcnQgeyBhcGlXcmFwcGVyLCBhcGlXcmFwcGVyU3luYyB9IGZyb20gXCIuL2FwaVdyYXBwZXJcIjtcclxuZXhwb3J0IHtcclxuICAgIGdldExvY2ssIE5PX0xPQ0ssIHJlbGVhc2VMb2NrLFxyXG4gICAgZXh0ZW5kTG9jaywgaXNOb2xvY2tcclxufSBmcm9tIFwiLi9sb2NrXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBpZkV4aXN0cywgZ2V0T3JEZWZhdWx0LCBpc0RlZmluZWQsXHJcbiAgICBpc05vbk51bGwsIGlzTm90TmFOLCBhbGxUcnVlLCBpc1NvbWV0aGluZyxcclxuICAgIG1hcElmU29tZXRoaW5nT3JEZWZhdWx0LCBtYXBJZlNvbWV0aGluZ09yQmxhbmssXHJcbiAgICBjb25maWdGb2xkZXIsIGZpZWxkRGVmaW5pdGlvbnMsIGlzTm90aGluZywgbm90LFxyXG4gICAgc3dpdGNoQ2FzZSwgZGVmYXVsdENhc2UsIFN0YXJ0c1dpdGgsIGNvbnRhaW5zLFxyXG4gICAgdGVtcGxhdGVEZWZpbml0aW9ucywgaGFuZGxlRXJyb3JXaXRoLFxyXG4gICAgaGFuZGxlRXJyb3JXaXRoVW5kZWZpbmVkLCB0cnlPciwgdHJ5T3JJZ25vcmUsXHJcbiAgICB0cnlBd2FpdE9yLCB0cnlBd2FpdE9ySWdub3JlLCBkaXJJbmRleCwga2V5U2VwLFxyXG4gICAgJCwgJCQsIGdldERpckZvbUtleSwgZ2V0RmlsZUZyb21LZXksIHNwbGl0S2V5LFxyXG4gICAgc29tZXRoaW5nT3JEZWZhdWx0LCBnZXRJbmRleEtleUZyb21GaWxlS2V5LCBqb2luS2V5LFxyXG4gICAgc29tZXRoaW5nT3JHZXREZWZhdWx0LCBhcHBEZWZpbml0aW9uRmlsZSwgaXNWYWx1ZSwgYWxsLFxyXG4gICAgaXNPbmVPZiwgbWVtYmVyTWF0Y2hlcywgZGVmaW5lRXJyb3IsIGFueVRydWUsIGlzTm9uRW1wdHlBcnJheSxcclxuICAgIGNhdXNlc0V4Y2VwdGlvbiwgZXhlY3V0ZXNXaXRob3V0RXhjZXB0aW9uLCBub25lLCBnZXRIYXNoQ29kZSxcclxuICAgIGF3RXgsIGFwaVdyYXBwZXIsIGV2ZW50cywgaXNOb3RoaW5nT3JFbXB0eSwgaXNTYWZlSW50ZWdlcixcclxuICAgIHRvTnVtYmVyLCB0b0RhdGU6IHRvRGF0ZU9yTnVsbCwgdG9Cb29sOiB0b0Jvb2xPck51bGwsXHJcbiAgICBpc0FycmF5T2ZTdHJpbmcsIGdldExvY2ssIE5PX0xPQ0ssIGlzTm9sb2NrLCBpbnNlbnNpdGl2ZUVxdWFscywgcGF1c2UsIHJldHJ5XHJcbn07XHJcblxyXG4iLCJpbXBvcnQgeyQsIGlzU29tZXRoaW5nfSBmcm9tIFwiLi9pbmRleFwiO1xyXG5pbXBvcnQge2ZpbHRlciwgbWFwfSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcblxyXG5leHBvcnQgY29uc3Qgc3RyaW5nTm90RW1wdHkgPSBzID0+IGlzU29tZXRoaW5nKHMpICYmIHMudHJpbSgpLmxlbmd0aCA+IDA7XHJcblxyXG5leHBvcnQgY29uc3QgbWFrZXJ1bGUgPSAoZmllbGQsIGVycm9yLCBpc1ZhbGlkKSA9PiAoe2ZpZWxkLCBlcnJvciwgaXNWYWxpZH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IChydWxlLCBpdGVtKSA9PiAoey4uLnJ1bGUsIGl0ZW19KTtcclxuXHJcbmV4cG9ydCBjb25zdCBhcHBseVJ1bGVTZXQgPSBydWxlU2V0ID0+IGl0ZW1Ub1ZhbGlkYXRlID0+IFxyXG4gICAgJChydWxlU2V0LCBbXHJcbiAgICAgICAgbWFwKGFwcGx5UnVsZShpdGVtVG9WYWxpZGF0ZSkpLFxyXG4gICAgICAgIGZpbHRlcihpc1NvbWV0aGluZylcclxuICAgIF0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGFwcGx5UnVsZSA9IGl0ZW1Ub3ZhbGlkYXRlID0+IHJ1bGUgPT4gXHJcbiAgICBydWxlLmlzVmFsaWQoaXRlbVRvdmFsaWRhdGUpIFxyXG4gICAgPyBudWxsXHJcbiAgICA6IHZhbGlkYXRpb25FcnJvcihydWxlLCBpdGVtVG92YWxpZGF0ZSk7IiwiaW1wb3J0IHtjb21waWxlRXhwcmVzc2lvbiwgY29tcGlsZUNvZGV9IGZyb20gXCJAbngtanMvY29tcGlsZXItdXRpbFwiO1xyXG5pbXBvcnQge2lzVW5kZWZpbmVkLCBrZXlzLCBoYXMsIFxyXG4gICAgICAgIGNsb25lLCBpc0Z1bmN0aW9ufSBmcm9tIFwibG9kYXNoXCI7XHJcbmltcG9ydCB7ZGVmaW5lRXJyb3J9IGZyb20gXCIuLi9jb21tb25cIjtcclxuXHJcbmV4cG9ydCBjb25zdCBmaWx0ZXJFdmFsID0gXCJGSUxURVJfRVZBTFVBVEVcIjtcclxuZXhwb3J0IGNvbnN0IGZpbHRlckNvbXBpbGUgPSBcIkZJTFRFUl9DT01QSUxFXCI7XHJcbmV4cG9ydCBjb25zdCBtYXBFdmFsPSBcIk1BUF9FVkFMVUFURVwiO1xyXG5leHBvcnQgY29uc3QgbWFwQ29tcGlsZSA9IFwiTUFQX0NPTVBJTEVcIjtcclxuZXhwb3J0IGNvbnN0IHJlbW92ZVVuZGVjbGFyZWRGaWVsZHMgPSBcIlJFTU9cXFZFX1VOREVDTEFSRURfRklFTERTXCI7XHJcbmV4cG9ydCBjb25zdCBhZGRVbk1hcHBlZEZpZWxkcyA9IFwiQUREX1VOTUFQUEVEX0ZJRUxEU1wiO1xyXG5leHBvcnQgY29uc3QgYWRkVGhlS2V5ID0gXCJBRERfS0VZXCI7XHJcblxyXG5cclxuY29uc3QgZ2V0RXZhbHVhdGVSZXN1bHQgPSAoKSA9PiAgKHtcclxuICAgIGlzRXJyb3I6IGZhbHNlLFxyXG4gICAgcGFzc2VkRmlsdGVyOiB0cnVlLFxyXG4gICAgcmVzdWx0OiBudWxsXHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbXBpbGVGaWx0ZXIgPSBpbmRleCA9PiBcclxuICAgIGNvbXBpbGVFeHByZXNzaW9uKGluZGV4LmZpbHRlcik7XHJcblxyXG5leHBvcnQgY29uc3QgY29tcGlsZU1hcCA9IGluZGV4ID0+IFxyXG4gICAgY29tcGlsZUNvZGUoaW5kZXgubWFwKTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXNzZXNGaWx0ZXIgPSAocmVjb3JkLCBpbmRleCkgPT4ge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHtyZWNvcmR9O1xyXG4gICAgaWYoIWluZGV4LmZpbHRlcikgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgY29uc3QgY29tcGlsZWRGaWx0ZXIgPSBkZWZpbmVFcnJvcihcclxuICAgICAgICAoKSA9PiBjb21waWxlRmlsdGVyKGluZGV4KSxcclxuICAgICAgICBmaWx0ZXJDb21waWxlKVxyXG5cclxuICAgIHJldHVybiBkZWZpbmVFcnJvcihcclxuICAgICAgICAgICAgKCkgPT4gY29tcGlsZWRGaWx0ZXIoY29udGV4dCksXHJcbiAgICAgICAgICAgIGZpbHRlckV2YWwpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG1hcFJlY29yZCA9IChyZWNvcmQsIGluZGV4KSA9PiB7XHJcbiAgICBjb25zdCByZWNvcmRDbG9uZSA9IGNsb25lKHJlY29yZCk7XHJcbiAgICBjb25zdCBjb250ZXh0ID0ge3JlY29yZDpyZWNvcmRDbG9uZX07XHJcblxyXG4gICAgY29uc3QgbWFwID0gaW5kZXgubWFwID8gaW5kZXgubWFwIDogXCJyZXR1cm4gey4uLnJlY29yZH07XCI7XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbXBpbGVkTWFwID0gZGVmaW5lRXJyb3IoXHJcbiAgICAgICAgKCkgPT4gY29tcGlsZUNvZGUobWFwKSxcclxuICAgICAgICBtYXBDb21waWxlKTtcclxuXHJcbiAgICBjb25zdCBtYXBwZWQgPSBkZWZpbmVFcnJvcihcclxuICAgICAgICAoKSA9PiBjb21waWxlZE1hcChjb250ZXh0KSxcclxuICAgICAgICBtYXBFdmFsKTsgICAgXHJcblxyXG4gICAgY29uc3QgbWFwcGVkS2V5cyA9IGtleXMobWFwcGVkKTtcclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBtYXBwZWRLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbWFwcGVkS2V5c1tpXTtcclxuICAgICAgICBtYXBwZWRba2V5XSA9IGlzVW5kZWZpbmVkKG1hcHBlZFtrZXldKSA/IG51bGwgOiBtYXBwZWRba2V5XTtcclxuICAgICAgICBpZihpc0Z1bmN0aW9uKG1hcHBlZFtrZXldKSkge1xyXG4gICAgICAgICAgICBkZWxldGUgbWFwcGVkW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG1hcHBlZC5rZXkgPSByZWNvcmQua2V5O1xyXG4gICAgbWFwcGVkLnNvcnRLZXkgPSBpbmRleC5nZXRTb3J0S2V5IFxyXG4gICAgICAgICAgICAgICAgICAgICA/IGNvbXBpbGVDb2RlKGluZGV4LmdldFNvcnRLZXkpKGNvbnRleHQpIFxyXG4gICAgICAgICAgICAgICAgICAgICA6IHJlY29yZC5pZDtcclxuXHJcbiAgICByZXR1cm4gbWFwcGVkO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGV2YWx1YXRlID0gcmVjb3JkID0+IGluZGV4ID0+IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGdldEV2YWx1YXRlUmVzdWx0KCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXN1bHQucGFzc2VkRmlsdGVyID0gcGFzc2VzRmlsdGVyKHJlY29yZCwgaW5kZXgpO1xyXG4gICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICByZXN1bHQuaXNFcnJvciA9IHRydWU7XHJcbiAgICAgICAgcmVzdWx0LnBhc3NlZEZpbHRlciA9IGZhbHNlO1xyXG4gICAgICAgIHJlc3VsdC5yZXN1bHQgPSBlcnIubWVzc2FnZTtcclxuICAgIH1cclxuXHJcbiAgICBpZighcmVzdWx0LnBhc3NlZEZpbHRlcikgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlc3VsdC5yZXN1bHQgPSBtYXBSZWNvcmQocmVjb3JkLCBpbmRleCk7XHJcbiAgICB9IGNhdGNoKGVycikge1xyXG4gICAgICAgIHJlc3VsdC5pc0Vycm9yID0gdHJ1ZTtcclxuICAgICAgICByZXN1bHQucmVzdWx0ID0gZXJyLm1lc3NhZ2U7XHJcbiAgICB9ICAgXHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBldmFsdWF0ZTsiLCJpbXBvcnQge2FwcGx5UnVsZVNldCwgbWFrZXJ1bGV9IGZyb20gXCIuLi9jb21tb24vdmFsaWRhdGlvbkNvbW1vblwiO1xyXG5pbXBvcnQge2NvbXBpbGVGaWx0ZXIsIGNvbXBpbGVNYXB9IGZyb20gXCIuLi9pbmRleGluZy9ldmFsdWF0ZVwiO1xyXG5pbXBvcnQge2lzRW1wdHksIGNvdW50QnksIGZsYXR0ZW4sIGluY2x1ZGVzfSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcbmltcG9ydCB7am9pbiwga2V5c30gZnJvbSBcImxvZGFzaFwiO1xyXG5pbXBvcnQge2lzTm9uRW1wdHlTdHJpbmcsIGV4ZWN1dGVzV2l0aG91dEV4Y2VwdGlvbiwgJH0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge2lzUmVjb3JkfSBmcm9tIFwiLi9oZWlyYXJjaHlcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBpbmRleFR5cGVzID0geyByZWZlcmVuY2U6IFwicmVmZXJlbmNlXCIsIGFuY2VzdG9yOiBcImFuY2VzdG9yXCIgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBpbmRleFJ1bGVTZXQgPSBbXHJcbiAgICBtYWtlcnVsZShcIm1hcFwiLCBcImluZGV4IGhhcyBubyBtYXAgZnVuY3Rpb25cIixcclxuICAgICAgICBpbmRleCA9PiBpc05vbkVtcHR5U3RyaW5nKGluZGV4Lm1hcCkpLFxyXG4gICAgbWFrZXJ1bGUoXCJtYXBcIiwgXCJpbmRleCdzIG1hcCBmdW5jdGlvbiBkb2VzIG5vdCBjb21waWxlXCIsXHJcbiAgICAgICAgaW5kZXggPT4gIWlzTm9uRW1wdHlTdHJpbmcoaW5kZXgubWFwKVxyXG4gICAgICAgICAgICAgICAgfHwgZXhlY3V0ZXNXaXRob3V0RXhjZXB0aW9uKCgpID0+IGNvbXBpbGVNYXAoaW5kZXgpKSksXHJcbiAgICBtYWtlcnVsZShcImZpbHRlclwiLCBcImluZGV4J3MgZmlsdGVyIGZ1bmN0aW9uIGRvZXMgbm90IGNvbXBpbGVcIixcclxuICAgICAgICBpbmRleCA9PiAhaXNOb25FbXB0eVN0cmluZyhpbmRleC5maWx0ZXIpXHJcbiAgICAgICAgICAgICAgICB8fCAgZXhlY3V0ZXNXaXRob3V0RXhjZXB0aW9uKCgpID0+IGNvbXBpbGVGaWx0ZXIoaW5kZXgpKSksXHJcbiAgICBtYWtlcnVsZShcIm5hbWVcIiwgXCJtdXN0IGRlY2xhcmUgYSBuYW1lIGZvciBpbmRleFwiLFxyXG4gICAgICAgIGluZGV4ID0+IGlzTm9uRW1wdHlTdHJpbmcoaW5kZXgubmFtZSkpLFxyXG4gICAgbWFrZXJ1bGUoXCJuYW1lXCIsIFwidGhlcmUgaXMgYSBkdXBsaWNhdGUgbmFtZWQgaW5kZXggb24gdGhpcyBub2RlXCIsXHJcbiAgICAgICAgaW5kZXggPT4gaXNFbXB0eShpbmRleC5uYW1lKSAgXHJcbiAgICAgICAgICAgICAgICB8fCBjb3VudEJ5KCduYW1lJylcclxuICAgICAgICAgICAgICAgICAgIChpbmRleC5wYXJlbnQoKS5pbmRleGVzKVtpbmRleC5uYW1lXSA9PT0gMSkgLFxyXG4gICAgbWFrZXJ1bGUoXCJpbmRleFR5cGVcIiwgYHJlZmVyZW5jZSBpbmRleCBtYXkgb25seSBleGlzdCBvbiBhIHJlY29yZCBub2RlYCxcclxuICAgICAgICBpbmRleCA9PiAgaXNSZWNvcmQoaW5kZXgucGFyZW50KCkpIFxyXG4gICAgICAgICAgICAgICAgICB8fCBpbmRleC5pbmRleFR5cGUgIT09IGluZGV4VHlwZXMucmVmZXJlbmNlKSxcclxuICAgIG1ha2VydWxlKFwiaW5kZXhUeXBlXCIsIGBpbmRleCB0eXBlIG11c3QgYmUgb25lIG9mOiAke2pvaW4oXCIsIFwiLCBrZXlzKGluZGV4VHlwZXMpKX1gLFxyXG4gICAgICAgIGluZGV4ID0+ICBpbmNsdWRlcyhpbmRleC5pbmRleFR5cGUpKGtleXMoaW5kZXhUeXBlcykpKVxyXG5dO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5kZXggPSAoaW5kZXgsIGFsbFJlZmVyZW5jZUluZGV4ZXNPbk5vZGUpID0+IFxyXG4gICAgYXBwbHlSdWxlU2V0KGluZGV4UnVsZVNldChhbGxSZWZlcmVuY2VJbmRleGVzT25Ob2RlKSlcclxuICAgICAgICAgICAgICAgIChpbmRleCk7XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVBbGxJbmRleGVzID0gKG5vZGUpID0+IFxyXG4gICAgJChub2RlLmluZGV4ZXMsIFtcclxuICAgICAgICBtYXAoaSA9PiB2YWxpZGF0ZUluZGV4KGksIG5vZGUuaW5kZXhlcykpLFxyXG4gICAgICAgIGZsYXR0ZW5cclxuICAgIF0pOyIsImltcG9ydCB7ZmluZCwgY29uc3RhbnQsIG1hcCwgbGFzdCwgXG4gICAgZmlyc3QsIHNwbGl0LCBpbnRlcnNlY3Rpb24sdGFrZSwgXG4gICAgdW5pb24sIGluY2x1ZGVzLCBmaWx0ZXIsIHNvbWV9IGZyb20gXCJsb2Rhc2gvZnBcIjtcbmltcG9ydCB7JCwgc3dpdGNoQ2FzZSwgaXNOb3RoaW5nLCBpc1NvbWV0aGluZyxcbiAgICBkZWZhdWx0Q2FzZSwgc3BsaXRLZXksIGlzTm9uRW1wdHlTdHJpbmcsXG4gICAgam9pbktleSwgZ2V0SGFzaENvZGV9IGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7IGluZGV4VHlwZXMgfSBmcm9tIFwiLi9pbmRleGVzXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRGbGF0dGVuZWRIaWVyYXJjaHkgPSAoYXBwSGVpcmFyY2h5LCB1c2VDYWNoZWQ9dHJ1ZSkgPT4ge1xuXG4gICAgaWYoaXNTb21ldGhpbmcoYXBwSGVpcmFyY2h5LmdldEZsYXR0ZW5lZEhlaXJhcmNoeSkgJiYgdXNlQ2FjaGVkKVxuICAgICAgICByZXR1cm4gYXBwSGVpcmFyY2h5LmdldEZsYXR0ZW5lZEhlaXJhcmNoeSgpO1xuXG4gICAgY29uc3QgZmxhdHRlbkhlaXJhcmNoeSA9IChjdXJyZW50Tm9kZSwgZmxhdHRlbmVkKSA9PiB7XG4gICAgICAgIGZsYXR0ZW5lZC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgaWYoKCFjdXJyZW50Tm9kZS5jaGlsZHJlbiBcbiAgICAgICAgICAgIHx8IGN1cnJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICYmIFxuICAgICAgICAgICAgKCFjdXJyZW50Tm9kZS5pbmRleGVzXG4gICAgICAgICAgICB8fCBjdXJyZW50Tm9kZS5pbmRleGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICYmIFxuICAgICAgICAgICAgKCFjdXJyZW50Tm9kZS5hZ2dyZWdhdGVHcm91cHNcbiAgICAgICAgICAgIHx8IGN1cnJlbnROb2RlLmFnZ3JlZ2F0ZUdyb3Vwcy5sZW5ndGggPT09IDApKXtcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1bmlvbklmQW55ID0gbDIgPT4gbDEgPT5cbiAgICAgICAgICAgIHVuaW9uKGwxKSghbDIgPyBbXSA6IGwyKTtcblxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9ICQoW10sIFtcbiAgICAgICAgICAgIHVuaW9uSWZBbnkoY3VycmVudE5vZGUuY2hpbGRyZW4pLFxuICAgICAgICAgICAgdW5pb25JZkFueShjdXJyZW50Tm9kZS5pbmRleGVzKSxcbiAgICAgICAgICAgIHVuaW9uSWZBbnkoY3VycmVudE5vZGUuYWdncmVnYXRlR3JvdXBzKVxuICAgICAgICBdKTtcblxuICAgICAgICBmb3IobGV0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmbGF0dGVuSGVpcmFyY2h5KGNoaWxkLCBmbGF0dGVuZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuZWQ7XG4gICAgfTtcblxuICAgIGFwcEhlaXJhcmNoeS5nZXRGbGF0dGVuZWRIZWlyYXJjaHkgPSAoKSA9PiBmbGF0dGVuSGVpcmFyY2h5KGFwcEhlaXJhcmNoeSwgW10pO1xuICAgIHJldHVybiBhcHBIZWlyYXJjaHkuZ2V0RmxhdHRlbmVkSGVpcmFyY2h5KCk7XG5cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRMYXN0UGFydEluS2V5ID0ga2V5ID0+IFxuICAgIGxhc3Qoc3BsaXRLZXkoa2V5KSk7XG5cbmV4cG9ydCBjb25zdCBnZXROb2Rlc0luUGF0aCA9IGFwcEhlaXJhcmNoeSA9PiBrZXkgPT4gXG4gICAgJChhcHBIZWlyYXJjaHksIFtcbiAgICAgICAgZ2V0RmxhdHRlbmVkSGllcmFyY2h5LFxuICAgICAgICBmaWx0ZXIobiA9PiBuZXcgUmVnRXhwKGAke24ucGF0aFJlZ3goKX1gKS50ZXN0KGtleSkpXG4gICAgXSk7XG5cbmV4cG9ydCBjb25zdCBnZXRFeGFjdE5vZGVGb3JQYXRoID0gYXBwSGVpcmFyY2h5ID0+IGtleSA9PiBcbiAgICAkKGFwcEhlaXJhcmNoeSwgW1xuICAgICAgICBnZXRGbGF0dGVuZWRIaWVyYXJjaHksXG4gICAgICAgIGZpbmQobiA9PiBuZXcgUmVnRXhwKGAke24ucGF0aFJlZ3goKX0kYCkudGVzdChrZXkpKVxuICAgIF0pO1xuXG5leHBvcnQgY29uc3QgZ2V0Tm9kZUZvckNvbGxlY3Rpb25QYXRoID0gYXBwSGVpcmFyY2h5ID0+IGNvbGxlY3Rpb25LZXkgPT4gXG4gICAgJChhcHBIZWlyYXJjaHksIFtcbiAgICAgICAgZ2V0RmxhdHRlbmVkSGllcmFyY2h5LFxuICAgICAgICBmaW5kKG4gPT4gKGlzQ29sbGVjdGlvblJlY29yZChuKSBcbiAgICAgICAgICAgICAgICAgICAmJiBuZXcgUmVnRXhwKGAke24uY29sbGVjdGlvblBhdGhSZWd4KCl9JGApLnRlc3QoY29sbGVjdGlvbktleSkpKVxuICAgIF0pO1xuXG5leHBvcnQgY29uc3QgaGFzTWF0Y2hpbmdBbmNlc3RvciA9IGFuY2VzdG9yUHJlZGljYXRlID0+IGRlY2VuZGFudE5vZGUgPT5cbiAgICBzd2l0Y2hDYXNlKFxuICAgICAgICBcbiAgICAgICAgW25vZGUgPT4gaXNOb3RoaW5nKG5vZGUucGFyZW50KCkpLCBcbiAgICAgICAgY29uc3RhbnQoZmFsc2UpXSxcblxuICAgICAgICBbbm9kZSA9PiBhbmNlc3RvclByZWRpY2F0ZShub2RlLnBhcmVudCgpKSwgXG4gICAgICAgIGNvbnN0YW50KHRydWUpXSxcblxuICAgICAgICBbZGVmYXVsdENhc2UsIFxuICAgICAgICBub2RlID0+IGhhc01hdGNoaW5nQW5jZXN0b3IoYW5jZXN0b3JQcmVkaWNhdGUpKG5vZGUucGFyZW50KCkpXVxuXG4gICAgKShkZWNlbmRhbnROb2RlKTtcblxuZXhwb3J0IGNvbnN0IGdldE5vZGUgPSAoYXBwSGVpcmFyY2h5LCBub2RlS2V5KSA9PiBcbiAgICAkKGFwcEhlaXJhcmNoeSwgW1xuICAgICAgICBnZXRGbGF0dGVuZWRIaWVyYXJjaHksXG4gICAgICAgIGZpbmQobiA9PiBuLm5vZGVLZXkoKSA9PT0gbm9kZUtleVxuICAgICAgICAgICAgICAgICAgfHwgKGlzQ29sbGVjdGlvblJlY29yZChuKVxuICAgICAgICAgICAgICAgICAgICAgICYmIG4uY29sbGVjdGlvbk5vZGVLZXkoKSA9PT0gbm9kZUtleSkpXG4gICAgXSk7XG5cbmV4cG9ydCBjb25zdCBnZXRDb2xsZWN0aW9uTm9kZSA9IChhcHBIZWlyYXJjaHksIG5vZGVLZXkpID0+IFxuICAgICQoYXBwSGVpcmFyY2h5LCBbXG4gICAgICAgIGdldEZsYXR0ZW5lZEhpZXJhcmNoeSxcbiAgICAgICAgZmluZChuID0+IChpc0NvbGxlY3Rpb25SZWNvcmQobilcbiAgICAgICAgICAgICAgICAgICAgJiYgbi5jb2xsZWN0aW9uTm9kZUtleSgpID09PSBub2RlS2V5KSlcbiAgICBdKTtcblxuZXhwb3J0IGNvbnN0IGdldE5vZGVCeUtleU9yTm9kZUtleSA9IChhcHBIZWlyYXJjaHksIGtleU9yTm9kZUtleSkgPT4ge1xuICAgIGNvbnN0IG5vZGVCeUtleSA9IGdldEV4YWN0Tm9kZUZvclBhdGgoYXBwSGVpcmFyY2h5KShrZXlPck5vZGVLZXkpO1xuICAgIHJldHVybiBpc05vdGhpbmcobm9kZUJ5S2V5KVxuICAgICAgICAgICA/IGdldE5vZGUoYXBwSGVpcmFyY2h5LCBrZXlPck5vZGVLZXkpXG4gICAgICAgICAgIDogbm9kZUJ5S2V5O1xufVxuXG5leHBvcnQgY29uc3QgZ2V0Q29sbGVjdGlvbk5vZGVCeUtleU9yTm9kZUtleSA9IChhcHBIZWlyYXJjaHksIGtleU9yTm9kZUtleSkgPT4ge1xuICAgIGNvbnN0IG5vZGVCeUtleSA9IGdldE5vZGVGb3JDb2xsZWN0aW9uUGF0aChhcHBIZWlyYXJjaHkpKGtleU9yTm9kZUtleSk7XG4gICAgcmV0dXJuIGlzTm90aGluZyhub2RlQnlLZXkpXG4gICAgICAgICAgID8gZ2V0Q29sbGVjdGlvbk5vZGUoYXBwSGVpcmFyY2h5LCBrZXlPck5vZGVLZXkpXG4gICAgICAgICAgIDogbm9kZUJ5S2V5O1xufVxuXG5cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAoYXBwSGVpcmFyY2h5LCBrZXkpID0+IFxuICAgIGlzU29tZXRoaW5nKGdldEV4YWN0Tm9kZUZvclBhdGgoYXBwSGVpcmFyY2h5KShrZXkpKVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0dWFsS2V5T2ZQYXJlbnQgPSAocGFyZW50Tm9kZUtleSwgYWN0dWFsQ2hpbGRLZXkpID0+IFxuICAgICQoYWN0dWFsQ2hpbGRLZXksIFtcbiAgICAgICAgc3BsaXRLZXksXG4gICAgICAgIHRha2Uoc3BsaXRLZXkocGFyZW50Tm9kZUtleSkubGVuZ3RoKSxcbiAgICAgICAga3MgPT4gam9pbktleSguLi5rcylcbiAgICBdKTtcblxuZXhwb3J0IGNvbnN0IGdldFBhcmVudEtleSA9IGtleSA9PiB7XG4gICAgY29uc3Qgc3BsaXQgPSBzcGxpdEtleShrZXkpO1xuICAgIGNvbnN0IHRha2VuID0gdGFrZShzcGxpdEtleShrZXkpLmxlbmd0aCAtIDEpKHNwbGl0KTtcbiAgICBjb25zdCBqb2luZWQgPSBqb2luS2V5KC4uLnRha2VuKTtcbiAgICByZXR1cm4gJChrZXksIFtcbiAgICAgICAgc3BsaXRLZXksXG4gICAgICAgIHRha2Uoc3BsaXRLZXkoa2V5KS5sZW5ndGggLSAxKSxcbiAgICAgICAgam9pbktleVxuICAgIF0pO1xufVxuXG5leHBvcnQgY29uc3QgaXNLZXlBbmNlc3Rvck9mID0gYW5jZXN0b3JLZXkgPT4gZGVjZW5kYW50Tm9kZSA9PlxuICAgIGhhc01hdGNoaW5nQW5jZXN0b3IocCA9PiBwLm5vZGVLZXkoKSA9PT0gYW5jZXN0b3JLZXkpKGRlY2VuZGFudE5vZGUpO1xuXG5leHBvcnQgY29uc3QgaGFzTm9NYXRjaGluZ0FuY2VzdG9ycyA9IHBhcmVudFByZWRpY2F0ZSA9PiBub2RlID0+IFxuICAgICFoYXNNYXRjaGluZ0FuY2VzdG9yKHBhcmVudFByZWRpY2F0ZSkobm9kZSk7XG4gICAgXG5leHBvcnQgY29uc3QgZmluZEZpZWxkID0gKHJlY29yZE5vZGUsIGZpZWxkTmFtZSkgPT4gXG4gICAgZmluZChmID0+IGYubmFtZSA9PSBmaWVsZE5hbWUpKHJlY29yZE5vZGUuZmllbGRzKTtcblxuZXhwb3J0IGNvbnN0IGlzQW5jZXN0b3IgPSBkZWNlbmRhbnQgPT4gYW5jZXN0b3IgPT5cbiAgICBpc0tleUFuY2VzdG9yT2YoYW5jZXN0b3Iubm9kZUtleSgpKShkZWNlbmRhbnQpO1xuICAgIFxuZXhwb3J0IGNvbnN0IGlzRGVjZW5kYW50ID0gYW5jZXN0b3IgPT4gZGVjZW5kYW50ID0+XG4gICAgaXNBbmNlc3RvcihkZWNlbmRhbnQpKGFuY2VzdG9yKTtcblxuZXhwb3J0IGNvbnN0IGdldFJlY29yZE5vZGVJZCA9IHJlY29yZEtleSA9PlxuICAgICQocmVjb3JkS2V5LCBbXG4gICAgICAgIHNwbGl0S2V5LFxuICAgICAgICBsYXN0LFxuICAgICAgICBnZXRSZWNvcmROb2RlSWRGcm9tSWRcbiAgICBdKTtcblxuZXhwb3J0IGNvbnN0IGdldFJlY29yZE5vZGVJZEZyb21JZCA9IHJlY29yZElkID0+XG4gICAgJChyZWNvcmRJZCwgW3NwbGl0KFwiLVwiKSwgZmlyc3QsIHBhcnNlSW50XSlcblxuZXhwb3J0IGNvbnN0IGdldFJlY29yZE5vZGVCeUlkID0gKGhlaXJhcmNoeSwgcmVjb3JkSWQpID0+IFxuICAgICQoaGVpcmFyY2h5LCBbXG4gICAgICAgIGdldEZsYXR0ZW5lZEhpZXJhcmNoeSxcbiAgICAgICAgZmluZChuID0+IGlzUmVjb3JkKG4pIFxuICAgICAgICAgICAgICAgICAgICAmJiBuLm5vZGVJZCA9PT0gZ2V0UmVjb3JkTm9kZUlkRnJvbUlkKHJlY29yZElkKSlcbiAgICBdKTtcblxuZXhwb3J0IGNvbnN0IHJlY29yZE5vZGVJZElzQWxsb3dlZCA9IChpbmRleE5vZGUpID0+IChub2RlSWQpID0+XG4gICAgaW5kZXhOb2RlLmFsbG93ZWRSZWNvcmROb2RlSWRzLmxlbmd0aCA9PT0gMFxuICAgIHx8IGluY2x1ZGVzKG5vZGVJZCkoaW5kZXhOb2RlLmFsbG93ZWRSZWNvcmROb2RlSWRzKTtcblxuZXhwb3J0IGNvbnN0IHJlY29yZE5vZGVJc0FsbG93ZWQgPSAoaW5kZXhOb2RlKSA9PiAocmVjb3JkTm9kZSkgPT5cbiAgICByZWNvcmROb2RlSWRJc0FsbG93ZWQoaW5kZXhOb2RlKShyZWNvcmROb2RlLm5vZGVJZCk7XG5cbmV4cG9ydCBjb25zdCBnZXRBbGxvd2VkUmVjb3JkTm9kZXNGb3JJbmRleCA9IChhcHBIZWlyYXJjaHksIGluZGV4Tm9kZSkgPT4ge1xuICAgIGNvbnN0IHJlY29yZE5vZGVzID0gJChhcHBIZWlyYXJjaHksIFtcbiAgICAgICAgZ2V0RmxhdHRlbmVkSGllcmFyY2h5LFxuICAgICAgICBmaWx0ZXIoaXNSZWNvcmQpXG4gICAgXSk7XG5cblxuICAgIGlmKGlzR2xvYmFsSW5kZXgoaW5kZXhOb2RlKSkge1xuICAgICAgICByZXR1cm4gJChyZWNvcmROb2RlcywgW1xuICAgICAgICAgICAgZmlsdGVyKHJlY29yZE5vZGVJc0FsbG93ZWQoaW5kZXhOb2RlKSlcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgaWYoaXNBbmNlc3RvckluZGV4KGluZGV4Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuICQocmVjb3JkTm9kZXMsIFtcbiAgICAgICAgICAgIGZpbHRlcihpc0RlY2VuZGFudChpbmRleE5vZGUucGFyZW50KCkpKSxcbiAgICAgICAgICAgIGZpbHRlcihyZWNvcmROb2RlSXNBbGxvd2VkKGluZGV4Tm9kZSkpXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIGlmKGlzUmVmZXJlbmNlSW5kZXgoaW5kZXhOb2RlKSkge1xuICAgICAgICByZXR1cm4gJChyZWNvcmROb2RlcywgW1xuICAgICAgICAgICAgZmlsdGVyKG4gPT4gc29tZShmaWVsZFJldmVyc2VzUmVmZXJlbmNlVG9JbmRleChpbmRleE5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG4uZmllbGRzKSlcbiAgICAgICAgXSk7XG4gICAgfVxuXG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Tm9kZUZyb21Ob2RlS2V5SGFzaCA9IGhlaXJhcmNoeSA9PiBoYXNoID0+XG4gICAgJChoZWlyYXJjaHksIFtcbiAgICAgICAgZ2V0RmxhdHRlbmVkSGllcmFyY2h5LFxuICAgICAgICBmaW5kKG4gPT4gZ2V0SGFzaENvZGUobi5ub2RlS2V5KCkpID09PSBoYXNoKVxuICAgIF0pO1xuICAgIFxuZXhwb3J0IGNvbnN0IGlzUmVjb3JkID0gbm9kZSA9PiBpc1NvbWV0aGluZyhub2RlKSAmJiBub2RlLnR5cGUgPT09IFwicmVjb3JkXCI7XG5leHBvcnQgY29uc3QgaXNTaW5nbGVSZWNvcmQgPSBub2RlID0+IGlzUmVjb3JkKG5vZGUpICYmIG5vZGUuaXNTaW5nbGU7XG5leHBvcnQgY29uc3QgaXNDb2xsZWN0aW9uUmVjb3JkID0gbm9kZSA9PiBpc1JlY29yZChub2RlKSAmJiAhbm9kZS5pc1NpbmdsZTtcbmV4cG9ydCBjb25zdCBpc0luZGV4ID0gbm9kZSA9PiBpc1NvbWV0aGluZyhub2RlKSAmJiBub2RlLnR5cGUgPT09IFwiaW5kZXhcIjtcbmV4cG9ydCBjb25zdCBpc2FnZ3JlZ2F0ZUdyb3VwID0gbm9kZSA9PiBpc1NvbWV0aGluZyhub2RlKSAmJiBub2RlLnR5cGUgPT09IFwiYWdncmVnYXRlR3JvdXBcIlxuZXhwb3J0IGNvbnN0IGlzU2hhcmRlZEluZGV4ID0gbm9kZSA9PiBpc0luZGV4KG5vZGUpICYmIGlzTm9uRW1wdHlTdHJpbmcobm9kZS5nZXRTaGFyZE5hbWUpO1xuZXhwb3J0IGNvbnN0IGlzUm9vdCA9IG5vZGUgPT4gaXNTb21ldGhpbmcobm9kZSkgJiYgbm9kZS5pc1Jvb3QoKTtcbmV4cG9ydCBjb25zdCBpc0RlY2VuZGFudE9mQVJlY29yZCA9IGhhc01hdGNoaW5nQW5jZXN0b3IoaXNSZWNvcmQpXG5leHBvcnQgY29uc3QgaXNHbG9iYWxJbmRleCA9IG5vZGUgPT4gXG4gICAgaXNJbmRleChub2RlKSAmJiBpc1Jvb3Qobm9kZS5wYXJlbnQoKSk7IFxuZXhwb3J0IGNvbnN0IGlzUmVmZXJlbmNlSW5kZXggPSBub2RlID0+XG4gICAgaXNJbmRleChub2RlKSAmJiBub2RlLmluZGV4VHlwZSA9PT0gaW5kZXhUeXBlcy5yZWZlcmVuY2U7XG5leHBvcnQgY29uc3QgaXNBbmNlc3RvckluZGV4ID0gbm9kZSA9PiBcbiAgICBpc0luZGV4KG5vZGUpICYmIG5vZGUuaW5kZXhUeXBlID09PSBpbmRleFR5cGVzLmFuY2VzdG9yO1xuXG5leHBvcnQgY29uc3QgZmllbGRSZXZlcnNlc1JlZmVyZW5jZVRvTm9kZSA9IG5vZGUgPT4gZmllbGQgPT4gXG4gICAgZmllbGQudHlwZSA9PT0gXCJyZWZlcmVuY2VcIlxuICAgICYmIGludGVyc2VjdGlvbihmaWVsZC50eXBlT3B0aW9ucy5yZXZlcnNlSW5kZXhOb2RlS2V5cylcbiAgICAgICAgICAgICAgICAgICAobWFwKGkgPT4gaS5ub2RlS2V5KCkpKG5vZGUuaW5kZXhlcykpXG4gICAgICAgICAgICAgICAgICAgLmxlbmd0aCA+IDA7XG5cbmV4cG9ydCBjb25zdCBmaWVsZFJldmVyc2VzUmVmZXJlbmNlVG9JbmRleCA9IGluZGV4Tm9kZSA9PiBmaWVsZCA9PiBcbiAgICBmaWVsZC50eXBlID09PSBcInJlZmVyZW5jZVwiXG4gICAgJiYgaW50ZXJzZWN0aW9uKGZpZWxkLnR5cGVPcHRpb25zLnJldmVyc2VJbmRleE5vZGVLZXlzKVxuICAgICAgICAoW2luZGV4Tm9kZS5ub2RlS2V5KCldKVxuICAgICAgICAubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIFxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGdldExhc3RQYXJ0SW5LZXksIGdldE5vZGVzSW5QYXRoLCBnZXRFeGFjdE5vZGVGb3JQYXRoLCBcbiAgICBoYXNNYXRjaGluZ0FuY2VzdG9yLCBnZXROb2RlLCBnZXROb2RlQnlLZXlPck5vZGVLZXksIGlzTm9kZSxcbiAgICBnZXRBY3R1YWxLZXlPZlBhcmVudCwgZ2V0UGFyZW50S2V5LCBpc0tleUFuY2VzdG9yT2YsIGhhc05vTWF0Y2hpbmdBbmNlc3RvcnMsXG4gICAgZmluZEZpZWxkLCBpc0FuY2VzdG9yLCBpc0RlY2VuZGFudCwgZ2V0UmVjb3JkTm9kZUlkLCBnZXRSZWNvcmROb2RlSWRGcm9tSWQsXG4gICAgZ2V0UmVjb3JkTm9kZUJ5SWQsIHJlY29yZE5vZGVJZElzQWxsb3dlZCwgcmVjb3JkTm9kZUlzQWxsb3dlZCwgXG4gICAgZ2V0QWxsb3dlZFJlY29yZE5vZGVzRm9ySW5kZXgsIGdldE5vZGVGcm9tTm9kZUtleUhhc2gsIGlzUmVjb3JkLFxuICAgIGlzQ29sbGVjdGlvblJlY29yZCwgaXNJbmRleCwgaXNhZ2dyZWdhdGVHcm91cCwgaXNTaGFyZGVkSW5kZXgsIGlzUm9vdCxcbiAgICBpc0RlY2VuZGFudE9mQVJlY29yZCwgaXNHbG9iYWxJbmRleCwgaXNSZWZlcmVuY2VJbmRleCwgaXNBbmNlc3RvckluZGV4LFxuICAgIGZpZWxkUmV2ZXJzZXNSZWZlcmVuY2VUb05vZGUsIGZpZWxkUmV2ZXJzZXNSZWZlcmVuY2VUb0luZGV4LFxuICAgIGdldEZsYXR0ZW5lZEhpZXJhcmNoeSxcbn0iLCJpbXBvcnQge21lcmdlLCBoYXN9IGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHtjb25zdGFudCwgaXNVbmRlZmluZWQsIGtleXMsIFxyXG4gICAgbWFwLCBmaWx0ZXIsIHJlZHVjZSwgbWFwVmFsdWVzLCBcclxuICAgIGlzTnVsbCwgY2xvbmVEZWVwfSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcbmltcG9ydCB7JCwgaXNOb3RFbXB0eX0gZnJvbSBcIi4uL2NvbW1vblwiXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0U2FmZUZpZWxkUGFyc2VyID0gKHRyeVBhcnNlLCBkZWZhdWx0VmFsdWVGdW5jdGlvbnMpID0+IChmaWVsZCwgcmVjb3JkKSA9PiB7XHJcbiAgICBpZihoYXMocmVjb3JkLCBmaWVsZC5uYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRTYWZlVmFsdWVQYXJzZXIodHJ5UGFyc2UsIGRlZmF1bHRWYWx1ZUZ1bmN0aW9ucylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlY29yZFtmaWVsZC5uYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlRnVuY3Rpb25zW2ZpZWxkLmdldFVuZGVmaW5lZFZhbHVlXSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0U2FmZVZhbHVlUGFyc2VyID0gKHRyeVBhcnNlLCBkZWZhdWx0VmFsdWVGdW5jdGlvbnMpID0+IHZhbHVlID0+IHtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHRyeVBhcnNlKHZhbHVlKTtcclxuICAgIGlmKHBhcnNlZC5zdWNjZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlZC52YWx1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZUZ1bmN0aW9uc1tcImRlZmF1bHRcIl0oKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldE5ld1ZhbHVlID0gKHRyeVBhcnNlLCBkZWZhdWx0VmFsdWVGdW5jdGlvbnMpID0+IGZpZWxkID0+IHtcclxuICAgIGNvbnN0IGdldEluaXRpYWxWYWx1ZSA9IGlzVW5kZWZpbmVkKGZpZWxkKSB8fCBpc1VuZGVmaW5lZChmaWVsZC5nZXRJbml0aWFsVmFsdWUpIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcImRlZmF1bHRcIiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGQuZ2V0SW5pdGlhbFZhbHVlO1xyXG5cclxuICAgIHJldHVybiBoYXMoZGVmYXVsdFZhbHVlRnVuY3Rpb25zLCBnZXRJbml0aWFsVmFsdWUpXHJcbiAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVGdW5jdGlvbnNbZ2V0SW5pdGlhbFZhbHVlXSgpXHJcbiAgICAgICAgICAgOiBnZXRTYWZlVmFsdWVQYXJzZXIodHJ5UGFyc2UsIGRlZmF1bHRWYWx1ZUZ1bmN0aW9ucykoZ2V0SW5pdGlhbFZhbHVlKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0eXBlRnVuY3Rpb25zID0gc3BlY2lmaWNGdW5jdGlvbnMgPT4gXHJcbiAgICBtZXJnZSh7XHJcbiAgICAgICAgdmFsdWU6IGNvbnN0YW50LFxyXG4gICAgICAgIG51bGw6IGNvbnN0YW50KG51bGwpXHJcbiAgICB9LCBzcGVjaWZpY0Z1bmN0aW9ucyk7XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVUeXBlQ29uc3RyYWludHMgPSAodmFsaWRhdGlvblJ1bGVzKSA9PiBcclxuYXN5bmMgKGZpZWxkLCByZWNvcmQsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IGZpZWxkVmFsdWUgPSByZWNvcmRbZmllbGQubmFtZV07XHJcbiAgICBjb25zdCB2YWxpZGF0ZVJ1bGUgPSBhc3luYyByID0+IFxyXG4gICAgICAgICEgYXdhaXQgci5pc1ZhbGlkKGZpZWxkVmFsdWUsIGZpZWxkLnR5cGVPcHRpb25zLCBjb250ZXh0KSBcclxuICAgICAgICA/IHIuZ2V0TWVzc2FnZShmaWVsZFZhbHVlLCBmaWVsZC50eXBlT3B0aW9ucykgXHJcbiAgICAgICAgOiBcIlwiO1xyXG5cclxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xyXG4gICAgZm9yKGxldCByIG9mIHZhbGlkYXRpb25SdWxlcykge1xyXG4gICAgICAgIGNvbnN0IGVyciA9IGF3YWl0IHZhbGlkYXRlUnVsZShyKTtcclxuICAgICAgICBpZihpc05vdEVtcHR5KGVycikpIGVycm9ycy5wdXNoKGVycik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVycm9ycztcclxufTtcclxuXHJcbmNvbnN0IGdldERlZmF1bHRPcHRpb25zID0gbWFwVmFsdWVzKHYgPT4gdi5kZWZhdWx0VmFsdWUpXHJcblxyXG5leHBvcnQgY29uc3QgbWFrZXJ1bGUgPSAoaXNWYWxpZCwgZ2V0TWVzc2FnZSkgPT4gKHtpc1ZhbGlkLCBnZXRNZXNzYWdlfSk7XHJcbmV4cG9ydCBjb25zdCBwYXJzZWRGYWlsZWQgPSB2YWwgPT4gKHtzdWNjZXNzOmZhbHNlLCB2YWx1ZTp2YWx9KTtcclxuZXhwb3J0IGNvbnN0IHBhcnNlZFN1Y2Nlc3MgPSB2YWwgPT4gKHtzdWNjZXNzOnRydWUsIHZhbHVlOnZhbH0pO1xyXG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdEV4cG9ydCA9IChuYW1lLCB0cnlQYXJzZSwgZnVuY3Rpb25zLCBvcHRpb25zLCB2YWxpZGF0aW9uUnVsZXMsIHNhbXBsZVZhbHVlLCBzdHJpbmdpZnkpID0+ICh7XHJcbiAgICBnZXROZXcgOiBnZXROZXdWYWx1ZSh0cnlQYXJzZSwgZnVuY3Rpb25zKSwgXHJcbiAgICBzYWZlUGFyc2VGaWVsZDogZ2V0U2FmZUZpZWxkUGFyc2VyKHRyeVBhcnNlLCBmdW5jdGlvbnMpLCBcclxuICAgIHNhZmVQYXJzZVZhbHVlOiBnZXRTYWZlVmFsdWVQYXJzZXIodHJ5UGFyc2UsIGZ1bmN0aW9ucyksXHJcbiAgICB0cnlQYXJzZSwgXHJcbiAgICBuYW1lLFxyXG4gICAgZ2V0RGVmYXVsdE9wdGlvbnMgOiAoKSA9PiBnZXREZWZhdWx0T3B0aW9ucyhjbG9uZURlZXAob3B0aW9ucykpLCBcclxuICAgIG9wdGlvbkRlZmluaXRpb25zOiBvcHRpb25zLFxyXG4gICAgdmFsaWRhdGVUeXBlQ29uc3RyYWludHMgOiB2YWxpZGF0ZVR5cGVDb25zdHJhaW50cyh2YWxpZGF0aW9uUnVsZXMpLFxyXG4gICAgc2FtcGxlVmFsdWUsXHJcbiAgICBzdHJpbmdpZnk6IHZhbCA9PiB2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQgXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiXCIgOiBzdHJpbmdpZnkodmFsKSxcclxuICAgIGdldERlZmF1bHRWYWx1ZTogZnVuY3Rpb25zLmRlZmF1bHRcclxufSk7XHJcblxyXG4iLCJpbXBvcnQge3R5cGVGdW5jdGlvbnMsICBcclxuICAgIG1ha2VydWxlLCBwYXJzZWRTdWNjZXNzLCBnZXREZWZhdWx0RXhwb3J0fSBmcm9tIFwiLi90eXBlSGVscGVyc1wiO1xyXG5pbXBvcnQge2NvbnN0YW50LCBpc1N0cmluZywgaXNBcnJheSwgXHJcbiAgICBpc051bGwsIGluY2x1ZGVzLCBpc0Jvb2xlYW59IGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHtzd2l0Y2hDYXNlLCBkZWZhdWx0Q2FzZSwgdG9Cb29sT3JOdWxsLCB0b051bWJlck9yTnVsbCxcclxuICAgIGlzU2FmZUludGVnZXIsIGlzQXJyYXlPZlN0cmluZ30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5cclxuY29uc3Qgc3RyaW5nRnVuY3Rpb25zID0gdHlwZUZ1bmN0aW9ucyh7XHJcbiAgICBkZWZhdWx0OiBjb25zdGFudChudWxsKVxyXG59KTtcclxuXHJcbmNvbnN0IHN0cmluZ1RyeVBhcnNlID0gXHJcbiAgICBzd2l0Y2hDYXNlKFxyXG4gICAgICAgIFtpc1N0cmluZywgcGFyc2VkU3VjY2Vzc10sXHJcbiAgICAgICAgW2lzTnVsbCwgcGFyc2VkU3VjY2Vzc10sXHJcbiAgICAgICAgW2RlZmF1bHRDYXNlLCB2ID0+IHBhcnNlZFN1Y2Nlc3Modi50b1N0cmluZygpKV1cclxuICAgICk7XHJcblxyXG5jb25zdCBvcHRpb25zID0ge1xyXG4gICAgbWF4TGVuZ3RoOiB7XHJcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLCBcclxuICAgICAgICBpc1ZhbGlkOiBuID0+IG4gPT09IG51bGwgfHwgaXNTYWZlSW50ZWdlcihuKSAmJiBuID4gMCxcclxuICAgICAgICByZXF1aXJlbWVudERlc2NyaXB0aW9uOiBcIm1heCBsZW5ndGggbXVzdCBiZSBudWxsIChubyBsaW1pdCkgb3IgYSBncmVhdGVyIHRoYW4gemVybyBpbnRlZ2VyXCIsXHJcbiAgICAgICAgcGFyc2U6IHRvTnVtYmVyT3JOdWxsXHJcbiAgICB9LFxyXG4gICAgdmFsdWVzOiB7XHJcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLFxyXG4gICAgICAgIGlzVmFsaWQ6IHYgPT4gdiA9PT0gbnVsbCB8fCAoaXNBcnJheU9mU3RyaW5nKHYpICYmIHYubGVuZ3RoID4gMCAmJiB2Lmxlbmd0aCA8IDEwMDAwKSxcclxuICAgICAgICByZXF1aXJlbWVudERlc2NyaXB0aW9uOiBcIid2YWx1ZXMnIG11c3QgYmUgbnVsbCAobm8gdmFsdWVzKSBvciBhbiBhcnJ5IG9mIGF0IGxlYXN0IG9uZSBzdHJpbmdcIixcclxuICAgICAgICBwYXJzZTogcz0+c1xyXG4gICAgfSxcclxuICAgIGFsbG93RGVjbGFyZWRWYWx1ZXNPbmx5OiB7XHJcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcclxuICAgICAgICBpc1ZhbGlkOiBpc0Jvb2xlYW4sXHJcbiAgICAgICAgcmVxdWlyZW1lbnREZXNjcmlwdGlvbjogXCJhbGxvd0RlY2xhcmVkVmFsdWVzT25seSBtdXN0IGJlIHRydWUgb3IgZmFsc2VcIixcclxuICAgICAgICBwYXJzZTogdG9Cb29sT3JOdWxsXHJcbiAgICB9XHJcbn07XHJcblxyXG5jb25zdCB0eXBlQ29uc3RyYWludHMgPSBbXHJcbiAgICBtYWtlcnVsZShhc3luYyAodmFsLG9wdHMpID0+IHZhbCA9PT0gbnVsbCB8fCBvcHRzLm1heExlbmd0aCA9PT0gbnVsbCB8fCB2YWwubGVuZ3RoIDw9IG9wdHMubWF4TGVuZ3RoLCBcclxuICAgICAgICAgICAgICh2YWwsb3B0cykgPT4gYHZhbHVlIGV4Y2VlZHMgbWF4aW11bSBsZW5ndGggb2YgJHtvcHRzLm1heExlbmd0aH1gKSxcclxuICAgIG1ha2VydWxlKGFzeW5jICh2YWwsIG9wdHMpID0+IHZhbCA9PT0gbnVsbCAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IG9wdHMuYWxsb3dEZWNsYXJlZFZhbHVlc09ubHkgPT09IGZhbHNlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBpbmNsdWRlcyhvcHRzLnZhbHVlcywgdmFsKSxcclxuICAgICAgICAgICAgICh2YWwsb3B0cykgPT4gYFwiJHt2YWx9XCIgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3Qgb2YgYWxsb3dlZCB2YWx1ZXNgKSBcclxuXTsgXHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXREZWZhdWx0RXhwb3J0KFxyXG4gICAgXCJzdHJpbmdcIiwgXHJcbiAgICBzdHJpbmdUcnlQYXJzZSwgXHJcbiAgICBzdHJpbmdGdW5jdGlvbnMsXHJcbiAgICBvcHRpb25zLCBcclxuICAgIHR5cGVDb25zdHJhaW50cyxcclxuICAgIFwiYWJjZGVcIixcclxuICAgIHN0ciA9PiBzdHIpOyIsImltcG9ydCB7Z2V0U2FmZUZpZWxkUGFyc2VyLCB0eXBlRnVuY3Rpb25zLCBcclxuICAgIG1ha2VydWxlLCBwYXJzZWRGYWlsZWQsIHBhcnNlZFN1Y2Nlc3MsXHJcbiAgICBnZXREZWZhdWx0RXhwb3J0fSBmcm9tIFwiLi90eXBlSGVscGVyc1wiO1xyXG5pbXBvcnQge2NvbnN0YW50LCBpc0Jvb2xlYW4sIGlzTnVsbH0gZnJvbSBcImxvZGFzaFwiO1xyXG5pbXBvcnQge3N3aXRjaENhc2UsIGRlZmF1bHRDYXNlLCBpc09uZU9mLCB0b0Jvb2xPck51bGx9IGZyb20gXCIuLi9jb21tb25cIjtcclxuXHJcbmNvbnN0IGJvb2xGdW5jdGlvbnMgPSB0eXBlRnVuY3Rpb25zKHtcclxuICAgIGRlZmF1bHQ6IGNvbnN0YW50KG51bGwpLFxyXG59KTtcclxuXHJcbmNvbnN0IGJvb2xUcnlQYXJzZSA9IFxyXG4gICAgc3dpdGNoQ2FzZShcclxuICAgICAgICBbaXNCb29sZWFuLCBwYXJzZWRTdWNjZXNzXSxcclxuICAgICAgICBbaXNOdWxsLCBwYXJzZWRTdWNjZXNzXSxcclxuICAgICAgICBbaXNPbmVPZihcInRydWVcIiwgXCIxXCIsIFwieWVzXCIsIFwib25cIiksIHYgPT4gcGFyc2VkU3VjY2Vzcyh0cnVlKV0sXHJcbiAgICAgICAgW2lzT25lT2YoXCJmYWxzZVwiLCBcIjBcIiwgXCJub1wiLCBcIm9mZlwiKSwgdiA9PiBwYXJzZWRTdWNjZXNzKGZhbHNlKV0sXHJcbiAgICAgICAgW2RlZmF1bHRDYXNlLCBwYXJzZWRGYWlsZWRdXHJcbiAgICApO1xyXG5cclxuY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgIGFsbG93TnVsbHM6IHtcclxuICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWUsIFxyXG4gICAgICAgIGlzVmFsaWQ6IGlzQm9vbGVhbixcclxuICAgICAgICByZXF1aXJlbWVudERlc2NyaXB0aW9uOiBcIm11c3QgYmUgYSB0cnVlIG9yIGZhbHNlXCIsXHJcbiAgICAgICAgcGFyc2U6IHRvQm9vbE9yTnVsbFxyXG4gICAgfVxyXG59O1xyXG5cclxuY29uc3QgdHlwZUNvbnN0cmFpbnRzID0gW1xyXG4gICAgbWFrZXJ1bGUoYXN5bmMgKHZhbCxvcHRzKSA9PiBvcHRzLmFsbG93TnVsbHMgPT09IHRydWUgfHwgdmFsICE9PSBudWxsLCBcclxuICAgICAgICAgICAgICh2YWwsb3B0cykgPT4gXCJmaWVsZCBjYW5ub3QgYmUgbnVsbFwiKVxyXG5dOyBcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldERlZmF1bHRFeHBvcnQoXHJcbiAgICBcImJvb2xcIiwgYm9vbFRyeVBhcnNlLCBib29sRnVuY3Rpb25zLCBcclxuICAgIG9wdGlvbnMsIHR5cGVDb25zdHJhaW50cywgdHJ1ZSwgSlNPTi5zdHJpbmdpZnkpOyIsImltcG9ydCB7bWFrZXJ1bGUsIHR5cGVGdW5jdGlvbnMsIGdldE5ld1ZhbHVlXHJcbiAgICAsIHBhcnNlZEZhaWxlZCwgcGFyc2VkU3VjY2VzcywgZ2V0RGVmYXVsdEV4cG9ydH0gZnJvbSBcIi4vdHlwZUhlbHBlcnNcIjtcclxuaW1wb3J0IHtjb25zdGFudCwgaXNOdW1iZXIsIGlzU3RyaW5nLCBpc051bGx9IGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHtzd2l0Y2hDYXNlLCBkZWZhdWx0Q2FzZSwgdG9OdW1iZXJPck51bGwsXHJcbiAgICBpc1NhZmVJbnRlZ2VyfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcblxyXG5jb25zdCBudW1iZXJGdW5jdGlvbnMgPSB0eXBlRnVuY3Rpb25zKHtcclxuICAgIGRlZmF1bHQ6IGNvbnN0YW50KG51bGwpXHJcbn0pO1xyXG5cclxuY29uc3QgcGFyc2VTdHJpbmd0b051bWJlck9yTnVsbCA9IHMgPT4ge1xyXG4gICAgY29uc3QgbnVtID0gTnVtYmVyKHMpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG51bSkgPyBwYXJzZWRGYWlsZWQocykgOiBwYXJzZWRTdWNjZXNzKG51bSk7IFxyXG59O1xyXG5cclxuY29uc3QgbnVtYmVyVHJ5UGFyc2UgPSBcclxuICAgIHN3aXRjaENhc2UoXHJcbiAgICAgICAgW2lzTnVtYmVyLCBwYXJzZWRTdWNjZXNzXSxcclxuICAgICAgICBbaXNTdHJpbmcsIHBhcnNlU3RyaW5ndG9OdW1iZXJPck51bGxdLFxyXG4gICAgICAgIFtpc051bGwsIHBhcnNlZFN1Y2Nlc3NdLFxyXG4gICAgICAgIFtkZWZhdWx0Q2FzZSwgcGFyc2VkRmFpbGVkXVxyXG4gICAgKTtcclxuXHJcbmNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICBtYXhWYWx1ZToge1xyXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXHJcbiAgICAgICAgaXNWYWxpZDogaXNTYWZlSW50ZWdlcixcclxuICAgICAgICByZXF1aXJlbWVudERlc2NyaXB0aW9uOiBcIm11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyXCIsXHJcbiAgICAgICAgcGFyc2U6IHRvTnVtYmVyT3JOdWxsXHJcbiAgICB9LFxyXG4gICAgbWluVmFsdWU6IHtcclxuICAgICAgICBkZWZhdWx0VmFsdWU6IDAtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXHJcbiAgICAgICAgaXNWYWxpZDogaXNTYWZlSW50ZWdlcixcclxuICAgICAgICByZXF1aXJlbWVudERlc2NyaXB0aW9uOiBcIm11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyXCIsXHJcbiAgICAgICAgcGFyc2U6IHRvTnVtYmVyT3JOdWxsXHJcbiAgICB9LFxyXG4gICAgZGVjaW1hbFBsYWNlczoge1xyXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogMCxcclxuICAgICAgICBpc1ZhbGlkOiBuID0+IGlzU2FmZUludGVnZXIobikgJiYgbiA+PSAwLFxyXG4gICAgICAgIHJlcXVpcmVtZW50RGVzY3JpcHRpb246IFwibXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIixcclxuICAgICAgICBwYXJzZTogdG9OdW1iZXJPck51bGxcclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IGdldERlY2ltYWxQbGFjZXMgPSB2YWwgPT4ge1xyXG4gICAgdmFyIHNwbGl0RGVjaW1hbCA9IHZhbC50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcclxuICAgIGlmKHNwbGl0RGVjaW1hbC5sZW5ndGggPT09IDEpIHJldHVybiAwO1xyXG4gICAgcmV0dXJuIHNwbGl0RGVjaW1hbFsxXS5sZW5ndGg7XHJcbn1cclxuXHJcbmNvbnN0IHR5cGVDb25zdHJhaW50cyA9IFtcclxuICAgIG1ha2VydWxlKGFzeW5jICh2YWwsb3B0cykgPT4gdmFsID09PSBudWxsIHx8IG9wdHMubWluVmFsdWUgPT09IG51bGwgfHwgdmFsID49IG9wdHMubWluVmFsdWUsXHJcbiAgICAgICAgICAgICAodmFsLG9wdHMpID0+IGB2YWx1ZSAoJHt2YWwudG9TdHJpbmcoKX0pIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7b3B0cy5taW5WYWx1ZX1gKSxcclxuICAgIG1ha2VydWxlKGFzeW5jICh2YWwsb3B0cykgPT4gdmFsID09PSBudWxsIHx8IG9wdHMubWF4VmFsdWUgPT09IG51bGwgfHwgdmFsIDw9IG9wdHMubWF4VmFsdWUsIFxyXG4gICAgICAgICAgICAgKHZhbCxvcHRzKSA9PiBgdmFsdWUgKCR7dmFsLnRvU3RyaW5nKCl9KSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAke29wdHMubWluVmFsdWV9IG9wdGlvbnNgKSxcclxuICAgIG1ha2VydWxlKGFzeW5jICh2YWwsb3B0cykgPT4gdmFsID09PSBudWxsIHx8IG9wdHMuZGVjaW1hbFBsYWNlcyA+PSBnZXREZWNpbWFsUGxhY2VzKHZhbCksXHJcbiAgICAgICAgICAgICAodmFsLG9wdHMpID0+IGB2YWx1ZSAoJHt2YWwudG9TdHJpbmcoKX0pIG11c3QgaGF2ZSAke29wdHMuZGVjaW1hbFBsYWNlc30gZGVjaW1hbCBwbGFjZXMgb3IgbGVzc2ApXHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXREZWZhdWx0RXhwb3J0KFxyXG4gICAgXCJudW1iZXJcIiwgXHJcbiAgICBudW1iZXJUcnlQYXJzZSwgXHJcbiAgICBudW1iZXJGdW5jdGlvbnMsIFxyXG4gICAgb3B0aW9ucywgXHJcbiAgICB0eXBlQ29uc3RyYWludHMsXHJcbiAgICAxLFxyXG4gICAgbnVtID0+IG51bS50b1N0cmluZygpKTtcclxuIiwiaW1wb3J0IHttYWtlcnVsZSwgdHlwZUZ1bmN0aW9ucywgZ2V0TmV3VmFsdWVcclxuICAgICAgICAsIHBhcnNlZEZhaWxlZCwgcGFyc2VkU3VjY2VzcywgZ2V0RGVmYXVsdEV4cG9ydH0gZnJvbSBcIi4vdHlwZUhlbHBlcnNcIjtcclxuaW1wb3J0IHtjb25zdGFudCwgaXNEYXRlLCBpc1N0cmluZywgaXNOdWxsfSBmcm9tIFwibG9kYXNoXCI7XHJcbmltcG9ydCB7c3dpdGNoQ2FzZSwgZGVmYXVsdENhc2UsICQsIHRvRGF0ZU9yTnVsbH0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5cclxuY29uc3QgZGF0ZUZ1bmN0aW9ucyA9IHR5cGVGdW5jdGlvbnMoe1xyXG4gICAgZGVmYXVsdDogY29uc3RhbnQobnVsbCksXHJcbiAgICBub3c6ICgpID0+IG5ldyBEYXRlKClcclxufSk7XHJcblxyXG5jb25zdCBpc1ZhbGlkRGF0ZSA9IGQgPT4gXHJcbiAgICBkIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4oZCk7XHJcblxyXG5jb25zdCBwYXJzZVN0cmluZ1RvRGF0ZSA9IHMgPT4gXHJcbiAgICBzd2l0Y2hDYXNlKFxyXG4gICAgICAgIFtpc1ZhbGlkRGF0ZSwgcGFyc2VkU3VjY2Vzc10sXHJcbiAgICAgICAgW2RlZmF1bHRDYXNlLCBwYXJzZWRGYWlsZWRdXHJcbiAgICApKG5ldyBEYXRlKHMpKTtcclxuICAgIFxyXG5cclxuY29uc3QgZGF0ZVRyeVBhcnNlID0gXHJcbiAgICBzd2l0Y2hDYXNlKFxyXG4gICAgICAgIFtpc0RhdGUsIHBhcnNlZFN1Y2Nlc3NdLFxyXG4gICAgICAgIFtpc1N0cmluZywgcGFyc2VTdHJpbmdUb0RhdGVdLFxyXG4gICAgICAgIFtpc051bGwsIHBhcnNlZFN1Y2Nlc3NdLFxyXG4gICAgICAgIFtkZWZhdWx0Q2FzZSwgcGFyc2VkRmFpbGVkXVxyXG4gICAgKTtcclxuXHJcbmNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICBtYXhWYWx1ZToge1xyXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogbmV3IERhdGUoMzI1MDM2ODAwMDAwMDApLFxyXG4gICAgICAgIGlzVmFsaWQ6IGlzRGF0ZSxcclxuICAgICAgICByZXF1aXJlbWVudERlc2NyaXB0aW9uOiBcIm11c3QgYmUgYSB2YWxpZCBkYXRlXCIsXHJcbiAgICAgICAgcGFyc2U6IHRvRGF0ZU9yTnVsbFxyXG4gICAgfSxcclxuICAgIG1pblZhbHVlOiB7XHJcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBuZXcgRGF0ZSgtODUyMDMzNjAwMDAwMCksIFxyXG4gICAgICAgIGlzVmFsaWQ6IGlzRGF0ZSxcclxuICAgICAgICByZXF1aXJlbWVudERlc2NyaXB0aW9uOiBcIm11c3QgYmUgYSB2YWxpZCBkYXRlXCIsXHJcbiAgICAgICAgcGFyc2U6IHRvRGF0ZU9yTnVsbFxyXG4gICAgfVxyXG59O1xyXG5cclxuY29uc3QgdHlwZUNvbnN0cmFpbnRzID0gW1xyXG4gICAgbWFrZXJ1bGUoYXN5bmMgKHZhbCxvcHRzKSA9PiB2YWwgPT09IG51bGwgfHwgb3B0cy5taW5WYWx1ZSA9PT0gbnVsbCB8fCB2YWwgPj0gb3B0cy5taW5WYWx1ZSxcclxuICAgICAgICAgICAgICh2YWwsb3B0cykgPT4gYHZhbHVlICgke3ZhbC50b1N0cmluZygpfSkgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtvcHRzLm1pblZhbHVlfWApLFxyXG4gICAgbWFrZXJ1bGUoYXN5bmMgKHZhbCxvcHRzKSA9PiB2YWwgPT09IG51bGwgfHwgb3B0cy5tYXhWYWx1ZSA9PT0gbnVsbCB8fCB2YWwgPD0gb3B0cy5tYXhWYWx1ZSwgXHJcbiAgICAgICAgICAgICAodmFsLG9wdHMpID0+IGB2YWx1ZSAoJHt2YWwudG9TdHJpbmcoKX0pIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7b3B0cy5taW5WYWx1ZX0gb3B0aW9uc2ApXHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXREZWZhdWx0RXhwb3J0KFxyXG4gICAgXCJkYXRldGltZVwiLCBcclxuICAgIGRhdGVUcnlQYXJzZSwgXHJcbiAgICBkYXRlRnVuY3Rpb25zLFxyXG4gICAgb3B0aW9ucywgXHJcbiAgICB0eXBlQ29uc3RyYWludHMsXHJcbiAgICBuZXcgRGF0ZSgxOTg0LDQsMSksXHJcbiAgICBkYXRlID0+IEpTT04uc3RyaW5naWZ5KGRhdGUpLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXCJcIiwgJ2cnKSwgXCJcIikpOyIsImltcG9ydCB7dHlwZUZ1bmN0aW9ucywgbWFrZXJ1bGUsXHJcbiAgICBwYXJzZWRGYWlsZWQsIGdldERlZmF1bHRFeHBvcnQsIHBhcnNlZFN1Y2Nlc3N9IGZyb20gXCIuL3R5cGVIZWxwZXJzXCI7XHJcbmltcG9ydCB7Y29uc3RhbnQsIGlzQXJyYXl9IGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHttYXB9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHtzd2l0Y2hDYXNlLCBkZWZhdWx0Q2FzZSwgdG9OdW1iZXJPck51bGwsXHJcbiAgICAkJCwgaXNTYWZlSW50ZWdlcn0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5cclxuY29uc3QgYXJyYXlGdW5jdGlvbnMgPSB0eXBlID0+IHR5cGVGdW5jdGlvbnMoe1xyXG4gICBkZWZhdWx0OiBjb25zdGFudChbXSlcclxufSk7XHJcblxyXG5jb25zdCBtYXBUb1BhcnNlZEFycmFyeSA9IHR5cGUgPT4gJCQoXHJcbiAgICBtYXAoaSA9PiB0eXBlLnNhZmVQYXJzZVZhbHVlKGkpKSxcclxuICAgIHBhcnNlZFN1Y2Nlc3NcclxuKTtcclxuXHJcbmNvbnN0IGFycmF5VHJ5UGFyc2UgPSB0eXBlID0+XHJcbiAgIHN3aXRjaENhc2UoXHJcbiAgICAgICBbaXNBcnJheSwgbWFwVG9QYXJzZWRBcnJhcnkodHlwZSldLFxyXG4gICAgICAgW2RlZmF1bHRDYXNlLCBwYXJzZWRGYWlsZWRdXHJcbiAgICk7XHJcblxyXG5jb25zdCB0eXBlTmFtZSA9IHR5cGUgPT4gYGFycmF5PCR7dHlwZX0+YDtcclxuXHJcblxyXG5jb25zdCBvcHRpb25zID0ge1xyXG4gICAgbWF4TGVuZ3RoOiB7XHJcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAxMDAwMCxcclxuICAgICAgICBpc1ZhbGlkOiBpc1NhZmVJbnRlZ2VyLFxyXG4gICAgICAgIHJlcXVpcmVtZW50RGVzY3JpcHRpb246IFwibXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIixcclxuICAgICAgICBwYXJzZTogdG9OdW1iZXJPck51bGxcclxuICAgIH0sXHJcbiAgICBtaW5MZW5ndGg6IHtcclxuICAgICAgICBkZWZhdWx0VmFsdWU6IDAsXHJcbiAgICAgICAgaXNWYWxpZCA6IG4gPT4gaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsXHJcbiAgICAgICAgcmVxdWlyZW1lbnREZXNjcmlwdGlvbjogXCJtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiLFxyXG4gICAgICAgIHBhcnNlOiB0b051bWJlck9yTnVsbFxyXG4gICAgfVxyXG59O1xyXG5cclxuY29uc3QgdHlwZUNvbnN0cmFpbnRzID0gW1xyXG4gICAgbWFrZXJ1bGUoYXN5bmMgKHZhbCxvcHRzKSA9PiB2YWwgPT09IG51bGwgfHwgdmFsLmxlbmd0aCA+PSBvcHRzLm1pbkxlbmd0aCwgXHJcbiAgICAgICAgICAgICAodmFsLG9wdHMpID0+IGBtdXN0IGNob29zZSAke29wdHMubWluTGVuZ3RofSBvciBtb3JlIG9wdGlvbnNgKSxcclxuICAgIG1ha2VydWxlKGFzeW5jICh2YWwsb3B0cykgPT4gdmFsID09PSBudWxsIHx8IHZhbC5sZW5ndGggPD0gb3B0cy5tYXhMZW5ndGgsIFxyXG4gICAgICAgICAgICAgKHZhbCxvcHRzKSA9PiBgY2Fubm90IGNob29zZSBtb3JlIHRoYW4gJHtvcHRzLm1heExlbmd0aH0gb3B0aW9uc2ApXHJcbl07IFxyXG5cclxuZXhwb3J0IGRlZmF1bHQgdHlwZSA9PiBcclxuICAgIGdldERlZmF1bHRFeHBvcnQoXHJcbiAgICAgICAgdHlwZU5hbWUodHlwZS5uYW1lKSxcclxuICAgICAgICBhcnJheVRyeVBhcnNlKHR5cGUpLCBcclxuICAgICAgICBhcnJheUZ1bmN0aW9ucyh0eXBlKSxcclxuICAgICAgICBvcHRpb25zLFxyXG4gICAgICAgIHR5cGVDb25zdHJhaW50cyxcclxuICAgICAgICBbdHlwZS5zYW1wbGVWYWx1ZV0sXHJcbiAgICAgICAgSlNPTi5zdHJpbmdpZnlcclxuICAgICAgICApOyIsImltcG9ydCB7dHlwZUZ1bmN0aW9ucywgbWFrZXJ1bGUsIFxyXG4gICAgcGFyc2VkU3VjY2VzcywgZ2V0RGVmYXVsdEV4cG9ydCwgXHJcbiAgICBwYXJzZWRGYWlsZWR9IGZyb20gXCIuL3R5cGVIZWxwZXJzXCI7XHJcbmltcG9ydCB7aXNTdHJpbmcsIGlzT2JqZWN0TGlrZSwgXHJcbiAgICBpc051bGwsIGhhcywgaXNFbXB0eX0gZnJvbSBcImxvZGFzaFwiO1xyXG5pbXBvcnQge3N3aXRjaENhc2UsIGRlZmF1bHRDYXNlLCBcclxuICAgIGlzTm9uRW1wdHlTdHJpbmcsIGlzQXJyYXlPZlN0cmluZ30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5cclxuY29uc3QgcmVmZXJlbmNlTm90aGluZyA9ICgpID0+ICh7a2V5OlwiXCJ9KTtcclxuXHJcbmNvbnN0IHJlZmVyZW5jZUZ1bmN0aW9ucyA9IHR5cGVGdW5jdGlvbnMoe1xyXG4gICAgZGVmYXVsdDogcmVmZXJlbmNlTm90aGluZyBcclxufSk7XHJcblxyXG5jb25zdCBoYXNTdHJpbmdWYWx1ZSA9IChvYiwgcGF0aCkgPT4gXHJcbiAgICBoYXMob2IsIHBhdGgpIFxyXG4gICAgJiYgaXNTdHJpbmcob2JbcGF0aF0pO1xyXG5cclxuY29uc3QgaXNPYmplY3RXaXRoS2V5ID0gdiA9PiBcclxuICAgIGlzT2JqZWN0TGlrZSh2KSBcclxuICAgICYmIGhhc1N0cmluZ1ZhbHVlKHYsIFwia2V5XCIpO1xyXG5cclxuY29uc3QgcmVmZXJlbmNlVHJ5UGFyc2UgPSB2ID0+XHJcbiAgICBzd2l0Y2hDYXNlKFxyXG4gICAgICAgIFtpc09iamVjdFdpdGhLZXksIHBhcnNlZFN1Y2Nlc3NdLFxyXG4gICAgICAgIFtpc051bGwsICgpID0+IHBhcnNlZFN1Y2Nlc3MocmVmZXJlbmNlTm90aGluZygpKV0sXHJcbiAgICAgICAgW2RlZmF1bHRDYXNlLCBwYXJzZWRGYWlsZWRdXHJcbiAgICApKHYpO1xyXG5cclxuY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgIGluZGV4Tm9kZUtleToge1xyXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCxcclxuICAgICAgICBpc1ZhbGlkIDogaXNOb25FbXB0eVN0cmluZyAsXHJcbiAgICAgICAgcmVxdWlyZW1lbnREZXNjcmlwdGlvbjogXCJtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiLFxyXG4gICAgICAgIHBhcnNlOiBzPT5zXHJcbiAgICB9LFxyXG4gICAgZGlzcGxheVZhbHVlOiB7XHJcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIlwiLCBcclxuICAgICAgICBpc1ZhbGlkIDogaXNOb25FbXB0eVN0cmluZyxcclxuICAgICAgICByZXF1aXJlbWVudERlc2NyaXB0aW9uOiBcIm11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIsXHJcbiAgICAgICAgcGFyc2U6IHM9PnNcclxuICAgIH0sXHJcbiAgICByZXZlcnNlSW5kZXhOb2RlS2V5czoge1xyXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCxcclxuICAgICAgICBpc1ZhbGlkIDogdiA9PiBpc0FycmF5T2ZTdHJpbmcodikgJiYgdi5sZW5ndGggPiAwLFxyXG4gICAgICAgIHJlcXVpcmVtZW50RGVzY3JpcHRpb246IFwibXVzdCBiZSBhIG5vbi1lbXB0eSBhcnJheSBvZiBzdHJpbmdzXCIsXHJcbiAgICAgICAgcGFyc2U6IHM9PnNcclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IGlzRW1wdHlTdHJpbmcgPSBzID0+IFxyXG4gICAgaXNTdHJpbmcocykgJiYgaXNFbXB0eShzKTtcclxuXHJcbmNvbnN0IGVuc3VyZVJlZmVyZW5jZUV4aXN0cyA9IGFzeW5jICh2YWwsIG9wdHMsIGNvbnRleHQpID0+IFxyXG4gICAgaXNFbXB0eVN0cmluZyh2YWwua2V5KSBcclxuICAgIHx8IGF3YWl0IGNvbnRleHQucmVmZXJlbmNlRXhpc3RzKG9wdHMsIHZhbC5rZXkpO1xyXG5cclxuY29uc3QgdHlwZUNvbnN0cmFpbnRzID0gW1xyXG4gICAgbWFrZXJ1bGUoXHJcbiAgICAgICAgZW5zdXJlUmVmZXJlbmNlRXhpc3RzLFxyXG4gICAgICAgICh2YWwsb3B0cykgPT4gYFwiJHt2YWxbb3B0cy5kaXNwbGF5VmFsdWVdfVwiIGRvZXMgbm90IGV4aXN0IGluIG9wdGlvbnMgbGlzdCAoa2V5OiAke3ZhbC5rZXl9KWApXHJcbl07IFxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2V0RGVmYXVsdEV4cG9ydChcclxuICAgIFwicmVmZXJlbmNlXCIsIFxyXG4gICAgcmVmZXJlbmNlVHJ5UGFyc2UsIFxyXG4gICAgcmVmZXJlbmNlRnVuY3Rpb25zLFxyXG4gICAgb3B0aW9ucywgXHJcbiAgICB0eXBlQ29uc3RyYWludHMsXHJcbiAgICB7a2V5Olwia2V5XCIsIHZhbHVlOlwidmFsdWVcIn0sXHJcbiAgICBKU09OLnN0cmluZ2lmeSk7IiwiaW1wb3J0IHt0eXBlRnVuY3Rpb25zLCBwYXJzZWRGYWlsZWQsXHJcbiAgICBwYXJzZWRTdWNjZXNzLCBnZXREZWZhdWx0RXhwb3J0fSBmcm9tIFwiLi90eXBlSGVscGVyc1wiO1xyXG5pbXBvcnQge2xhc3QsIGhhcywgaXNTdHJpbmcsIGludGVyc2VjdGlvbiwgXHJcbiAgICBpc051bGwsIGlzTnVtYmVyfSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcbmltcG9ydCB7c3dpdGNoQ2FzZSwgZGVmYXVsdENhc2UsIG5vbmUsXHJcbiAgICAgICAgJCwgc3BsaXRLZXl9IGZyb20gXCIuLi9jb21tb25cIjtcclxuXHJcbmNvbnN0IGlsbGVnYWxDaGFyYWN0ZXJzID0gXCIqP1xcXFwvOjw+fFxcMFxcYlxcZlxcdlwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzTGVnYWxGaWxlbmFtZSA9IGZpbGVQYXRoID0+IHtcclxuICAgIGNvbnN0IGZuID0gZmlsZU5hbWUoZmlsZVBhdGgpO1xyXG4gICAgcmV0dXJuIGZuLmxlbmd0aCA8PSAyNTVcclxuICAgICYmIGludGVyc2VjdGlvbihmbi5zcGxpdChcIlwiKSlcclxuICAgICAgICAgICAgICAgICAgICAoaWxsZWdhbENoYXJhY3RlcnMuc3BsaXQoXCJcIikpLmxlbmd0aCA9PT0gMFxyXG4gICAgJiYgbm9uZShmID0+IGYgPT09IFwiLi5cIikoc3BsaXRLZXkoZmlsZVBhdGgpKTtcclxufVxyXG5cclxuY29uc3QgZmlsZU5vdGhpbmcgPSAoKSA9PiAoe3JlbGF0aXZlUGF0aDpcIlwiLHNpemU6MH0pO1xyXG5cclxuY29uc3QgZmlsZUZ1bmN0aW9ucyA9IHR5cGVGdW5jdGlvbnMoe1xyXG4gICAgZGVmYXVsdDogZmlsZU5vdGhpbmdcclxufSk7XHJcblxyXG5jb25zdCBmaWxlVHJ5UGFyc2UgPSB2ID0+XHJcbiAgICBzd2l0Y2hDYXNlKFxyXG4gICAgICAgIFtpc1ZhbGlkRmlsZSwgcGFyc2VkU3VjY2Vzc10sXHJcbiAgICAgICAgW2lzTnVsbCwgKCkgPT4gcGFyc2VkU3VjY2VzcyhmaWxlTm90aGluZygpKV0sXHJcbiAgICAgICAgW2RlZmF1bHRDYXNlLCBwYXJzZWRGYWlsZWRdXHJcbiAgICApKHYpO1xyXG5cclxuY29uc3QgZmlsZU5hbWUgPSBmaWxlUGF0aCA9PiBcclxuICAgICQoZmlsZVBhdGgsIFtcclxuICAgICAgICBzcGxpdEtleSxcclxuICAgICAgICBsYXN0XHJcbiAgICBdKTtcclxuXHJcbmNvbnN0IGlzVmFsaWRGaWxlID0gZiA9PiB7XHJcbiAgICByZXR1cm4gIWlzTnVsbChmKVxyXG4gICAgJiYgaGFzKFwicmVsYXRpdmVQYXRoXCIpKGYpICYmIGhhcyhcInNpemVcIikoZilcclxuICAgICYmIGlzTnVtYmVyKGYuc2l6ZSlcclxuICAgICYmIGlzU3RyaW5nKGYucmVsYXRpdmVQYXRoKSBcclxuICAgICYmIGlzTGVnYWxGaWxlbmFtZShmLnJlbGF0aXZlUGF0aClcclxufVxyXG5cclxuY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG5cclxuY29uc3QgdHlwZUNvbnN0cmFpbnRzID0gW107IFxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2V0RGVmYXVsdEV4cG9ydChcclxuICAgIFwiZmlsZVwiLCBcclxuICAgIGZpbGVUcnlQYXJzZSwgXHJcbiAgICBmaWxlRnVuY3Rpb25zLFxyXG4gICAgb3B0aW9ucywgXHJcbiAgICB0eXBlQ29uc3RyYWludHMsXHJcbiAgICB7cmVsYXRpdmVQYXRoOlwic29tZV9maWxlLmpwZ1wiLCBzaXplOjEwMDB9LFxyXG4gICAgSlNPTi5zdHJpbmdpZnkpOyIsImltcG9ydCB7YXNzaWduLCBrZXlzLCBtZXJnZSwgaGFzfSBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBtYXAsIGlzU3RyaW5nLCBpc051bWJlciwgXG4gICAgICAgIGlzQm9vbGVhbiwgaXNEYXRlLCBcbiAgICAgICAgaXNPYmplY3QsIGlzQXJyYXl9IGZyb20gXCJsb2Rhc2gvZnBcIjtcbmltcG9ydCB7JH0gZnJvbSBcIi4uL2NvbW1vblwiO1xuaW1wb3J0IHtwYXJzZWRTdWNjZXNzfSBmcm9tIFwiLi90eXBlSGVscGVyc1wiO1xuaW1wb3J0IHN0cmluZyBmcm9tIFwiLi9zdHJpbmdcIjtcbmltcG9ydCBib29sIGZyb20gXCIuL2Jvb2xcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5pbXBvcnQgZGF0ZXRpbWUgZnJvbSBcIi4vZGF0ZXRpbWVcIjtcbmltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHJlZmVyZW5jZSBmcm9tIFwiLi9yZWZlcmVuY2VcIjtcbmltcG9ydCBmaWxlIGZyb20gXCIuL2ZpbGVcIjtcblxuY29uc3QgYWxsVHlwZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgYmFzaWNUeXBlcyA9IHtcbiAgICAgICAgc3RyaW5nLCBudW1iZXIsIGRhdGV0aW1lLCBib29sLCByZWZlcmVuY2UsIGZpbGVcbiAgICB9OyAgICAgICAgXG5cbiAgICBjb25zdCBhcnJheXMgPSAkKGJhc2ljVHlwZXMsIFtcbiAgICAgICAga2V5cyxcbiAgICAgICAgbWFwKGsgPT4ge1xuICAgICAgICAgICAgY29uc3Qga3ZUeXBlID0ge307XG4gICAgICAgICAgICBjb25zdCBjb25jcmV0ZUFycmF5ID0gYXJyYXkoYmFzaWNUeXBlc1trXSk7XG4gICAgICAgICAgICBrdlR5cGVbY29uY3JldGVBcnJheS5uYW1lXSA9IGNvbmNyZXRlQXJyYXk7XG4gICAgICAgICAgICByZXR1cm4ga3ZUeXBlO1xuICAgICAgICB9KSxcbiAgICAgICAgdHlwZXMgPT4gYXNzaWduKHt9LCAuLi50eXBlcykgXG4gICAgXSk7XG4gICAgXG4gICAgcmV0dXJuIG1lcmdlKHt9LCBiYXNpY1R5cGVzLCBhcnJheXMpO1xufTsgXG5cblxuZXhwb3J0IGNvbnN0IGFsbCA9IGFsbFR5cGVzKCk7XG5cbmV4cG9ydCBjb25zdCBnZXRUeXBlID0gdHlwZU5hbWUgPT4gIHtcbiAgICBpZighaGFzKGFsbCwgdHlwZU5hbWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJEbyBub3QgcmVjb2duaXNlIHR5cGUgXCIgKyB0eXBlTmFtZSk7XG4gICAgcmV0dXJuIGFsbFt0eXBlTmFtZV07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2FtcGxlRmllbGRWYWx1ZSA9IGZpZWxkID0+XG4gICAgZ2V0VHlwZShmaWVsZC50eXBlKS5zYW1wbGVWYWx1ZTtcblxuZXhwb3J0IGNvbnN0IGdldE5ld0ZpZWxkVmFsdWUgPSBmaWVsZCA9PiBcbiAgICBnZXRUeXBlKGZpZWxkLnR5cGUpLmdldE5ldyhmaWVsZCk7XG5cbmV4cG9ydCBjb25zdCBzYWZlUGFyc2VGaWVsZCA9IChmaWVsZCwgcmVjb3JkKSA9PiBcbiAgICBnZXRUeXBlKGZpZWxkLnR5cGUpLnNhZmVQYXJzZUZpZWxkKGZpZWxkLCByZWNvcmQpO1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVGaWVsZFBhcnNlID0gKGZpZWxkLCByZWNvcmQpID0+IFxuICAgIGhhcyhyZWNvcmQsIGZpZWxkLm5hbWUpIFxuICAgID8gZ2V0VHlwZShmaWVsZC50eXBlKS50cnlQYXJzZShyZWNvcmRbZmllbGQubmFtZV0pXG4gICAgOiBwYXJzZWRTdWNjZXNzKHVuZGVmaW5lZCk7IC8vIGZpZWxkcyBtYXkgYmUgdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblxuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRPcHRpb25zID0gdHlwZSA9PiBcbiAgICBnZXRUeXBlKHR5cGUpLmdldERlZmF1bHRPcHRpb25zKCk7XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVR5cGVDb25zdHJhaW50cyA9IGFzeW5jIChmaWVsZCwgcmVjb3JkLCBjb250ZXh0KSA9PiBcbiAgICBhd2FpdCBnZXRUeXBlKGZpZWxkLnR5cGUpLnZhbGlkYXRlVHlwZUNvbnN0cmFpbnRzKGZpZWxkLCByZWNvcmQsIGNvbnRleHQpO1xuXG5leHBvcnQgY29uc3QgZGV0ZWN0VHlwZSA9IHZhbHVlID0+IHtcbiAgICBpZihpc1N0cmluZyh2YWx1ZSkpIHJldHVybiBzdHJpbmc7XG4gICAgaWYoaXNCb29sZWFuKHZhbHVlKSkgcmV0dXJuIGJvb2w7XG4gICAgaWYoaXNOdW1iZXIodmFsdWUpKSByZXR1cm4gbnVtYmVyO1xuICAgIGlmKGlzRGF0ZSh2YWx1ZSkpIHJldHVybiBkYXRldGltZTtcbiAgICBpZihpc0FycmF5KHZhbHVlKSkgcmV0dXJuIGFycmF5KGRldGVjdFR5cGUodmFsdWVbMF0pKTtcbiAgICBpZihpc09iamVjdCh2YWx1ZSkgXG4gICAgICAgJiYgaGFzKHZhbHVlLCBcImtleVwiKVxuICAgICAgICYmIGhhcyh2YWx1ZSwgXCJ2YWx1ZVwiKSkgcmV0dXJuIHJlZmVyZW5jZTtcbiAgICBpZihpc09iamVjdCh2YWx1ZSlcbiAgICAgICAgJiYgaGFzKHZhbHVlLCBcInJlbGF0aXZlUGF0aFwiKVxuICAgICAgICAmJiBoYXModmFsdWUsIFwic2l6ZVwiKSkgcmV0dXJuIGZpbGU7XG4gICAgXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRldGVybWluZSB0eXBlOiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59IiwiaW1wb3J0IHtqb2luS2V5LCAkfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7Y2xvbmUsIGZpbmQsIHNwbGl0fSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcbi8vIDUgbWludXRlc1xyXG5leHBvcnQgY29uc3QgdGVtcENvZGVFeHBpcnlMZW5ndGggPSA1ICogNjAgKiA2MDtcclxuXHJcbmV4cG9ydCBjb25zdCBBVVRIX0ZPTERFUiA9IFwiLy5hdXRoXCI7XHJcbmV4cG9ydCBjb25zdCBVU0VSU19MSVNUX0ZJTEUgPSBqb2luS2V5KEFVVEhfRk9MREVSLCBcInVzZXJzLmpzb25cIik7XHJcbmV4cG9ydCBjb25zdCB1c2VyQXV0aEZpbGU9IHVzZXJuYW1lID0+IGpvaW5LZXkoQVVUSF9GT0xERVIsIGBhdXRoXyR7dXNlcm5hbWV9Lmpzb25gKTtcclxuZXhwb3J0IGNvbnN0IFVTRVJTX0xPQ0tfRklMRSA9IGpvaW5LZXkoQVVUSF9GT0xERVIsIFwidXNlcnNfbG9ja1wiKTtcclxuZXhwb3J0IGNvbnN0IEFDQ0VTU19MRVZFTFNfRklMRSA9IGpvaW5LZXkoQVVUSF9GT0xERVIsIFwiYWNjZXNzX2xldmVscy5qc29uXCIpO1xyXG5leHBvcnQgY29uc3QgQUNDRVNTX0xFVkVMU19MT0NLX0ZJTEUgPSBqb2luS2V5KEFVVEhfRk9MREVSLCBcImFjY2Vzc19sZXZlbHNfbG9ja1wiKTtcclxuXHJcbmV4cG9ydCBjb25zdCBwZXJtaXNzaW9uVHlwZXMgPSB7XHJcbiAgICBDUkVBVEVfUkVDT1JEIDogXCJjcmVhdGUgcmVjb3JkXCIsXHJcbiAgICBVUERBVEVfUkVDT1JEIDogXCJ1cGRhdGUgcmVjb3JkXCIsXHJcbiAgICBSRUFEX1JFQ09SRCA6IFwicmVhZCByZWNvcmRcIixcclxuICAgIERFTEVURV9SRUNPUkQgOiBcImRlbGV0ZSByZWNvcmRcIixcclxuICAgIFJFQURfSU5ERVggOiBcInJlYWQgaW5kZXhcIixcclxuICAgIE1BTkFHRV9JTkRFWCA6IFwibWFuYWdlIGluZGV4XCIsXHJcbiAgICBNQU5BR0VfQ09MTEVDVElPTiA6IFwibWFuYWdlIGNvbGxlY3Rpb25cIixcclxuICAgIFdSSVRFX1RFTVBMQVRFUyA6IFwid3JpdGUgdGVtcGxhdGVzXCIsXHJcbiAgICBDUkVBVEVfVVNFUiA6IFwiY3JlYXRlIHVzZXJcIixcclxuICAgIFNFVF9QQVNTV09SRCA6IFwic2V0IHBhc3N3b3JkXCIsXHJcbiAgICBDUkVBVEVfVEVNUE9SQVJZX0FDQ0VTUyA6IFwiY3JlYXRlIHRlbXBvcmFyeSBhY2Nlc3NcIixcclxuICAgIEVOQUJMRV9ESVNBQkxFX1VTRVIgOiBcImVuYWJsZSBvciBkaXNhYmxlIHVzZXJcIixcclxuICAgIFdSSVRFX0FDQ0VTU19MRVZFTFMgOiBcIndyaXRlIGFjY2VzcyBsZXZlbHNcIixcclxuICAgIExJU1RfVVNFUlMgOiBcImxpc3QgdXNlcnNcIixcclxuICAgIExJU1RfQUNDRVNTX0xFVkVMUyA6IFwibGlzdCBhY2Nlc3MgbGV2ZWxzXCIsXHJcbiAgICBFWEVDVVRFX0FDVElPTiA6IFwiZXhlY3V0ZSBhY3Rpb25cIixcclxuICAgIFNFVF9VU0VSX0FDQ0VTU19MRVZFTFM6IFwic2V0IHVzZXIgYWNjZXNzIGxldmVsc1wiXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRVc2VyQnlOYW1lID0gKHVzZXJzLCBuYW1lKSA9PiAkKHVzZXJzLCBbXHJcbiAgICBmaW5kKHUgPT4gdS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSlcclxuXSk7XHJcblxyXG5leHBvcnQgY29uc3Qgc3RyaXBVc2VyT2ZTZW5zaXRpdmVTdHVmZiA9IHVzZXIgPT4ge1xyXG4gICAgY29uc3Qgc3RyaXBwZWQgPSBjbG9uZSh1c2VyKTtcclxuICAgIGRlbGV0ZSBzdHJpcHBlZC50ZW1wQ29kZTtcclxuICAgIHJldHVybiBzdHJpcHBlZDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlVGVtcG9yYXJ5Q29kZSA9IGZ1bGxDb2RlID0+IFxyXG4gICAgJChmdWxsQ29kZSwgW1xyXG4gICAgICAgIHNwbGl0KFwiOlwiKSxcclxuICAgICAgICBwYXJ0cyA9PiAoe1xyXG4gICAgICAgICAgICBpZDpwYXJ0c1sxXSxcclxuICAgICAgICAgICAgY29kZTpwYXJ0c1syXVxyXG4gICAgICAgIH0pXHJcbiAgICBdKTsiLCJpbXBvcnQge3Blcm1pc3Npb25UeXBlc30gZnJvbSBcIi4vYXV0aENvbW1vblwiO1xyXG5pbXBvcnQge3ZhbHVlcywgaW5jbHVkZXMsIHNvbWV9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHskLCBpc05vdGhpbmcsIGFwaVdyYXBwZXJTeW5jLCBldmVudHN9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHtnZXROb2RlQnlLZXlPck5vZGVLZXksIGlzTm9kZX0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xyXG5pbXBvcnQge2Fsd2F5c0F1dGhvcml6ZWR9IGZyb20gXCIuL3Blcm1pc3Npb25zXCI7XHJcblxyXG5leHBvcnQgY29uc3QgaXNBdXRob3JpemVkID0gKGFwcCkgPT4gKHBlcm1pc3Npb25UeXBlLCByZXNvdXJjZUtleSkgPT4gXHJcbiAgICBhcGlXcmFwcGVyU3luYyhcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgZXZlbnRzLmF1dGhBcGkuaXNBdXRob3JpemVkLCBcclxuICAgICAgICBhbHdheXNBdXRob3JpemVkLFxyXG4gICAgICAgIHtyZXNvdXJjZUtleSwgcGVybWlzc2lvblR5cGV9LFxyXG4gICAgICAgIF9pc0F1dGhvcml6ZWQsIGFwcCwgcGVybWlzc2lvblR5cGUsIHJlc291cmNlS2V5KTtcclxuXHJcbmV4cG9ydCBjb25zdCBfaXNBdXRob3JpemVkID0gIChhcHAsIHBlcm1pc3Npb25UeXBlLCByZXNvdXJjZUtleSkgPT4ge1xyXG4gICAgXHJcbiAgICBpZighYXBwLnVzZXIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdmFsaWRUeXBlID0gJChwZXJtaXNzaW9uVHlwZXMsIFtcclxuICAgICAgICB2YWx1ZXMsXHJcbiAgICAgICAgaW5jbHVkZXMocGVybWlzc2lvblR5cGUpXHJcbiAgICBdKTtcclxuXHJcbiAgICBpZighdmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBlcm1NYXRjaGVzUmVzb3VyY2UgPSB1c2VycGVybSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IG5vZGVLZXkgPSBpc05vdGhpbmcocmVzb3VyY2VLZXkpIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpc05vZGUoYXBwLmhlaXJhcmNoeSwgcmVzb3VyY2VLZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZ2V0Tm9kZUJ5S2V5T3JOb2RlS2V5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwLmhlaXJhcmNoeSwgcmVzb3VyY2VLZXkpLm5vZGVLZXkoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlc291cmNlS2V5O1xyXG5cclxuICAgICAgICByZXR1cm4gKHVzZXJwZXJtLnR5cGUgPT09IHBlcm1pc3Npb25UeXBlKVxyXG4gICAgICAgICYmXHJcbiAgICAgICAgKFxyXG4gICAgICAgICAgICBpc05vdGhpbmcocmVzb3VyY2VLZXkpXHJcbiAgICAgICAgICAgIHx8XHJcbiAgICAgICAgICAgIG5vZGVLZXkgPT09IHVzZXJwZXJtLm5vZGVLZXlcclxuICAgICAgICApOyAgICBcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJChhcHAudXNlci5wZXJtaXNzaW9ucywgW1xyXG4gICAgICAgIHNvbWUocGVybU1hdGNoZXNSZXNvdXJjZSlcclxuICAgIF0pO1xyXG4gICAgXHJcbn07IiwiaW1wb3J0IHtwZXJtaXNzaW9uVHlwZXN9IGZyb20gXCIuL2F1dGhDb21tb25cIjtcclxuaW1wb3J0IHtpc0F1dGhvcml6ZWR9IGZyb20gXCIuL2lzQXV0aG9yaXplZFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IHRlbXBvcmFyeUFjY2Vzc1Blcm1pc3Npb25zID0gKCkgPT5cclxuICAgIChbe3R5cGU6cGVybWlzc2lvblR5cGVzLlNFVF9QQVNTV09SRH1dKTtcclxuXHJcbmNvbnN0IG5vZGVQZXJtaXNzaW9uID0gKHR5cGUpID0+ICh7XHJcbiAgICBhZGQgOiAobm9kZUtleSwgYWNjZXNzTGV2ZWwpID0+IGFjY2Vzc0xldmVsLnBlcm1pc3Npb25zLnB1c2goe3R5cGUsIG5vZGVLZXl9KSxcclxuICAgIGlzQXV0aG9yaXplZDogcmVzb3VyY2VLZXkgPT4gYXBwID0+IGlzQXV0aG9yaXplZChhcHApKHR5cGUsIHJlc291cmNlS2V5KSxcclxuICAgIGlzTm9kZTp0cnVlLFxyXG4gICAgZ2V0OiBub2RlS2V5ID0+ICh7dHlwZSwgbm9kZUtleX0pXHJcbn0pO1xyXG5cclxuY29uc3Qgc3RhdGljUGVybWlzc2lvbiA9ICh0eXBlKSA9PiAoe1xyXG4gICAgYWRkIDogYWNjZXNzTGV2ZWwgPT4gYWNjZXNzTGV2ZWwucGVybWlzc2lvbnMucHVzaCh7dHlwZX0pLFxyXG4gICAgaXNBdXRob3JpemVkOiBhcHAgPT4gaXNBdXRob3JpemVkKGFwcCkodHlwZSksXHJcbiAgICBpc05vZGU6ZmFsc2UsXHJcbiAgICBnZXQ6ICgpID0+ICh7dHlwZX0pXHJcbn0pO1xyXG5cclxuY29uc3QgY3JlYXRlUmVjb3JkID0gbm9kZVBlcm1pc3Npb24ocGVybWlzc2lvblR5cGVzLkNSRUFURV9SRUNPUkQpO1xyXG5cclxuY29uc3QgdXBkYXRlUmVjb3JkID0gbm9kZVBlcm1pc3Npb24ocGVybWlzc2lvblR5cGVzLlVQREFURV9SRUNPUkQpO1xyXG5cclxuY29uc3QgZGVsZXRlUmVjb3JkID0gbm9kZVBlcm1pc3Npb24ocGVybWlzc2lvblR5cGVzLkRFTEVURV9SRUNPUkQpO1xyXG5cclxuY29uc3QgcmVhZFJlY29yZCA9IG5vZGVQZXJtaXNzaW9uKHBlcm1pc3Npb25UeXBlcy5SRUFEX1JFQ09SRCk7XHJcblxyXG5jb25zdCB3cml0ZVRlbXBsYXRlcyA9IHN0YXRpY1Blcm1pc3Npb24ocGVybWlzc2lvblR5cGVzLldSSVRFX1RFTVBMQVRFUyk7XHJcblxyXG5jb25zdCBjcmVhdGVVc2VyID0gc3RhdGljUGVybWlzc2lvbihwZXJtaXNzaW9uVHlwZXMuQ1JFQVRFX1VTRVIpO1xyXG5cclxuY29uc3Qgc2V0UGFzc3dvcmQgPSBzdGF0aWNQZXJtaXNzaW9uKHBlcm1pc3Npb25UeXBlcy5TRVRfUEFTU1dPUkQpO1xyXG5cclxuY29uc3QgcmVhZEluZGV4ID0gbm9kZVBlcm1pc3Npb24ocGVybWlzc2lvblR5cGVzLlJFQURfSU5ERVgpO1xyXG5cclxuY29uc3QgbWFuYWdlSW5kZXggPSBzdGF0aWNQZXJtaXNzaW9uKHBlcm1pc3Npb25UeXBlcy5NQU5BR0VfSU5ERVgpO1xyXG5cclxuY29uc3QgbWFuYWdlQ29sbGVjdGlvbiA9IHN0YXRpY1Blcm1pc3Npb24ocGVybWlzc2lvblR5cGVzLk1BTkFHRV9DT0xMRUNUSU9OKVxyXG5cclxuY29uc3QgY3JlYXRlVGVtcG9yYXJ5QWNjZXNzID0gc3RhdGljUGVybWlzc2lvbihwZXJtaXNzaW9uVHlwZXMuQ1JFQVRFX1RFTVBPUkFSWV9BQ0NFU1MpO1xyXG5cclxuY29uc3QgZW5hYmxlRGlzYWJsZVVzZXIgPSBzdGF0aWNQZXJtaXNzaW9uKHBlcm1pc3Npb25UeXBlcy5FTkFCTEVfRElTQUJMRV9VU0VSKTtcclxuXHJcbmNvbnN0IHdyaXRlQWNjZXNzTGV2ZWxzID0gc3RhdGljUGVybWlzc2lvbihwZXJtaXNzaW9uVHlwZXMuV1JJVEVfQUNDRVNTX0xFVkVMUyk7XHJcblxyXG5jb25zdCBsaXN0VXNlcnMgPSBzdGF0aWNQZXJtaXNzaW9uKHBlcm1pc3Npb25UeXBlcy5MSVNUX1VTRVJTKTtcclxuXHJcbmNvbnN0IGxpc3RBY2Nlc3NMZXZlbHMgPSBzdGF0aWNQZXJtaXNzaW9uKHBlcm1pc3Npb25UeXBlcy5MSVNUX0FDQ0VTU19MRVZFTFMpO1xyXG5cclxuY29uc3Qgc2V0VXNlckFjY2Vzc0xldmVscyA9IHN0YXRpY1Blcm1pc3Npb24ocGVybWlzc2lvblR5cGVzLlNFVF9VU0VSX0FDQ0VTU19MRVZFTFMpO1xyXG5cclxuY29uc3QgZXhlY3V0ZUFjdGlvbiA9IG5vZGVQZXJtaXNzaW9uKHBlcm1pc3Npb25UeXBlcy5FWEVDVVRFX0FDVElPTik7XHJcblxyXG5leHBvcnQgY29uc3QgYWx3YXlzQXV0aG9yaXplZCA9ICgpID0+IHRydWU7XHJcblxyXG5leHBvcnQgY29uc3QgcGVybWlzc2lvbiA9IHtcclxuICAgIGNyZWF0ZVJlY29yZCwgdXBkYXRlUmVjb3JkLCBkZWxldGVSZWNvcmQsXHJcbiAgICByZWFkUmVjb3JkLCB3cml0ZVRlbXBsYXRlcywgY3JlYXRlVXNlcixcclxuICAgIHNldFBhc3N3b3JkLCByZWFkSW5kZXgsIGNyZWF0ZVRlbXBvcmFyeUFjY2VzcyxcclxuICAgIGVuYWJsZURpc2FibGVVc2VyLCB3cml0ZUFjY2Vzc0xldmVscywgbGlzdFVzZXJzLFxyXG4gICAgbGlzdEFjY2Vzc0xldmVscywgbWFuYWdlSW5kZXgsIG1hbmFnZUNvbGxlY3Rpb24sXHJcbiAgICBleGVjdXRlQWN0aW9uLCBzZXRVc2VyQWNjZXNzTGV2ZWxzXHJcbn07IiwiaW1wb3J0IHtnZXROb2RlRm9yQ29sbGVjdGlvblBhdGh9IGZyb20gXCIuLi90ZW1wbGF0ZUFwaS9oZWlyYXJjaHlcIjtcbmltcG9ydCB7Z2V0TmV3RmllbGRWYWx1ZX0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQge2ZpbmQsIGtleUJ5LCBtYXBWYWx1ZXMsIGNvbnN0YW50fSBmcm9tIFwibG9kYXNoL2ZwXCI7XG5pbXBvcnQgeyQsIGpvaW5LZXksIHNhZmVLZXksIGFwaVdyYXBwZXJTeW5jLCBldmVudHN9IGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7Z2VuZXJhdGV9IGZyb20gXCJzaG9ydGlkXCI7XG5pbXBvcnQge3Blcm1pc3Npb259IGZyb20gXCIuLi9hdXRoQXBpL3Blcm1pc3Npb25zXCI7XG5cbmV4cG9ydCBjb25zdCBnZXROZXcgPSBhcHAgPT4gKGNvbGxlY3Rpb25LZXksIHJlY29yZFR5cGVOYW1lKSA9PiB7XG4gICAgY29uc3QgcmVjb3JkTm9kZSA9IGdldFJlY29yZE5vZGUoYXBwLCBjb2xsZWN0aW9uS2V5LCByZWNvcmRUeXBlTmFtZSk7XG4gICAgcmV0dXJuIGFwaVdyYXBwZXJTeW5jKFxuICAgICAgICBhcHAsXG4gICAgICAgIGV2ZW50cy5yZWNvcmRBcGkuZ2V0TmV3LCBcbiAgICAgICAgcGVybWlzc2lvbi5jcmVhdGVSZWNvcmQuaXNBdXRob3JpemVkKHJlY29yZE5vZGUubm9kZUtleSgpKSxcbiAgICAgICAge2NvbGxlY3Rpb25LZXksIHJlY29yZFR5cGVOYW1lfSxcbiAgICAgICAgX2dldE5ldywgcmVjb3JkTm9kZSwgY29sbGVjdGlvbktleSk7XG59XG5cbmNvbnN0IF9nZXROZXcgPSAocmVjb3JkTm9kZSwgY29sbGVjdGlvbktleSkgPT4gXG4gICAgY29uc3RydWN0UmVjb3JkKHJlY29yZE5vZGUsIGdldE5ld0ZpZWxkVmFsdWUsIGNvbGxlY3Rpb25LZXkpO1xuXG5jb25zdCBnZXRSZWNvcmROb2RlID0gKGFwcCwgY29sbGVjdGlvbktleSwgcmVjb3JkVHlwZU5hbWUpID0+IHtcbiAgICBjb2xsZWN0aW9uS2V5ID0gc2FmZUtleShjb2xsZWN0aW9uS2V5KTtcbiAgICByZXR1cm4gZ2V0Tm9kZUZvckNvbGxlY3Rpb25QYXRoKGFwcC5oZWlyYXJjaHkpKGNvbGxlY3Rpb25LZXkpO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0TmV3Q2hpbGQgPSAoYXBwKSA9PiBcbiAgICAgICAgKHJlY29yZEtleSwgY29sbGVjdGlvbk5hbWUsIHJlY29yZFR5cGVOYW1lKSA9PiBcbiAgICBnZXROZXcoYXBwKShqb2luS2V5KHJlY29yZEtleSwgY29sbGVjdGlvbk5hbWUpLCByZWNvcmRUeXBlTmFtZSk7XG5cbmV4cG9ydCBjb25zdCBjb25zdHJ1Y3RSZWNvcmQgPSAocmVjb3JkTm9kZSwgZ2V0RmllbGRWYWx1ZSwgY29sbGVjdGlvbktleSkgPT4ge1xuICAgIGNvbnN0IHJlY29yZCA9ICQocmVjb3JkTm9kZS5maWVsZHMsIFtcbiAgICAgICAga2V5QnkoXCJuYW1lXCIpLFxuICAgICAgICBtYXBWYWx1ZXMoZ2V0RmllbGRWYWx1ZSlcbiAgICBdKTtcblxuICAgIHJlY29yZC5pZCA9IGAke3JlY29yZE5vZGUubm9kZUlkfS0ke2dlbmVyYXRlKCl9YDtcbiAgICByZWNvcmQua2V5ID0gam9pbktleShjb2xsZWN0aW9uS2V5LCByZWNvcmQuaWQpO1xuICAgIHJlY29yZC5pc05ldyA9IHRydWU7XG4gICAgcmVjb3JkLnR5cGUgPSByZWNvcmROb2RlLm5hbWU7XG4gICAgcmV0dXJuIHJlY29yZDtcbn07XG4iLCJpbXBvcnQge2dldEV4YWN0Tm9kZUZvclBhdGh9IGZyb20gXCIuLi90ZW1wbGF0ZUFwaS9oZWlyYXJjaHlcIjtcbmltcG9ydCB7c2FmZVBhcnNlRmllbGR9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHtrZXlCeSwgbWFwVmFsdWVzLCBmaWx0ZXIsIG1hcCwgaW5jbHVkZXMsXG4gICAgICAgIGNvbnN0YW50LCBsYXN0fSBmcm9tIFwibG9kYXNoL2ZwXCI7XG5pbXBvcnQgeyQsIHNwbGl0S2V5LCBzYWZlS2V5LCBpc05vbkVtcHR5U3RyaW5nLFxuICAgIGFwaVdyYXBwZXIsIGV2ZW50cywgam9pbktleX0gZnJvbSBcIi4uL2NvbW1vblwiO1xuaW1wb3J0IHttYXBSZWNvcmR9IGZyb20gXCIuLi9pbmRleGluZy9ldmFsdWF0ZVwiO1xuaW1wb3J0IHtwZXJtaXNzaW9ufSBmcm9tIFwiLi4vYXV0aEFwaS9wZXJtaXNzaW9uc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0UmVjb3JkRmlsZU5hbWUgPSBrZXkgPT4gXG4gICAgam9pbktleShrZXksIFwicmVjb3JkLmpzb25cIik7XG5cbmV4cG9ydCBjb25zdCBsb2FkID0gKGFwcCkgPT4gYXN5bmMga2V5ID0+IFxuICAgIGFwaVdyYXBwZXIoXG4gICAgICAgIGFwcCxcbiAgICAgICAgZXZlbnRzLnJlY29yZEFwaS5sb2FkLCBcbiAgICAgICAgcGVybWlzc2lvbi5yZWFkUmVjb3JkLmlzQXV0aG9yaXplZChrZXkpLFxuICAgICAgICB7a2V5fSxcbiAgICAgICAgX2xvYWQsIGFwcCwga2V5KTtcblxuZXhwb3J0IGNvbnN0IF9sb2FkID0gYXN5bmMgKGFwcCwga2V5LCBrZXlTdGFjaz1bXSkgPT4ge1xuICAgIGtleSA9IHNhZmVLZXkoa2V5KTtcbiAgICBjb25zdCByZWNvcmROb2RlID0gZ2V0RXhhY3ROb2RlRm9yUGF0aChhcHAuaGVpcmFyY2h5KShrZXkpO1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBhd2FpdCBhcHAuZGF0YXN0b3JlLmxvYWRKc29uKFxuICAgICAgICBnZXRSZWNvcmRGaWxlTmFtZShrZXkpXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCB7dHlwZX0gPSBzdG9yZWREYXRhO1xuXG4gICAgY29uc3QgbG9hZGVkUmVjb3JkID0gJChyZWNvcmROb2RlLmZpZWxkcywgW1xuICAgICAgICBrZXlCeShcIm5hbWVcIiksXG4gICAgICAgIG1hcFZhbHVlcyhmID0+IHNhZmVQYXJzZUZpZWxkKGYsIHN0b3JlZERhdGEpKVxuICAgIF0pO1xuXG4gICAgY29uc3QgbmV3S2V5U3RhY2sgPSBbLi4ua2V5U3RhY2ssIGtleV07XG5cbiAgICBjb25zdCByZWZlcmVuY2VzID0gJChyZWNvcmROb2RlLmZpZWxkcywgW1xuICAgICAgICBmaWx0ZXIoZiA9PiBmLnR5cGUgPT09IFwicmVmZXJlbmNlXCIgXG4gICAgICAgICAgICAgICAgICAgICYmIGlzTm9uRW1wdHlTdHJpbmcobG9hZGVkUmVjb3JkW2YubmFtZV0ua2V5KVxuICAgICAgICAgICAgICAgICAgICAmJiAhaW5jbHVkZXMobG9hZGVkUmVjb3JkW2YubmFtZV0ua2V5KShuZXdLZXlTdGFjaykpLFxuICAgICAgICBtYXAoZiA9PiAoe1xuICAgICAgICAgICAgcHJvbWlzZTpfbG9hZChhcHAsIGxvYWRlZFJlY29yZFtmLm5hbWVdLmtleSwgbmV3S2V5U3RhY2spLFxuICAgICAgICAgICAgaW5kZXg6IGdldEV4YWN0Tm9kZUZvclBhdGgoYXBwLmhlaXJhcmNoeSkoZi50eXBlT3B0aW9ucy5pbmRleE5vZGVLZXkpLFxuICAgICAgICAgICAgZmllbGQ6IGZcbiAgICAgICAgfSkpXG4gICAgXSk7XG5cbiAgICBpZihyZWZlcmVuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcmVmUmVjb3JkcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgbWFwKHAgPT4gcC5wcm9taXNlKShyZWZlcmVuY2VzKVxuICAgICAgICApO1xuXG4gICAgICAgIGZvcihsZXQgcmVmIG9mIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGxvYWRlZFJlY29yZFtyZWYuZmllbGQubmFtZV0gPSBtYXBSZWNvcmQoXG4gICAgICAgICAgICAgICAgcmVmUmVjb3Jkc1tyZWZlcmVuY2VzLmluZGV4T2YocmVmKV0sIFxuICAgICAgICAgICAgICAgIHJlZi5pbmRleFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRlZFJlY29yZC50cmFuc2FjdGlvbklkID0gc3RvcmVkRGF0YS50cmFuc2FjdGlvbklkO1xuICAgIGxvYWRlZFJlY29yZC5pc05ldyA9IGZhbHNlO1xuICAgIGxvYWRlZFJlY29yZC5rZXkgPSBrZXk7XG4gICAgbG9hZGVkUmVjb3JkLmlkID0gJChrZXksIFtzcGxpdEtleSwgbGFzdF0pO1xuICAgIGxvYWRlZFJlY29yZC50eXBlID0gcmVjb3JkTm9kZS5uYW1lO1xuICAgIHJldHVybiBsb2FkZWRSZWNvcmQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBsb2FkOyIsImltcG9ydCB7Z2V0QWN0dWFsS2V5T2ZQYXJlbnQsIGlzR2xvYmFsSW5kZXgsIFxyXG4gICAgICAgIGdldFBhcmVudEtleSAsaXNTaGFyZGVkSW5kZXgsXHJcbiAgICAgICAgZ2V0RXhhY3ROb2RlRm9yUGF0aH0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xyXG5pbXBvcnQge2pvaW5LZXksIGlzTm9uRW1wdHlTdHJpbmcsIHNwbGl0S2V5LCAkfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7Y29tcGlsZUNvZGV9IGZyb20gXCJAbngtanMvY29tcGlsZXItdXRpbFwiO1xyXG5pbXBvcnQge2ZpbHRlciwgaW5jbHVkZXMsIG1hcCwgbGFzdH0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEluZGV4ZWREYXRhS2V5ID0gKGluZGV4Tm9kZSwgaW5kZXhLZXksIHJlY29yZCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IGdldFNoYXJkTmFtZSA9IChpbmRleE5vZGUsIHJlY29yZCkgPT4gXHJcbiAgICAgICAgY29tcGlsZUNvZGUoaW5kZXhOb2RlLmdldFNoYXJkTmFtZSkoe3JlY29yZH0pO1xyXG4gICAgXHJcbiAgICBjb25zdCBzaGFyZE5hbWUgPSBpc05vbkVtcHR5U3RyaW5nKGluZGV4Tm9kZS5nZXRTaGFyZE5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IGAke2dldFNoYXJkTmFtZShpbmRleE5vZGUsIHJlY29yZCl9LmNzdmBcclxuICAgICAgICAgICAgICAgICAgICAgIDogXCJpbmRleC5jc3ZcIjtcclxuICAgICAgICBcclxuICAgIHJldHVybiBqb2luS2V5KGluZGV4S2V5LCBzaGFyZE5hbWUpOyAgICBcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldFNoYXJkS2V5c0luUmFuZ2UgPSBhc3luYyAoYXBwLCBpbmRleEtleSwgc3RhcnRSZWNvcmQ9bnVsbCwgZW5kUmVjb3JkPW51bGwpID0+IHtcclxuXHJcbiAgICBjb25zdCBpbmRleE5vZGUgPSBnZXRFeGFjdE5vZGVGb3JQYXRoKGFwcC5oZWlyYXJjaHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGluZGV4S2V5KTtcclxuXHJcbiAgICBjb25zdCBzdGFydFNoYXJkTmFtZSA9ICFzdGFydFJlY29yZCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNoYXJkTmFtZUZyb21LZXkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXhlZERhdGFLZXkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Tm9kZSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4S2V5LCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRSZWNvcmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICBjb25zdCBlbmRTaGFyZE5hbWUgPSAhZW5kUmVjb3JkIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgOiBzaGFyZE5hbWVGcm9tS2V5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXhlZERhdGFLZXkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhOb2RlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEtleSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUmVjb3JkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgIHJldHVybiAkKGF3YWl0IGdldFNoYXJkTWFwKGFwcC5kYXRhc3RvcmUsIGluZGV4S2V5KSxbXHJcbiAgICAgICAgZmlsdGVyKGsgPT4gKHN0YXJ0UmVjb3JkID09PSBudWxsIHx8IGsgPj0gc3RhcnRTaGFyZE5hbWUpIFxyXG4gICAgICAgICAgICAgICAgICAgICYmIChlbmRSZWNvcmQgPT09IG51bGwgfHwgayA8PSBlbmRTaGFyZE5hbWUpKSxcclxuICAgICAgICBtYXAoayA9PiBqb2luS2V5KGluZGV4S2V5LCBrICsgXCIuY3N2XCIpKVxyXG4gICAgXSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZW5zdXJlU2hhcmROYW1lSXNJblNoYXJkTWFwID0gYXN5bmMgKHN0b3JlLCBpbmRleEtleSwgaW5kZXhlZERhdGFLZXkpID0+IHtcclxuICAgIGNvbnN0IG1hcCA9IGF3YWl0IGdldFNoYXJkTWFwKHN0b3JlLCBpbmRleEtleSk7XHJcbiAgICBjb25zdCBzaGFyZE5hbWUgPSBzaGFyZE5hbWVGcm9tS2V5KGluZGV4ZWREYXRhS2V5KTtcclxuICAgIGlmKCFpbmNsdWRlcyhzaGFyZE5hbWUpKG1hcCkpIHtcclxuICAgICAgICBtYXAucHVzaChzaGFyZE5hbWUpO1xyXG4gICAgICAgIGF3YWl0IHdyaXRlU2hhcmRNYXAoc3RvcmUsIGluZGV4S2V5LCBtYXApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0U2hhcmRNYXAgPSBhc3luYyAoZGF0YXN0b3JlLCBpbmRleEtleSkgPT4ge1xyXG4gICAgY29uc3Qgc2hhcmRNYXBLZXkgPSBnZXRTaGFyZE1hcEtleShpbmRleEtleSk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBkYXRhc3RvcmUubG9hZEpzb24oc2hhcmRNYXBLZXkpO1xyXG4gICAgfSBjYXRjaChfKSB7XHJcbiAgICAgICAgYXdhaXQgZGF0YXN0b3JlLmNyZWF0ZUpzb24oc2hhcmRNYXBLZXksIFtdKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB3cml0ZVNoYXJkTWFwID0gYXN5bmMgKGRhdGFzdG9yZSwgaW5kZXhLZXksIHNoYXJkTWFwKSA9PiBcclxuICAgIGF3YWl0IGRhdGFzdG9yZS51cGRhdGVKc29uKFxyXG4gICAgICAgIGdldFNoYXJkTWFwS2V5KGluZGV4S2V5KSxcclxuICAgICAgICBzaGFyZE1hcFxyXG4gICAgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRBbGxTaGFyZEtleXMgPSBhc3luYyAoYXBwLCBpbmRleEtleSkgPT4gXHJcbiAgICBhd2FpdCBnZXRTaGFyZEtleXNJblJhbmdlKGFwcCwgaW5kZXhLZXkpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFNoYXJkTWFwS2V5ID0gaW5kZXhLZXkgPT4gXHJcbiAgICBqb2luS2V5KGluZGV4S2V5LCBcInNoYXJkTWFwLmpzb25cIik7XHJcbiAgICBcclxuZXhwb3J0IGNvbnN0IGdldFVuc2hhcmRlZEluZGV4RGF0YUtleSA9IGluZGV4S2V5ID0+XHJcbiAgICBqb2luS2V5KGluZGV4S2V5LCBcImluZGV4LmNzdlwiKTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRJbmRleEZvbGRlcktleSA9IGluZGV4S2V5ID0+IGluZGV4S2V5O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUluZGV4RmlsZSA9IGFzeW5jIChkYXRhc3RvcmUsIGluZGV4ZWREYXRhS2V5LCBpbmRleCkgPT4ge1xyXG4gICAgaWYoaXNTaGFyZGVkSW5kZXgoaW5kZXgpKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhLZXkgPSBnZXRQYXJlbnRLZXkoaW5kZXhlZERhdGFLZXkpO1xyXG4gICAgICAgIGNvbnN0IHNoYXJkTWFwID0gYXdhaXQgZ2V0U2hhcmRNYXAoZGF0YXN0b3JlLCBpbmRleEtleSk7XHJcbiAgICAgICAgc2hhcmRNYXAucHVzaChcclxuICAgICAgICAgICAgc2hhcmROYW1lRnJvbUtleShpbmRleGVkRGF0YUtleSlcclxuICAgICAgICApO1xyXG4gICAgICAgIGF3YWl0IHdyaXRlU2hhcmRNYXAoZGF0YXN0b3JlLCBpbmRleEtleSwgc2hhcmRNYXApO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgZGF0YXN0b3JlLmNyZWF0ZUZpbGUoaW5kZXhlZERhdGFLZXksIFwiXCIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNoYXJkTmFtZUZyb21LZXkgPSBrZXkgPT4gXHJcbiAgICAkKGtleSxbXHJcbiAgICAgICAgc3BsaXRLZXksXHJcbiAgICAgICAgbGFzdFxyXG4gICAgXSkucmVwbGFjZShcIi5jc3ZcIixcIlwiKTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRJbmRleEtleV9CYXNlZE9uRGVjZW5kYW50ID0gKGRlY2VuZGFudEtleSwgaW5kZXhOb2RlKSA9PiB7XHJcblxyXG4gICAgaWYoaXNHbG9iYWxJbmRleChpbmRleE5vZGUpKVxyXG4gICAgICAgIHJldHVybiBgJHtpbmRleE5vZGUubm9kZUtleSgpfWBcclxuXHJcbiAgICBjb25zdCBpbmRleGVkRGF0YVBhcmVudEtleSA9IFxyXG4gICAgICAgICAgICBnZXRBY3R1YWxLZXlPZlBhcmVudChcclxuICAgICAgICAgICAgICAgIGluZGV4Tm9kZS5wYXJlbnQoKS5ub2RlS2V5KCkgICAgXHJcbiAgICAgICAgICAgICAgICAsZGVjZW5kYW50S2V5KTtcclxuXHJcbiAgICByZXR1cm4gam9pbktleShcclxuICAgICAgICBpbmRleGVkRGF0YVBhcmVudEtleSxcclxuICAgICAgICBpbmRleE5vZGUubmFtZVxyXG4gICAgKTtcclxufTtcclxuIiwiaW1wb3J0IHtnZXRBbGxvd2VkUmVjb3JkTm9kZXNGb3JJbmRleH0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xyXG5pbXBvcnQge21hcFJlY29yZH0gZnJvbSBcIi4vZXZhbHVhdGVcIjtcclxuaW1wb3J0IHtjb25zdHJ1Y3RSZWNvcmR9IGZyb20gXCIuLi9yZWNvcmRBcGkvZ2V0TmV3XCI7XHJcbmltcG9ydCB7Z2V0U2FtcGxlRmllbGRWYWx1ZSwgZGV0ZWN0VHlwZSwgYWxsfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHskfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7aGFzLCBrZXlzLCBtYXAsIG9yZGVyQnksIFxyXG4gICAgICAgIGZpbHRlciwgY29uY2F0LCByZXZlcnNlfSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVTY2hlbWEgPSAoaGVpcmFyY2h5LCBpbmRleE5vZGUpID0+IHtcclxuXHJcbiAgICBjb25zdCByZWNvcmROb2RlcyA9IGdldEFsbG93ZWRSZWNvcmROb2Rlc0ZvckluZGV4KGhlaXJhcmNoeSwgaW5kZXhOb2RlKTtcclxuICAgIGNvbnN0IG1hcHBlZFJlY29yZHMgPSAkKHJlY29yZE5vZGVzLCBbXHJcbiAgICAgICAgbWFwKG4gPT4gbWFwUmVjb3JkKGNyZWF0ZVNhbXBsZVJlY29yZChuKSwgaW5kZXhOb2RlKSksXHJcbiAgICBdKTtcclxuXHJcbiAgICAvLyBhbHdheXMgaGFzIHJlY29yZCBrZXkgYW5kIHNvcnQga2V5XHJcbiAgICBjb25zdCBzY2hlbWEgPSB7XHJcbiAgICAgICAgc29ydEtleTphbGwuc3RyaW5nLFxyXG4gICAgICAgIGtleTogYWxsLnN0cmluZyxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZmllbGRzSGFzID0gaGFzKHNjaGVtYSk7XHJcbiAgICBjb25zdCBzZXRGaWVsZCA9IChmaWVsZE5hbWUsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgaWYodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICBjb25zdCB0aGlzVHlwZSA9IGRldGVjdFR5cGUodmFsdWUpO1xyXG4gICAgICAgIGlmKGZpZWxkc0hhcyhmaWVsZE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGlmKHNjaGVtYVtmaWVsZE5hbWVdICE9PSB0aGlzVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgc2NoZW1hW2ZpZWxkTmFtZV0gPSBhbGwuc3RyaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2NoZW1hW2ZpZWxkTmFtZV0gPSB0aGlzVHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZvcihsZXQgbWFwcGVkUmVjIG9mIG1hcHBlZFJlY29yZHMpIHtcclxuICAgICAgICBmb3IobGV0IGYgaW4gbWFwcGVkUmVjKSB7XHJcbiAgICAgICAgICAgIHNldEZpZWxkKGYsIG1hcHBlZFJlY1tmXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHJldHVyaW5nIGFuIGFycmF5IG9mIHtuYW1lLCB0eXBlfVxyXG4gICAgcmV0dXJuICQoc2NoZW1hLCBbXHJcbiAgICAgICAga2V5cyxcclxuICAgICAgICBtYXAoayA9PiAoe25hbWU6aywgdHlwZTpzY2hlbWFba10ubmFtZX0pKSxcclxuICAgICAgICBmaWx0ZXIocyA9PiBzLm5hbWUgIT09IFwic29ydEtleVwiKSwgXHJcbiAgICAgICAgb3JkZXJCeShcIm5hbWVcIiwgW1wiZGVzY1wiXSksIC8vIHJldmVyc2UgYXBsaGFcclxuICAgICAgICBjb25jYXQoW3tuYW1lOlwic29ydEtleVwiLHR5cGU6YWxsLnN0cmluZy5uYW1lfV0pLCAvLyBzb3J0S2V5IG9uIGVuZFxyXG4gICAgICAgIHJldmVyc2UgLy8gc29ydEtleSBmaXJzdCwgdGhlbiByZXN0IGFyZSBhbHBoYWJldGljYWxcclxuICAgIF0pO1xyXG5cclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZVNhbXBsZVJlY29yZCA9IHJlY29yZE5vZGUgPT4gXHJcbiAgICBjb25zdHJ1Y3RSZWNvcmQoXHJcbiAgICAgICAgcmVjb3JkTm9kZSwgXHJcbiAgICAgICAgZ2V0U2FtcGxlRmllbGRWYWx1ZSwgXHJcbiAgICAgICAgcmVjb3JkTm9kZS5wYXJlbnQoKS5ub2RlS2V5KCkpOyIsImltcG9ydCB7Z2VuZXJhdGVTY2hlbWF9IGZyb20gXCIuL2luZGV4U2NoZW1hQ3JlYXRvclwiO1xyXG5pbXBvcnQgeyBoYXMsIGlzU3RyaW5nLCBkaWZmZXJlbmNlLCBmaW5kIH0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwic2FmZS1idWZmZXJcIjtcclxuaW1wb3J0IHtTdHJpbmdEZWNvZGVyfSBmcm9tIFwic3RyaW5nX2RlY29kZXJcIjtcclxuaW1wb3J0IHtnZXRUeXBlfSBmcm9tIFwiLi4vdHlwZXNcIjtcclxuaW1wb3J0IHsgaXNTb21ldGhpbmcgfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcblxyXG5leHBvcnQgY29uc3QgQlVGRkVSX01BWF9CWVRFUyA9IDUyNDI4ODsgLy8gMC41TWJcclxuXHJcbmV4cG9ydCBjb25zdCBDT05USU5VRV9SRUFESU5HX1JFQ09SRFMgPSBcIkNPTlRJTlVFX1JFQURJTkdcIjtcclxuZXhwb3J0IGNvbnN0IFJFQURfUkVNQUlOSU5HX1RFWFQgPSBcIlJFQURfUkVNQUlOSU5HXCI7XHJcbmV4cG9ydCBjb25zdCBDQU5DRUxfUkVBRCA9IFwiQ0FOQ0VMXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0SW5kZXhXcml0ZXIgPSAoaGVpcmFyY2h5LCBpbmRleE5vZGUsIGdldE5leHRJbnB1dEJ5dGVzLCBmbHVzaE91dHB1dEJ1ZmZlcikgPT4ge1xyXG4gICAgY29uc3Qgc2NoZW1hID0gZ2VuZXJhdGVTY2hlbWEoaGVpcmFyY2h5LCBpbmRleE5vZGUpO1xyXG5cclxuICAgIHJldHVybiAoe1xyXG4gICAgICAgIHJlYWQ6IHJlYWQoZ2V0TmV4dElucHV0Qnl0ZXMsIHNjaGVtYSksXHJcbiAgICAgICAgdXBkYXRlSW5kZXg6IHVwZGF0ZUluZGV4KGdldE5leHRJbnB1dEJ5dGVzLCBmbHVzaE91dHB1dEJ1ZmZlciwgc2NoZW1hKVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0SW5kZXhSZWFkZXIgPSAoaGVpcmFyY2h5LCBpbmRleE5vZGUsIGdldE5leHRJbnB1dEJ5dGVzKSA9PiBcclxuICAgIHJlYWQoXHJcbiAgICAgICAgZ2V0TmV4dElucHV0Qnl0ZXMsIFxyXG4gICAgICAgIGdlbmVyYXRlU2NoZW1hKGhlaXJhcmNoeSwgaW5kZXhOb2RlKVxyXG4gICAgKTtcclxuXHJcbmNvbnN0IHVwZGF0ZUluZGV4ID0gKGdldE5leHRJbnB1dEJ5dGVzLCBmbHVzaE91dHB1dEJ1ZmZlciwgc2NoZW1hKSA9PiAoaXRlbXNUb1dyaXRlLCBrZXlzVG9SZW1vdmUpID0+IHtcclxuICAgIGNvbnN0IHdyaXRlID0gbmV3T3V0cHV0V3JpdGVyKEJVRkZFUl9NQVhfQllURVMsIGZsdXNoT3V0cHV0QnVmZmVyKTtcclxuICAgIGNvbnN0IHdyaXR0ZW5JdGVtcyA9IFtdOyBcclxuICAgIHJlYWQoZ2V0TmV4dElucHV0Qnl0ZXMsIHNjaGVtYSkoXHJcbiAgICAgICAgaW5kZXhlZEl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkID0gZmluZChpID0+IGluZGV4ZWRJdGVtLmtleSA9PT0gaS5rZXkpKGl0ZW1zVG9Xcml0ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSBmaW5kKGsgPT4gaW5kZXhlZEl0ZW0ua2V5ID09PSBrKShrZXlzVG9SZW1vdmUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYoaXNTb21ldGhpbmcocmVtb3ZlZCkpIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTlRJTlVFX1JFQURJTkdfUkVDT1JEUztcclxuXHJcbiAgICAgICAgICAgIGlmKGlzU29tZXRoaW5nKHVwZGF0ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkSXRlbSA9ICBzZXJpYWxpemVJdGVtKHNjaGVtYSwgdXBkYXRlZCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZShzZXJpYWxpemVkSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB3cml0dGVuSXRlbXMucHVzaCh1cGRhdGVkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlKFxyXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUl0ZW0oc2NoZW1hLCBpbmRleGVkSXRlbSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQ09OVElOVUVfUkVBRElOR19SRUNPUkRTO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIHRleHQgPT4gd3JpdGUodGV4dClcclxuICAgICk7XHJcblxyXG4gICAgaWYod3JpdHRlbkl0ZW1zLmxlbmd0aCAhPT0gaXRlbXNUb1dyaXRlLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHRvQWRkID0gZGlmZmVyZW5jZShpdGVtc1RvV3JpdGUsIHdyaXR0ZW5JdGVtcyk7XHJcbiAgICAgICAgZm9yKGxldCBhZGRlZCBvZiB0b0FkZCkge1xyXG4gICAgICAgICAgICB3cml0ZShcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUl0ZW0oc2NoZW1hLCBhZGRlZClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYod3JpdHRlbkl0ZW1zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIC8vIHBvdGVudGlhbGx5IGFyZSBubyByZWNvcmRzXHJcbiAgICAgICAgd3JpdGUoXCJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgd3JpdGUoKTtcclxufTtcclxuXHJcbmNvbnN0IHJlYWQgPSAoZ2V0TmV4dElucHV0Qnl0ZXMsIHNjaGVtYSkgPT4gKG9uR2V0SXRlbSwgb25HZXRUZXh0KSA9PiB7XHJcbiAgICBjb25zdCByZWFkSW5wdXQgPSBuZXdJbnB1dFJlYWRlcihnZXROZXh0SW5wdXRCeXRlcyk7XHJcbiAgICBsZXQgdGV4dCA9IHJlYWRJbnB1dCgpO1xyXG4gICAgbGV0IHN0YXR1cyA9IENPTlRJTlVFX1JFQURJTkdfUkVDT1JEUztcclxuICAgIHdoaWxlKHRleHQubGVuZ3RoID4gMCkge1xyXG5cclxuICAgICAgICBpZihzdGF0dXMgPT09IFJFQURfUkVNQUlOSU5HX1RFWFQpIHtcclxuICAgICAgICAgICAgb25HZXRUZXh0KHRleHQpO1xyXG4gICAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihzdGF0dXMgPT09IENBTkNFTF9SRUFEKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByb3dUZXh0ID0gXCJcIjtcclxuICAgICAgICBsZXQgY3VycmVudENoYXJJbmRleD0wO1xyXG4gICAgICAgIGZvcihsZXQgY3VycmVudENoYXIgb2YgdGV4dCkge1xyXG4gICAgICAgICAgICByb3dUZXh0ICs9IGN1cnJlbnRDaGFyO1xyXG4gICAgICAgICAgICBpZihjdXJyZW50Q2hhciA9PT0gXCJcXHJcIikge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gb25HZXRJdGVtKFxyXG4gICAgICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplUm93KHNjaGVtYSwgcm93VGV4dClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICByb3dUZXh0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGlmKHN0YXR1cyA9PT0gUkVBRF9SRU1BSU5JTkdfVEVYVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRDaGFySW5kZXgrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGN1cnJlbnRDaGFySW5kZXggPCB0ZXh0Lmxlbmd0aCAtMSkge1xyXG4gICAgICAgICAgICBvbkdldFRleHQodGV4dC5zdWJzdHJpbmcoY3VycmVudENoYXJJbmRleCArIDEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRleHQgPSByZWFkSW5wdXQoKTtcclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IG5ld091dHB1dFdyaXRlciA9IChmbHVzaEJvdW5kYXJ5LCBmbHVzaCkgPT4ge1xyXG4gICAgXHJcbiAgICBsZXQgY3VycmVudEJ1ZmZlciA9IG51bGw7XHJcblxyXG4gICAgcmV0dXJuICh0ZXh0KSA9PiB7XHJcblxyXG4gICAgICAgIGlmKGlzU3RyaW5nKHRleHQpICYmIGN1cnJlbnRCdWZmZXIgPT09IG51bGwpXHJcbiAgICAgICAgICAgIGN1cnJlbnRCdWZmZXIgPSBCdWZmZXIuZnJvbSh0ZXh0LCBcInV0ZjhcIik7XHJcbiAgICAgICAgZWxzZSBpZihpc1N0cmluZyh0ZXh0KSlcclxuICAgICAgICAgICAgY3VycmVudEJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEJ1ZmZlcixcclxuICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKHRleHQsIFwidXRmOFwiKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICBcclxuICAgICAgICBpZihjdXJyZW50QnVmZmVyICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgIChjdXJyZW50QnVmZmVyLmxlbmd0aCA+IGZsdXNoQm91bmRhcnlcclxuICAgICAgICAgICAgIHx8ICFpc1N0cmluZyh0ZXh0KSkpIHtcclxuXHJcbiAgICAgICAgICAgIGZsdXNoKGN1cnJlbnRCdWZmZXIpO1xyXG4gICAgICAgICAgICBjdXJyZW50QnVmZmVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5jb25zdCBuZXdJbnB1dFJlYWRlciA9IChnZXROZXh0SW5wdXRCeXRlcykgPT4ge1xyXG5cclxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcigndXRmOCcpO1xyXG4gICAgbGV0IHJlbWFpbmluZ0J5dGVzID0gW107XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBjb25zdCBuZXh0Qnl0ZXMgPSBnZXROZXh0SW5wdXRCeXRlcygpO1xyXG4gICAgICAgIGNvbnN0IGZyb21ieXRlcyA9IFsuLi5yZW1haW5pbmdCeXRlcywgLi4uKCFuZXh0Qnl0ZXMgPyBbXSA6IG5leHRCeXRlcyldO1xyXG4gICAgICAgIGlmKGZyb21ieXRlcy5sZW5ndGggPT09IHJlbWFpbmluZ0J5dGVzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZnJvbWJ5dGVzKTtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gZGVjb2Rlci53cml0ZShidWZmZXIpO1xyXG4gICAgICAgIHJlbWFpbmluZ0J5dGVzID0gZGVjb2Rlci5lbmQoYnVmZmVyKTtcclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH07XHJcbn07XHJcblxyXG5jb25zdCBkZXNlcmlhbGl6ZVJvdyA9IChzY2hlbWEsIHJvd1RleHQpID0+IHtcclxuICAgIGxldCBjdXJyZW50UHJvcEluZGV4ID0gMDtcclxuICAgIGxldCBjdXJyZW50Q2hhckluZGV4ID0gMDtcclxuICAgIGxldCBjdXJyZW50VmFsdWVUZXh0ID0gXCJcIjtcclxuICAgIGxldCBpc0VzY2FwZWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IGl0ZW0gPSB7fTtcclxuXHJcbiAgICBjb25zdCBzZXRDdXJyZW50UHJvcCA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50UHJvcCA9IHNjaGVtYVtjdXJyZW50UHJvcEluZGV4XTtcclxuICAgICAgICBjb25zdCB0eXBlID0gZ2V0VHlwZShjdXJyZW50UHJvcC50eXBlKTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnRWYWx1ZVRleHQgPT09IFwiXCJcclxuICAgICAgICAgICAgICAgICAgICAgID8gdHlwZS5nZXREZWZhdWx0VmFsdWUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiB0eXBlLnNhZmVQYXJzZVZhbHVlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZVRleHQpO1xyXG4gICAgICAgIGl0ZW1bY3VycmVudFByb3AubmFtZV0gPSB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHdoaWxlKGN1cnJlbnRQcm9wSW5kZXggPCBzY2hlbWEubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgIGlmKGN1cnJlbnRDaGFySW5kZXggPCByb3dUZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q2hhciA9IHJvd1RleHRbY3VycmVudENoYXJJbmRleF07XHJcbiAgICAgICAgICAgIGlmKGlzRXNjYXBlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYoY3VycmVudENoYXIgPT09IFwiclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlVGV4dCArPSBcIlxcclwiO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVUZXh0ICs9IGN1cnJlbnRDaGFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaXNFc2NhcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50Q2hhciA9PT0gXCIsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50UHJvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZVRleHQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihjdXJyZW50Q2hhciA9PT0gXCJcXFxcXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0VzY2FwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVUZXh0ICs9IGN1cnJlbnRDaGFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRDaGFySW5kZXgrKzsgXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudFZhbHVlVGV4dCA9IFwiXCI7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRQcm9wKCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wSW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGl0ZW07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2VyaWFsaXplSXRlbSA9IChzY2hlbWEsIGl0ZW0pICA9PiB7XHJcblxyXG4gICAgbGV0IHJvd1RleHQgPSBcIlwiXHJcblxyXG4gICAgZm9yKGxldCBwcm9wIG9mIHNjaGVtYSkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKHByb3AudHlwZSk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBoYXMocHJvcC5uYW1lKShpdGVtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgPyBpdGVtW3Byb3AubmFtZV1cclxuICAgICAgICAgICAgICAgICAgICAgIDogdHlwZS5nZXREZWZhdWx0VmFsdWUoKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHZhbFN0ciA9IHR5cGUuc3RyaW5naWZ5KHZhbHVlKTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHZhbFN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q2hhciA9IHZhbFN0cltpXTtcclxuICAgICAgICAgICAgaWYoY3VycmVudENoYXIgPT09IFwiLFwiIFxyXG4gICAgICAgICAgICAgICB8fCBjdXJyZW50Q2hhciA9PT0gXCJcXHJcIiBcclxuICAgICAgICAgICAgICAgfHwgY3VycmVudENoYXIgPT09IFwiXFxcXFwiKSB7XHJcbiAgICAgICAgICAgICAgICByb3dUZXh0ICs9IFwiXFxcXFwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihjdXJyZW50Q2hhciA9PT0gXCJcXHJcIikge1xyXG4gICAgICAgICAgICAgICAgcm93VGV4dCArPSBcInJcIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvd1RleHQgKz0gY3VycmVudENoYXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJvd1RleHQgKz0gXCIsXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcm93VGV4dCArPSBcIlxcclwiO1xyXG4gICAgcmV0dXJuIHJvd1RleHQ7XHJcbn07IiwiaW1wb3J0IHsgZ2V0SGFzaENvZGUsXG4gICAgam9pbktleSwgJH0gZnJvbSBcIi4uL2NvbW1vblwiO1xuaW1wb3J0IHtnZXRBY3R1YWxLZXlPZlBhcmVudCwgXG4gICAgICAgICBpc0dsb2JhbEluZGV4fSBmcm9tIFwiLi4vdGVtcGxhdGVBcGkvaGVpcmFyY2h5XCI7XG5pbXBvcnQge2NyZWF0ZUluZGV4RmlsZX0gZnJvbSBcIi4uL2luZGV4aW5nL3NoYXJkaW5nXCI7XG5pbXBvcnQge2dlbmVyYXRlU2NoZW1hfSBmcm9tIFwiLi4vaW5kZXhpbmcvaW5kZXhTY2hlbWFDcmVhdG9yXCI7XG5pbXBvcnQge2dldEluZGV4UmVhZGVyLCBDT05USU5VRV9SRUFESU5HX1JFQ09SRFN9IGZyb20gXCIuL3NlcmlhbGl6ZXJcIjtcbmltcG9ydCBsdW5yIGZyb20gXCJsdW5yXCI7XG5cbmV4cG9ydCBjb25zdCByZWFkSW5kZXggPSBhc3luYyAoaGVpcmFyY2h5LCBkYXRhc3RvcmUsIGluZGV4LCBpbmRleGVkRGF0YUtleSkgPT4ge1xuICAgIGNvbnN0IHJlY29yZHMgPSBbXTtcbiAgICBjb25zdCBkb1JlYWQgPSBpdGVyYXRlSW5kZXgoXG4gICAgICAgIGl0ZW0gPT4ge1xuICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIENPTlRJTlVFX1JFQURJTkdfUkVDT1JEUztcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gcmVjb3Jkc1xuICAgIClcblxuICAgIHJldHVybiBhd2FpdCBkb1JlYWQoaGVpcmFyY2h5LCBkYXRhc3RvcmUsIGluZGV4LCBpbmRleGVkRGF0YUtleSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2VhcmNoSW5kZXggPSBhc3luYyAoaGVpcmFyY2h5LCBkYXRhc3RvcmUsIGluZGV4LCBpbmRleGVkRGF0YUtleSwgc2VhcmNoUGhyYXNlKSA9PiB7XG4gICAgY29uc3QgcmVjb3JkcyA9IFtdO1xuICAgIGNvbnN0IHNjaGVtYSA9IGdlbmVyYXRlU2NoZW1hKGhlaXJhcmNoeSwgaW5kZXgpO1xuICAgIGNvbnN0IGRvUmVhZCA9IGl0ZXJhdGVJbmRleChcbiAgICAgICAgaXRlbSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBsdW5yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZigna2V5Jyk7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBmaWVsZCBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWVsZChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hSZXN1bHRzID0gaWR4LnNlYXJjaChzZWFyY2hQaHJhc2UpO1xuICAgICAgICAgICAgaWYoc2VhcmNoUmVzdWx0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpdGVtLl9zZWFyY2hSZXN1bHQgPSBzZWFyY2hSZXN1bHRzWzBdO1xuICAgICAgICAgICAgICAgIHJlY29yZHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDT05USU5VRV9SRUFESU5HX1JFQ09SRFM7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHJlY29yZHNcbiAgICApXG5cbiAgICByZXR1cm4gYXdhaXQgZG9SZWFkKGhlaXJhcmNoeSwgZGF0YXN0b3JlLCBpbmRleCwgaW5kZXhlZERhdGFLZXkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEluZGV4ZWREYXRhS2V5X2Zyb21JbmRleEtleSA9IChpbmRleEtleSwgcmVjb3JkKSA9PiB7XG4gICAgcmV0dXJuIGAke2luZGV4S2V5fSR7aW5kZXhLZXkuZW5kc1dpdGgoXCIuY3N2XCIpID8gXCJcIiA6IFwiLmNzdlwifWA7XG59XG5cbmV4cG9ydCBjb25zdCB1bmlxdWVJbmRleE5hbWUgPSAoaW5kZXgpID0+IFxuICAgIFwiaWR4X1wiICtcbiAgICBnZXRIYXNoQ29kZShgJHtpbmRleC5maWx0ZXJ9JHtpbmRleC5tYXB9YCkgK1xuICAgIFwiLmNzdlwiO1xuXG5leHBvcnQgY29uc3QgZ2V0SW5kZXhlZERhdGFLZXkgPSAoZGVjZW5kYW50S2V5LCBpbmRleE5vZGUpID0+IHtcblxuICAgIGlmKGlzR2xvYmFsSW5kZXgoaW5kZXhOb2RlKSlcbiAgICAgICAgcmV0dXJuIGAke2luZGV4Tm9kZS5ub2RlS2V5KCl9LmNzdmBcblxuICAgIGNvbnN0IGluZGV4ZWREYXRhUGFyZW50S2V5ID0gXG4gICAgICAgICAgICBnZXRBY3R1YWxLZXlPZlBhcmVudChcbiAgICAgICAgICAgICAgICBpbmRleE5vZGUucGFyZW50KCkubm9kZUtleSgpICAgIFxuICAgICAgICAgICAgICAgICxkZWNlbmRhbnRLZXkpO1xuXG4gICAgY29uc3QgaW5kZXhOYW1lID0gXG4gICAgICAgIGluZGV4Tm9kZS5uYW1lIFxuICAgICAgICA/IGAke2luZGV4Tm9kZS5uYW1lfS5jc3ZgXG4gICAgICAgIDogdW5pcXVlSW5kZXhOYW1lKGluZGV4Tm9kZSk7XG5cbiAgICByZXR1cm4gam9pbktleShcbiAgICAgICAgaW5kZXhlZERhdGFQYXJlbnRLZXksXG4gICAgICAgIGluZGV4TmFtZVxuICAgICk7XG59XG5cbmV4cG9ydCBjb25zdCBpdGVyYXRlSW5kZXggPSAob25HZXRJdGVtLCBnZXRGaW5hbFJlc3VsdCkgPT4gYXN5bmMgKGhlaXJhcmNoeSwgZGF0YXN0b3JlLCBpbmRleCwgaW5kZXhlZERhdGFLZXkpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IGF3YWl0IGRhdGFzdG9yZS5yZWFkYWJsZUZpbGVTdHJlYW0oaW5kZXhlZERhdGFLZXkpO1xuICAgICAgICBjb25zdCByZWFkID0gZ2V0SW5kZXhSZWFkZXIoaGVpcmFyY2h5LCBpbmRleCwgKCkgPT4gcmVhZGFibGVTdHJlYW0ucmVhZCgpKTtcbiAgICAgICAgcmVhZChvbkdldEl0ZW0pO1xuICAgICAgICByZXR1cm4gZ2V0RmluYWxSZXN1bHQoKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgaWYoYXdhaXQgZGF0YXN0b3JlLmV4aXN0cyhpbmRleGVkRGF0YUtleSkpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVJbmRleEZpbGUoXG4gICAgICAgICAgICAgICAgZGF0YXN0b3JlLFxuICAgICAgICAgICAgICAgIGluZGV4ZWREYXRhS2V5LCBcbiAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuIiwiaW1wb3J0IHtzYWZlS2V5LCBhcGlXcmFwcGVyLCAkLFxuICAgIGV2ZW50cywgaXNOb25FbXB0eVN0cmluZ30gZnJvbSBcIi4uL2NvbW1vblwiO1xuaW1wb3J0IHtyZWFkSW5kZXgsIHNlYXJjaEluZGV4fSBmcm9tIFwiLi4vaW5kZXhpbmcvcmVhZFwiO1xuaW1wb3J0IHtnZXRVbnNoYXJkZWRJbmRleERhdGFLZXksIFxuICAgIGdldFNoYXJkS2V5c0luUmFuZ2V9IGZyb20gXCIuLi9pbmRleGluZy9zaGFyZGluZ1wiO1xuaW1wb3J0IHtnZXRFeGFjdE5vZGVGb3JQYXRoLCBpc0luZGV4LCBcbiAgICBpc1NoYXJkZWRJbmRleH0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xuaW1wb3J0IHtmbGF0dGVuLCBtZXJnZX0gZnJvbSBcImxvZGFzaC9mcFwiO1xuaW1wb3J0IHtwZXJtaXNzaW9ufSBmcm9tIFwiLi4vYXV0aEFwaS9wZXJtaXNzaW9uc1wiO1xuXG5leHBvcnQgY29uc3QgbGlzdEl0ZW1zID0gYXBwID0+IGFzeW5jIChpbmRleEtleSwgb3B0aW9ucykgPT4gXG4gICAgYXBpV3JhcHBlcihcbiAgICAgICAgYXBwLFxuICAgICAgICBldmVudHMuaW5kZXhBcGkubGlzdEl0ZW1zLCBcbiAgICAgICAgcGVybWlzc2lvbi5yZWFkSW5kZXguaXNBdXRob3JpemVkKGluZGV4S2V5KSxcbiAgICAgICAge2luZGV4S2V5LCBvcHRpb25zfSxcbiAgICAgICAgX2xpc3RJdGVtcywgYXBwLCBpbmRleEtleSwgb3B0aW9ucyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge3JhbmdlU3RhcnRQYXJhbXM6bnVsbCwgcmFuZ2VFbmRQYXJhbXM6bnVsbCwgc2VhcmNoUGhyYXNlOm51bGx9O1xuXG5jb25zdCBfbGlzdEl0ZW1zID0gYXN5bmMgKGFwcCwgaW5kZXhLZXksIG9wdGlvbnM9ZGVmYXVsdE9wdGlvbnMpID0+IHsgXG4gICAgXG4gICAgbGV0IHtzZWFyY2hQaHJhc2UsIHJhbmdlU3RhcnRQYXJhbXMsIHJhbmdlRW5kUGFyYW1zfT0gXG4gICAgICAgICQoe30sIFtcbiAgICAgICAgICAgIG1lcmdlKG9wdGlvbnMpLFxuICAgICAgICAgICAgbWVyZ2UoZGVmYXVsdE9wdGlvbnMpXG4gICAgICAgIF0pO1xuXG4gICAgY29uc3QgZ2V0SXRlbXMgPSBhc3luYyAoa2V5KSA9PlxuICAgICAgICAgaXNOb25FbXB0eVN0cmluZyhzZWFyY2hQaHJhc2UpXG4gICAgICAgICA/IGF3YWl0IHNlYXJjaEluZGV4KFxuICAgICAgICAgICAgIGFwcC5oZWlyYXJjaHksIFxuICAgICAgICAgICAgIGFwcC5kYXRhc3RvcmUsIFxuICAgICAgICAgICAgIGluZGV4Tm9kZSwgXG4gICAgICAgICAgICAga2V5LCBcbiAgICAgICAgICAgICBzZWFyY2hQaHJhc2UpXG4gICAgICAgICA6IGF3YWl0IHJlYWRJbmRleChcbiAgICAgICAgICAgICBhcHAuaGVpcmFyY2h5LCBcbiAgICAgICAgICAgICBhcHAuZGF0YXN0b3JlLCBcbiAgICAgICAgICAgICBpbmRleE5vZGUsIFxuICAgICAgICAgICAgIGtleSk7XG5cbiAgICBpbmRleEtleSA9IHNhZmVLZXkoaW5kZXhLZXkpO1xuICAgIGNvbnN0IGluZGV4Tm9kZSA9IGdldEV4YWN0Tm9kZUZvclBhdGgoYXBwLmhlaXJhcmNoeSkoaW5kZXhLZXkpO1xuXG4gICAgaWYoIWlzSW5kZXgoaW5kZXhOb2RlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3VwcGxpZWQga2V5IGlzIG5vdCBhbiBpbmRleFwiKTtcblxuICAgIGlmKGlzU2hhcmRlZEluZGV4KGluZGV4Tm9kZSkpIHtcbiAgICAgICAgY29uc3Qgc2hhcmRLZXlzID0gYXdhaXQgZ2V0U2hhcmRLZXlzSW5SYW5nZShcbiAgICAgICAgICAgIGFwcCwgaW5kZXhLZXksIHJhbmdlU3RhcnRQYXJhbXMsIHJhbmdlRW5kUGFyYW1zXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGZvcihsZXQgayBvZiBzaGFyZEtleXMpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYXdhaXQgZ2V0SXRlbXMoaykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuKGl0ZW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0SXRlbXMoXG4gICAgICAgICAgICBnZXRVbnNoYXJkZWRJbmRleERhdGFLZXkoaW5kZXhLZXkpXG4gICAgICAgICk7XG4gICAgfSAgICBcbn07XG4iLCJpbXBvcnQge2dldEV4YWN0Tm9kZUZvclBhdGgsXG4gICAgZmluZEZpZWxkLCBnZXROb2RlLCBpc0dsb2JhbEluZGV4fSBmcm9tIFwiLi4vdGVtcGxhdGVBcGkvaGVpcmFyY2h5XCI7XG5pbXBvcnQge2xpc3RJdGVtc30gZnJvbSBcIi4uL2luZGV4QXBpL2xpc3RJdGVtc1wiO1xuaW1wb3J0IHtoYXMsIHNvbWV9IGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7bWFwLCBpc1N0cmluZ30gZnJvbSBcImxvZGFzaC9mcFwiO1xuaW1wb3J0IHskLCBhcGlXcmFwcGVyU3luYywgZXZlbnRzLCBqb2luS2V5fSBmcm9tIFwiLi4vY29tbW9uXCI7XG5pbXBvcnQge2dldEluZGV4S2V5X0Jhc2VkT25EZWNlbmRhbnR9IGZyb20gXCIuLi9pbmRleGluZy9zaGFyZGluZ1wiO1xuaW1wb3J0IHtwZXJtaXNzaW9ufSBmcm9tIFwiLi4vYXV0aEFwaS9wZXJtaXNzaW9uc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0Q29udGV4dCA9IGFwcCA9PiByZWNvcmRLZXkgPT4gXG4gICAgYXBpV3JhcHBlclN5bmMoXG4gICAgICAgIGFwcCxcbiAgICAgICAgZXZlbnRzLnJlY29yZEFwaS5nZXRDb250ZXh0LCBcbiAgICAgICAgcGVybWlzc2lvbi5yZWFkUmVjb3JkLmlzQXV0aG9yaXplZChyZWNvcmRLZXkpLFxuICAgICAgICB7cmVjb3JkS2V5fSxcbiAgICAgICAgX2dldENvbnRleHQsIGFwcCwgcmVjb3JkS2V5KTtcblxuZXhwb3J0IGNvbnN0IF9nZXRDb250ZXh0ID0gKGFwcCwgcmVjb3JkS2V5KSA9PiB7XG5cbiAgICBjb25zdCByZWNvcmROb2RlID0gZ2V0RXhhY3ROb2RlRm9yUGF0aChhcHAuaGVpcmFyY2h5KShyZWNvcmRLZXkpOyAgICBcblxuICAgIGNvbnN0IGNhY2hlZFJlZmVyZW5jZUluZGV4ZXMgPSB7fTtcblxuICAgIGNvbnN0IGxhenlMb2FkUmVmZXJlbmNlSW5kZXggPSBhc3luYyB0eXBlT3B0aW9ucyA9PiB7XG5cbiAgICAgICAgaWYoIWhhcyhjYWNoZWRSZWZlcmVuY2VJbmRleGVzLCB0eXBlT3B0aW9ucy5pbmRleE5vZGVLZXkpKSB7XG4gICAgICAgICAgICBjYWNoZWRSZWZlcmVuY2VJbmRleGVzW3R5cGVPcHRpb25zLmluZGV4Tm9kZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZU9wdGlvbnM6IHR5cGVPcHRpb25zLFxuICAgICAgICAgICAgICAgIGRhdGE6IGF3YWl0IHJlYWRSZWZlcmVuY2VJbmRleChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcCwgcmVjb3JkS2V5LCB0eXBlT3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGVkUmVmZXJlbmNlSW5kZXhlc1t0eXBlT3B0aW9ucy5pbmRleE5vZGVLZXldO1xuICAgIH1cblxuICAgIGNvbnN0IGdldFR5cGVPcHRpb25zID0gdHlwZU9wdGlvbnNfb3JfZmllbGROYW1lID0+IFxuICAgICAgICBpc1N0cmluZyh0eXBlT3B0aW9uc19vcl9maWVsZE5hbWUpXG4gICAgICAgID8gZmluZEZpZWxkKHJlY29yZE5vZGUsIHR5cGVPcHRpb25zX29yX2ZpZWxkTmFtZSlcbiAgICAgICAgICAgIC50eXBlT3B0aW9uc1xuICAgICAgICA6IHR5cGVPcHRpb25zX29yX2ZpZWxkTmFtZTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZmVyZW5jZUV4aXN0cyA6IGFzeW5jICh0eXBlT3B0aW9uc19vcl9maWVsZE5hbWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZU9wdGlvbnMgPSBnZXRUeXBlT3B0aW9ucyh0eXBlT3B0aW9uc19vcl9maWVsZE5hbWUpO1xuICAgICAgICAgICAgY29uc3Qge2RhdGF9ID0gYXdhaXQgbGF6eUxvYWRSZWZlcmVuY2VJbmRleCh0eXBlT3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gc29tZShkYXRhLCBpID0+IGkua2V5ID09PSBrZXkpO1xuICAgICAgICB9LFxuICAgICAgICByZWZlcmVuY2VPcHRpb25zOiBhc3luYyAodHlwZU9wdGlvbnNfb3JfZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eXBlT3B0aW9ucyA9IGdldFR5cGVPcHRpb25zKHR5cGVPcHRpb25zX29yX2ZpZWxkTmFtZSk7XG4gICAgICAgICAgICBjb25zdCB7ZGF0YX0gPSBhd2FpdCBsYXp5TG9hZFJlZmVyZW5jZUluZGV4KHR5cGVPcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICByZWNvcmROb2RlXG4gICAgfTtcbn1cblxuY29uc3QgcmVhZFJlZmVyZW5jZUluZGV4ID0gYXN5bmMgKGFwcCwgcmVjb3JkS2V5LHR5cGVPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgaW5kZXhOb2RlID0gZ2V0Tm9kZShhcHAuaGVpcmFyY2h5LCB0eXBlT3B0aW9ucy5pbmRleE5vZGVLZXkpO1xuICAgIGNvbnN0IGluZGV4S2V5ID0gaXNHbG9iYWxJbmRleChpbmRleE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICA/IGluZGV4Tm9kZS5ub2RlS2V5KClcbiAgICAgICAgICAgICAgICAgICAgIDogZ2V0SW5kZXhLZXlfQmFzZWRPbkRlY2VuZGFudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRLZXksIGluZGV4Tm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgbGlzdEl0ZW1zKGFwcCkoaW5kZXhLZXkpO1xuICAgIHJldHVybiAkKGl0ZW1zLCBbXG4gICAgICAgIG1hcChpID0+ICh7XG4gICAgICAgICAgICBrZXk6IGkua2V5LFxuICAgICAgICAgICAgdmFsdWU6IGlbdHlwZU9wdGlvbnMuZGlzcGxheVZhbHVlXVxuICAgICAgICB9KSlcbiAgICBdKTtcbiB9IiwiaW1wb3J0IHtnZXRFeGFjdE5vZGVGb3JQYXRofSBmcm9tIFwiLi4vdGVtcGxhdGVBcGkvaGVpcmFyY2h5XCI7XG5pbXBvcnQge3ZhbGlkYXRlRmllbGRQYXJzZSwgdmFsaWRhdGVUeXBlQ29uc3RyYWludHN9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHttYXAsIHJlZHVjZSwgZmlsdGVyLCBcbiAgICBpc0VtcHR5LCBmbGF0dGVuLCBlYWNofSBmcm9tIFwibG9kYXNoL2ZwXCI7XG5pbXBvcnQgeyQsIGlzTm90aGluZywgaXNOb25FbXB0eVN0cmluZ30gZnJvbSBcIi4uL2NvbW1vblwiO1xuaW1wb3J0IHtjb21waWxlRXhwcmVzc2lvbn0gZnJvbSBcIkBueC1qcy9jb21waWxlci11dGlsXCI7XG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQge19nZXRDb250ZXh0fSBmcm9tIFwiLi9nZXRDb250ZXh0XCI7XG5pbXBvcnQge3Blcm1pc3Npb259IGZyb20gXCIuLi9hdXRoQXBpL3Blcm1pc3Npb25zXCI7XG5cbmNvbnN0IGZpZWxkUGFyc2VFcnJvciA9IChmaWVsZE5hbWUsIHZhbHVlKSA9PiBcbiAgICAoe2ZpZWxkczpbZmllbGROYW1lXSwgXG4gICAgbWVzc2FnZTogYENvdWxkIG5vdCBwYXJzZSBmaWVsZCAke2ZpZWxkTmFtZX06JHt2YWx1ZX1gfSk7XG5cbmNvbnN0IHZhbGlkYXRlQWxsRmllbGRQYXJzZSA9IChyZWNvcmQsIHJlY29yZE5vZGUpID0+IFxuICAgICQocmVjb3JkTm9kZS5maWVsZHMsIFtcbiAgICAgICAgbWFwKGYgPT4gKHtuYW1lOmYubmFtZSwgcGFyc2VSZXN1bHQ6dmFsaWRhdGVGaWVsZFBhcnNlKGYsIHJlY29yZCl9KSksXG4gICAgICAgIHJlZHVjZSgoZXJyb3JzLCBmKSA9PiB7XG4gICAgICAgICAgICBpZihmLnBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICAgICAgICBmaWVsZFBhcnNlRXJyb3IoZi5uYW1lLCBmLnBhcnNlUmVzdWx0LnZhbHVlKSk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICB9LCBbXSlcbiAgICBdKTtcblxuY29uc3QgdmFsaWRhdGVBbGxUeXBlQ29uc3RyYWludHMgPSBhc3luYyAocmVjb3JkLCByZWNvcmROb2RlLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yKGxldCBmaWVsZCBvZiByZWNvcmROb2RlLmZpZWxkcykge1xuICAgICAgICAkKGF3YWl0IHZhbGlkYXRlVHlwZUNvbnN0cmFpbnRzKGZpZWxkLCByZWNvcmQsIGNvbnRleHQpLCBbXG4gICAgICAgICAgICBmaWx0ZXIoaXNOb25FbXB0eVN0cmluZyksXG4gICAgICAgICAgICBtYXAobSA9PiAoe21lc3NhZ2U6bSwgZmllbGRzOltmaWVsZC5uYW1lXX0pKSxcbiAgICAgICAgICAgIGVhY2goZSA9PiBlcnJvcnMucHVzaChlKSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuXG5jb25zdCBydW5SZWNvcmRWYWxpZGF0aW9uUnVsZXMgPSAocmVjb3JkLCByZWNvcmROb2RlKSA9PiB7XG5cbiAgICBjb25zdCBydW5WYWxpZGF0aW9uUnVsZSA9IHJ1bGUgPT4ge1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gY29tcGlsZUV4cHJlc3Npb24ocnVsZS5leHByZXNzaW9uV2hlblZhbGlkKTtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbkNvbnRleHQgPSB7cmVjb3JkLCBffTtcbiAgICAgICAgcmV0dXJuIChpc1ZhbGlkKGV4cHJlc3Npb25Db250ZXh0KVxuICAgICAgICAgICAgPyB7dmFsaWQ6dHJ1ZX1cbiAgICAgICAgICAgIDogKHt2YWxpZDpmYWxzZSwgXG4gICAgICAgICAgICAgICAgZmllbGRzOiBydWxlLmludmFsaWRGaWVsZHMsIFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6cnVsZS5tZXNzYWdlV2hlbkludmFsaWR9KSk7XG4gICAgfTtcblxuICAgIHJldHVybiAkKHJlY29yZE5vZGUudmFsaWRhdGlvblJ1bGVzLCBbXG4gICAgICAgIG1hcChydW5WYWxpZGF0aW9uUnVsZSksXG4gICAgICAgIGZsYXR0ZW4sXG4gICAgICAgIGZpbHRlcihyID0+IHIudmFsaWQgPT09IGZhbHNlKSxcbiAgICAgICAgbWFwKHIgPT4gKHtmaWVsZHM6ci5maWVsZHMsIG1lc3NhZ2U6ci5tZXNzYWdlfSkpXG4gICAgXSk7XG59XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZSA9IGFwcCA9PiBhc3luYyAocmVjb3JkLCBjb250ZXh0KSA9PiB7XG4gICAgY29udGV4dCA9IGlzTm90aGluZyhjb250ZXh0KSBcbiAgICAgICAgICAgICAgPyBfZ2V0Q29udGV4dChhcHAsIHJlY29yZC5rZXkpXG4gICAgICAgICAgICAgIDogY29udGV4dDtcblxuICAgIGNvbnN0IHJlY29yZE5vZGUgPSBnZXRFeGFjdE5vZGVGb3JQYXRoKGFwcC5oZWlyYXJjaHkpKHJlY29yZC5rZXkpO1xuICAgIGNvbnN0IGZpZWxkUGFyc2VGYWlscyA9ICB2YWxpZGF0ZUFsbEZpZWxkUGFyc2UocmVjb3JkLCByZWNvcmROb2RlKTtcbiAgICBcbiAgICAvLyBub24gcGFyc2luZyB3b3VsZCBjYXVzZSBmdXJ0aGVyIGlzc3VlcyAtIGV4aXQgaGVyZVxuICAgIGlmKCFpc0VtcHR5KGZpZWxkUGFyc2VGYWlscykpXG4gICAgICAgIHJldHVybiAoe2lzVmFsaWQ6ZmFsc2UsIGVycm9yczpmaWVsZFBhcnNlRmFpbHN9KTtcblxuICAgIGNvbnN0IHJlY29yZFZhbGlkYXRpb25SdWxlRmFpbHMgPSBydW5SZWNvcmRWYWxpZGF0aW9uUnVsZXMocmVjb3JkLCByZWNvcmROb2RlKTtcbiAgICBjb25zdCB0eXBlQ29udHJhaW50RmFpbHMgPSBhd2FpdCB2YWxpZGF0ZUFsbFR5cGVDb25zdHJhaW50cyhyZWNvcmQsIHJlY29yZE5vZGUsIGNvbnRleHQpO1xuXG4gICAgaWYoaXNFbXB0eShmaWVsZFBhcnNlRmFpbHMpIFxuICAgICAgICYmIGlzRW1wdHkocmVjb3JkVmFsaWRhdGlvblJ1bGVGYWlscylcbiAgICAgICAmJiBpc0VtcHR5KHR5cGVDb250cmFpbnRGYWlscykpIHtcbiAgICAgICAgICAgcmV0dXJuICh7aXNWYWxpZDp0cnVlLCBlcnJvcnM6W119KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICh7XG4gICAgICAgIGlzVmFsaWQ6ZmFsc2UsIFxuICAgICAgICBlcnJvcnM6IF8udW5pb24oZmllbGRQYXJzZUZhaWxzLCB0eXBlQ29udHJhaW50RmFpbHMsIHJlY29yZFZhbGlkYXRpb25SdWxlRmFpbHMpfSk7XG59XG4iLCJpbXBvcnQge2dldEZsYXR0ZW5lZEhpZXJhcmNoeSwgaGFzTm9NYXRjaGluZ0FuY2VzdG9ycywgXG4gICAgaXNDb2xsZWN0aW9uUmVjb3JkLCBpc1Jvb3QsXG4gICAgaXNSZWNvcmQsIGdldEV4YWN0Tm9kZUZvclBhdGh9IGZyb20gXCIuLi90ZW1wbGF0ZUFwaS9oZWlyYXJjaHlcIjtcbmltcG9ydCB7JCwgYWxsVHJ1ZSwgam9pbktleX0gZnJvbSBcIi4uL2NvbW1vblwiO1xuaW1wb3J0IHtmaWx0ZXJ9IGZyb20gXCJsb2Rhc2gvZnBcIjtcblxuY29uc3QgZW5zdXJlQ29sbGVjdGlvbklzSW5pdGlhbGlzZWQgPSBhc3luYyAoZGF0YXN0b3JlLCBub2RlLCBwYXJlbnRLZXkpID0+IHtcblxuICAgIGlmKCFhd2FpdCBkYXRhc3RvcmUuZXhpc3RzKHBhcmVudEtleSkpIHtcbiAgICAgICAgYXdhaXQgZGF0YXN0b3JlLmNyZWF0ZUZvbGRlcihwYXJlbnRLZXkpO1xuICAgICAgICBhd2FpdCBkYXRhc3RvcmUuY3JlYXRlRm9sZGVyKFxuICAgICAgICAgICAgam9pbktleShwYXJlbnRLZXksXCJhbGxpZHNcIilcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgZGF0YXN0b3JlLmNyZWF0ZUZvbGRlcihcbiAgICAgICAgICAgIGpvaW5LZXkoXG4gICAgICAgICAgICAgICAgcGFyZW50S2V5LFxuICAgICAgICAgICAgICAgIFwiYWxsaWRzXCIsXG4gICAgICAgICAgICAgICAgbm9kZS5ub2RlSWQudG9TdHJpbmcoKSlcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgfSAgIFxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpc2VSb290Q29sbGVjdGlvbnMgPSBhc3luYyAoZGF0YXN0b3JlLCBoZWlyYXJjaHkpID0+IHtcblxuICAgIGNvbnN0IHJvb3RDb2xsZWN0aW9uUmVjb3JkID0gXG4gICAgICAgIGFsbFRydWUoXG4gICAgICAgICAgICBuID0+IGlzUm9vdChuLnBhcmVudCgpKSwgXG4gICAgICAgICAgICBpc0NvbGxlY3Rpb25SZWNvcmRcbiAgICAgICAgKTtcblxuICAgIGNvbnN0IGZsYXRoZWlyYXJjaHkgPSBnZXRGbGF0dGVuZWRIaWVyYXJjaHkoaGVpcmFyY2h5KTtcblxuICAgIGNvbnN0IGNvbGxlY3Rpb25SZWNvcmRzID0gJChmbGF0aGVpcmFyY2h5LCBbXG4gICAgICAgIGZpbHRlcihyb290Q29sbGVjdGlvblJlY29yZClcbiAgICBdKTtcbiAgICBcbiAgICBmb3IobGV0IGNvbCBvZiBjb2xsZWN0aW9uUmVjb3Jkcykge1xuICAgICAgICBhd2FpdCBlbnN1cmVDb2xsZWN0aW9uSXNJbml0aWFsaXNlZChcbiAgICAgICAgICAgICAgICBkYXRhc3RvcmUsIFxuICAgICAgICAgICAgICAgIGNvbCwgXG4gICAgICAgICAgICAgICAgY29sLmNvbGxlY3Rpb25QYXRoUmVneCgpKTtcbiAgICB9ICAgXG5cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXNlQ2hpbGRDb2xsZWN0aW9ucyA9IGFzeW5jIChhcHAsIHJlY29yZEtleSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkQ29sbGVjdGlvblJlY29yZHMgPSAkKHJlY29yZEtleSwgW1xuICAgICAgICBnZXRFeGFjdE5vZGVGb3JQYXRoKGFwcC5oZWlyYXJjaHkpLFxuICAgICAgICBuID0+IG4uY2hpbGRyZW4sXG4gICAgICAgIGZpbHRlcihpc0NvbGxlY3Rpb25SZWNvcmQpXG4gICAgXSk7XG5cbiAgICBmb3IobGV0IGNoaWxkIG9mIGNoaWxkQ29sbGVjdGlvblJlY29yZHMpIHtcbiAgICAgICAgYXdhaXQgZW5zdXJlQ29sbGVjdGlvbklzSW5pdGlhbGlzZWQoXG4gICAgICAgICAgICBhcHAuZGF0YXN0b3JlLFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICBqb2luS2V5KHJlY29yZEtleSwgY2hpbGQuY29sbGVjdGlvbk5hbWUpXG4gICAgICAgICk7XG4gICAgfVxufTsiLCJpbXBvcnQge2dldEV4YWN0Tm9kZUZvclBhdGgsIGdldFBhcmVudEtleSwgXG4gICAgZ2V0RmxhdHRlbmVkSGllcmFyY2h5LCAgXG4gICAgZ2V0Q29sbGVjdGlvbk5vZGVCeUtleU9yTm9kZUtleSwgZ2V0Tm9kZUZvckNvbGxlY3Rpb25QYXRoLFxuICAgIGlzQ29sbGVjdGlvblJlY29yZCwgaXNBbmNlc3Rvcn0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xuaW1wb3J0IHtqb2luS2V5LCBzYWZlS2V5LCAkfSBmcm9tIFwiLi4vY29tbW9uXCI7XG5pbXBvcnQge2pvaW4sIHB1bGwsIFxuICAgICAgICBtYXAsIGZsYXR0ZW4sIG9yZGVyQnksXG4gICAgICAgIGZpbHRlciwgZmluZH0gZnJvbSBcImxvZGFzaC9mcFwiO1xuXG5jb25zdCBhbGxJZENoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWl8tXCI7XG5cbmNvbnN0IGFsbElkc1N0cmluZ3NGb3JGYWN0b3IgPSBjb2xsZWN0aW9uTm9kZSA9PiB7XG4gICAgY29uc3QgZmFjdG9yID0gY29sbGVjdGlvbk5vZGUuYWxsaWRzU2hhcmRGYWN0b3I7XG4gICAgY29uc3QgY2hhclJhbmdlUGVyU2hhcmQgPSA2NCAvIGZhY3RvcjtcbiAgICBjb25zdCBhbGxJZFN0cmluZ3MgPSBbXTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBjdXJyZW50SWRzU2hhcmQgPSBcIlwiO1xuICAgIHdoaWxlKGluZGV4IDwgNjQpIHtcbiAgICAgICAgY3VycmVudElkc1NoYXJkID0gY3VycmVudElkc1NoYXJkIFxuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFsbElkQ2hhcnNbaW5kZXhdO1xuICAgICAgICBpZigoaW5kZXggKyAxKSAlIGNoYXJSYW5nZVBlclNoYXJkID09PSAwKSB7XG4gICAgICAgICAgICBhbGxJZFN0cmluZ3MucHVzaChjdXJyZW50SWRzU2hhcmQpO1xuICAgICAgICAgICAgY3VycmVudElkc1NoYXJkID0gXCJcIjtcbiAgICAgICAgfSBcbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gYWxsSWRTdHJpbmdzO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEFsbElkc1NoYXJkTmFtZXMgPSAoYXBwSGVpcmFyY2h5LCBjb2xsZWN0aW9uS2V5KSA9PiB7XG4gICAgY29uc3QgY29sbGVjdGlvblJlY29yZE5vZGUgPSBnZXROb2RlRm9yQ29sbGVjdGlvblBhdGgoYXBwSGVpcmFyY2h5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb2xsZWN0aW9uS2V5KTtcbiAgICByZXR1cm4gJChjb2xsZWN0aW9uUmVjb3JkTm9kZSxbXG4gICAgICAgIGMgPT4gW2Mubm9kZUlkXSxcbiAgICAgICAgbWFwKGkgPT4gXG4gICAgICAgICAgICBtYXAoYyA9PiBfYWxsSWRzU2hhcmRLZXkoY29sbGVjdGlvbktleSwgaSwgYykpXG4gICAgICAgICAgICAgICAgKGFsbElkc1N0cmluZ3NGb3JGYWN0b3IoY29sbGVjdGlvblJlY29yZE5vZGUpKVxuICAgICAgICApLFxuICAgICAgICBmbGF0dGVuXG4gICAgXSk7XG59XG5cbmNvbnN0IF9hbGxJZHNTaGFyZEtleSA9IChjb2xsZWN0aW9uS2V5LCBjaGlsZE5vLCBzaGFyZEtleSkgPT4gXG4gICAgam9pbktleShcbiAgICAgICAgY29sbGVjdGlvbktleSxcbiAgICAgICAgXCJhbGxpZHNcIixcbiAgICAgICAgY2hpbGRObyxcbiAgICAgICAgc2hhcmRLZXlcbiAgICApO1xuXG5leHBvcnQgY29uc3QgZ2V0QWxsSWRzU2hhcmRLZXkgPSAoYXBwSGVpcmFyY2h5LCBjb2xsZWN0aW9uS2V5LCByZWNvcmRJZCkgPT4geyAgXG4gICAgY29uc3QgaW5kZXhPZkZpcnN0RGFzaCA9IHJlY29yZElkLmluZGV4T2YoXCItXCIpO1xuXG4gICAgY29uc3QgY29sbGVjdGlvbk5vZGUgPSBnZXROb2RlRm9yQ29sbGVjdGlvblBhdGgoYXBwSGVpcmFyY2h5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb2xsZWN0aW9uS2V5KTtcblxuICAgIGNvbnN0IGlkRmlyc3RDaGFyID0gcmVjb3JkSWRbaW5kZXhPZkZpcnN0RGFzaCArIDFdO1xuICAgIGNvbnN0IGFsbElkc1NoYXJkSWQgPSAkKGNvbGxlY3Rpb25Ob2RlLCBbXG4gICAgICAgIGFsbElkc1N0cmluZ3NGb3JGYWN0b3IsXG4gICAgICAgIGZpbmQoaSA9PiBpLmluY2x1ZGVzKGlkRmlyc3RDaGFyKSlcbiAgICBdKTtcblxuICAgIHJldHVybiBfYWxsSWRzU2hhcmRLZXkoXG4gICAgICAgIGNvbGxlY3Rpb25LZXksIFxuICAgICAgICByZWNvcmRJZC5zbGljZSgwLCBpbmRleE9mRmlyc3REYXNoKSwgXG4gICAgICAgIGFsbElkc1NoYXJkSWQpXG4gICAgICAgIFxufTtcblxuY29uc3QgZ2V0T3JDcmVhdGVTaGFyZEZpbGUgPSBhc3luYyAoZGF0YXN0b3JlLCBhbGxJZHNLZXkpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZGF0YXN0b3JlLmxvYWRGaWxlKGFsbElkc0tleSk7XG4gICAgfSBjYXRjaChlTG9hZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZGF0YXN0b3JlLmNyZWF0ZUZpbGUoYWxsSWRzS2V5LCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9IGNhdGNoIChlQ3JlYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFcnJvciBsb2FkaW5nLCB0aGVuIGNyZWF0aW5nIGFsbElkcyBcIiArIGFsbElkc0tleSBcbiAgICAgICAgICAgICAgICArIFwiIDogTE9BRCA6IFwiICsgZUxvYWQubWVzc2FnZSBcbiAgICAgICAgICAgICAgICArIFwiIDogQ1JFQVRFIDogXCIgKyBlQ3JlYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IGdldFNoYXJkRmlsZSA9IGFzeW5jIChkYXRhc3RvcmUsIGFsbElkc0tleSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBkYXRhc3RvcmUubG9hZEZpbGUoYWxsSWRzS2V5KTtcbiAgICB9IGNhdGNoKGVMb2FkKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBhZGRUb0FsbElkcyA9IChhcHBIZWlyYXJjaHksIGRhdGFzdG9yZSkgPT4gYXN5bmMgcmVjb3JkID0+IHtcbiAgICBjb25zdCBhbGxJZHNLZXkgPSBnZXRBbGxJZHNTaGFyZEtleShcbiAgICAgICAgYXBwSGVpcmFyY2h5LFxuICAgICAgICBnZXRQYXJlbnRLZXkocmVjb3JkLmtleSksXG4gICAgICAgIHJlY29yZC5pZFxuICAgICk7XG5cbiAgICBsZXQgYWxsSWRzID0gYXdhaXQgZ2V0T3JDcmVhdGVTaGFyZEZpbGUoZGF0YXN0b3JlLCBhbGxJZHNLZXkpOyAgICBcblxuICAgIGFsbElkcyArPSBgJHthbGxJZHMubGVuZ3RoID4gMCA/IFwiLFwiIDogXCJcIn0ke3JlY29yZC5pZH1gO1xuXG4gICAgYXdhaXQgZGF0YXN0b3JlLnVwZGF0ZUZpbGUoYWxsSWRzS2V5LCBhbGxJZHMpOyAgICBcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRBbGxJZHNJdGVyYXRvciA9IChhcHApID0+IGFzeW5jIChjb2xsZWN0aW9uX0tleV9vcl9Ob2RlS2V5KSA9PiB7XG5cbiAgICBjb2xsZWN0aW9uX0tleV9vcl9Ob2RlS2V5ID0gc2FmZUtleShjb2xsZWN0aW9uX0tleV9vcl9Ob2RlS2V5KTtcbiAgICBjb25zdCB0YXJnZXROb2RlID0gZ2V0Q29sbGVjdGlvbk5vZGVCeUtleU9yTm9kZUtleShcbiAgICAgICAgYXBwLmhlaXJhcmNoeSxcbiAgICAgICAgY29sbGVjdGlvbl9LZXlfb3JfTm9kZUtleSk7XG5cbiAgICBjb25zdCBnZXRBbGxJZHNJdGVyYXRvckZvckNvbGxlY3Rpb25LZXkgPSBhc3luYyAoY29sbGVjdGlvbktleSkgPT4geyBcblxuICAgICAgICBjb25zdCBhbGxfYWxsSWRzS2V5cyA9IGdldEFsbElkc1NoYXJkTmFtZXMoYXBwLmhlaXJhcmNoeSwgY29sbGVjdGlvbktleSk7XG4gICAgICAgIGxldCBzaGFyZEluZGV4ID0gMDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFsbElkc0Zyb21TaGFyZEl0ZXJhdG9yID0gYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICBpZihzaGFyZEluZGV4ID09PSBhbGxfYWxsSWRzS2V5cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuICh7ZG9uZTp0cnVlLCByZXN1bHQ6e2lkczpbXSwgY29sbGVjdGlvbktleX19KTtcblxuICAgICAgICAgICAgY29uc3Qgc2hhcmRLZXkgPSBhbGxfYWxsSWRzS2V5c1tzaGFyZEluZGV4XTtcblxuICAgICAgICAgICAgY29uc3QgYWxsSWRzID0gYXdhaXQgZ2V0QWxsSWRzRnJvbVNoYXJkKGFwcC5kYXRhc3RvcmUsIHNoYXJkS2V5KTtcbiAgICAgICAgXG4gICAgICAgICAgICBzaGFyZEluZGV4Kys7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAoeyBcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaWRzOiBhbGxJZHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25LZXlcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYWxsSWRzRnJvbVNoYXJkSXRlcmF0b3I7XG4gICAgfTsgICAgXG4gICAgXG4gICAgY29uc3QgYW5jZXN0b3JzID0gJChnZXRGbGF0dGVuZWRIaWVyYXJjaHkoYXBwLmhlaXJhcmNoeSksIFtcbiAgICAgICAgZmlsdGVyKGlzQ29sbGVjdGlvblJlY29yZCksXG4gICAgICAgIGZpbHRlcihuID0+IGlzQW5jZXN0b3IodGFyZ2V0Tm9kZSkobikgXG4gICAgICAgICAgICAgICAgICAgIHx8IG4ubm9kZUtleSgpID09PSB0YXJnZXROb2RlLm5vZGVLZXkoKSksXG4gICAgICAgIG9yZGVyQnkoW24gPT4gbi5ub2RlS2V5KCkubGVuZ3RoXSwgW1wiYXNjXCJdKVxuICAgIF0pOyAvLyBwYXJlbnRzIGZpcnN0XG5cbiAgICBjb25zdCB0cmF2ZXJzZUZvckl0ZXJhdGVyYXRvcnMgPSBhc3luYyAocGFyZW50UmVjb3JkS2V5ID0gXCJcIiwgY3VycmVudE5vZGVJbmRleCA9IDApID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBhbmNlc3RvcnNbY3VycmVudE5vZGVJbmRleF07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2xsZWN0aW9uS2V5ID0gam9pbktleShcbiAgICAgICAgICAgIHBhcmVudFJlY29yZEtleSxcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmNvbGxlY3Rpb25OYW1lXG4gICAgICAgICk7XG4gICAgICAgIGlmKGN1cnJlbnROb2RlLm5vZGVLZXkoKSA9PT0gdGFyZ2V0Tm9kZS5ub2RlS2V5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXdhaXQgZ2V0QWxsSWRzSXRlcmF0b3JGb3JDb2xsZWN0aW9uS2V5KFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29sbGVjdGlvbktleSldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbEl0ZXJhdG9ycyA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50SXRlcmF0b3IgPSBhd2FpdCBnZXRBbGxJZHNJdGVyYXRvckZvckNvbGxlY3Rpb25LZXkoXG4gICAgICAgICAgICBjdXJyZW50Q29sbGVjdGlvbktleVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgbGV0IGlkcyA9IGF3YWl0IGN1cnJlbnRJdGVyYXRvcigpO1xuICAgICAgICB3aGlsZShpZHMuZG9uZSA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgZm9yKGxldCBpZCBvZiBpZHMucmVzdWx0Lmlkcykge1xuICAgICAgICAgICAgICAgIGFsbEl0ZXJhdG9ycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0cmF2ZXJzZUZvckl0ZXJhdGVyYXRvcnMoXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luS2V5KGN1cnJlbnRDb2xsZWN0aW9uS2V5LCBpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZUluZGV4ICsgMSAgXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZHMgPSBhd2FpdCBjdXJyZW50SXRlcmF0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbGF0dGVuKGFsbEl0ZXJhdG9ycyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yc0FycmF5ID0gYXdhaXQgdHJhdmVyc2VGb3JJdGVyYXRlcmF0b3JzKCk7XG4gICAgbGV0IGN1cnJlbnRJdGVyYXRvckluZGV4ID0gMDtcbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZihpdGVyYXRvcnNBcnJheS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4ge2RvbmU6dHJ1ZSwgcmVzdWx0OltdfTsgXG4gICAgICAgIGNvbnN0IGlubmVyUmVzdWx0ID0gYXdhaXQgaXRlcmF0b3JzQXJyYXlbY3VycmVudEl0ZXJhdG9ySW5kZXhdKCk7XG4gICAgICAgIGlmKCFpbm5lclJlc3VsdC5kb25lKSBcbiAgICAgICAgICAgIHJldHVybiBpbm5lclJlc3VsdDtcbiAgICAgICAgaWYoY3VycmVudEl0ZXJhdG9ySW5kZXggPT0gaXRlcmF0b3JzQXJyYXkubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICByZXR1cm4ge2RvbmU6dHJ1ZSwgcmVzdWx0OiBpbm5lclJlc3VsdC5yZXN1bHR9O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJdGVyYXRvckluZGV4Kys7XG4gICAgICAgIHJldHVybiB7ZG9uZTpmYWxzZSwgcmVzdWx0OmlubmVyUmVzdWx0LnJlc3VsdH07XG4gICAgfTtcbn07XG5cbmNvbnN0IGdldEFsbElkc0Zyb21TaGFyZCA9IGFzeW5jIChkYXRhc3RvcmUsIHNoYXJkS2V5KSA9PiB7XG4gICAgXG4gICAgY29uc3QgYWxsSWRzU3RyID0gYXdhaXQgZ2V0U2hhcmRGaWxlKGRhdGFzdG9yZSwgc2hhcmRLZXkpO1xuXG4gICAgY29uc3QgYWxsSWRzID0gW107XG4gICAgbGV0IGN1cnJlbnRJZCA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxJZHNTdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGN1cnJlbnRDaGFyID0gYWxsSWRzU3RyLmNoYXJBdChpKTtcbiAgICAgICAgY29uc3QgaXNMYXN0ID0gKGkgPT09IGFsbElkc1N0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYoY3VycmVudENoYXIgPT09IFwiLFwiIHx8IGlzTGFzdCkge1xuICAgICAgICAgICAgaWYoaXNMYXN0KSBjdXJyZW50SWQgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICBhbGxJZHMucHVzaChjdXJyZW50SWQpO1xuICAgICAgICAgICAgY3VycmVudElkID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRJZCArPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsSWRzO1xufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZlRnJvbUFsbElkcyA9IChhcHBIZWlyYXJjaHksZGF0YXN0b3JlKSA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgKHJlY29yZCkgPT4ge1xuICAgIGNvbnN0IHNoYXJkS2V5ID0gZ2V0QWxsSWRzU2hhcmRLZXkoXG4gICAgICAgIGFwcEhlaXJhcmNoeSxcbiAgICAgICAgZ2V0UGFyZW50S2V5KHJlY29yZC5rZXkpLFxuICAgICAgICByZWNvcmQuaWRcbiAgICApO1xuICAgIGNvbnN0IGFsbElkcyA9IGF3YWl0IGdldEFsbElkc0Zyb21TaGFyZChkYXRhc3RvcmUsIHNoYXJkS2V5KTtcbiAgICBcbiAgICBjb25zdCBuZXdJZHMgPSAkKGFsbElkcywgW1xuICAgICAgICBwdWxsKHJlY29yZC5pZCksXG4gICAgICAgIGpvaW4oXCIsXCIpXG4gICAgXSk7XG5cbiAgICBhd2FpdCBkYXRhc3RvcmUudXBkYXRlRmlsZShzaGFyZEtleSwgbmV3SWRzKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldEFsbElkc0l0ZXJhdG9yO1xuIiwiaW1wb3J0IHtqb2luS2V5LCBrZXlTZXAsIGdldEhhc2hDb2RlLCAkLCAkJH0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge2dldExhc3RQYXJ0SW5LZXl9IGZyb20gXCIuLi90ZW1wbGF0ZUFwaS9oZWlyYXJjaHlcIjtcclxuaW1wb3J0IHtzcGxpdH0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OU19GT0xERVIgPSBrZXlTZXAgKyBcIi50cmFuc2FjdGlvbnNcIjtcclxuZXhwb3J0IGNvbnN0IExPQ0tfRklMRU5BTUUgPSBcImxvY2tcIjtcclxuZXhwb3J0IGNvbnN0IExPQ0tfRklMRV9LRVkgPSBqb2luS2V5KFxyXG4gICAgVFJBTlNBQ1RJT05TX0ZPTERFUiwgTE9DS19GSUxFTkFNRSk7XHJcbmV4cG9ydCBjb25zdCBpZFNlcCA9IFwiJFwiO1xyXG5cclxuXHJcbmNvbnN0IGlzT2ZUeXBlID0gdHlwID0+IHRyYW5zID0+IFxyXG4gICAgdHJhbnMudHJhbnNhY3Rpb25UeXBlID09PSB0eXA7XHJcblxyXG5leHBvcnQgY29uc3QgQ1JFQVRFX1JFQ09SRF9UUkFOU0FDVElPTiA9IFwiY3JlYXRlXCI7XHJcbmV4cG9ydCBjb25zdCBVUERBVEVfUkVDT1JEX1RSQU5TQUNUSU9OID0gXCJ1cGRhdGVcIjtcclxuZXhwb3J0IGNvbnN0IERFTEVURV9SRUNPUkRfVFJBTlNBQ1RJT04gPSBcImRlbGV0ZVwiO1xyXG5leHBvcnQgY29uc3QgQlVJTERfSU5ERVhfVFJBTlNBQ1RJT04gPSBcImJ1aWxkXCI7XHJcblxyXG5leHBvcnQgY29uc3QgaXNVcGRhdGUgPSBpc09mVHlwZShVUERBVEVfUkVDT1JEX1RSQU5TQUNUSU9OKTtcclxuZXhwb3J0IGNvbnN0IGlzRGVsZXRlID0gaXNPZlR5cGUoREVMRVRFX1JFQ09SRF9UUkFOU0FDVElPTik7XHJcbmV4cG9ydCBjb25zdCBpc0NyZWF0ZSA9IGlzT2ZUeXBlKENSRUFURV9SRUNPUkRfVFJBTlNBQ1RJT04pO1xyXG5leHBvcnQgY29uc3QgaXNCdWlsZEluZGV4ID0gaXNPZlR5cGUoQlVJTERfSU5ERVhfVFJBTlNBQ1RJT04pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGtleVRvRm9sZGVyTmFtZSA9IG5vZGVLZXkgPT4gZ2V0SGFzaENvZGUobm9kZUtleSk7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VHJhbnNhY3Rpb25JZCA9IChyZWNvcmRJZCwgdHJhbnNhY3Rpb25UeXBlLCB1bmlxdWVJZCkgPT4gXHJcbiAgICBgJHtyZWNvcmRJZH0ke2lkU2VwfSR7dHJhbnNhY3Rpb25UeXBlfSR7aWRTZXB9JHt1bmlxdWVJZH1gO1xyXG5cclxuZXhwb3J0IGNvbnN0IGJ1aWxkSW5kZXhGb2xkZXIgPSBcIi5CVUlMRC1cIjtcclxuZXhwb3J0IGNvbnN0IG5vZGVLZXlIYXNoRnJvbUJ1aWxkRm9sZGVyID0gZm9sZGVyID0+XHJcbiAgICBmb2xkZXIucmVwbGFjZShidWlsZEluZGV4Rm9sZGVyLCBcIlwiKTtcclxuXHJcbmV4cG9ydCBjb25zdCBpc0J1aWxkSW5kZXhGb2xkZXIgPSBrZXkgPT4gXHJcbiAgICBnZXRMYXN0UGFydEluS2V5KGtleSkuc3RhcnRzV2l0aChidWlsZEluZGV4Rm9sZGVyKTtcclxuXHJcbmV4cG9ydCBjb25zdCBJbmRleE5vZGVLZXlGb2xkZXIgPSBpbmRleE5vZGVLZXkgPT4gXHJcbiAgICBqb2luS2V5KFxyXG4gICAgICAgIFRSQU5TQUNUSU9OU19GT0xERVIsIFxyXG4gICAgICAgIGJ1aWxkSW5kZXhGb2xkZXIgKyBrZXlUb0ZvbGRlck5hbWUoaW5kZXhOb2RlS2V5KSk7XHJcblxyXG5leHBvcnQgY29uc3QgSW5kZXhOb2RlS2V5QmF0Y2hGb2xkZXIgPSAoaW5kZXhOb2RlS2V5LCBjb3VudCkgPT4gXHJcbiAgICBqb2luS2V5KEluZGV4Tm9kZUtleUZvbGRlcihpbmRleE5vZGVLZXkpLCBNYXRoLmZsb29yKGNvdW50L0JVSUxESU5ERVhfQkFUQ0hfQ09VTlQpLnRvU3RyaW5nKCkpO1xyXG5cclxuZXhwb3J0IGNvbnN0IEluZGV4U2hhcmRLZXlGb2xkZXIgPSAoaW5kZXhOb2RlS2V5LCBpbmRleFNoYXJkS2V5KSA9PiBcclxuICAgIGpvaW5LZXkoSW5kZXhOb2RlS2V5Rm9sZGVyKGluZGV4Tm9kZUtleSksIGluZGV4U2hhcmRLZXkpO1xyXG5cclxuZXhwb3J0IGNvbnN0IEJVSUxESU5ERVhfQkFUQ0hfQ09VTlQgPSAxMDAwO1xyXG5leHBvcnQgY29uc3QgdGltZW91dE1pbGxpc2Vjb25kcyA9ICAzMCAqIDEwMDA7IC8vIDMwIHNlY3NcclxuZXhwb3J0IGNvbnN0IG1heExvY2tSZXRyaWVzID0gMTtcclxuXHJcbiIsImltcG9ydCB7Z2VuZXJhdGV9IGZyb20gXCJzaG9ydGlkXCI7XHJcbmltcG9ydCB7am9pbktleX0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge2dldExhc3RQYXJ0SW5LZXl9IGZyb20gXCIuLi90ZW1wbGF0ZUFwaS9oZWlyYXJjaHlcIjtcclxuaW1wb3J0IHsgSW5kZXhOb2RlS2V5Rm9sZGVyLCBCVUlMRElOREVYX0JBVENIX0NPVU5ULFxyXG4gICAgSW5kZXhOb2RlS2V5QmF0Y2hGb2xkZXIsIFRSQU5TQUNUSU9OU19GT0xERVIsIGdldFRyYW5zYWN0aW9uSWQsIENSRUFURV9SRUNPUkRfVFJBTlNBQ1RJT04sIFVQREFURV9SRUNPUkRfVFJBTlNBQ1RJT04sXHJcbiAgICBERUxFVEVfUkVDT1JEX1RSQU5TQUNUSU9OLCBCVUlMRF9JTkRFWF9UUkFOU0FDVElPTlxyXG59IGZyb20gXCIuL3RyYW5zYWN0aW9uc0NvbW1vblwiO1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCB0cmFuc2FjdGlvbkZvckNyZWF0ZVJlY29yZCA9IGFzeW5jIChhcHAsIHJlY29yZCkgPT4gXHJcbiAgICBhd2FpdCB0cmFuc2FjdGlvbihcclxuICAgICAgICBhcHAuZGF0YXN0b3JlLCBDUkVBVEVfUkVDT1JEX1RSQU5TQUNUSU9OLCBcclxuICAgICAgICByZWNvcmQua2V5LCB7cmVjb3JkfSxcclxuICAgICAgICBnZXRUcmFuc2FjdGlvbktleV9SZWNvcmRzKTtcclxuXHJcbmV4cG9ydCBjb25zdCB0cmFuc2FjdGlvbkZvclVwZGF0ZVJlY29yZCA9IGFzeW5jIChhcHAsIG9sZFJlY29yZCwgbmV3UmVjb3JkKSA9PiBcclxuICAgIGF3YWl0IHRyYW5zYWN0aW9uKFxyXG4gICAgICAgIGFwcC5kYXRhc3RvcmUsIFVQREFURV9SRUNPUkRfVFJBTlNBQ1RJT04sIFxyXG4gICAgICAgIG5ld1JlY29yZC5rZXksIHtvbGRSZWNvcmQsIHJlY29yZDpuZXdSZWNvcmR9LFxyXG4gICAgICAgIGdldFRyYW5zYWN0aW9uS2V5X1JlY29yZHMpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHRyYW5zYWN0aW9uRm9yRGVsZXRlUmVjb3JkID0gYXN5bmMgKGFwcCwgcmVjb3JkKSA9PiBcclxuICAgIGF3YWl0IHRyYW5zYWN0aW9uKFxyXG4gICAgICAgIGFwcC5kYXRhc3RvcmUsIERFTEVURV9SRUNPUkRfVFJBTlNBQ1RJT04sIFxyXG4gICAgICAgIHJlY29yZC5rZXksIHtyZWNvcmR9LFxyXG4gICAgICAgIGdldFRyYW5zYWN0aW9uS2V5X1JlY29yZHMpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHRyYW5zYWN0aW9uRm9yQnVpbGRJbmRleCA9IGFzeW5jIChhcHAsIGluZGV4Tm9kZUtleSwgcmVjb3JkS2V5LCBjb3VudCkgPT4ge1xyXG4gICAgXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbkZvbGRlciA9ICBJbmRleE5vZGVLZXlCYXRjaEZvbGRlcihpbmRleE5vZGVLZXksIGNvdW50KTtcclxuICAgIGlmKGNvdW50ICUgQlVJTERJTkRFWF9CQVRDSF9DT1VOVCA9PT0gMCkge1xyXG4gICAgICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUuY3JlYXRlRm9sZGVyKHRyYW5zYWN0aW9uRm9sZGVyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXdhaXQgdHJhbnNhY3Rpb24oXHJcbiAgICAgICAgICAgIGFwcC5kYXRhc3RvcmUsIEJVSUxEX0lOREVYX1RSQU5TQUNUSU9OLFxyXG4gICAgICAgICAgICByZWNvcmRLZXksIHtyZWNvcmRLZXl9LFxyXG4gICAgICAgICAgICBpZCA9PiBqb2luS2V5KHRyYW5zYWN0aW9uRm9sZGVyLCBpZCkpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlQnVpbGRJbmRleEZvbGRlciA9IGFzeW5jKGRhdGFzdG9yZSwgaW5kZXhOb2RlS2V5KSA9PlxyXG4gICAgYXdhaXQgZGF0YXN0b3JlLmNyZWF0ZUZvbGRlcihcclxuICAgICAgICBJbmRleE5vZGVLZXlGb2xkZXIoaW5kZXhOb2RlS2V5KSk7XHJcblxyXG5jb25zdCBnZXRUcmFuc2FjdGlvbktleV9SZWNvcmRzID0gaWQgPT4gam9pbktleShUUkFOU0FDVElPTlNfRk9MREVSLCBpZCk7XHJcblxyXG5jb25zdCB0cmFuc2FjdGlvbiA9IGFzeW5jIChkYXRhc3RvcmUsIHRyYW5zYWN0aW9uVHlwZSwgcmVjb3JkS2V5LCBkYXRhLCBnZXRUcmFuc2FjdGlvbktleSkgPT4ge1xyXG5cclxuICAgIGNvbnN0IHJlY29yZElkID0gZ2V0TGFzdFBhcnRJbktleShyZWNvcmRLZXkpO1xyXG4gICAgY29uc3QgdW5pcXVlSWQgPSBnZW5lcmF0ZSgpO1xyXG4gICAgY29uc3QgaWQgPSBnZXRUcmFuc2FjdGlvbklkKFxyXG4gICAgICAgIHJlY29yZElkLCB0cmFuc2FjdGlvblR5cGUsIHVuaXF1ZUlkXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGtleSA9IGdldFRyYW5zYWN0aW9uS2V5KGlkKTtcclxuXHJcbiAgICBjb25zdCB0cmFucyA9IHtcclxuICAgICAgICB0cmFuc2FjdGlvblR5cGUsXHJcbiAgICAgICAgcmVjb3JkS2V5LFxyXG4gICAgICAgIC4uLmRhdGEsXHJcbiAgICAgICAgaWRcclxuICAgIH07XHJcblxyXG4gICAgYXdhaXQgZGF0YXN0b3JlLmNyZWF0ZUpzb24oXHJcbiAgICAgICAga2V5LCB0cmFuc1xyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdHJhbnM7XHJcbn1cclxuIiwiaW1wb3J0IHtpc1NoYXJkZWRJbmRleH0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xyXG5pbXBvcnQge2pvaW5LZXl9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHtnZXRTaGFyZE1hcEtleSwgZ2V0VW5zaGFyZGVkSW5kZXhEYXRhS2V5LCBjcmVhdGVJbmRleEZpbGV9IGZyb20gXCIuLi9pbmRleGluZy9zaGFyZGluZ1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGluaXRpYWxpc2VJbmRleCA9IGFzeW5jIChkYXRhc3RvcmUsIHBhcmVudEtleSwgaW5kZXgpID0+IHtcclxuICAgIGNvbnN0IGluZGV4S2V5ID0gam9pbktleShwYXJlbnRLZXksIGluZGV4Lm5hbWUpO1xyXG5cclxuICAgIGF3YWl0IGRhdGFzdG9yZS5jcmVhdGVGb2xkZXIoaW5kZXhLZXkpO1xyXG5cclxuICAgIGlmKGlzU2hhcmRlZEluZGV4KGluZGV4KSkge1xyXG4gICAgICAgIGF3YWl0IGRhdGFzdG9yZS5jcmVhdGVGaWxlKFxyXG4gICAgICAgICAgICBnZXRTaGFyZE1hcEtleShpbmRleEtleSksXHJcbiAgICAgICAgICAgIFwiW11cIlxyXG4gICAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IGNyZWF0ZUluZGV4RmlsZShcclxuICAgICAgICAgICAgZGF0YXN0b3JlLFxyXG4gICAgICAgICAgICBnZXRVbnNoYXJkZWRJbmRleERhdGFLZXkoaW5kZXhLZXkpLCBcclxuICAgICAgICAgICAgaW5kZXhcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59OyIsImltcG9ydCB7Y2xvbmVEZWVwLCBjb25zdGFudCwgaXNFcXVhbCxcbiAgICAgICAgZmxhdHRlbiwgbWFwLCBmaWx0ZXJ9IGZyb20gXCJsb2Rhc2gvZnBcIjtcbmltcG9ydCB7aW5pdGlhbGlzZUNoaWxkQ29sbGVjdGlvbnN9IGZyb20gXCIuLi9jb2xsZWN0aW9uQXBpL2luaXRpYWxpc2VcIjtcbmltcG9ydCB7dmFsaWRhdGV9IGZyb20gXCIuL3ZhbGlkYXRlXCI7XG5pbXBvcnQge19sb2FkLCBnZXRSZWNvcmRGaWxlTmFtZX0gZnJvbSBcIi4vbG9hZFwiO1xuaW1wb3J0IHthcGlXcmFwcGVyLCBldmVudHMsICQsIGpvaW5LZXl9IGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7IGdldEZsYXR0ZW5lZEhpZXJhcmNoeSwgZ2V0TGFzdFBhcnRJbktleSxcbiAgICAgICAgZ2V0RXhhY3ROb2RlRm9yUGF0aCwgaXNSZWNvcmQsXG4gICAgICAgIGdldE5vZGUsIGZpZWxkUmV2ZXJzZXNSZWZlcmVuY2VUb05vZGV9IGZyb20gXCIuLi90ZW1wbGF0ZUFwaS9oZWlyYXJjaHlcIjtcbmltcG9ydCB7bWFwUmVjb3JkfSBmcm9tIFwiLi4vaW5kZXhpbmcvZXZhbHVhdGVcIjtcbmltcG9ydCB7bGlzdEl0ZW1zfSBmcm9tIFwiLi4vaW5kZXhBcGkvbGlzdEl0ZW1zXCI7XG5pbXBvcnQge2FkZFRvQWxsSWRzfSBmcm9tIFwiLi4vaW5kZXhpbmcvYWxsSWRzXCI7XG5pbXBvcnQge3RyYW5zYWN0aW9uRm9yQ3JlYXRlUmVjb3JkLFxuICAgIHRyYW5zYWN0aW9uRm9yVXBkYXRlUmVjb3JkfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zL2NyZWF0ZVwiO1xuaW1wb3J0IHtwZXJtaXNzaW9ufSBmcm9tIFwiLi4vYXV0aEFwaS9wZXJtaXNzaW9uc1wiO1xuaW1wb3J0IHtpbml0aWFsaXNlSW5kZXh9IGZyb20gXCIuLi9pbmRleGluZy9pbml0aWFsaXNlSW5kZXhcIjtcblxuZXhwb3J0IGNvbnN0IHNhdmUgPSAoYXBwKSA9PiBhc3luYyAocmVjb3JkLCBjb250ZXh0KSA9PiBcbiAgICBhcGlXcmFwcGVyKFxuICAgICAgICBhcHAsXG4gICAgICAgIGV2ZW50cy5yZWNvcmRBcGkuc2F2ZSwgXG4gICAgICAgIHJlY29yZC5pc05ldyBcbiAgICAgICAgPyBwZXJtaXNzaW9uLmNyZWF0ZVJlY29yZC5pc0F1dGhvcml6ZWQocmVjb3JkLmtleSlcbiAgICAgICAgOiBwZXJtaXNzaW9uLnVwZGF0ZVJlY29yZC5pc0F1dGhvcml6ZWQocmVjb3JkLmtleSksXG4gICAgICAgIHtyZWNvcmR9LFxuICAgICAgICBfc2F2ZSwgYXBwLCByZWNvcmQsIGNvbnRleHQsIGZhbHNlKTtcblxuXG5jb25zdCBfc2F2ZSA9IGFzeW5jIChhcHAsIHJlY29yZCwgY29udGV4dCwgc2tpcFZhbGlkYXRpb249ZmFsc2UpID0+IHtcbiAgICBjb25zdCByZWNvcmRDbG9uZSA9IGNsb25lRGVlcChyZWNvcmQpO1xuICAgIGlmKCFza2lwVmFsaWRhdGlvbikge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgdmFsaWRhdGUoYXBwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWNvcmRDbG9uZSwgY29udGV4dCk7XG4gICAgICAgIGlmKCF2YWxpZGF0aW9uUmVzdWx0LmlzVmFsaWQpIHtcbiAgICAgICAgICAgIGFwcC5wdWJsaXNoKGV2ZW50cy5yZWNvcmRBcGkuc2F2ZS5vbkludmFsaWQsIFxuICAgICAgICAgICAgICAgICAgICAgICAge3JlY29yZCx2YWxpZGF0aW9uUmVzdWx0fSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTYXZlIDogUmVjb3JkIEludmFsaWQgOiBcIiBcbiAgICAgICAgICAgICAgICAgICAgKyBKU09OLnN0cmluZ2lmeSh2YWxpZGF0aW9uUmVzdWx0LmVycm9ycykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYocmVjb3JkQ2xvbmUuaXNOZXcpIHtcbiAgICAgICAgYXdhaXQgYWRkVG9BbGxJZHMoYXBwLmhlaXJhcmNoeSwgYXBwLmRhdGFzdG9yZSkocmVjb3JkQ2xvbmUpO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRyYW5zYWN0aW9uRm9yQ3JlYXRlUmVjb3JkKFxuICAgICAgICAgICAgYXBwLCByZWNvcmRDbG9uZSk7XG4gICAgICAgIHJlY29yZENsb25lLnRyYW5zYWN0aW9uSWQgPSB0cmFuc2FjdGlvbi5pZDtcbiAgICAgICAgYXdhaXQgYXBwLmRhdGFzdG9yZS5jcmVhdGVGb2xkZXIocmVjb3JkQ2xvbmUua2V5KVxuICAgICAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLmNyZWF0ZUZvbGRlcihcbiAgICAgICAgICAgIGpvaW5LZXkocmVjb3JkQ2xvbmUua2V5LCBcImZpbGVzXCIpKTtcbiAgICAgICAgYXdhaXQgYXBwLmRhdGFzdG9yZS5jcmVhdGVKc29uKFxuICAgICAgICAgICAgZ2V0UmVjb3JkRmlsZU5hbWUocmVjb3JkQ2xvbmUua2V5KSwgXG4gICAgICAgICAgICByZWNvcmRDbG9uZVxuICAgICAgICApO1xuICAgICAgICBhd2FpdCBpbml0aWFsaXNlUmV2ZXJzZVJlZmVyZW5jZUluZGV4ZXMoYXBwLCByZWNvcmQpO1xuICAgICAgICBhd2FpdCBpbml0aWFsaXNlQW5jZXN0b3JJbmRleGVzKGFwcCwgcmVjb3JkKTtcbiAgICAgICAgYXdhaXQgaW5pdGlhbGlzZUNoaWxkQ29sbGVjdGlvbnMoYXBwLCByZWNvcmRDbG9uZS5rZXkpO1xuICAgICAgICBhcHAucHVibGlzaChldmVudHMucmVjb3JkQXBpLnNhdmUub25SZWNvcmRDcmVhdGVkLCB7XG4gICAgICAgICAgICByZWNvcmQ6cmVjb3JkQ2xvbmVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBvbGRSZWNvcmQgPSBhd2FpdCBfbG9hZChhcHAsIHJlY29yZENsb25lLmtleSk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdHJhbnNhY3Rpb25Gb3JVcGRhdGVSZWNvcmQoXG4gICAgICAgICAgICBhcHAsIG9sZFJlY29yZCwgcmVjb3JkQ2xvbmUpO1xuICAgICAgICByZWNvcmRDbG9uZS50cmFuc2FjdGlvbklkID0gdHJhbnNhY3Rpb24uaWQ7XG4gICAgICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUudXBkYXRlSnNvbihcbiAgICAgICAgICAgIGdldFJlY29yZEZpbGVOYW1lKHJlY29yZENsb25lLmtleSksIFxuICAgICAgICAgICAgcmVjb3JkQ2xvbmUpO1xuICAgICAgICBcbiAgICAgICAgYXBwLnB1Ymxpc2goZXZlbnRzLnJlY29yZEFwaS5zYXZlLm9uUmVjb3JkVXBkYXRlZCwge1xuICAgICAgICAgICAgb2xkOm9sZFJlY29yZCxcbiAgICAgICAgICAgIG5ldzpyZWNvcmRDbG9uZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhd2FpdCBhcHAuY2xlYW51cFRyYW5zYWN0aW9ucygpO1xuICAgXG4gICAgY29uc3QgcmV0dXJuZWRDbG9uZSA9IGNsb25lRGVlcChyZWNvcmRDbG9uZSk7XG4gICAgcmV0dXJuZWRDbG9uZS5pc05ldyA9IGZhbHNlO1xuICAgIHJldHVybiByZXR1cm5lZENsb25lO1xufTtcblxuY29uc3QgaW5pdGlhbGlzZUFuY2VzdG9ySW5kZXhlcyA9IGFzeW5jIChhcHAsIHJlY29yZCkgPT4ge1xuICAgIGNvbnN0IHJlY29yZE5vZGUgPSBnZXRFeGFjdE5vZGVGb3JQYXRoKGFwcC5oZWlyYXJjaHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVjb3JkLmtleSk7XG5cbiAgICBmb3IobGV0IGluZGV4IG9mIHJlY29yZE5vZGUuaW5kZXhlcykge1xuICAgICAgICBjb25zdCBpbmRleEtleSA9IGpvaW5LZXkocmVjb3JkLmtleSwgaW5kZXgubmFtZSk7XG4gICAgICAgIGlmKCFhd2FpdCBhcHAuZGF0YXN0b3JlLmV4aXN0cyhpbmRleEtleSkpXG4gICAgICAgICAgICBhd2FpdCBpbml0aWFsaXNlSW5kZXgoYXBwLmRhdGFzdG9yZSwgcmVjb3JkLmtleSwgaW5kZXgpO1xuICAgIH0gXG59XG5cbmNvbnN0IGluaXRpYWxpc2VSZXZlcnNlUmVmZXJlbmNlSW5kZXhlcyA9IGFzeW5jIChhcHAsIHJlY29yZCkgPT4ge1xuXG4gICAgY29uc3QgcmVjb3JkTm9kZSA9IGdldEV4YWN0Tm9kZUZvclBhdGgoYXBwLmhlaXJhcmNoeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWNvcmQua2V5KTtcblxuICAgIGNvbnN0IGluZGV4Tm9kZXMgPSBcbiAgICAgICAgJChmaWVsZHNUaGF0UmVmZXJlbmNlVGhpc1JlY29yZChhcHAsIHJlY29yZE5vZGUpLCBbXG4gICAgICAgICAgICBtYXAoZiA9PiAkKGYudHlwZU9wdGlvbnMucmV2ZXJzZUluZGV4Tm9kZUtleXMsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcChuID0+IGdldE5vZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAuaGVpcmFyY2h5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbikpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZmxhdHRlblxuICAgICAgICBdKTtcblxuICAgIGZvcihsZXQgaW5kZXhOb2RlIG9mIGluZGV4Tm9kZXMpIHtcbiAgICAgICAgYXdhaXQgaW5pdGlhbGlzZUluZGV4KFxuICAgICAgICAgICAgYXBwLmRhdGFzdG9yZSwgcmVjb3JkLmtleSwgaW5kZXhOb2RlXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5jb25zdCBtYWludGFpblJlZmVyZW50aWFsSW50ZWdyaXR5ID0gXG4gICAgYXN5bmMgKGFwcCwgaW5kZXhpbmdBcGksIG9sZFJlY29yZCwgbmV3UmVjb3JkKSA9PiB7XG4gICAgLypcbiAgICBGT1JFQUNIIEZpZWxkIHRoYXQgcmVmZXJlbmNlIHRoaXMgb2JqZWN0XG4gICAgLSBvcHRpb25zIEluZGV4IG5vZGUgdGhhdCBmb3IgZmllbGRcbiAgICAtIGhhcyBvcHRpb25zIGluZGV4IGNoYW5nZWQgZm9yIHJlZmVyZW5jZWQgcmVjb3JkP1xuICAgIC0gRk9SRUFDSCByZXZlcnNlIGluZGV4IG9mIGZpZWxkXG4gICAgICAtIEZPUkVBQ0ggcmVmZXJlbmNpbmdSZWNvcmQgaW4gcmV2ZXJzZSBpbmRleFxuICAgICAgICAtIElzIGZpZWxkIHZhbHVlIHN0aWxsIHBvaW50aW5nIHRvIHJlZmVyZW5jZWRSZWNvcmRcbiAgICAgICAgLSBVcGRhdGUgcmVmZXJlbmNpbmdSZWNvcmQuZmllbGROYW1lIHRvIG5ldyB2YWx1ZSBcbiAgICAgICAgLSBTYXZlXG4gICAgKi9cbiAgICBjb25zdCByZWNvcmROb2RlID0gZ2V0RXhhY3ROb2RlRm9yUGF0aChhcHAuaGVpcmFyY2h5KShuZXdSZWNvcmQua2V5KTtcbiAgICBjb25zdCByZWZlcmVuY2VGaWVsZHMgPSBmaWVsZHNUaGF0UmVmZXJlbmNlVGhpc1JlY29yZChcbiAgICAgICAgYXBwLCByZWNvcmROb2RlKTtcbiAgICBcbiAgICBjb25zdCB1cGRhdGVzID0gJChyZWZlcmVuY2VGaWVsZHMsIFtcbiAgICAgICAgbWFwKGYgPT4gKHtcbiAgICAgICAgICAgIG5vZGU6IGdldE5vZGUoXG4gICAgICAgICAgICAgICAgYXBwLmhlaXJhcmNoeSwgZi50eXBlT3B0aW9ucy5pbmRleE5vZGVLZXkpLFxuICAgICAgICAgICAgZmllbGQ6IGZcbiAgICAgICAgfSkpLFxuICAgICAgICBtYXAobiA9PiAoe1xuICAgICAgICAgICAgb2xkOiBtYXBSZWNvcmQob2xkUmVjb3JkLCBuLm5vZGUpLFxuICAgICAgICAgICAgbmV3OiBtYXBSZWNvcmQobmV3UmVjb3JkLCBuLm5vZGUpLFxuICAgICAgICAgICAgaW5kZXhOb2RlOiBuLm5vZGUsXG4gICAgICAgICAgICBmaWVsZDogbi5maWVsZCxcbiAgICAgICAgICAgIHJldmVyc2VJbmRleEtleXM6IFxuICAgICAgICAgICAgICAgICQobi5maWVsZC50eXBlT3B0aW9ucy5yZXZlcnNlSW5kZXhOb2RlS2V5cyxbXG4gICAgICAgICAgICAgICAgICAgIG1hcChrID0+IGpvaW5LZXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSZWNvcmQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TGFzdFBhcnRJbktleShrKSkpXG4gICAgICAgICAgICAgICAgXSkgIFxuICAgICAgICB9KSksXG4gICAgICAgIGZpbHRlcihkaWZmID0+ICFpc0VxdWFsKGRpZmYub2xkKShkaWZmLm5ldykpXG4gICAgXSk7XG5cbiAgICBmb3IobGV0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICAgIGZvcihsZXQgcmV2ZXJzZUluZGV4S2V5IG9mIHVwZGF0ZS5yZXZlcnNlSW5kZXhLZXlzKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJvd3MgPSBhd2FpdCBsaXN0SXRlbXMoYXBwKShyZXZlcnNlSW5kZXhLZXkpO1xuXG4gICAgICAgICAgICBmb3IobGV0IGtleSBvZiBtYXAociA9PiByLmtleSkocm93cykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmQgPSBcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgX2xvYWQoYXBwLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmKHJlY29yZFt1cGRhdGUuZmllbGQubmFtZV0ua2V5ID09PSBuZXdSZWNvcmQua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZFt1cGRhdGUuZmllbGQubmFtZV0gPSB1cGRhdGUubmV3O1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBfc2F2ZShhcHAsIGluZGV4aW5nQXBpLCByZWNvcmQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmNvbnN0IGZpZWxkc1RoYXRSZWZlcmVuY2VUaGlzUmVjb3JkID0gKGFwcCwgcmVjb3JkTm9kZSkgPT5cbiAgICAkKGFwcC5oZWlyYXJjaHksIFtcbiAgICAgICAgZ2V0RmxhdHRlbmVkSGllcmFyY2h5LFxuICAgICAgICBmaWx0ZXIoaXNSZWNvcmQpLFxuICAgICAgICBtYXAobiA9PiBuLmZpZWxkcyksXG4gICAgICAgIGZsYXR0ZW4sXG4gICAgICAgIGZpbHRlcihmaWVsZFJldmVyc2VzUmVmZXJlbmNlVG9Ob2RlKHJlY29yZE5vZGUpKVxuICAgIF0pO1xuIiwiaW1wb3J0IHthcGlXcmFwcGVyLCBldmVudHMsIFxyXG4gICAgICAgIHRyeUF3YWl0T3JJZ25vcmV9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHtpc0luZGV4LCBpc1NoYXJkZWRJbmRleCxcclxuICAgICAgICBnZXRFeGFjdE5vZGVGb3JQYXRofSBmcm9tIFwiLi4vdGVtcGxhdGVBcGkvaGVpcmFyY2h5XCI7XHJcbmltcG9ydCB7Z2V0QWxsU2hhcmRLZXlzLCBnZXRTaGFyZE1hcEtleSxcclxuICAgICAgICBnZXRVbnNoYXJkZWRJbmRleERhdGFLZXl9IGZyb20gXCIuLi9pbmRleGluZy9zaGFyZGluZ1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IF9kZWxldGVJbmRleCA9IGFzeW5jIChhcHAsIGluZGV4S2V5LCBpbmNsdWRlRm9sZGVyKSA9PiB7XHJcbiAgICBjb25zdCBpbmRleE5vZGUgPSBnZXRFeGFjdE5vZGVGb3JQYXRoKGFwcC5oZWlyYXJjaHkpKGluZGV4S2V5KTtcclxuICAgIFxyXG4gICAgaWYoIWlzSW5kZXgoaW5kZXhOb2RlKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwbGllZCBrZXkgaXMgbm90IGFuIGluZGV4XCIpO1xyXG4gICAgXHJcbiAgICBpZihpc1NoYXJkZWRJbmRleChpbmRleE5vZGUpKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhcmRLZXlzID0gYXdhaXQgZ2V0QWxsU2hhcmRLZXlzKGFwcCwgaW5kZXhLZXkpO1xyXG4gICAgICAgIGZvcihsZXQgayBvZiBzaGFyZEtleXMpIHtcclxuICAgICAgICAgICAgYXdhaXQgdHJ5QXdhaXRPcklnbm9yZShcclxuICAgICAgICAgICAgICAgIGFwcC5kYXRhc3RvcmUuZGVsZXRlRmlsZShrKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnlBd2FpdE9ySWdub3JlKFxyXG4gICAgICAgICAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLmRlbGV0ZUZpbGUoXHJcbiAgICAgICAgICAgICAgICBnZXRTaGFyZE1hcEtleShpbmRleEtleSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IHRyeUF3YWl0T3JJZ25vcmUoXHJcbiAgICAgICAgICAgIGFwcC5kYXRhc3RvcmUuZGVsZXRlRmlsZShcclxuICAgICAgICAgICAgICAgIGdldFVuc2hhcmRlZEluZGV4RGF0YUtleShpbmRleEtleSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoaW5jbHVkZUZvbGRlcikge1xyXG4gICAgICAgIHRyeUF3YWl0T3JJZ25vcmUoXHJcbiAgICAgICAgICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUuZGVsZXRlRm9sZGVyKGluZGV4S2V5KVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn07XHJcbiIsImltcG9ydCB7Z2V0Tm9kZUZvckNvbGxlY3Rpb25QYXRofSBmcm9tIFwiLi4vdGVtcGxhdGVBcGkvaGVpcmFyY2h5XCI7XHJcbmltcG9ydCB7c2FmZUtleSwgYXBpV3JhcHBlciwgXHJcbiAgICAgICAgZXZlbnRzLCBqb2luS2V5fSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7X2RlbGV0ZVJlY29yZH0gZnJvbSBcIi4uL3JlY29yZEFwaS9kZWxldGVcIjtcclxuaW1wb3J0IHtnZXRBbGxJZHNJdGVyYXRvciwgZ2V0QWxsSWRzU2hhcmRLZXl9IGZyb20gXCIuLi9pbmRleGluZy9hbGxJZHNcIjtcclxuaW1wb3J0IHtfZGVsZXRlSW5kZXh9IGZyb20gXCIuLi9pbmRleEFwaS9kZWxldGVcIjtcclxuaW1wb3J0IHtpbmNsdWRlc30gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5pbXBvcnQge3Blcm1pc3Npb259IGZyb20gXCIuLi9hdXRoQXBpL3Blcm1pc3Npb25zXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZGVsZXRlQ29sbGVjdGlvbiA9IChhcHAsIGRpc2FibGVDbGVhbnVwPWZhbHNlKSA9PiBhc3luYyBrZXkgPT4gXHJcbiAgICBhcGlXcmFwcGVyKFxyXG4gICAgICAgIGFwcCxcclxuICAgICAgICBldmVudHMuY29sbGVjdGlvbkFwaS5kZWxldGUsIFxyXG4gICAgICAgIHBlcm1pc3Npb24ubWFuYWdlQ29sbGVjdGlvbi5pc0F1dGhvcml6ZWQsXHJcbiAgICAgICAge2tleX0sXHJcbiAgICAgICAgX2RlbGV0ZUNvbGxlY3Rpb24sIGFwcCwga2V5LCBkaXNhYmxlQ2xlYW51cCk7XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IF9kZWxldGVDb2xsZWN0aW9uID0gYXN5bmMgKGFwcCwga2V5LCBkaXNhYmxlQ2xlYW51cCkgPT4ge1xyXG4gICAga2V5ID0gc2FmZUtleShrZXkpO1xyXG4gICAgY29uc3Qgbm9kZSA9IGdldE5vZGVGb3JDb2xsZWN0aW9uUGF0aChhcHAuaGVpcmFyY2h5KShrZXkpO1xyXG4gICAgXHJcbiAgICBhd2FpdCBkZWxldGVSZWNvcmRzKGFwcCwga2V5KTtcclxuICAgIGF3YWl0IGRlbGV0ZUFsbElkc0ZvbGRlcnMoYXBwLCBub2RlLCBrZXkpO1xyXG4gICAgYXdhaXQgZGVsZXRlQ29sbGVjdGlvbkZvbGRlcihhcHAsIGtleSk7XHJcbiAgICBpZighZGlzYWJsZUNsZWFudXApXHJcbiAgICAgICAgYXdhaXQgYXBwLmNsZWFudXBUcmFuc2FjdGlvbnMoKTtcclxufTtcclxuXHJcbmNvbnN0IGRlbGV0ZUNvbGxlY3Rpb25Gb2xkZXIgPSBhc3luYyAoYXBwLCBrZXkpID0+XHJcbiAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLmRlbGV0ZUZvbGRlcihrZXkpO1xyXG5cclxuXHJcbmNvbnN0IGRlbGV0ZUFsbElkc0ZvbGRlcnMgPSBhc3luYyAoYXBwLCBub2RlLCBrZXkpID0+IHtcclxuICAgICAgICBcclxuICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUuZGVsZXRlRm9sZGVyKFxyXG4gICAgICAgIGpvaW5LZXkoXHJcbiAgICAgICAgICAgIGtleSwgXCJhbGxpZHNcIiwgXHJcbiAgICAgICAgICAgIG5vZGUubm9kZUlkXHJcbiAgICAgICAgKVxyXG4gICAgKTsgICAgXHJcblxyXG4gICAgYXdhaXQgYXBwLmRhdGFzdG9yZS5kZWxldGVGb2xkZXIoXHJcbiAgICAgICAgam9pbktleShrZXksIFwiYWxsaWRzXCIpXHJcbiAgICApO1xyXG59O1xyXG5cclxuY29uc3QgZGVsZXRlUmVjb3JkcyA9IGFzeW5jIChhcHAsIGtleSkgPT4ge1xyXG5cclxuXHJcbiAgICBjb25zdCBkZWxldGVkQWxsSWRzU2hhcmRzID0gW107XHJcbiAgICBjb25zdCBkZWxldGVBbGxJZHNTaGFyZCA9IGFzeW5jIHJlY29yZElkID0+IHtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBzaGFyZEtleSA9IGdldEFsbElkc1NoYXJkS2V5KFxyXG4gICAgICAgICAgICBhcHAuaGVpcmFyY2h5LCBrZXksIHJlY29yZElkKTtcclxuXHJcbiAgICAgICAgaWYoaW5jbHVkZXMoc2hhcmRLZXkpKGRlbGV0ZWRBbGxJZHNTaGFyZHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlbGV0ZWRBbGxJZHNTaGFyZHMucHVzaChzaGFyZEtleSk7XHJcblxyXG4gICAgICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUuZGVsZXRlRmlsZShzaGFyZEtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaXRlcmF0ZSA9IGF3YWl0IGdldEFsbElkc0l0ZXJhdG9yKGFwcCkoa2V5KTtcclxuXHJcbiAgICBsZXQgaWRzID0gYXdhaXQgaXRlcmF0ZSgpO1xyXG4gICAgd2hpbGUoIWlkcy5kb25lKSB7XHJcblxyXG4gICAgICAgIGlmKGlkcy5yZXN1bHQuY29sbGVjdGlvbktleSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaWQgb2YgaWRzLnJlc3VsdC5pZHMpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IF9kZWxldGVSZWNvcmQoXHJcbiAgICAgICAgICAgICAgICAgICAgYXBwLCBcclxuICAgICAgICAgICAgICAgICAgICBqb2luS2V5KGtleSwgaWQpLCBcclxuICAgICAgICAgICAgICAgICAgICB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGRlbGV0ZUFsbElkc1NoYXJkKGlkKTtcclxuICAgICAgICAgICAgfSAgICAgICBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlkcyA9IGF3YWl0IGl0ZXJhdGUoKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxufTsiLCJpbXBvcnQge3NhZmVLZXksIGFwaVdyYXBwZXIsIGlzU29tZXRoaW5nLCBcbiAgICBldmVudHMsIGpvaW5LZXksICR9IGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7X2xvYWQsIGdldFJlY29yZEZpbGVOYW1lfSBmcm9tIFwiLi9sb2FkXCI7XG5pbXBvcnQge19kZWxldGVDb2xsZWN0aW9ufSBmcm9tIFwiLi4vY29sbGVjdGlvbkFwaS9kZWxldGVcIjtcbmltcG9ydCB7Z2V0RXhhY3ROb2RlRm9yUGF0aCwgXG4gICAgICAgIGdldEZsYXR0ZW5lZEhpZXJhcmNoeSwgZ2V0Tm9kZSxcbiAgICAgICAgZmllbGRSZXZlcnNlc1JlZmVyZW5jZVRvTm9kZX0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xuaW1wb3J0IHttYXAsIGZsYXR0ZW4sIGZpbHRlcn0gZnJvbSBcImxvZGFzaC9mcFwiO1xuaW1wb3J0IHtfZGVsZXRlSW5kZXh9IGZyb20gXCIuLi9pbmRleEFwaS9kZWxldGVcIjtcbmltcG9ydCB7dHJhbnNhY3Rpb25Gb3JEZWxldGVSZWNvcmR9IGZyb20gXCIuLi90cmFuc2FjdGlvbnMvY3JlYXRlXCI7XG5pbXBvcnQge3JlbW92ZUZyb21BbGxJZHN9IGZyb20gXCIuLi9pbmRleGluZy9hbGxJZHNcIjtcbmltcG9ydCB7cGVybWlzc2lvbn0gZnJvbSBcIi4uL2F1dGhBcGkvcGVybWlzc2lvbnNcIjtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVJlY29yZCA9IChhcHAsIGRpc2FibGVDbGVhbnVwPWZhbHNlKSA9PiBhc3luYyAoa2V5KSA9PiBcbiAgICBhcGlXcmFwcGVyKFxuICAgICAgICBhcHAsXG4gICAgICAgIGV2ZW50cy5yZWNvcmRBcGkuZGVsZXRlLCBcbiAgICAgICAgcGVybWlzc2lvbi5kZWxldGVSZWNvcmQuaXNBdXRob3JpemVkKGtleSksXG4gICAgICAgIHtrZXl9LFxuICAgICAgICBfZGVsZXRlUmVjb3JkLCBhcHAsIGtleSwgZGlzYWJsZUNsZWFudXApO1xuXG4vLyBjYWxsZWQgZGVsZXRlUmVjb3JkIGJlY2F1c2UgZGVsZXRlIGlzIGEga2V5d29yZFxuZXhwb3J0IGNvbnN0IF9kZWxldGVSZWNvcmQgPSBhc3luYyAoYXBwLCBrZXksIGRpc2FibGVDbGVhbnVwKSA9PiB7IFxuICAgIGtleSA9IHNhZmVLZXkoa2V5KTtcbiAgICBjb25zdCBub2RlID0gZ2V0RXhhY3ROb2RlRm9yUGF0aChhcHAuaGVpcmFyY2h5KShrZXkpO1xuICAgIFxuICAgIGNvbnN0IHJlY29yZCA9IGF3YWl0IF9sb2FkKGFwcCwga2V5KTtcbiAgICBhd2FpdCB0cmFuc2FjdGlvbkZvckRlbGV0ZVJlY29yZChhcHAsIHJlY29yZCk7XG5cbiAgICBcbiAgICBmb3IobGV0IGNvbGxlY3Rpb25SZWNvcmQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uS2V5ID0gam9pbktleShcbiAgICAgICAgICAgIGtleSwgY29sbGVjdGlvblJlY29yZC5jb2xsZWN0aW9uTmFtZVxuICAgICAgICApO1xuICAgICAgICBhd2FpdCBfZGVsZXRlQ29sbGVjdGlvbihhcHAsIGNvbGxlY3Rpb25LZXksIHRydWUpO1xuICAgIH1cblxuICAgIFxuICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUuZGVsZXRlRmlsZShcbiAgICAgICAgZ2V0UmVjb3JkRmlsZU5hbWUoa2V5KSk7XG5cbiAgICBhd2FpdCBkZWxldGVGaWxlcyhhcHAsIGtleSk7XG5cbiAgICBhd2FpdCByZW1vdmVGcm9tQWxsSWRzKGFwcC5oZWlyYXJjaHksIGFwcC5kYXRhc3RvcmUpKHJlY29yZCk7XG4gICAgXG4gICAgaWYoIWRpc2FibGVDbGVhbnVwKVxuICAgICAgICBhd2FpdCBhcHAuY2xlYW51cFRyYW5zYWN0aW9ucygpO1xuICAgICAgICBcbiAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLmRlbGV0ZUZvbGRlcihrZXkpO1xuICAgIGF3YWl0IGRlbGV0ZUluZGV4ZXMoYXBwLCBrZXkpXG59O1xuXG5jb25zdCBkZWxldGVJbmRleGVzID0gYXN5bmMgKGFwcCwga2V5KSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGdldEV4YWN0Tm9kZUZvclBhdGgoYXBwLmhlaXJhcmNoeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChrZXkpO1xuICAgIC8qY29uc3QgcmV2ZXJzZUluZGV4S2V5cyA9ICQoYXBwLmhlaXJhcmNoeSwgW1xuICAgICAgICBnZXRGbGF0dGVuZWRIaWVyYXJjaHksXG4gICAgICAgIG1hcChuID0+IG4uZmllbGRzKSxcbiAgICAgICAgZmxhdHRlbixcbiAgICAgICAgZmlsdGVyKGlzU29tZXRoaW5nKSxcbiAgICAgICAgZmlsdGVyKGZpZWxkUmV2ZXJzZXNSZWZlcmVuY2VUb05vZGUobm9kZSkpLFxuICAgICAgICBtYXAoZiA9PiAkKGYudHlwZU9wdGlvbnMucmV2ZXJzZUluZGV4Tm9kZUtleXMsIFtcbiAgICAgICAgICAgICAgICAgICAgbWFwKG4gPT4gZ2V0Tm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwLmhlaXJhcmNoeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbikpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgKSxcbiAgICAgICAgZmxhdHRlbixcbiAgICAgICAgbWFwKG4gPT4gam9pbktleShrZXksIG4ubmFtZSkpXG4gICAgXSk7XG5cbiAgICBmb3IobGV0IGkgb2YgcmV2ZXJzZUluZGV4S2V5cykge1xuICAgICAgICBhd2FpdCBfZGVsZXRlSW5kZXgoYXBwLCBpLCB0cnVlKTtcbiAgICB9Ki9cblxuICAgIGZvcihsZXQgaW5kZXggb2Ygbm9kZS5pbmRleGVzKSB7XG4gICAgICAgIGNvbnN0IGluZGV4S2V5ID0gam9pbktleShrZXksIGluZGV4Lm5hbWUpO1xuICAgICAgICBhd2FpdCBfZGVsZXRlSW5kZXgoYXBwLCBpbmRleEtleSwgdHJ1ZSk7XG4gICAgfVxufVxuXG5jb25zdCBkZWxldGVGaWxlcyA9IGFzeW5jIChhcHAsIGtleSkgPT4ge1xuICAgIFxuICAgIGNvbnN0IGZpbGVzRm9sZGVyID0gam9pbktleShrZXksIFwiZmlsZXNcIik7XG4gICAgY29uc3QgYWxsRmlsZXMgPSBhd2FpdCBhcHAuZGF0YXN0b3JlLmdldEZvbGRlckNvbnRlbnRzKFxuICAgICAgICBmaWxlc0ZvbGRlclxuICAgICk7XG5cbiAgICBmb3IobGV0IGZpbGUgb2YgYWxsRmlsZXMpIHtcbiAgICAgICAgYXdhaXQgYXBwLmRhdGFzdG9yZS5kZWxldGVGaWxlKGZpbGUpO1xuICAgIH1cbiAgICBcbiAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLmRlbGV0ZUZvbGRlcihcbiAgICAgICAgam9pbktleShrZXksIFwiZmlsZXNcIilcbiAgICApO1xufSIsImltcG9ydCB7aW5jbHVkZXMsIGZpbHRlciwgXHJcbiAgICBtYXAsIHNvbWV9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHtfbG9hZH0gZnJvbSBcIi4vbG9hZFwiO1xyXG5pbXBvcnQge2FwaVdyYXBwZXIsIGV2ZW50cywgc3BsaXRLZXksIFxyXG4gICAgICAgICQsIGpvaW5LZXksIGlzTm90aGluZywgdHJ5QXdhaXRPcklnbm9yZX0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQgeyBnZXRFeGFjdE5vZGVGb3JQYXRofSBmcm9tIFwiLi4vdGVtcGxhdGVBcGkvaGVpcmFyY2h5XCI7XHJcbmltcG9ydCB7cGVybWlzc2lvbn0gZnJvbSBcIi4uL2F1dGhBcGkvcGVybWlzc2lvbnNcIjtcclxuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCB7Z2VuZXJhdGV9IGZyb20gXCJzaG9ydGlkXCI7XHJcbmltcG9ydCB7aXNMZWdhbEZpbGVuYW1lfSBmcm9tIFwiLi4vdHlwZXMvZmlsZVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwbG9hZEZpbGUgPSAoYXBwKSA9PiBhc3luYyAocmVjb3JkS2V5LCByZWFkYWJsZVN0cmVhbSwgcmVsYXRpdmVQYXRoKSA9PiBcclxuICAgIGFwaVdyYXBwZXIoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGV2ZW50cy5yZWNvcmRBcGkudXBsb2FkRmlsZSwgXHJcbiAgICAgICAgcGVybWlzc2lvbi51cGRhdGVSZWNvcmQuaXNBdXRob3JpemVkKHJlY29yZEtleSksXHJcbiAgICAgICAge3JlY29yZEtleSwgcmVhZGFibGVTdHJlYW0sIHJlbGF0aXZlUGF0aH0sXHJcbiAgICAgICAgX3VwbG9hZEZpbGUsIGFwcCwgcmVjb3JkS2V5LCByZWFkYWJsZVN0cmVhbSwgcmVsYXRpdmVQYXRoKTtcclxuXHJcblxyXG5jb25zdCBfdXBsb2FkRmlsZSA9IGFzeW5jIChhcHAsIHJlY29yZEtleSwgcmVhZGFibGVTdHJlYW0sIHJlbGF0aXZlUGF0aCkgPT4ge1xyXG4gICAgXHJcbiAgICBpZihpc05vdGhpbmcocmVjb3JkS2V5KSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWNvcmQgS2V5IG5vdCBzdXBwbGllZFwiKTtcclxuICAgIGlmKGlzTm90aGluZyhyZWxhdGl2ZVBhdGgpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpbGUgcGF0aCBub3Qgc3VwcGxpZWRcIik7XHJcbiAgICBpZighaXNMZWdhbEZpbGVuYW1lKHJlbGF0aXZlUGF0aCkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBmaWxlbmFtZVwiKTtcclxuXHJcblxyXG4gICAgY29uc3QgcmVjb3JkID0gYXdhaXQgX2xvYWQoYXBwLCByZWNvcmRLZXkpO1xyXG4gICAgXHJcbiAgICBjb25zdCBmdWxsRmlsZVBhdGggPSBzYWZlR2V0RnVsbEZpbGVQYXRoKFxyXG4gICAgICAgIHJlY29yZEtleSwgcmVsYXRpdmVQYXRoKTtcclxuXHJcbiAgICBjb25zdCB0ZW1wRmlsZVBhdGggPSBgJHtmdWxsRmlsZVBhdGh9XyR7Z2VuZXJhdGUoKX0udGVtcGA7XHJcblxyXG4gICAgY29uc3QgZmlsZVN0cmVhbSA9IGF3YWl0IGFwcC5kYXRhc3RvcmUud3JpdGFibGVGaWxlU3RyZWFtKFxyXG4gICAgICAgIHRlbXBGaWxlUGF0aCk7XHJcblxyXG4gICAgcmVhZGFibGVTdHJlYW0ucGlwZShmaWxlU3RyZWFtKTsgICAgXHJcblxyXG4gICAgYXdhaXQgbmV3IFByb21pc2UoZnVsZmlsbCA9PiBmaWxlU3RyZWFtLm9uKFwiZmluaXNoXCIsIGZ1bGZpbGwpKTtcclxuXHJcbiAgICBjb25zdCBpc0V4cGVjdGVkRmlsZVNpemUgPSBjaGVja0ZpbGVTaXplQWdhaW5zdEZpZWxkcyhcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgcmVjb3JkLCByZWxhdGl2ZVBhdGgsIFxyXG4gICAgICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUuZ2V0RmlsZVNpemUodGVtcEZpbGVQYXRoKSk7XHJcblxyXG4gICAgaWYoIWlzRXhwZWN0ZWRGaWxlU2l6ZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZHMgZm9yIFwiICsgcmVsYXRpdmVGaWxlUGF0aCArIFwiIGRvIG5vdCBoYXZlIGV4cGVjdGVkIHNpemU6IFwiICsgam9pbihcIixcIikoaW5jb3JyZWN0RmllbGRzKSk7XHJcbiAgICBcclxuICAgIGF3YWl0IHRyeUF3YWl0T3JJZ25vcmUoYXBwLmRhdGFzdG9yZS5kZWxldGVGaWxlLCBmdWxsRmlsZVBhdGgpO1xyXG5cclxuICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUucmVuYW1lRmlsZSh0ZW1wRmlsZVBhdGgsIGZ1bGxGaWxlUGF0aCk7XHJcbn1cclxuXHJcbmNvbnN0IGNoZWNrRmlsZVNpemVBZ2FpbnN0RmllbGRzID0gKGFwcCwgcmVjb3JkLCByZWxhdGl2ZUZpbGVQYXRoLCBleHBlY3RlZFNpemUpID0+IHtcclxuICAgIGNvbnN0IHJlY29yZE5vZGUgPSBnZXRFeGFjdE5vZGVGb3JQYXRoKGFwcC5oZWlyYXJjaHkpKHJlY29yZC5rZXkpO1xyXG5cclxuICAgIGNvbnN0IGluY29ycmVjdEZpbGVGaWVsZHMgPSAkKHJlY29yZE5vZGUuZmllbGRzLCBbXHJcbiAgICAgICAgZmlsdGVyKGYgPT4gZi50eXBlID09PSBcImZpbGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICYmIHJlY29yZFtmLm5hbWVdLnJlbGF0aXZlUGF0aCA9PT0gcmVsYXRpdmVGaWxlUGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICYmIHJlY29yZFtmLm5hbWVdLnNpemUgIT09IGV4cGVjdGVkU2l6ZSksXHJcbiAgICAgICAgbWFwKGYgPT4gZi5uYW1lKVxyXG4gICAgXSk7XHJcblxyXG4gICAgY29uc3QgaW5jb3JyZWN0RmlsZUFycmF5RmllbGRzID0gJChyZWNvcmROb2RlLmZpZWxkcywgW1xyXG4gICAgICAgIGZpbHRlcihhID0+IGEudHlwZSA9PT0gXCJhcnJheTxmaWxlPlwiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgJChyZWNvcmRbYS5uYW1lXSwgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb21lKGYgPT4gcmVjb3JkW2YubmFtZV0ucmVsYXRpdmVQYXRoID09PSByZWxhdGl2ZUZpbGVQYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiByZWNvcmRbZi5uYW1lXS5zaXplICE9PSBleHBlY3RlZFNpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICApLFxyXG4gICAgICAgIG1hcChmID0+IGYubmFtZSlcclxuICAgIF0pO1xyXG5cclxuICAgIGNvbnN0IGluY29ycmVjdEZpZWxkcyA9IFtcclxuICAgICAgICAuLi5pbmNvcnJlY3RGaWxlRmllbGRzLFxyXG4gICAgICAgIC4uLmluY29ycmVjdEZpbGVBcnJheUZpZWxkc1xyXG4gICAgXTtcclxuXHJcbiAgICBpZihpbmNvcnJlY3RGaWVsZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHNhZmVHZXRGdWxsRmlsZVBhdGggPSAocmVjb3JkS2V5LCByZWxhdGl2ZVBhdGgpID0+IHtcclxuICAgXHJcbiAgICBjb25zdCBuYXVnaHR5VXNlciA9ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKFwibmF1Z2h0eSBuYXVnaHR5XCIpOyB9O1xyXG5cclxuICAgIGlmKHJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiLi5cIikpIG5hdWdodHlVc2VyKCk7XHJcblxyXG4gICAgY29uc3QgcGF0aFBhcnRzID0gc3BsaXRLZXkocmVsYXRpdmVQYXRoKTtcclxuXHJcbiAgICBpZihpbmNsdWRlcyhcIi4uXCIpKHBhdGhQYXJ0cykpIG5hdWdodHlVc2VyKCk7XHJcblxyXG4gICAgY29uc3QgcmVjb3JkS2V5UGFydHMgPSBzcGxpdEtleShyZWNvcmRLZXkpO1xyXG5cclxuICAgIGNvbnN0IGZ1bGxQYXRoUGFydHMgPSBbXHJcbiAgICAgICAgLi4ucmVjb3JkS2V5UGFydHMsXHJcbiAgICAgICAgXCJmaWxlc1wiLCBcclxuICAgICAgICAuLi5maWx0ZXIocCA9PiBwICE9PSBcIi5cIikocGF0aFBhcnRzKVxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gam9pbktleShmdWxsUGF0aFBhcnRzKTtcclxuXHJcbn0iLCJpbXBvcnQge2FwaVdyYXBwZXIsIGV2ZW50cywgaXNOb3RoaW5nfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7cGVybWlzc2lvbn0gZnJvbSBcIi4uL2F1dGhBcGkvcGVybWlzc2lvbnNcIjtcclxuaW1wb3J0IHtzYWZlR2V0RnVsbEZpbGVQYXRofSBmcm9tIFwiLi91cGxvYWRGaWxlXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZG93bmxvYWRGaWxlID0gKGFwcCkgPT4gYXN5bmMgKHJlY29yZEtleSwgcmVsYXRpdmVQYXRoKSA9PiBcclxuICAgIGFwaVdyYXBwZXIoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGV2ZW50cy5yZWNvcmRBcGkudXBsb2FkRmlsZSwgXHJcbiAgICAgICAgcGVybWlzc2lvbi5yZWFkUmVjb3JkLmlzQXV0aG9yaXplZChyZWNvcmRLZXkpLFxyXG4gICAgICAgIHtyZWNvcmRLZXksIHJlY29yZEtleSwgcmVsYXRpdmVQYXRofSxcclxuICAgICAgICBfZG93bmxvYWRGaWxlLCBhcHAsIHJlY29yZEtleSwgcmVsYXRpdmVQYXRoKTtcclxuXHJcblxyXG5jb25zdCBfZG93bmxvYWRGaWxlID0gYXN5bmMgKGFwcCwgcmVjb3JkS2V5LCByZWxhdGl2ZVBhdGgpID0+IHtcclxuICAgIFxyXG4gICAgaWYoaXNOb3RoaW5nKHJlY29yZEtleSkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjb3JkIEtleSBub3Qgc3VwcGxpZWRcIik7XHJcbiAgICBpZihpc05vdGhpbmcocmVsYXRpdmVQYXRoKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWxlIHBhdGggbm90IHN1cHBsaWVkXCIpO1xyXG5cclxuICAgIHJldHVybiBhd2FpdCBhcHAuZGF0YXN0b3JlLnJlYWRhYmxlRmlsZVN0cmVhbShcclxuICAgICAgICBzYWZlR2V0RnVsbEZpbGVQYXRoKFxyXG4gICAgICAgICAgICByZWNvcmRLZXksIHJlbGF0aXZlUGF0aClcclxuICAgICk7XHJcbn07XHJcblxyXG4iLCJpbXBvcnQge2dldE5ldywgZ2V0TmV3Q2hpbGR9IGZyb20gXCIuL2dldE5ld1wiO1xuaW1wb3J0IHtsb2FkfSBmcm9tIFwiLi9sb2FkXCI7XG5pbXBvcnQge3ZhbGlkYXRlfSBmcm9tIFwiLi92YWxpZGF0ZVwiO1xuaW1wb3J0IHtnZXRDb250ZXh0fSBmcm9tIFwiLi9nZXRDb250ZXh0XCI7XG5pbXBvcnQge3NhdmV9IGZyb20gXCIuL3NhdmVcIjtcbmltcG9ydCB7ZGVsZXRlUmVjb3JkfSBmcm9tIFwiLi9kZWxldGVcIjtcbmltcG9ydCB7dXBsb2FkRmlsZX0gZnJvbSBcIi4vdXBsb2FkRmlsZVwiO1xuaW1wb3J0IHtkb3dubG9hZEZpbGV9IGZyb20gXCIuL2Rvd25sb2FkRmlsZVwiO1xuXG5jb25zdCBhcGkgPSBhcHAgPT4ge1xuICAgIHJldHVybiAoe1xuICAgICAgICBnZXROZXcgOiBnZXROZXcoYXBwKSwgXG4gICAgICAgIGdldE5ld0NoaWxkOiBnZXROZXdDaGlsZChhcHApLFxuICAgICAgICBzYXZlOiBzYXZlKGFwcCksIFxuICAgICAgICBsb2FkOiBsb2FkKGFwcCksIFxuICAgICAgICBkZWxldGU6IGRlbGV0ZVJlY29yZChhcHAsIGZhbHNlKSxcbiAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlKGFwcCksXG4gICAgICAgIGdldENvbnRleHQ6IGdldENvbnRleHQoYXBwKSxcbiAgICAgICAgdXBsb2FkRmlsZTogdXBsb2FkRmlsZShhcHApLFxuICAgICAgICBkb3dubG9hZEZpbGU6IGRvd25sb2FkRmlsZShhcHApXG4gICAgfSk7XG59O1xuXG5cbmV4cG9ydCBjb25zdCBnZXRSZWNvcmRBcGkgPSAoYXBwKSA9PiBcbiAgICBhcGkoYXBwKTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmVjb3JkQXBpO1xuIiwiaW1wb3J0IHtnZXROb2RlRm9yQ29sbGVjdGlvblBhdGh9IGZyb20gXCIuLi90ZW1wbGF0ZUFwaS9oZWlyYXJjaHlcIjtcclxuaW1wb3J0IHtpc05vdGhpbmcsIHNhZmVLZXksIGFwaVdyYXBwZXJTeW5jLCBldmVudHN9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHttYXB9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHthbHdheXNBdXRob3JpemVkfSBmcm9tIFwiLi4vYXV0aEFwaS9wZXJtaXNzaW9uc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEFsbG93ZWRSZWNvcmRUeXBlcyA9IChhcHApID0+IChrZXkpID0+IFxyXG4gICAgYXBpV3JhcHBlclN5bmMoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGV2ZW50cy5jb2xsZWN0aW9uQXBpLmdldEFsbG93ZWRSZWNvcmRUeXBlcywgXHJcbiAgICAgICAgYWx3YXlzQXV0aG9yaXplZCxcclxuICAgICAgICB7a2V5fSxcclxuICAgICAgICBfZ2V0QWxsb3dlZFJlY29yZFR5cGVzLCBhcHAsIGtleSk7XHJcblxyXG5cclxuY29uc3QgX2dldEFsbG93ZWRSZWNvcmRUeXBlcyA9IChhcHAsIGtleSkgPT4ge1xyXG4gICAga2V5ID0gc2FmZUtleShrZXkpO1xyXG4gICAgY29uc3Qgbm9kZSA9IGdldE5vZGVGb3JDb2xsZWN0aW9uUGF0aChhcHAuaGVpcmFyY2h5KShrZXkpO1xyXG4gICAgcmV0dXJuIGlzTm90aGluZyhub2RlKSA/IFtdIDogW25vZGUubmFtZV07XHJcbn07IiwiaW1wb3J0IHtnZXRBbGxJZHNJdGVyYXRvcn0gZnJvbSBcIi4uL2luZGV4aW5nL2FsbElkc1wiO1xuaW1wb3J0IHtnZXRBbGxvd2VkUmVjb3JkVHlwZXN9IGZyb20gXCIuL2dldEFsbG93ZWRSZWNvcmRUeXBlc1wiO1xuaW1wb3J0IHtkZWxldGVDb2xsZWN0aW9ufSBmcm9tIFwiLi9kZWxldGVcIjtcblxuZXhwb3J0IGNvbnN0IGdldENvbGxlY3Rpb25BcGkgPSBhcHAgPT4gKHtcbiAgICBnZXRBbGxvd2VkUmVjb3JkVHlwZXMgOiBnZXRBbGxvd2VkUmVjb3JkVHlwZXMoYXBwKSxcbiAgICBnZXRBbGxJZHNJdGVyYXRvciA6IGdldEFsbElkc0l0ZXJhdG9yKGFwcCksXG4gICAgZGVsZXRlOiBkZWxldGVDb2xsZWN0aW9uKGFwcClcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRDb2xsZWN0aW9uQXBpOyIsImltcG9ydCB7Z2V0QWxsSWRzSXRlcmF0b3J9IGZyb20gXCIuLi9pbmRleGluZy9hbGxJZHNcIjtcbmltcG9ydCB7Z2V0RmxhdHRlbmVkSGllcmFyY2h5LCBnZXRSZWNvcmROb2RlQnlJZCwgXG4gICAgZ2V0Q29sbGVjdGlvbk5vZGVCeUtleU9yTm9kZUtleSwgZ2V0Tm9kZSwgaXNJbmRleCwgXG4gICAgaXNSZWNvcmQsIGlzRGVjZW5kYW50LCBnZXRBbGxvd2VkUmVjb3JkTm9kZXNGb3JJbmRleCxcbiAgICBmaWVsZFJldmVyc2VzUmVmZXJlbmNlVG9JbmRleH0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xuaW1wb3J0IHtmaW5kLCBmaWx0ZXIsIGluY2x1ZGVzLFxuICAgIHNvbWUsIG1hcH0gZnJvbSBcImxvZGFzaC9mcFwiO1xuaW1wb3J0IHtqb2luS2V5LCBhcGlXcmFwcGVyLCBldmVudHMsICQsIGFsbFRydWV9IGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7Y3JlYXRlQnVpbGRJbmRleEZvbGRlciwgXG4gICAgdHJhbnNhY3Rpb25Gb3JCdWlsZEluZGV4fSBmcm9tIFwiLi4vdHJhbnNhY3Rpb25zL2NyZWF0ZVwiO1xuaW1wb3J0IHtwZXJtaXNzaW9ufSBmcm9tIFwiLi4vYXV0aEFwaS9wZXJtaXNzaW9uc1wiO1xuXG5cbi8qKiByZWJ1aWxkcyBhbiBpbmRleFxuICogQHBhcmFtIHtvYmplY3R9IGFwcCAtIHRoZSBhcHBsaWNhdGlvbiBjb250YWluZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbmRleE5vZGVLZXkgLSBub2RlIGtleSBvZiB0aGUgaW5kZXgsIHdoaWNoIHRoZSBpbmRleCBiZWxvbmdzIHRvIFxuICovXG5leHBvcnQgY29uc3QgYnVpbGRJbmRleCA9IGFwcCA9PiBhc3luYyAoaW5kZXhOb2RlS2V5KSA9PiBcbiAgICBhcGlXcmFwcGVyKFxuICAgICAgICBhcHAsXG4gICAgICAgIGV2ZW50cy5pbmRleEFwaS5idWlsZEluZGV4LCBcbiAgICAgICAgcGVybWlzc2lvbi5tYW5hZ2VJbmRleC5pc0F1dGhvcml6ZWQsXG4gICAgICAgIHtpbmRleE5vZGVLZXl9LFxuICAgICAgICBfYnVpbGRJbmRleCwgYXBwLCBpbmRleE5vZGVLZXkpO1xuXG5jb25zdCBfYnVpbGRJbmRleCA9IGFzeW5jIChhcHAsIGluZGV4Tm9kZUtleSkgPT4ge1xuICAgIGNvbnN0IGluZGV4Tm9kZSA9IGdldE5vZGUoYXBwLmhlaXJhcmNoeSwgaW5kZXhOb2RlS2V5KTtcblxuICAgIGF3YWl0IGNyZWF0ZUJ1aWxkSW5kZXhGb2xkZXIoYXBwLmRhdGFzdG9yZSwgaW5kZXhOb2RlS2V5KTtcblxuICAgIGlmKCFpc0luZGV4KGluZGV4Tm9kZSkpIFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWlsZEluZGV4OiBtdXN0IHN1cHBseSBhIGluZGV4bm9kZVwiKTtcblxuICAgIGlmKGluZGV4Tm9kZS5pbmRleFR5cGUgPT09IFwicmVmZXJlbmNlXCIpIHtcbiAgICAgICAgYXdhaXQgYnVpbGRSZXZlcnNlUmVmZXJlbmNlSW5kZXgoXG4gICAgICAgICAgICBhcHAsIGluZGV4Tm9kZVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGJ1aWxkSGVpcmFyY2hhbEluZGV4KFxuICAgICAgICAgICAgYXBwLCBpbmRleE5vZGVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhd2FpdCBhcHAuY2xlYW51cFRyYW5zYWN0aW9ucygpO1xufTtcblxuY29uc3QgYnVpbGRSZXZlcnNlUmVmZXJlbmNlSW5kZXggPSBhc3luYyAoYXBwLCBpbmRleE5vZGUpID0+IHtcblxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgcmVmZXJlbmNJTkcgcmVjb3JkcywgXG4gICAgLy8gYW5kIHVwZGF0ZSByZWZlcmVuY2VkIGluZGV4IGZvciBlYWNoIHJlY29yZFxuICAgIGxldCByZWNvcmRDb3VudCA9IDA7XG4gICAgY29uc3QgcmVmZXJlbmNpbmdOb2RlcyA9ICQoYXBwLmhlaXJhcmNoeSwgW1xuICAgICAgICBnZXRGbGF0dGVuZWRIaWVyYXJjaHksXG4gICAgICAgIGZpbHRlcihuID0+IGlzUmVjb3JkKG4pXG4gICAgICAgICAgICAgICAgICAgICYmIHNvbWUoZmllbGRSZXZlcnNlc1JlZmVyZW5jZVRvSW5kZXgoaW5kZXhOb2RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChuLmZpZWxkcykpXG4gICAgXSk7XG5cbiAgICBjb25zdCBjcmVhdGVUcmFuc2FjdGlvbnNGb3JSZWZlcmVuY2luZ05vZGUgPSBhc3luYyByZWZlcmVuY2luZ05vZGUgPT4ge1xuXG4gICAgICAgIGNvbnN0IGl0ZXJhdGVSZWZlcmVuY2luZ05vZGVzID0gXG4gICAgICAgICAgICBhd2FpdCBnZXRBbGxJZHNJdGVyYXRvcihhcHApXG4gICAgICAgICAgICAgICAgICAgIChyZWZlcmVuY2luZ05vZGUuY29sbGVjdGlvbk5vZGVLZXkoKSk7XG5cbiAgICAgICAgbGV0IHJlZmVyZW5jaW5nSWRJdGVyYXRvciA9IGF3YWl0IGl0ZXJhdGVSZWZlcmVuY2luZ05vZGVzKCk7XG4gICAgICAgIHdoaWxlKCFyZWZlcmVuY2luZ0lkSXRlcmF0b3IuZG9uZSkge1xuICAgICAgICAgICAgY29uc3Qge3Jlc3VsdH0gPSByZWZlcmVuY2luZ0lkSXRlcmF0b3I7XG4gICAgICAgICAgICBmb3IobGV0IGlkIG9mIHJlc3VsdC5pZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRLZXkgPSBqb2luS2V5KHJlc3VsdC5jb2xsZWN0aW9uS2V5LCBpZCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb25Gb3JCdWlsZEluZGV4KGFwcCwgaW5kZXhOb2RlLm5vZGVLZXkoKSwgcmVjb3JkS2V5LCByZWNvcmRDb3VudCk7XG4gICAgICAgICAgICAgICAgcmVjb3JkQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZmVyZW5jaW5nSWRJdGVyYXRvciA9IGF3YWl0IGl0ZXJhdGVSZWZlcmVuY2luZ05vZGVzKCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBmb3IobGV0IHJlZmVyZW5jaW5nTm9kZSBvZiByZWZlcmVuY2luZ05vZGVzKSB7XG4gICAgICAgIGF3YWl0IGNyZWF0ZVRyYW5zYWN0aW9uc0ZvclJlZmVyZW5jaW5nTm9kZShyZWZlcmVuY2luZ05vZGUpO1xuICAgIH1cbn07XG5cbmNvbnN0IGdldEFsbG93ZWRQYXJlbnRDb2xsZWN0aW9uTm9kZXMgPSAoaGVpcmFyY2h5LCBpbmRleE5vZGUpID0+IFxuICAgICQoZ2V0QWxsb3dlZFJlY29yZE5vZGVzRm9ySW5kZXgoaGVpcmFyY2h5LCBpbmRleE5vZGUpLCBbXG4gICAgICAgIG1hcChuID0+IG4ucGFyZW50KCkpXG4gICAgXSk7XG5cbmNvbnN0IGJ1aWxkSGVpcmFyY2hhbEluZGV4ID0gYXN5bmMgKGFwcCwgaW5kZXhOb2RlKSA9PiB7XG5cbiAgICBsZXQgcmVjb3JkQ291bnQgPSAwO1xuXG4gICAgY29uc3QgY3JlYXRlVHJhbnNhY3Rpb25zRm9ySWRzID0gYXN5bmMgKGNvbGxlY3Rpb25LZXksIGlkcykgPT4ge1xuXG4gICAgICAgIGZvcihsZXQgcmVjb3JkSWQgb2YgaWRzKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmRLZXkgPSBqb2luS2V5KGNvbGxlY3Rpb25LZXksIHJlY29yZElkKTtcblxuICAgICAgICAgICAgY29uc3QgcmVjb3JkTm9kZSA9IGdldFJlY29yZE5vZGVCeUlkKFxuICAgICAgICAgICAgICAgIGFwcC5oZWlyYXJjaHksXG4gICAgICAgICAgICAgICAgcmVjb3JkSWRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmKHJlY29yZE5vZGVBcHBsaWVzKGluZGV4Tm9kZSkocmVjb3JkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbkZvckJ1aWxkSW5kZXgoXG4gICAgICAgICAgICAgICAgICAgIGFwcCwgaW5kZXhOb2RlLm5vZGVLZXkoKSwgXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZEtleSwgcmVjb3JkQ291bnQpO1xuICAgICAgICAgICAgICAgIHJlY29yZENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgXG4gICAgY29uc3QgY29sbGVjdGlvblJlY29yZHMgPSBnZXRBbGxvd2VkUmVjb3JkTm9kZXNGb3JJbmRleChhcHAuaGVpcmFyY2h5LCBpbmRleE5vZGUpO1xuXG4gICAgZm9yKGxldCB0YXJnZXRDb2xsZWN0aW9uUmVjb3JkTm9kZSBvZiBjb2xsZWN0aW9uUmVjb3Jkcykge1xuICAgICAgICBjb25zdCBhbGxJZHNJdGVyYXRvciA9IGF3YWl0ICBnZXRBbGxJZHNJdGVyYXRvcihhcHApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRhcmdldENvbGxlY3Rpb25SZWNvcmROb2RlLmNvbGxlY3Rpb25Ob2RlS2V5KCkpO1xuICAgICAgICBcbiAgICAgICAgbGV0IGFsbElkcyA9IGF3YWl0IGFsbElkc0l0ZXJhdG9yKCk7XG4gICAgICAgIHdoaWxlKGFsbElkcy5kb25lID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXdhaXQgY3JlYXRlVHJhbnNhY3Rpb25zRm9ySWRzKFxuICAgICAgICAgICAgICAgIGFsbElkcy5yZXN1bHQuY29sbGVjdGlvbktleSxcbiAgICAgICAgICAgICAgICBhbGxJZHMucmVzdWx0Lmlkcyk7XG4gICAgICAgICAgICBhbGxJZHMgPSBhd2FpdCBhbGxJZHNJdGVyYXRvcigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVjb3JkQ291bnQ7XG59XG5cbmNvbnN0IGNob29zZUNoaWxkUmVjb3JkTm9kZUJ5S2V5ID0gKGNvbGxlY3Rpb25Ob2RlLCByZWNvcmRJZCkgPT4gXG4gICAgZmluZChjID0+IHJlY29yZElkLnN0YXJ0c1dpdGgoYy5ub2RlSWQpKVxuICAgICAgICAoY29sbGVjdGlvbk5vZGUuY2hpbGRyZW4pO1xuXG5jb25zdCByZWNvcmROb2RlQXBwbGllcyA9IGluZGV4Tm9kZSA9PiByZWNvcmROb2RlID0+IFxuICAgIGluY2x1ZGVzKHJlY29yZE5vZGUubm9kZUlkKShpbmRleE5vZGUuYWxsb3dlZFJlY29yZE5vZGVJZHMpO1xuXG5jb25zdCBoYXNBcHBsaWNhYmxlRGVjZW5kYW50ID0gKGhlaXJhcmNoeSwgYW5jZXN0b3JOb2RlLCBpbmRleE5vZGUpID0+IFxuICAgICQoaGVpcmFyY2h5LCBbXG4gICAgICAgIGdldEZsYXR0ZW5lZEhpZXJhcmNoeSxcbiAgICAgICAgZmlsdGVyKFxuICAgICAgICAgICAgYWxsVHJ1ZShcbiAgICAgICAgICAgICAgICBpc1JlY29yZCwgXG4gICAgICAgICAgICAgICAgaXNEZWNlbmRhbnQoYW5jZXN0b3JOb2RlKSwgXG4gICAgICAgICAgICAgICAgcmVjb3JkTm9kZUFwcGxpZXMoaW5kZXhOb2RlKVxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgXSk7XG5cbmNvbnN0IGFwcGx5QWxsRGVjZW5kYW50UmVjb3JkcyA9IFxuICAgIGFzeW5jIChhcHAsIGNvbGxlY3Rpb25fS2V5X29yX05vZGVLZXksIFxuICAgICAgICAgICAgaW5kZXhOb2RlLCBpbmRleEtleSwgY3VycmVudEluZGV4ZWREYXRhLCBcbiAgICAgICAgICAgY3VycmVudEluZGV4ZWREYXRhS2V5LCByZWNvcmRDb3VudD0wKSA9PiB7XG5cbiAgICBjb25zdCBjb2xsZWN0aW9uTm9kZSA9IFxuICAgICAgICBnZXRDb2xsZWN0aW9uTm9kZUJ5S2V5T3JOb2RlS2V5KFxuICAgICAgICAgICAgYXBwLmhlaXJhcmNoeSwgXG4gICAgICAgICAgICBjb2xsZWN0aW9uX0tleV9vcl9Ob2RlS2V5KTtcblxuICAgIGNvbnN0IGFsbElkc0l0ZXJhdG9yID0gYXdhaXQgIGdldEFsbElkc0l0ZXJhdG9yKGFwcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb2xsZWN0aW9uX0tleV9vcl9Ob2RlS2V5KTtcblxuICAgIFxuICAgIGNvbnN0IGNyZWF0ZVRyYW5zYWN0aW9uc0ZvcklkcyA9IGFzeW5jIChjb2xsZWN0aW9uS2V5LCBhbGxJZHMpID0+IHtcblxuICAgICAgICBmb3IobGV0IHJlY29yZElkIG9mIGFsbElkcykge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkS2V5ID0gam9pbktleShjb2xsZWN0aW9uS2V5LCByZWNvcmRJZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlY29yZE5vZGUgPSBjaG9vc2VDaGlsZFJlY29yZE5vZGVCeUtleShcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTm9kZSxcbiAgICAgICAgICAgICAgICByZWNvcmRJZFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYocmVjb3JkTm9kZUFwcGxpZXMoaW5kZXhOb2RlKShyZWNvcmROb2RlKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uRm9yQnVpbGRJbmRleChcbiAgICAgICAgICAgICAgICAgICAgYXBwLCBpbmRleE5vZGUubm9kZUtleSgpLCBcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkS2V5LCByZWNvcmRDb3VudCk7XG4gICAgICAgICAgICAgICAgcmVjb3JkQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoaGFzQXBwbGljYWJsZURlY2VuZGFudChhcHAuaGVpcmFyY2h5LCByZWNvcmROb2RlLCBpbmRleE5vZGUpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcihsZXQgY2hpbGRDb2xsZWN0aW9uTm9kZSBvZiByZWNvcmROb2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZENvdW50ID0gYXdhaXQgYXBwbHlBbGxEZWNlbmRhbnRSZWNvcmRzKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbktleShyZWNvcmRLZXksIGNoaWxkQ29sbGVjdGlvbk5vZGUuY29sbGVjdGlvbk5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhOb2RlLCBpbmRleEtleSwgY3VycmVudEluZGV4ZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4ZWREYXRhS2V5LCByZWNvcmRDb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGxldCBhbGxJZHMgPSBhd2FpdCBhbGxJZHNJdGVyYXRvcigpO1xuICAgIHdoaWxlKGFsbElkcy5kb25lID09PSBmYWxzZSkge1xuICAgICAgICBhd2FpdCBjcmVhdGVUcmFuc2FjdGlvbnNGb3JJZHMoXG4gICAgICAgICAgICBhbGxJZHMucmVzdWx0LmNvbGxlY3Rpb25LZXksXG4gICAgICAgICAgICBhbGxJZHMucmVzdWx0Lmlkcyk7XG4gICAgICAgIGFsbElkcyA9IGF3YWl0IGFsbElkc0l0ZXJhdG9yKCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZWNvcmRDb3VudDs7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBidWlsZEluZGV4OyIsImltcG9ydCB7c2FmZUtleSwgYXBpV3JhcHBlciwgJCxcclxuICAgIGV2ZW50cywgaXNOb25FbXB0eVN0cmluZ30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge2l0ZXJhdGVJbmRleH0gZnJvbSBcIi4uL2luZGV4aW5nL3JlYWRcIjtcclxuaW1wb3J0IHtnZXRVbnNoYXJkZWRJbmRleERhdGFLZXksIFxyXG4gICAgZ2V0U2hhcmRLZXlzSW5SYW5nZX0gZnJvbSBcIi4uL2luZGV4aW5nL3NoYXJkaW5nXCI7XHJcbmltcG9ydCB7Z2V0RXhhY3ROb2RlRm9yUGF0aCwgaXNJbmRleCwgXHJcbiAgICBpc1NoYXJkZWRJbmRleH0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xyXG5pbXBvcnQge2hhcywgaXNOdW1iZXIsIGlzVW5kZWZpbmVkfSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcbmltcG9ydCB7Y29tcGlsZUV4cHJlc3Npb24sIGNvbXBpbGVDb2RlfSBmcm9tIFwiQG54LWpzL2NvbXBpbGVyLXV0aWxcIjtcclxuaW1wb3J0IHtDT05USU5VRV9SRUFESU5HX1JFQ09SRFN9IGZyb20gXCIuLi9pbmRleGluZy9zZXJpYWxpemVyXCI7XHJcbmltcG9ydCB7cGVybWlzc2lvbn0gZnJvbSBcIi4uL2F1dGhBcGkvcGVybWlzc2lvbnNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBhZ2dyZWdhdGVzID0gYXBwID0+IGFzeW5jIChpbmRleEtleSwgcmFuZ2VTdGFydFBhcmFtcz1udWxsLCByYW5nZUVuZFBhcmFtcz1udWxsKSA9PiBcclxuICAgIGFwaVdyYXBwZXIoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGV2ZW50cy5pbmRleEFwaS5hZ2dyZWdhdGVzLCBcclxuICAgICAgICBwZXJtaXNzaW9uLnJlYWRJbmRleC5pc0F1dGhvcml6ZWQoaW5kZXhLZXkpLFxyXG4gICAgICAgIHtpbmRleEtleSwgcmFuZ2VTdGFydFBhcmFtcywgcmFuZ2VFbmRQYXJhbXN9LFxyXG4gICAgICAgIF9hZ2dyZWdhdGVzLCBhcHAsIGluZGV4S2V5LCByYW5nZVN0YXJ0UGFyYW1zLCByYW5nZUVuZFBhcmFtcyk7XHJcblxyXG5jb25zdCBfYWdncmVnYXRlcyA9IGFzeW5jIChhcHAsIGluZGV4S2V5LCByYW5nZVN0YXJ0UGFyYW1zLCByYW5nZUVuZFBhcmFtcykgPT4ge1xyXG4gICAgaW5kZXhLZXkgPSBzYWZlS2V5KGluZGV4S2V5KTtcclxuICAgIGNvbnN0IGluZGV4Tm9kZSA9IGdldEV4YWN0Tm9kZUZvclBhdGgoYXBwLmhlaXJhcmNoeSkoaW5kZXhLZXkpO1xyXG5cclxuICAgIGlmKCFpc0luZGV4KGluZGV4Tm9kZSkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3VwcGxpZWQga2V5IGlzIG5vdCBhbiBpbmRleFwiKTtcclxuXHJcbiAgICBpZihpc1NoYXJkZWRJbmRleChpbmRleE5vZGUpKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhcmRLZXlzID0gYXdhaXQgZ2V0U2hhcmRLZXlzSW5SYW5nZShcclxuICAgICAgICAgICAgYXBwLCBpbmRleEtleSwgcmFuZ2VTdGFydFBhcmFtcywgcmFuZ2VFbmRQYXJhbXNcclxuICAgICAgICApO1xyXG4gICAgICAgIGxldCBhZ2dyZWdhdGVSZXN1bHQgPSBudWxsO1xyXG4gICAgICAgIGZvcihsZXQgayBvZiBzaGFyZEtleXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hhcmRSZXN1bHQgPSBhd2FpdCBnZXRBZ2dyZWdhdGVzKGFwcC5oZWlyYXJjaHksIGFwcC5kYXRhc3RvcmUsIGluZGV4Tm9kZSwgayk7XHJcbiAgICAgICAgICAgIGlmKGFnZ3JlZ2F0ZVJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYWdncmVnYXRlUmVzdWx0ID0gc2hhcmRSZXN1bHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVSZXN1bHQgPSBtZXJnZVNoYXJkQWdncmVnYXRlKFxyXG4gICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZVJlc3VsdCxcclxuICAgICAgICAgICAgICAgICAgICBzaGFyZFJlc3VsdFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZVJlc3VsdDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldEFnZ3JlZ2F0ZXMoXHJcbiAgICAgICAgICAgIGFwcC5oZWlyYXJjaHksXHJcbiAgICAgICAgICAgIGFwcC5kYXRhc3RvcmUsIFxyXG4gICAgICAgICAgICBpbmRleE5vZGUsXHJcbiAgICAgICAgICAgIGdldFVuc2hhcmRlZEluZGV4RGF0YUtleShpbmRleEtleSlcclxuICAgICAgICApO1xyXG4gICAgfSAgICBcclxufTtcclxuXHJcbmNvbnN0IG1lcmdlU2hhcmRBZ2dyZWdhdGUgPSAodG90YWxzLCBzaGFyZCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IG1lcmdlR3JvdXBpbmcgPSAodG90LCBzaHIpID0+IHtcclxuICAgICAgICB0b3QuY291bnQgPSB0b3QuY291bnQgKyBzaHIuY291bnQ7XHJcbiAgICAgICAgZm9yKGxldCBhZ2dOYW1lIGluIHRvdCkge1xyXG4gICAgICAgICAgICBpZihhZ2dOYW1lID09PSBcImNvdW50XCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBjb25zdCB0b3RhZ2cgPSB0b3RbYWdnTmFtZV07XHJcbiAgICAgICAgICAgIGNvbnN0IHNocmFnZyA9IHNoclthZ2dOYW1lXTtcclxuICAgICAgICAgICAgdG90YWdnLnN1bSA9IHRvdGFnZy5zdW0gKyBzaHJhZ2cuc3VtOyAgXHJcbiAgICAgICAgICAgIHRvdGFnZy5tYXggPSB0b3RhZ2cubWF4ID4gc2hyYWdnLm1heFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyB0b3RhZ2cubWF4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICA6IHNocmFnZy5tYXg7XHJcbiAgICAgICAgICAgIHRvdGFnZy5taW4gPSB0b3RhZ2cubWluIDwgc2hyYWdnLm1pblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyB0b3RhZ2cubWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICA6IHNocmFnZy5taW47XHJcbiAgICAgICAgICAgIHRvdGFnZy5tZWFuID0gdG90YWdnLnN1bSAvIHRvdC5jb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvdDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IobGV0IGFnZ0dyb3VwRGVmIGluIHRvdGFscykge1xyXG4gICAgICAgIGZvcihsZXQgZ3JvdXBpbmcgaW4gc2hhcmRbYWdnR3JvdXBEZWZdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwaW5nVG90YWwgPSB0b3RhbHNbYWdnR3JvdXBEZWZdW2dyb3VwaW5nXTtcclxuICAgICAgICAgICAgdG90YWxzW2FnZ0dyb3VwRGVmXVtncm91cGluZ10gPSBcclxuICAgICAgICAgICAgICAgIGlzVW5kZWZpbmVkKGdyb3VwaW5nVG90YWwpXHJcbiAgICAgICAgICAgICAgICA/IHNoYXJkW2FnZ0dyb3VwRGVmXVtncm91cGluZ11cclxuICAgICAgICAgICAgICAgIDogbWVyZ2VHcm91cGluZyhcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbHNbYWdnR3JvdXBEZWZdW2dyb3VwaW5nXSxcclxuICAgICAgICAgICAgICAgICAgICBzaGFyZFthZ2dHcm91cERlZl1bZ3JvdXBpbmddXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdG90YWxzO1xyXG59XHJcblxyXG5jb25zdCBnZXRBZ2dyZWdhdGVzID0gYXN5bmMgKGhlaXJhcmNoeSwgZGF0YXN0b3JlLCBpbmRleCwgaW5kZXhlZERhdGFLZXkpID0+IHtcclxuICAgIGNvbnN0IGFnZ3JlZ2F0ZVJlc3VsdCA9IHt9XHJcbiAgICBjb25zdCBkb1JlYWQgPSBpdGVyYXRlSW5kZXgoXHJcbiAgICAgICAgaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGFwcGx5SXRlbVRvQWdncmVnYXRlUmVzdWx0KFxyXG4gICAgICAgICAgICAgICAgaW5kZXgsIGFnZ3JlZ2F0ZVJlc3VsdCwgaXRlbVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gQ09OVElOVUVfUkVBRElOR19SRUNPUkRTO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgKCkgPT4gYWdncmVnYXRlUmVzdWx0XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBhd2FpdCBkb1JlYWQoaGVpcmFyY2h5LCBkYXRhc3RvcmUsIGluZGV4LCBpbmRleGVkRGF0YUtleSk7XHJcbn07XHJcblxyXG5cclxuY29uc3QgYXBwbHlJdGVtVG9BZ2dyZWdhdGVSZXN1bHQgPSAoaW5kZXhOb2RlLCByZXN1bHQsIGl0ZW0pID0+IHtcclxuICAgIFxyXG4gICAgY29uc3QgZ2V0SW5pdGlhbEFnZ3JlZ2F0ZVJlc3VsdCA9ICgpID0+ICh7XHJcbiAgICAgICAgc3VtOiAwLCBtZWFuOiBudWxsLCBtYXg6IG51bGwsIG1pbjogbnVsbFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgYXBwbHlBZ2dyZWdhdGVSZXN1bHQgPSAoYWdnLCBleGlzdGluZywgY291bnQpID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbXBpbGVDb2RlKGFnZy5hZ2dyZWdhdGVkVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh7cmVjb3JkOml0ZW19KTtcclxuICAgICAgICBcclxuICAgICAgICBpZighaXNOdW1iZXIodmFsdWUpKSByZXR1cm4gZXhpc3Rpbmc7XHJcblxyXG4gICAgICAgIGV4aXN0aW5nLnN1bSA9IGV4aXN0aW5nLnN1bSArIHZhbHVlO1xyXG4gICAgICAgIGV4aXN0aW5nLm1heCA9IHZhbHVlID4gZXhpc3RpbmcubWF4IHx8IGV4aXN0aW5nLm1heCA9PT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWUgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgOiBleGlzdGluZy5tYXg7XHJcbiAgICAgICAgZXhpc3RpbmcubWluID0gdmFsdWUgPCBleGlzdGluZy5taW4gfHwgZXhpc3RpbmcubWluID09PSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgIDogZXhpc3RpbmcubWluO1xyXG4gICAgICAgIGV4aXN0aW5nLm1lYW4gPSBleGlzdGluZy5zdW0gLyBjb3VudDtcclxuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XHJcbiAgICB9O1xyXG5cclxuICAgIGZvcihsZXQgYWdnR3JvdXAgb2YgaW5kZXhOb2RlLmFnZ3JlZ2F0ZUdyb3VwcykgeyAgXHJcblxyXG4gICAgICAgIGlmKCFoYXMoYWdnR3JvdXAubmFtZSkocmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXN1bHRbYWdnR3JvdXAubmFtZV0gPSB7fVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHRoaXNHcm91cFJlc3VsdCA9IHJlc3VsdFthZ2dHcm91cC5uYW1lXTtcclxuXHJcbiAgICAgICAgaWYoaXNOb25FbXB0eVN0cmluZyhhZ2dHcm91cC5jb25kaXRpb24pKSB7XHJcbiAgICAgICAgICAgIGlmKCFjb21waWxlRXhwcmVzc2lvbihhZ2dHcm91cC5jb25kaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh7cmVjb3JkOml0ZW19KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBncm91cCA9IGlzTm9uRW1wdHlTdHJpbmcoYWdnR3JvdXAuZ3JvdXBCeSlcclxuICAgICAgICAgICAgICAgICAgICAgID8gY29tcGlsZUNvZGUoYWdnR3JvdXAuZ3JvdXBCeSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoe3JlY29yZDppdGVtfSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogXCJhbGxcIjtcclxuICAgICAgICBpZighaXNOb25FbXB0eVN0cmluZyhncm91cCkpIHtcclxuICAgICAgICAgICAgZ3JvdXAgPSBcIihub25lKVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZighaGFzKGdyb3VwKSh0aGlzR3JvdXBSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHRoaXNHcm91cFJlc3VsdFtncm91cF0gPSB7Y291bnQ6MH07XHJcbiAgICAgICAgICAgIGZvcihsZXQgYWdnIG9mIGFnZ0dyb3VwLmFnZ3JlZ2F0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNHcm91cFJlc3VsdFtncm91cF1bYWdnLm5hbWVdID0gXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0SW5pdGlhbEFnZ3JlZ2F0ZVJlc3VsdCgpO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpc0dyb3VwUmVzdWx0W2dyb3VwXS5jb3VudCsrO1xyXG5cclxuICAgICAgICBmb3IobGV0IGFnZyBvZiBhZ2dHcm91cC5hZ2dyZWdhdGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWVzID0gdGhpc0dyb3VwUmVzdWx0W2dyb3VwXVthZ2cubmFtZV07XHJcbiAgICAgICAgICAgIHRoaXNHcm91cFJlc3VsdFtncm91cF1bYWdnLm5hbWVdID0gXHJcbiAgICAgICAgICAgICAgICBhcHBseUFnZ3JlZ2F0ZVJlc3VsdChcclxuICAgICAgICAgICAgICAgICAgICBhZ2csIGV4aXN0aW5nVmFsdWVzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNHcm91cFJlc3VsdFtncm91cF0uY291bnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTsiLCJpbXBvcnQge2J1aWxkSW5kZXh9IGZyb20gXCIuL2J1aWxkSW5kZXhcIjtcbmltcG9ydCB7bGlzdEl0ZW1zfSBmcm9tIFwiLi9saXN0SXRlbXNcIjtcbmltcG9ydCB7ZGVsZXRlSW5kZXh9IGZyb20gXCIuL2RlbGV0ZVwiO1xuaW1wb3J0IHthZ2dyZWdhdGVzfSBmcm9tIFwiLi9hZ2dyZWdhdGVzXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRJbmRleEFwaSA9IGFwcCA9PiAoe1xuICAgIGxpc3RJdGVtcyA6IGxpc3RJdGVtcyhhcHApLCBcbiAgICBidWlsZEluZGV4OiBidWlsZEluZGV4KGFwcCksXG4gICAgYWdncmVnYXRlczogYWdncmVnYXRlcyhhcHApXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0SW5kZXhBcGk7IiwiaW1wb3J0IHtzd2l0Y2hDYXNlLCBkZWZhdWx0Q2FzZSwgam9pbktleSwgXHJcbiAgICAkLCBpc05vdGhpbmcsIGlzU29tZXRoaW5nfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7ZWFjaCwgY29uc3RhbnQsIGZpbHRlciwgZmluZH0gZnJvbSBcImxvZGFzaFwiO1xyXG5pbXBvcnQge2lzSW5kZXgsIGlzUm9vdCwgaXNTaW5nbGVSZWNvcmQsIGlzQ29sbGVjdGlvblJlY29yZCxcclxuICAgICAgICBpc1JlY29yZCwgaXNhZ2dyZWdhdGVHcm91cCwgXHJcbiAgICAgICAgZ2V0RmxhdHRlbmVkSGllcmFyY2h5fSBmcm9tIFwiLi9oZWlyYXJjaHlcIjtcclxuaW1wb3J0IHthbGx9IGZyb20gXCIuLi90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZU5vZGVFcnJvcnMgPSB7XHJcbiAgICBpbmRleENhbm5vdEJlUGFyZW50IDogXCJJbmRleCB0ZW1wbGF0ZSBjYW5ub3QgYmUgYSBwYXJlbnRcIixcclxuICAgIGFsbE5vblJvb3ROb2Rlc011c3RIYXZlUGFyZW50OiBcIk9ubHkgdGhlIHJvb3Qgbm9kZSBtYXkgaGF2ZSBubyBwYXJlbnRcIixcclxuICAgIGluZGV4UGFyZW50TXVzdEJlUmVjb3JkT3JSb290OiBcIkFuIGluZGV4IG1heSBvbmx5IGhhdmUgYSByZWNvcmQgb3Igcm9vdCBhcyBhIHBhcmVudFwiLFxyXG4gICAgYWdncmVnYXRlUGFyZW50TXVzdEJlQW5JbmRleDogXCJhZ2dyZWdhdGVHcm91cCBwYXJlbnQgbXVzdCBiZSBhbiBpbmRleFwiXHJcbn07XHJcblxyXG5jb25zdCBwYXRoUmVneE1ha2VyID0gKG5vZGUpID0+ICgpID0+IFxyXG4gIG5vZGUubm9kZUtleSgpLnJlcGxhY2UoL3tpZH0vZywgXCJbYS16QS1aMC05X1xcLV0rXCIpO1xyXG5cclxuY29uc3Qgbm9kZUtleU1ha2VyID0gKG5vZGUpID0+ICgpID0+IFxyXG4gICAgc3dpdGNoQ2FzZShcclxuXHJcbiAgICAgICAgW24gPT4gaXNSZWNvcmQobikgJiYgIWlzU2luZ2xlUmVjb3JkKG4pLFxyXG4gICAgICAgICBuID0+IGpvaW5LZXkoXHJcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudCgpLm5vZGVLZXkoKSxcclxuICAgICAgICAgICAgICAgIG5vZGUuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBuLm5vZGVJZCArIFwiLXtpZH1cIildLFxyXG4gICAgICAgIFxyXG4gICAgICAgIFtpc1Jvb3QsXHJcbiAgICAgICAgIGNvbnN0YW50KFwiL1wiKV0sXHJcblxyXG4gICAgICAgIFtkZWZhdWx0Q2FzZSxcclxuICAgICAgICAgICAgbiA9PiBqb2luS2V5KG5vZGUucGFyZW50KCkubm9kZUtleSgpLCBuLm5hbWUpXVxyXG4gICAgICAgICBcclxuICAgICkobm9kZSk7XHJcblxyXG5cclxuY29uc3QgdmFsaWRhdGUgPSBwYXJlbnQgPT4gbm9kZSA9PiB7XHJcblxyXG4gICAgaWYoaXNJbmRleChub2RlKSBcclxuICAgICAgICAmJiBpc1NvbWV0aGluZyhwYXJlbnQpIFxyXG4gICAgICAgICYmICFpc1Jvb3QocGFyZW50KVxyXG4gICAgICAgICYmICFpc1JlY29yZChwYXJlbnQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNyZWF0ZU5vZGVFcnJvcnMuaW5kZXhQYXJlbnRNdXN0QmVSZWNvcmRPclJvb3QpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKGlzYWdncmVnYXRlR3JvdXAobm9kZSkgXHJcbiAgICAgICAgJiYgaXNTb21ldGhpbmcocGFyZW50KSBcclxuICAgICAgICAmJiAhaXNJbmRleChwYXJlbnQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNyZWF0ZU5vZGVFcnJvcnMuYWdncmVnYXRlUGFyZW50TXVzdEJlQW5JbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoaXNOb3RoaW5nKHBhcmVudCkgJiYgIWlzUm9vdChub2RlKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY3JlYXRlTm9kZUVycm9ycy5hbGxOb25Sb290Tm9kZXNNdXN0SGF2ZVBhcmVudCk7XHJcbiAgICBcclxuICAgIHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuY29uc3QgY29uc3RydWN0ID0gKHBhcmVudCkgPT4gKG5vZGUpID0+IHtcclxuICAgIFxyXG4gICAgbm9kZS5ub2RlS2V5ID0gbm9kZUtleU1ha2VyKG5vZGUpO1xyXG4gICAgbm9kZS5wYXRoUmVneCA9IHBhdGhSZWd4TWFrZXIobm9kZSk7ICAgIFxyXG4gICAgbm9kZS5wYXJlbnQgPSBjb25zdGFudChwYXJlbnQpO1xyXG4gICAgbm9kZS5pc1Jvb3QgPSAoKSA9PiBpc05vdGhpbmcocGFyZW50KSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgbm9kZS5uYW1lID09PSBcInJvb3RcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBub2RlLnR5cGUgPT09IFwicm9vdFwiXHJcbiAgICBpZihpc0NvbGxlY3Rpb25SZWNvcmQobm9kZSkpIHtcclxuICAgICAgICBub2RlLmNvbGxlY3Rpb25Ob2RlS2V5ID0gKCkgPT4gam9pbktleShcclxuICAgICAgICAgICAgcGFyZW50Lm5vZGVLZXkoKSwgbm9kZS5jb2xsZWN0aW9uTmFtZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbm9kZS5jb2xsZWN0aW9uUGF0aFJlZ3ggPSAoKSA9PiBqb2luS2V5KFxyXG4gICAgICAgICAgICBwYXJlbnQucGF0aFJlZ3goKSwgbm9kZS5jb2xsZWN0aW9uTmFtZVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZTtcclxufTtcclxuXHJcbmNvbnN0IGFkZFRvUGFyZW50ID0gb2JqID0+IHtcclxuICAgIGNvbnN0IHBhcmVudCA9IG9iai5wYXJlbnQoKTtcclxuICAgIGlmKGlzU29tZXRoaW5nKHBhcmVudCkpIHtcclxuICAgICAgICBpZihpc0luZGV4KG9iaikpXHJcbiAgICAgICAgICAgIC8vIFE6IHdoeSBhcmUgaW5kZXhlcyBub3QgY2hpbGRyZW4gP1xyXG4gICAgICAgICAgICAvLyBBOiBiZWNhdXNlIHRoZXkgY2Fubm90IGhhdmUgY2hpbGRyZW4gb2YgdGhlaXIgb3duLlxyXG4gICAgICAgICAgICBwYXJlbnQuaW5kZXhlcy5wdXNoKG9iaik7XHJcbiAgICAgICAgZWxzZSBpZihpc2FnZ3JlZ2F0ZUdyb3VwKG9iaikpXHJcbiAgICAgICAgICAgIHBhcmVudC5hZ2dyZWdhdGVHcm91cHMucHVzaChvYmopO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gob2JqKTtcclxuXHJcbiAgICAgICAgaWYoaXNSZWNvcmQob2JqKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0SW5kZXggPSBmaW5kKFxyXG4gICAgICAgICAgICAgICAgcGFyZW50LmluZGV4ZXMsIFxyXG4gICAgICAgICAgICAgICAgaSA9PiBpLm5hbWUgPT09IHBhcmVudC5uYW1lICsgXCJfaW5kZXhcIik7XHJcbiAgICAgICAgICAgIGlmKCEhZGVmYXVsdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0SW5kZXguYWxsb3dlZFJlY29yZE5vZGVJZHMucHVzaChvYmoubm9kZUlkKTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbnN0cnVjdE5vZGUgPSAocGFyZW50LCBvYmopID0+XHJcbiAgICAkKG9iaiwgW1xyXG4gICAgICAgIGNvbnN0cnVjdChwYXJlbnQpLFxyXG4gICAgICAgIHZhbGlkYXRlKHBhcmVudCksXHJcbiAgICAgICAgYWRkVG9QYXJlbnRcclxuICAgIF0pO1xyXG5cclxuY29uc3QgZ2V0Tm9kZUlkID0gKHBhcmVudE5vZGUpID0+IHtcclxuICAgIC8vIHRoaXMgY2FzZSBpcyBoYW5kbGVkIGJldHRlciBlbHNld2hlcmUgXHJcbiAgICBpZighcGFyZW50Tm9kZSkgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBmaW5kUm9vdCA9IG4gPT4gaXNSb290KG4pID8gbiA6IGZpbmRSb290KG4ucGFyZW50KCkpO1xyXG4gICAgY29uc3Qgcm9vdCA9IGZpbmRSb290KHBhcmVudE5vZGUpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZ2V0RmxhdHRlbmVkSGllcmFyY2h5KHJvb3QpLmxlbmd0aDsgICAgXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjb25zdHJ1Y3RIZWlyYXJjaHkgPSAobm9kZSwgcGFyZW50KSA9PiB7XHJcbiAgICBjb25zdHJ1Y3QocGFyZW50KShub2RlKTtcclxuICAgIGlmKG5vZGUuaW5kZXhlcykge1xyXG4gICAgICAgIGVhY2gobm9kZS5pbmRleGVzLCBcclxuICAgICAgICAgICAgY2hpbGQgPT4gY29uc3RydWN0SGVpcmFyY2h5KGNoaWxkLCBub2RlKSk7XHJcbiAgICB9XHJcbiAgICBpZihub2RlLmFnZ3JlZ2F0ZUdyb3Vwcykge1xyXG4gICAgICAgIGVhY2gobm9kZS5hZ2dyZWdhdGVHcm91cHMsIFxyXG4gICAgICAgICAgICBjaGlsZCA9PiBjb25zdHJ1Y3RIZWlyYXJjaHkoY2hpbGQsIG5vZGUpKTtcclxuICAgIH1cclxuICAgIGlmKG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZWFjaChub2RlLmNoaWxkcmVuLCBcclxuICAgICAgICAgICAgY2hpbGQgPT4gY29uc3RydWN0SGVpcmFyY2h5KGNoaWxkLCBub2RlKSk7XHJcbiAgICB9XHJcbiAgICBpZihub2RlLmZpZWxkcykge1xyXG4gICAgICAgIGVhY2gobm9kZS5maWVsZHMsIFxyXG4gICAgICAgICAgICBmID0+IGVhY2goZi50eXBlT3B0aW9ucywgKHZhbCwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gYWxsW2YudHlwZV0ub3B0aW9uRGVmaW5pdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBpZighZGVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVua25vd24gdHlwZU9wdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZi50eXBlT3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYudHlwZU9wdGlvbnNba2V5XSA9IGRlZi5wYXJzZSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IGdldE5ld1Jvb3RMZXZlbCA9ICgpID0+IFxyXG4gICAgY29uc3RydWN0KCkoe1xyXG4gICAgICAgIG5hbWU6XCJyb290XCIsXHJcbiAgICAgICAgdHlwZTpcInJvb3RcIixcclxuICAgICAgICBjaGlsZHJlbjpbXSxcclxuICAgICAgICBwYXRoTWFwczpbXSxcclxuICAgICAgICBpbmRleGVzOltdLFxyXG4gICAgICAgIG5vZGVJZDogMCxcclxuICAgIH0pO1xyXG5cclxuY29uc3QgX2dldE5ld1JlY29yZFRlbXBsYXRlID0gKHBhcmVudCwgbmFtZSwgY3JlYXRlRGVmYXVsdEluZGV4LCBpc1NpbmdsZSkgPT4ge1xyXG4gICAgY29uc3Qgbm9kZSA9IGNvbnN0cnVjdE5vZGUocGFyZW50LCB7XHJcbiAgICAgICAgbmFtZTpuYW1lLCBcclxuICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxyXG4gICAgICAgIGZpZWxkczpbXSwgXHJcbiAgICAgICAgY2hpbGRyZW46W10sICBcclxuICAgICAgICB2YWxpZGF0aW9uUnVsZXM6W10sXHJcbiAgICAgICAgbm9kZUlkOiBnZXROb2RlSWQocGFyZW50KSxcclxuICAgICAgICBpbmRleGVzOiBbXSxcclxuICAgICAgICBhbGxpZHNTaGFyZEZhY3RvcjogaXNSZWNvcmQocGFyZW50KSA/IDEgOiA2NCxcclxuICAgICAgICBjb2xsZWN0aW9uTmFtZTogXCJcIixcclxuICAgICAgICBpc1NpbmdsZVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYoY3JlYXRlRGVmYXVsdEluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdEluZGV4ID0gZ2V0TmV3SW5kZXhUZW1wbGF0ZShwYXJlbnQpO1xyXG4gICAgICAgIGRlZmF1bHRJbmRleC5uYW1lID0gbmFtZSArIFwiX2luZGV4XCI7XHJcbiAgICAgICAgZGVmYXVsdEluZGV4LmFsbG93ZWRSZWNvcmROb2RlSWRzLnB1c2gobm9kZS5ub2RlSWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub2RlO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0TmV3UmVjb3JkVGVtcGxhdGUgPSAocGFyZW50LCBuYW1lPVwiXCIsIGNyZWF0ZURlZmF1bHRJbmRleD10cnVlKSA9PlxyXG4gICAgX2dldE5ld1JlY29yZFRlbXBsYXRlKHBhcmVudCwgbmFtZSwgY3JlYXRlRGVmYXVsdEluZGV4LCBmYWxzZSk7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0TmV3U2luZ2xlUmVjb3JkVGVtcGxhdGUgPSAocGFyZW50KSA9PiBcclxuICAgIF9nZXROZXdSZWNvcmRUZW1wbGF0ZShwYXJlbnQsIFwiXCIsIGZhbHNlLCB0cnVlKTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXROZXdJbmRleFRlbXBsYXRlID0gKHBhcmVudCwgdHlwZT1cImFuY2VzdG9yXCIpID0+IFxyXG4gICAgY29uc3RydWN0Tm9kZShwYXJlbnQsIHtcclxuICAgICAgICBuYW1lOlwiXCIsXHJcbiAgICAgICAgdHlwZTpcImluZGV4XCIsXHJcbiAgICAgICAgbWFwOlwicmV0dXJuIHsuLi5yZWNvcmR9O1wiLFxyXG4gICAgICAgIGZpbHRlcjpcIlwiLFxyXG4gICAgICAgIGluZGV4VHlwZTogdHlwZSxcclxuICAgICAgICBnZXRTaGFyZE5hbWU6IFwiXCIsXHJcbiAgICAgICAgZ2V0U29ydEtleTogXCJyZWNvcmQuaWRcIixcclxuICAgICAgICBhZ2dyZWdhdGVHcm91cHM6IFtdLFxyXG4gICAgICAgIGFsbG93ZWRSZWNvcmROb2RlSWRzOiBbXSxcclxuICAgICAgICBub2RlSWQ6IGdldE5vZGVJZChwYXJlbnQpXHJcbiAgICB9KTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXROZXdBZ2dyZWdhdGVHcm91cFRlbXBsYXRlID0gaW5kZXggPT4gXHJcbiAgICBjb25zdHJ1Y3ROb2RlKGluZGV4LCB7XHJcbiAgICAgICAgbmFtZTogXCJcIixcclxuICAgICAgICB0eXBlOlwiYWdncmVnYXRlR3JvdXBcIixcclxuICAgICAgICBncm91cEJ5OiBcIlwiLFxyXG4gICAgICAgIGFnZ3JlZ2F0ZXM6IFtdLFxyXG4gICAgICAgIGNvbmRpdGlvbjogXCJcIixcclxuICAgICAgICBub2RlSWQ6IGdldE5vZGVJZChpbmRleClcclxuICAgIH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldE5ld0FnZ3JlZ2F0ZVRlbXBsYXRlID0gc2V0ID0+IHtcclxuICAgIGNvbnN0IGFnZ3JlZ2F0ZWRWYWx1ZSA9IHtcclxuICAgICAgICBuYW1lOiBcIlwiLFxyXG4gICAgICAgIGFnZ3JlZ2F0ZWRWYWx1ZTogXCJcIlxyXG4gICAgfTtcclxuICAgIHNldC5hZ2dyZWdhdGVzLnB1c2goYWdncmVnYXRlZFZhbHVlKTtcclxuICAgIHJldHVybiBhZ2dyZWdhdGVkVmFsdWU7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBnZXROZXdSb290TGV2ZWwsIGdldE5ld1JlY29yZFRlbXBsYXRlLCAgXHJcbiAgICBnZXROZXdJbmRleFRlbXBsYXRlLCBjcmVhdGVOb2RlRXJyb3JzLFxyXG4gICAgY29uc3RydWN0SGVpcmFyY2h5LCBnZXROZXdBZ2dyZWdhdGVHcm91cFRlbXBsYXRlLFxyXG4gICAgZ2V0TmV3QWdncmVnYXRlVGVtcGxhdGV9O1xyXG4iLCJpbXBvcnQge3NvbWUsIG1hcCwgZmlsdGVyLCBrZXlzLCBpbmNsdWRlcyxcclxuICAgICAgICBjb3VudEJ5LCBmbGF0dGVufSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcbmltcG9ydCB7aXNTb21ldGhpbmcsICQsIFxyXG4gICAgICAgIGlzTm9uRW1wdHlTdHJpbmcsIFxyXG4gICAgICAgIGlzTm90aGluZ09yRW1wdHksXHJcbiAgICAgICAgaXNOb3RoaW5nfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7YWxsLCBnZXREZWZhdWx0T3B0aW9uc30gZnJvbSBcIi4uL3R5cGVzXCI7XHJcbmltcG9ydCB7YXBwbHlSdWxlU2V0LCBtYWtlcnVsZX0gZnJvbSBcIi4uL2NvbW1vbi92YWxpZGF0aW9uQ29tbW9uXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZmllbGRFcnJvcnMgPSB7XHJcbiAgICBBZGRGaWVsZFZhbGlkYXRpb25GYWlsZWQgOiBcIkFkZCBmaWVsZCB2YWxpZGF0aW9uOiBcIlxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFsbG93ZWRUeXBlcyA9ICgpID0+IGtleXMoYWxsKTsgXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0TmV3RmllbGQgPSB0eXBlID0+ICh7XHJcbiAgICBuYW1lOiBcIlwiLCAgLy8gaG93IGZpZWxkIGlzIHJlZmVyZW5jZWQgaW50ZXJuYWxseVxyXG4gICAgdHlwZTogdHlwZSxcclxuICAgIHR5cGVPcHRpb25zOiBnZXREZWZhdWx0T3B0aW9ucyh0eXBlKSwgXHJcbiAgICBsYWJlbDogXCJcIiwgLy8gaG93IGZpZWxkIGlzIGRpc3BsYXllZFxyXG4gICAgZ2V0SW5pdGlhbFZhbHVlIDogXCJkZWZhdWx0XCIsIC8vIGZ1bmN0aW9uIHRoYXQgZ2V0cyB2YWx1ZSB3aGVuIGluaXRpYWxseSBjcmVhdGVkXHJcbiAgICBnZXRVbmRlZmluZWRWYWx1ZSA6IFwiZGVmYXVsdFwiLCAvLyBmdW5jdGlvbiB0aGF0IGdldHMgdmFsdWUgd2hlbiBmaWVsZCB1bmRlZmluZWQgb24gcmVjb3JkXHJcbn0pO1xyXG5cclxuY29uc3QgZmllbGRSdWxlcyA9IChhbGxGaWVsZHMpID0+IFtcclxuICAgIG1ha2VydWxlKFwibmFtZVwiLCBcImZpZWxkIG5hbWUgaXMgbm90IHNldFwiLFxyXG4gICAgICAgICAgICBmID0+IGlzTm9uRW1wdHlTdHJpbmcoZi5uYW1lKSksXHJcbiAgICBtYWtlcnVsZShcInR5cGVcIiwgXCJmaWVsZCB0eXBlIGlzIG5vdCBzZXRcIixcclxuICAgICAgICBmID0+IGlzTm9uRW1wdHlTdHJpbmcoZi50eXBlKSksXHJcbiAgICBtYWtlcnVsZShcImxhYmVsXCIsIFwiZmllbGQgbGFiZWwgaXMgbm90IHNldFwiLFxyXG4gICAgICAgIGYgPT4gaXNOb25FbXB0eVN0cmluZyhmLmxhYmVsKSksXHJcbiAgICBtYWtlcnVsZShcImdldEluaXRpYWxWYWx1ZVwiLCBcImdldEluaXRpYWxWYWx1ZSBmdW5jdGlvbiBpcyBub3Qgc2V0XCIsXHJcbiAgICAgICAgZiA9PiBpc05vbkVtcHR5U3RyaW5nKGYuZ2V0SW5pdGlhbFZhbHVlKSksXHJcbiAgICBtYWtlcnVsZShcImdldFVuZGVmaW5lZFZhbHVlXCIsIFwiZ2V0VW5kZWZpbmVkVmFsdWUgZnVuY3Rpb24gaXMgbm90IHNldFwiLFxyXG4gICAgICAgIGYgPT4gaXNOb25FbXB0eVN0cmluZyhmLmdldFVuZGVmaW5lZFZhbHVlKSksXHJcbiAgICBtYWtlcnVsZShcIm5hbWVcIiwgXCJmaWVsZCBuYW1lIGlzIGR1cGxpY2F0ZWRcIixcclxuICAgICAgICBmID0+IGlzTm90aGluZ09yRW1wdHkoZi5uYW1lKSB8fCBcclxuICAgICAgICAgICAgIGNvdW50QnkoXCJuYW1lXCIpKGFsbEZpZWxkcylbZi5uYW1lXSA9PT0gMSksXHJcbiAgICBtYWtlcnVsZShcInR5cGVcIiwgXCJ0eXBlIGlzIHVua25vd25cIixcclxuICAgICAgICBmID0+IGlzTm90aGluZ09yRW1wdHkoZi50eXBlKSBcclxuICAgICAgICAgICAgIHx8IHNvbWUodCA9PiBmLnR5cGUgPT09IHQpKGFsbG93ZWRUeXBlcygpKSksXHJcbl07XHJcblxyXG5jb25zdCB0eXBlT3B0aW9uc1J1bGVzID0gZmllbGQgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGFsbFtmaWVsZC50eXBlXTtcclxuICAgIGlmKGlzTm90aGluZyh0eXBlKSkgcmV0dXJuIFtdO1xyXG5cclxuICAgIGNvbnN0IGRlZiA9IG9wdE5hbWUgPT4gXHJcbiAgICAgICAgdHlwZS5vcHRpb25EZWZpbml0aW9uc1tvcHROYW1lXTtcclxuXHJcbiAgICByZXR1cm4gJChmaWVsZC50eXBlT3B0aW9ucywgW1xyXG4gICAgICAgIGtleXMsXHJcbiAgICAgICAgZmlsdGVyKG8gPT4gaXNTb21ldGhpbmcoZGVmKG8pKSBcclxuICAgICAgICAgICAgICAgICAgICAmJiBpc1NvbWV0aGluZyhkZWYobykuaXNWYWxpZCkpLFxyXG4gICAgICAgIG1hcChvID0+IG1ha2VydWxlKFxyXG4gICAgICAgICAgICBgdHlwZU9wdGlvbnMuJHtvfWAsXHJcbiAgICAgICAgICAgIGAke2RlZihvKS5yZXF1aXJlbWVudERlc2NyaXB0aW9ufWAsXHJcbiAgICAgICAgICAgIGZpZWxkID0+IGRlZihvKS5pc1ZhbGlkKGZpZWxkLnR5cGVPcHRpb25zW29dKVxyXG4gICAgICAgICkpXHJcbiAgICBdKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlRmllbGQgPSAoYWxsRmllbGRzKSA9PiAoZmllbGQpID0+IHtcclxuICAgIGNvbnN0IGV2ZXJ5U2luZ2xlRmllbGQgPSBpbmNsdWRlcyhmaWVsZCkoYWxsRmllbGRzKSA/IGFsbEZpZWxkcyA6IFsuLi5hbGxGaWVsZHMsIGZpZWxkXTtcclxuICAgIHJldHVybiBhcHBseVJ1bGVTZXQoWy4uLmZpZWxkUnVsZXMoZXZlcnlTaW5nbGVGaWVsZCksIC4uLnR5cGVPcHRpb25zUnVsZXMoZmllbGQpXSkoZmllbGQpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVBbGxGaWVsZHMgPSAocmVjb3JkTm9kZSkgPT4gXHJcbiAgICAkKHJlY29yZE5vZGUuZmllbGRzLCBbXHJcbiAgICAgICAgbWFwKHZhbGlkYXRlRmllbGQocmVjb3JkTm9kZS5maWVsZHMpKSxcclxuICAgICAgICBmbGF0dGVuXHJcbiAgICBdKTtcclxuXHJcbmV4cG9ydCBjb25zdCBhZGRGaWVsZCA9IChyZWNvcmRUZW1wbGF0ZSwgZmllbGQpID0+IHtcclxuICAgIGlmKGlzTm90aGluZ09yRW1wdHkoZmllbGQubGFiZWwpKSB7XHJcbiAgICAgICAgZmllbGQubGFiZWwgPSBmaWVsZC5uYW1lO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmFsaWRhdGlvbk1lc3NhZ2VzID0gdmFsaWRhdGVGaWVsZChbLi4ucmVjb3JkVGVtcGxhdGUuZmllbGRzLCBmaWVsZF0pKGZpZWxkKTtcclxuICAgIGlmKHZhbGlkYXRpb25NZXNzYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JzID0gbWFwKG0gPT4gbS5lcnJvcikodmFsaWRhdGlvbk1lc3NhZ2VzKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmllbGRFcnJvcnMuQWRkRmllbGRWYWxpZGF0aW9uRmFpbGVkICsgXCIgXCIgKyBlcnJvcnMuam9pbihcIiwgXCIpKTsgXHJcbiAgICB9XHJcbiAgICByZWNvcmRUZW1wbGF0ZS5maWVsZHMucHVzaChmaWVsZCk7XHJcbn07IiwiaW1wb3J0IHtzd2l0Y2hDYXNlfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7aXNOdW1iZXIsIGlzQm9vbGVhbiwgZGVmYXVsdENhc2V9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXROZXdSZWNvcmRWYWxpZGF0aW9uUnVsZSA9IFxyXG4gICAgICAgICAgICAoaW52YWxpZEZpZWxkcywgXHJcbiAgICAgICAgICAgIG1lc3NhZ2VXaGVuSW52YWxpZCwgXHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25XaGVuVmFsaWQpID0+IFxyXG4gICAgKHtcclxuICAgICAgICBpbnZhbGlkRmllbGRzLCBtZXNzYWdlV2hlbkludmFsaWQsIGV4cHJlc3Npb25XaGVuVmFsaWRcclxuICAgIH0pO1xyXG5cclxuY29uc3QgZ2V0U3RhdGljVmFsdWUgPSBzd2l0Y2hDYXNlKFxyXG4gICAgW2lzTnVtYmVyLCB2ID0+IHYudG9TdHJpbmcoKV0sXHJcbiAgICBbaXNCb29sZWFuLCB2ID0+IHYudG9TdHJpbmcoKV0sXHJcbiAgICBbZGVmYXVsdENhc2UsIHYgPT4gYCcke3Z9J2BdXHJcbilcclxuXHJcbmV4cG9ydCBjb25zdCBjb21tb25SZWNvcmRWYWxpZGF0aW9uUnVsZXMgPSAoeyBcclxuXHJcbiAgICBmaWVsZE5vdEVtcHR5IDogKGZpZWxkTmFtZSkgPT4gXHJcbiAgICAgICAgZ2V0TmV3UmVjb3JkVmFsaWRhdGlvblJ1bGUoXHJcbiAgICAgICAgICAgIFtmaWVsZE5hbWVdLCBcclxuICAgICAgICAgICAgYCR7ZmllbGROYW1lfSBpcyBlbXB0eWAsIFxyXG4gICAgICAgICAgICBgIV8uaXNFbXB0eShyZWNvcmRbJyR7ZmllbGROYW1lfSddKWApLFxyXG5cclxuICAgIGZpZWxkQmV0d2VlbiA6IChmaWVsZE5hbWUsIG1pbiwgbWF4KSA9PiBcclxuICAgICAgICBnZXROZXdSZWNvcmRWYWxpZGF0aW9uUnVsZShcclxuICAgICAgICAgICAgW2ZpZWxkTmFtZV0sXHJcbiAgICAgICAgICAgIGAke2ZpZWxkTmFtZX0gbXVzdCBiZSBiZXR3ZWVuICR7bWluLnRvU3RyaW5nKCl9IGFuZCAke21heC50b1N0cmluZygpfWAsXHJcbiAgICAgICAgICAgIGByZWNvcmRbJyR7ZmllbGROYW1lfSddID49ICR7Z2V0U3RhdGljVmFsdWUobWluKX0gJiYgIHJlY29yZFsnJHtmaWVsZE5hbWV9J10gPD0gJHtnZXRTdGF0aWNWYWx1ZShtYXgpfSBgKSxcclxuICAgIFxyXG4gICAgZmllbGRHcmVhdGVyVGhhbiA6IChmaWVsZE5hbWUsIG1pbikgPT5cclxuICAgICAgICBnZXROZXdSZWNvcmRWYWxpZGF0aW9uUnVsZShcclxuICAgICAgICAgICAgW2ZpZWxkTmFtZV0sXHJcbiAgICAgICAgICAgIGAke2ZpZWxkTmFtZX0gbXVzdCBiZSBncmVhdGVyIHRoYW4gJHttaW4udG9TdHJpbmcoKX0gYW5kICR7bWF4LnRvU3RyaW5nKCl9YCxcclxuICAgICAgICAgICAgYHJlY29yZFsnXFxndmZpZWxkTmFtZX0nXSA+PSAke2dldFN0YXRpY1ZhbHVlKG1pbil9ICBgKVxyXG59KTsgXHJcblxyXG5leHBvcnQgY29uc3QgYWRkUmVjb3JkVmFsaWRhdGlvblJ1bGUgPSByZWNvcmROb2RlID0+IHJ1bGUgPT4gXHJcbiAgICByZWNvcmROb2RlLnZhbGlkYXRpb25SdWxlcy5wdXNoKHJ1bGUpOyIsIlxyXG5leHBvcnQgY29uc3QgY3JlYXRlVHJpZ2dlciA9ICgpID0+ICh7XHJcbiAgICBhY3Rpb25OYW1lOiBcIlwiLFxyXG4gICAgZXZlbnROYW1lOiBcIlwiLFxyXG4gICAgLy8gZnVuY3Rpb24sIGhhcyBhY2Nlc3MgdG8gZXZlbnQgY29udGV4dCwgXHJcbiAgICAvLyByZXR1cm5zIG9iamVjdCB0aGF0IGlzIHVzZWQgYXMgcGFyYW1ldGVyIHRvIGFjdGlvblxyXG4gICAgLy8gb25seSB1c2VkIGlmIHRyaWdnZXJlZCBieSBldmVudFxyXG4gICAgb3B0aW9uc0NyZWF0b3I6IFwiXCIsXHJcbiAgICAvLyBhY3Rpb24gcnVucyBpZiB0cnVlLCBcclxuICAgIC8vIGhhcyBhY2Nlc3MgdG8gZXZlbnQgY29udGV4dCBcclxuICAgIGNvbmRpdGlvbjogXCJcIiBcclxufSlcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVBY3Rpb24gPSAoKSA9PiAoe1xyXG4gICAgbmFtZTogXCJcIiwgXHJcbiAgICBiZWhhdmlvdXJTb3VyY2U6IFwiXCIsIFxyXG4gICAgLy8gbmFtZSBvZiBmdW5jdGlvbiBpbiBhY3Rpb25Tb3VyY2VcclxuICAgIGJlaGF2aW91ck5hbWU6IFwiXCIsXHJcbiAgICAvLyBwYXJhbWV0ZXIgcGFzc2VkIGludG8gYmVoYXZpb3VyLiBcclxuICAgIC8vIGFueSBvdGhlciBwYXJtcyBwYXNzZWQgYXQgcnVudGltZSBlLmcuXHJcbiAgICAvLyBieSB0cmlnZ2VyLCBvciBtYW51YWxseSwgd2lsbCBiZSBtZXJnZWQgaW50byB0aGlzXHJcbiAgICBpbml0aWFsT3B0aW9uczoge31cclxufSk7XHJcblxyXG5cclxuIiwiaW1wb3J0IHthcHBseVJ1bGVTZXQsIG1ha2VydWxlfSBmcm9tIFwiLi4vY29tbW9uL3ZhbGlkYXRpb25Db21tb25cIjtcclxuaW1wb3J0IHtmbGF0dGVuLCBtYXB9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHtpc0VtcHR5LCBkaWZmZXJlbmNlfSBmcm9tIFwibG9kYXNoXCI7XHJcbmltcG9ydCB7aXNOb25FbXB0eVN0cmluZywgZXhlY3V0ZXNXaXRob3V0RXhjZXB0aW9uLCBcclxuICAgICAgICAkLCBpc05vbkVtcHR5QXJyYXl9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHtjb21waWxlRXhwcmVzc2lvbiwgY29tcGlsZUNvZGV9IGZyb20gXCJAbngtanMvY29tcGlsZXItdXRpbFwiO1xyXG5cclxuY29uc3QgYWdncmVnYXRlUnVsZXMgPSBbXHJcbiAgICBtYWtlcnVsZShcIm5hbWVcIiwgXCJjaG9vc2UgYSBuYW1lIGZvciB0aGUgYWdncmVnYXRlXCIsXHJcbiAgICAgICAgYSA9PiBpc05vbkVtcHR5U3RyaW5nKGEubmFtZSkpLFxyXG4gICAgbWFrZXJ1bGUoXCJhZ2dyZWdhdGVkVmFsdWVcIiwgXCJhZ2dyZWdhdGVkVmFsdWUgZG9lcyBub3QgY29tcGlsZVwiLFxyXG4gICAgICAgIGEgPT4gaXNFbXB0eShhLmFnZ3JlZ2F0ZWRWYWx1ZSlcclxuICAgICAgICAgICAgfHwgZXhlY3V0ZXNXaXRob3V0RXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgKCkgPT4gY29tcGlsZUNvZGUoYS5hZ2dyZWdhdGVkVmFsdWUpKSlcclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUFnZ3JlZ2F0ZSA9IChhZ2dyZWdhdGUpID0+IFxyXG4gICAgYXBwbHlSdWxlU2V0KGFnZ3JlZ2F0ZVJ1bGVzKShhZ2dyZWdhdGUpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQWxsQWdncmVnYXRlcyA9IGFsbCA9PiBcclxuICAgICQoYWxsLCBbXHJcbiAgICAgICAgbWFwKHZhbGlkYXRlQWdncmVnYXRlKSxcclxuICAgICAgICBmbGF0dGVuXHJcbiAgICBdKTsiLCJpbXBvcnQgeyQsIGlzU29tZXRoaW5nLCBzd2l0Y2hDYXNlXHJcbiAgICAgICAgLGFueVRydWUsIGlzTm9uRW1wdHlBcnJheSwgZXhlY3V0ZXNXaXRob3V0RXhjZXB0aW9uXHJcbiAgICAgICAgLCBpc05vbkVtcHR5U3RyaW5nLCBkZWZhdWx0Q2FzZX0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge2lzUmVjb3JkLCBpc1Jvb3QsIGlzYWdncmVnYXRlR3JvdXAsXHJcbiAgICAgICAgaXNJbmRleCwgZ2V0RmxhdHRlbmVkSGllcmFyY2h5fSBmcm9tIFwiLi9oZWlyYXJjaHlcIjtcclxuaW1wb3J0IHtmaWx0ZXIsIHVuaW9uLCBjb25zdGFudCwgXHJcbiAgICAgICAgbWFwLCBmbGF0dGVuLCBldmVyeSwgdW5pcUJ5LFxyXG4gICAgICAgIHNvbWUsIGluY2x1ZGVzLCBpc0VtcHR5fSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcbmltcG9ydCB7aGFzfSBmcm9tIFwibG9kYXNoXCI7XHJcbmltcG9ydCB7ZXZlbnRzTGlzdH0gZnJvbSBcIi4uL2NvbW1vbi9ldmVudHNcIjtcclxuaW1wb3J0IHtjb21waWxlRXhwcmVzc2lvbiwgY29tcGlsZUNvZGV9IGZyb20gXCJAbngtanMvY29tcGlsZXItdXRpbFwiO1xyXG5pbXBvcnQge3ZhbGlkYXRlQWxsRmllbGRzfSBmcm9tIFwiLi9maWVsZHNcIjtcclxuaW1wb3J0IHthcHBseVJ1bGVTZXQsIG1ha2VydWxlLCBzdHJpbmdOb3RFbXB0eSwgXHJcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yfSBmcm9tIFwiLi4vY29tbW9uL3ZhbGlkYXRpb25Db21tb25cIjtcclxuaW1wb3J0IHtpbmRleFJ1bGVTZXR9IGZyb20gXCIuL2luZGV4ZXNcIjtcclxuaW1wb3J0IHt2YWxpZGF0ZUFsbEFnZ3JlZ2F0ZXN9IGZyb20gXCIuL3ZhbGlkYXRlQWdncmVnYXRlXCI7XHJcblxyXG5leHBvcnQgY29uc3QgcnVsZVNldCA9ICguLi5zZXRzKSA9PiBcclxuICAgIGNvbnN0YW50KGZsYXR0ZW4oWy4uLnNldHNdKSk7XHJcblxyXG5jb25zdCBjb21tb25SdWxlcyA9IFtcclxuICAgIG1ha2VydWxlKFwibmFtZVwiLCBcIm5vZGUgbmFtZSBpcyBub3Qgc2V0XCIsIFxyXG4gICAgICAgICBub2RlID0+IHN0cmluZ05vdEVtcHR5KG5vZGUubmFtZSkpLFxyXG4gICAgbWFrZXJ1bGUoXCJ0eXBlXCIsIFwibm9kZSB0eXBlIG5vdCByZWNvZ25pc2VkXCIsXHJcbiAgICAgICAgYW55VHJ1ZShpc1JlY29yZCwgaXNSb290LCBpc0luZGV4LCBpc2FnZ3JlZ2F0ZUdyb3VwICkpXHJcbl07XHJcblxyXG5jb25zdCByZWNvcmRSdWxlcyA9IFtcclxuICAgIG1ha2VydWxlKFwiZmllbGRzXCIsIFwibm8gZmllbGRzIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgcmVjb3JkXCIsXHJcbiAgICAgICAgbm9kZSA9PiBpc05vbkVtcHR5QXJyYXkobm9kZS5maWVsZHMpKSxcclxuICAgIG1ha2VydWxlKFwidmFsaWRhdGlvblJ1bGVzXCIsIFwidmFsaWRhdGlvbiBydWxlIGlzIG1pc3NpbmcgYSAnbWVzc2FnZVdoZW5WYWxpZCcgbWVtYmVyXCIsXHJcbiAgICAgICAgbm9kZSA9PiBldmVyeShyID0+IGhhcyhyLCBcIm1lc3NhZ2VXaGVuSW52YWxpZFwiKSlcclxuICAgICAgICAgICAgICAgIChub2RlLnZhbGlkYXRpb25SdWxlcykpLFxyXG4gICAgbWFrZXJ1bGUoXCJ2YWxpZGF0aW9uUnVsZXNcIiwgXCJ2YWxpZGF0aW9uIHJ1bGUgaXMgbWlzc2luZyBhICdleHByZXNzaW9uV2hlblZhbGlkJyBtZW1iZXJcIixcclxuICAgICAgICBub2RlID0+IGV2ZXJ5KHIgPT4gaGFzKHIsIFwiZXhwcmVzc2lvbldoZW5WYWxpZFwiKSlcclxuICAgICAgICAgICAgICAgIChub2RlLnZhbGlkYXRpb25SdWxlcykpLFxyXG5dO1xyXG5cclxuXHJcbmNvbnN0IGFnZ3JlZ2F0ZUdyb3VwUnVsZXMgPSBbXHJcbiAgICBtYWtlcnVsZShcImNvbmRpdGlvblwiLCBcImNvbmRpdGlvbiBkb2VzIG5vdCBjb21waWxlXCIsXHJcbiAgICAgICAgYSA9PiBpc0VtcHR5KGEuY29uZGl0aW9uKVxyXG4gICAgICAgICAgICAgfHwgZXhlY3V0ZXNXaXRob3V0RXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICgpID0+IGNvbXBpbGVFeHByZXNzaW9uKGEuY29uZGl0aW9uKSkpLFxyXG5dO1xyXG5cclxuY29uc3QgZ2V0UnVsZVNldCA9IG5vZGUgPT4gXHJcbiAgICBzd2l0Y2hDYXNlKFxyXG5cclxuICAgICAgICBbaXNSZWNvcmQsIHJ1bGVTZXQoXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uUnVsZXMsIFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZFJ1bGVzKV0sXHJcblxyXG4gICAgICAgIFtpc0luZGV4LCBydWxlU2V0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgY29tbW9uUnVsZXMsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXhSdWxlU2V0KV0sXHJcblxyXG4gICAgICAgIFtpc2FnZ3JlZ2F0ZUdyb3VwLCBydWxlU2V0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uUnVsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVHcm91cFJ1bGVzKV0sXHJcblxyXG4gICAgICAgIFtkZWZhdWx0Q2FzZSwgcnVsZVNldChjb21tb25SdWxlcywgW10pXVxyXG4gICAgKShub2RlKTtcclxuXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZU5vZGUgPSBub2RlID0+IFxyXG4gICAgYXBwbHlSdWxlU2V0KGdldFJ1bGVTZXQobm9kZSkpKG5vZGUpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlQWxsID0gYXBwSGVpcmFyY2h5ID0+IHtcclxuICAgIFxyXG4gICAgdmFyIGZsYXR0ZW5lZCA9IGdldEZsYXR0ZW5lZEhpZXJhcmNoeShcclxuICAgICAgICBhcHBIZWlyYXJjaHlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgZHVwbGljYXRlTmFtZVJ1bGUgPSBtYWtlcnVsZShcclxuICAgICAgICBcIm5hbWVcIiwgXCJub2RlIG5hbWVzIG11c3QgYmUgdW5pcXVlIHVuZGVyIHNoYXJlZCBwYXJlbnRcIixcclxuICAgICAgICBuID0+IGZpbHRlcihmID0+IGYucGFyZW50KCkgPT09IG4ucGFyZW50KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBmLm5hbWUgPT09IG4ubmFtZSkgXHJcbiAgICAgICAgICAgICAgICAgICAgKGZsYXR0ZW5lZCkubGVuZ3RoID09PSAxXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGR1cGxpY2F0ZU5vZGVLZXlFcnJvcnMgPSAkKGZsYXR0ZW5lZCwgW1xyXG4gICAgICAgIG1hcChuID0+IGFwcGx5UnVsZVNldChbZHVwbGljYXRlTmFtZVJ1bGVdKShuKSksXHJcbiAgICAgICAgZmlsdGVyKGlzU29tZXRoaW5nKSxcclxuICAgICAgICBmbGF0dGVuXHJcbiAgICBdKTtcclxuXHJcbiAgICBjb25zdCBmaWVsZEVycm9ycyA9ICQoZmxhdHRlbmVkLCBbXHJcbiAgICAgICAgZmlsdGVyKGlzUmVjb3JkKSxcclxuICAgICAgICBtYXAodmFsaWRhdGVBbGxGaWVsZHMpLFxyXG4gICAgICAgIGZsYXR0ZW5cclxuICAgIF0pO1xyXG5cclxuICAgIGNvbnN0IGFnZ3JlZ2F0ZUVycm9ycyA9ICQoZmxhdHRlbmVkLCBbXHJcbiAgICAgICAgZmlsdGVyKGlzYWdncmVnYXRlR3JvdXApLFxyXG4gICAgICAgIG1hcChzID0+IHZhbGlkYXRlQWxsQWdncmVnYXRlcyhcclxuICAgICAgICAgICAgICAgICAgICBzLmFnZ3JlZ2F0ZXMpKSxcclxuICAgICAgICBmbGF0dGVuXHJcbiAgICBdKTtcclxuXHJcbiAgICByZXR1cm4gJChmbGF0dGVuZWQsIFtcclxuICAgICAgICBtYXAodmFsaWRhdGVOb2RlKSxcclxuICAgICAgICBmbGF0dGVuLFxyXG4gICAgICAgIHVuaW9uKGR1cGxpY2F0ZU5vZGVLZXlFcnJvcnMpLFxyXG4gICAgICAgIHVuaW9uKGZpZWxkRXJyb3JzKSxcclxuICAgICAgICB1bmlvbihhZ2dyZWdhdGVFcnJvcnMpXHJcbiAgICBdKTtcclxufTtcclxuXHJcbmNvbnN0IGFjdGlvblJ1bGVzID0gW1xyXG4gICAgbWFrZXJ1bGUoXCJuYW1lXCIsIFwiYWN0aW9uIG11c3QgaGF2ZSBhIG5hbWVcIiwgXHJcbiAgICAgICAgYSA9PiBpc05vbkVtcHR5U3RyaW5nKGEubmFtZSkpLFxyXG4gICAgbWFrZXJ1bGUoXCJiZWhhdmlvdXJOYW1lXCIsIFwibXVzdCBzdXBwbHkgYSBiZWhhdmlvdXIgbmFtZSB0byB0aGUgYWN0aW9uXCIsXHJcbiAgICAgICAgYSA9PiBpc05vbkVtcHR5U3RyaW5nKGEuYmVoYXZpb3VyTmFtZSkpLFxyXG4gICAgbWFrZXJ1bGUoXCJiZWhhdmlvdXJTb3VyY2VcIiwgXCJtdXN0IHN1cHBseSBhIGJlaGF2aW91ciBzb3VyY2UgZm9yIHRoZSBhY3Rpb25cIixcclxuICAgICAgICBhID0+IGlzTm9uRW1wdHlTdHJpbmcoYS5iZWhhdmlvdXJTb3VyY2UpKSxcclxuXTtcclxuXHJcbmNvbnN0IGR1cGxpY2F0ZUFjdGlvblJ1bGUgPSBcclxuICAgIG1ha2VydWxlKFwiXCIsIFwiYWN0aW9uIG5hbWUgbXVzdCBiZSB1bmlxdWVcIiwgKCkgPT57fSk7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUFjdGlvbiA9IGFjdGlvbiA9PiBcclxuICAgIGFwcGx5UnVsZVNldChhY3Rpb25SdWxlcykoYWN0aW9uKTtcclxuXHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVBY3Rpb25zID0gKGFsbEFjdGlvbnMpID0+IHtcclxuICAgIFxyXG4gICAgY29uc3QgZHVwbGljYXRlQWN0aW9ucyA9ICQoYWxsQWN0aW9ucywgW1xyXG4gICAgICAgIGZpbHRlcihhID0+IGZpbHRlcihhMiA9PiBhMi5uYW1lID09PSBhLm5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsbEFjdGlvbnMpLmxlbmd0aCA+IDEpLFxyXG4gICAgICAgIG1hcChhID0+IHZhbGlkYXRpb25FcnJvcihkdXBsaWNhdGVBY3Rpb25SdWxlLCBhKSlcclxuICAgIF0pO1xyXG4gICAgXHJcbiAgICBjb25zdCBlcnJvcnMgPSAkKGFsbEFjdGlvbnMsIFtcclxuICAgICAgICBtYXAodmFsaWRhdGVBY3Rpb24pLFxyXG4gICAgICAgIGZsYXR0ZW4sXHJcbiAgICAgICAgdW5pb24oZHVwbGljYXRlQWN0aW9ucyksXHJcbiAgICAgICAgdW5pcUJ5KFwibmFtZVwiKVxyXG4gICAgXSk7XHJcblxyXG4gICAgcmV0dXJuIGVycm9ycztcclxufTtcclxuXHJcbmNvbnN0IHRyaWdnZXJSdWxlcyA9IGFjdGlvbnMgPT4gKFtcclxuICAgIG1ha2VydWxlKFwiYWN0aW9uTmFtZVwiLCBcIm11c3Qgc3BlY2lmeSBhbiBhY3Rpb25cIiwgXHJcbiAgICAgICAgdCA9PiBpc05vbkVtcHR5U3RyaW5nKHQuYWN0aW9uTmFtZSkpLFxyXG4gICAgbWFrZXJ1bGUoXCJldmVudE5hbWVcIiwgXCJtdXN0IHNwZWNpZnkgYW5kIGV2ZW50XCIsXHJcbiAgICAgICAgdCA9PiBpc05vbkVtcHR5U3RyaW5nKHQuZXZlbnROYW1lKSksXHJcbiAgICBtYWtlcnVsZShcImFjdGlvbk5hbWVcIiwgXCJzcGVjaWZpZWQgYWN0aW9uIG5vdCBzdXBwbGllZFwiLFxyXG4gICAgICAgIHQgPT4gIXQuYWN0aW9uTmFtZSBcclxuICAgICAgICAgICAgIHx8IHNvbWUoYSA9PiBhLm5hbWUgPT09IHQuYWN0aW9uTmFtZSkoYWN0aW9ucykpLFxyXG4gICAgbWFrZXJ1bGUoXCJldmVudE5hbWVcIiwgXCJpbnZhbGlkIEV2ZW50IE5hbWVcIixcclxuICAgICAgICB0ID0+ICF0LmV2ZW50TmFtZSBcclxuICAgICAgICAgICAgIHx8IGluY2x1ZGVzKHQuZXZlbnROYW1lKShldmVudHNMaXN0KSksXHJcbiAgICBtYWtlcnVsZShcIm9wdGlvbnNDcmVhdG9yXCIsIFwiT3B0aW9ucyBDcmVhdG9yIGRvZXMgbm90IGNvbXBpbGUgLSBjaGVjayB5b3VyIGV4cHJlc3Npb25cIixcclxuICAgICAgICB0ID0+IHtcclxuICAgICAgICAgICAgaWYoIXQub3B0aW9uc0NyZWF0b3IpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB0cnkgeyBcclxuICAgICAgICAgICAgICAgIGNvbXBpbGVDb2RlKHQub3B0aW9uc0NyZWF0b3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0gY2F0Y2goXykgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgICAgICB9KSxcclxuICAgIG1ha2VydWxlKFwiY29uZGl0aW9uXCIsIFwiVHJpZ2dlciBjb25kaXRpb24gZG9lcyBub3QgY29tcGlsZSAtIGNoZWNrIHlvdXIgZXhwcmVzc2lvblwiLFxyXG4gICAgICAgIHQgPT4ge1xyXG4gICAgICAgICAgICBpZighdC5jb25kaXRpb24pIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB0cnkgeyBcclxuICAgICAgICAgICAgICAgIGNvbXBpbGVFeHByZXNzaW9uKHQuY29uZGl0aW9uKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9IGNhdGNoKF8pIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgICAgfSlcclxuXSk7XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVUcmlnZ2VyID0gKHRyaWdnZXIsIGFsbEFjdGlvbnMpID0+IHtcclxuXHJcbiAgICBjb25zdCBlcnJvcnMgPSBhcHBseVJ1bGVTZXQodHJpZ2dlclJ1bGVzKGFsbEFjdGlvbnMpKSh0cmlnZ2VyKTtcclxuXHJcbiAgICByZXR1cm4gZXJyb3JzO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlVHJpZ2dlcnMgPSAodHJpZ2dlcnMsIGFsbEFjdGlvbnMpID0+IFxyXG4gICAgJCh0cmlnZ2VycywgW1xyXG4gICAgICAgIG1hcCh0ID0+IHZhbGlkYXRlVHJpZ2dlcih0LCBhbGxBY3Rpb25zKSksXHJcbiAgICAgICAgZmxhdHRlblxyXG4gICAgXSk7XHJcbiAgICAiLCJpbXBvcnQge2FwcERlZmluaXRpb25GaWxlfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7Y29uc3RydWN0SGVpcmFyY2h5fSBmcm9tIFwiLi9jcmVhdGVOb2Rlc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEFwcGxpY2F0aW9uRGVmaW5pdGlvbiA9IChkYXRhc3RvcmUpID0+IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IGV4aXN0cyA9IGF3YWl0IGRhdGFzdG9yZS5leGlzdHMoYXBwRGVmaW5pdGlvbkZpbGUpO1xyXG5cclxuICAgIGlmKCFleGlzdHMpIHRocm93IG5ldyBFcnJvcihcIkFwcGxpY2F0aW9uIGRlZmluaXRpb24gZG9lcyBub3QgZXhpc3RcIik7XHJcblxyXG4gICAgY29uc3QgYXBwRGVmaW5pdGlvbiA9IGF3YWl0IGRhdGFzdG9yZS5sb2FkSnNvbihhcHBEZWZpbml0aW9uRmlsZSk7XHJcbiAgICBhcHBEZWZpbml0aW9uLmhlaXJhcmNoeSA9IGNvbnN0cnVjdEhlaXJhcmNoeShcclxuICAgICAgICBhcHBEZWZpbml0aW9uLmhlaXJhcmNoeSAgICAgICAgICAgIFxyXG4gICAgKTtcclxuICAgIHJldHVybiBhcHBEZWZpbml0aW9uO1xyXG59IiwiaW1wb3J0IHtwZXJtaXNzaW9ufSBmcm9tIFwiLi4vYXV0aEFwaS9wZXJtaXNzaW9uc1wiO1xyXG5pbXBvcnQge2FwcERlZmluaXRpb25GaWxlfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7am9pbn0gZnJvbSBcImxvZGFzaFwiO1xyXG5pbXBvcnQge3ZhbGlkYXRlQWxsfSBmcm9tIFwiLi92YWxpZGF0ZVwiO1xyXG5pbXBvcnQge2FwaVdyYXBwZXJ9IGZyb20gXCIuLi9jb21tb24vYXBpV3JhcHBlclwiO1xyXG5pbXBvcnQge2V2ZW50c30gZnJvbSBcIi4uL2NvbW1vbi9ldmVudHNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBzYXZlQXBwbGljYXRpb25IZWlyYXJjaHkgPSBhcHAgPT4gYXN5bmMgaGVpcmFyY2h5ID0+IFxyXG4gICAgYXBpV3JhcHBlcihcclxuICAgICAgICBhcHAsICBcclxuICAgICAgICBldmVudHMudGVtcGxhdGVBcGkuc2F2ZUFwcGxpY2F0aW9uSGVpcmFyY2h5LFxyXG4gICAgICAgIHBlcm1pc3Npb24ud3JpdGVUZW1wbGF0ZXMuaXNBdXRob3JpemVkLFxyXG4gICAgICAgIHtoZWlyYXJjaHl9LFxyXG4gICAgICAgIF9zYXZlQXBwbGljYXRpb25IZWlyYXJjaHksIGFwcC5kYXRhc3RvcmUsIGhlaXJhcmNoeVxyXG4gICAgKTtcclxuXHJcblxyXG5leHBvcnQgY29uc3QgX3NhdmVBcHBsaWNhdGlvbkhlaXJhcmNoeSA9IGFzeW5jIChkYXRhc3RvcmUsIGhlaXJhcmNoeSkgPT57XHJcblxyXG4gICAgY29uc3QgdmFsaWRhdGlvbkVycm9ycyA9IGF3YWl0IHZhbGlkYXRlQWxsKGhlaXJhcmNoeSk7XHJcbiAgICBpZih2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWlyYXJjaHkgaXMgaW52YWxpZDogXCIgKyBqb2luKFxyXG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLm1hcChlID0+IGAke2UuaXRlbS5ub2RlS2V5ID8gZS5pdGVtLm5vZGVLZXkoKSA6IFwiXCJ9IDogJHtlLmVycm9yfWApLFxyXG4gICAgICAgICAgICBcIixcIlxyXG4gICAgICAgICkpO1xyXG4gICAgfSBcclxuXHJcbiAgICBpZihhd2FpdCBkYXRhc3RvcmUuZXhpc3RzKGFwcERlZmluaXRpb25GaWxlKSl7XHJcbiAgICAgICAgY29uc3QgYXBwRGVmaW5pdGlvbiA9IGF3YWl0IGRhdGFzdG9yZS5sb2FkSnNvbihhcHBEZWZpbml0aW9uRmlsZSk7XHJcbiAgICAgICAgYXBwRGVmaW5pdGlvbi5oZWlyYXJjaHkgPSBoZWlyYXJjaHk7XHJcbiAgICAgICAgYXdhaXQgZGF0YXN0b3JlLnVwZGF0ZUpzb24oYXBwRGVmaW5pdGlvbkZpbGUsIGFwcERlZmluaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXdhaXQgZGF0YXN0b3JlLmNyZWF0ZUZvbGRlcihcIi8uY29uZmlnXCIpO1xyXG4gICAgICAgIGNvbnN0IGFwcERlZmluaXRpb24gPSB7YWN0aW9uczpbXSwgdHJpZ2dlcnM6W10sIGhlaXJhcmNoeX07XHJcbiAgICAgICAgYXdhaXQgZGF0YXN0b3JlLmNyZWF0ZUpzb24oYXBwRGVmaW5pdGlvbkZpbGUsIGFwcERlZmluaXRpb24pO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHthcHBEZWZpbml0aW9uRmlsZX0gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge2pvaW59IGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHttYXB9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHt2YWxpZGF0ZVRyaWdnZXJzLCB2YWxpZGF0ZUFjdGlvbnN9IGZyb20gXCIuL3ZhbGlkYXRlXCI7XHJcbmltcG9ydCB7YXBpV3JhcHBlcn0gZnJvbSBcIi4uL2NvbW1vbi9hcGlXcmFwcGVyXCI7XHJcbmltcG9ydCB7ZXZlbnRzfSBmcm9tIFwiLi4vY29tbW9uL2V2ZW50c1wiO1xyXG5pbXBvcnQge3Blcm1pc3Npb259IGZyb20gXCIuLi9hdXRoQXBpL3Blcm1pc3Npb25zXCI7XHJcblxyXG5leHBvcnQgY29uc3Qgc2F2ZUFjdGlvbnNBbmRUcmlnZ2VycyA9IGFwcCA9PiBhc3luYyAoYWN0aW9ucywgdHJpZ2dlcnMpID0+IFxyXG4gICAgYXBpV3JhcHBlcihcclxuICAgICAgICBhcHAsICBcclxuICAgICAgICBldmVudHMudGVtcGxhdGVBcGkuc2F2ZUFjdGlvbnNBbmRUcmlnZ2VycyxcclxuICAgICAgICBwZXJtaXNzaW9uLndyaXRlVGVtcGxhdGVzLmlzQXV0aG9yaXplZCxcclxuICAgICAgICB7YWN0aW9ucywgdHJpZ2dlcnN9LFxyXG4gICAgICAgIF9zYXZlQWN0aW9uc0FuZFRyaWdnZXJzLCBhcHAuZGF0YXN0b3JlLCBhY3Rpb25zLCB0cmlnZ2Vyc1xyXG4gICAgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBfc2F2ZUFjdGlvbnNBbmRUcmlnZ2VycyA9IGFzeW5jIChkYXRhc3RvcmUsIGFjdGlvbnMsIHRyaWdnZXJzKSA9PiB7XHJcbiAgICBpZihhd2FpdCBkYXRhc3RvcmUuZXhpc3RzKGFwcERlZmluaXRpb25GaWxlKSl7XHJcbiAgICAgICAgY29uc3QgYXBwRGVmaW5pdGlvbiA9IGF3YWl0IGRhdGFzdG9yZS5sb2FkSnNvbihhcHBEZWZpbml0aW9uRmlsZSk7XHJcbiAgICAgICAgYXBwRGVmaW5pdGlvbi5hY3Rpb25zID0gYWN0aW9ucztcclxuICAgICAgICBhcHBEZWZpbml0aW9uLnRyaWdnZXJzID0gdHJpZ2dlcnM7XHJcblxyXG4gICAgICAgIGNvbnN0IGFjdGlvblZhbGlkRXJycyA9IG1hcChlID0+IGUuZXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbGlkYXRlQWN0aW9ucyhhY3Rpb25zKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoYWN0aW9uVmFsaWRFcnJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWN0aW9ucyBhcmUgaW4gdmFsaWQ6IFwiICsgam9pbihhY3Rpb25WYWxpZEVycnMsXCIsIFwiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0cmlnZ2VyVmFsaWRFcnJzID0gbWFwKGUgPT4gZS5lcnJvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsaWRhdGVUcmlnZ2Vycyh0cmlnZ2VycywgYWN0aW9ucykpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRyaWdnZXJWYWxpZEVycnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmlnZ2VycyBhcmUgaW4gdmFsaWQ6IFwiICsgam9pbih0cmlnZ2VyVmFsaWRFcnJzLFwiLCBcIikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgZGF0YXN0b3JlLnVwZGF0ZUpzb24oYXBwRGVmaW5pdGlvbkZpbGUsIGFwcERlZmluaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNhdmUgYWN0aW9uczogQXBwbGljYXRpb24gZGVmaW5pdGlvbiBkb2VzIG5vdCBleGlzdFwiKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7Z2V0TmV3Um9vdExldmVsLCBcbiAgICAgICAgZ2V0TmV3UmVjb3JkVGVtcGxhdGUsIGdldE5ld0luZGV4VGVtcGxhdGUsXG4gICAgICAgIGNyZWF0ZU5vZGVFcnJvcnMsIGNvbnN0cnVjdEhlaXJhcmNoeSxcbiAgICAgICAgZ2V0TmV3QWdncmVnYXRlR3JvdXBUZW1wbGF0ZSwgZ2V0TmV3U2luZ2xlUmVjb3JkVGVtcGxhdGUsXG4gICAgICAgIGdldE5ld0FnZ3JlZ2F0ZVRlbXBsYXRlLCBjb25zdHJ1Y3ROb2RlfSBcbiAgICAgICAgZnJvbSBcIi4vY3JlYXRlTm9kZXNcIjtcbmltcG9ydCB7Z2V0TmV3RmllbGQsIHZhbGlkYXRlRmllbGQsIFxuICAgICAgICBhZGRGaWVsZCwgZmllbGRFcnJvcnN9IGZyb20gXCIuL2ZpZWxkc1wiO1xuaW1wb3J0IHtnZXROZXdSZWNvcmRWYWxpZGF0aW9uUnVsZSwgY29tbW9uUmVjb3JkVmFsaWRhdGlvblJ1bGVzLFxuICAgICAgICBhZGRSZWNvcmRWYWxpZGF0aW9uUnVsZX0gZnJvbSBcIi4vcmVjb3JkVmFsaWRhdGlvblJ1bGVzXCI7XG5pbXBvcnQge2NyZWF0ZUFjdGlvbiwgY3JlYXRlVHJpZ2dlcn0gZnJvbSBcIi4vY3JlYXRlQWN0aW9uc1wiO1xuaW1wb3J0IHt2YWxpZGF0ZVRyaWdnZXJzLCB2YWxpZGF0ZVRyaWdnZXIsIHZhbGlkYXRlTm9kZSxcbiAgICAgICAgdmFsaWRhdGVBY3Rpb25zLCB2YWxpZGF0ZUFsbH0gZnJvbSBcIi4vdmFsaWRhdGVcIjtcbmltcG9ydCB7Z2V0QXBwbGljYXRpb25EZWZpbml0aW9ufSBmcm9tIFwiLi9nZXRBcHBsaWNhdGlvbkRlZmluaXRpb25cIlxuaW1wb3J0IHtzYXZlQXBwbGljYXRpb25IZWlyYXJjaHl9IGZyb20gXCIuL3NhdmVBcHBsaWNhdGlvbkhlaXJhcmNoeVwiO1xuaW1wb3J0IHtzYXZlQWN0aW9uc0FuZFRyaWdnZXJzfSBmcm9tIFwiLi9zYXZlQWN0aW9uc0FuZFRyaWdnZXJzXCI7XG5pbXBvcnQge2FsbH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmNvbnN0IGFwaSA9IGFwcCA9PiAoe1xuICAgIFxuICAgIGdldEFwcGxpY2F0aW9uRGVmaW5pdGlvbiA6IGdldEFwcGxpY2F0aW9uRGVmaW5pdGlvbihhcHAuZGF0YXN0b3JlKSxcbiAgICBzYXZlQXBwbGljYXRpb25IZWlyYXJjaHkgOiBzYXZlQXBwbGljYXRpb25IZWlyYXJjaHkoYXBwKSxcbiAgICBzYXZlQWN0aW9uc0FuZFRyaWdnZXJzIDogc2F2ZUFjdGlvbnNBbmRUcmlnZ2VycyhhcHApLFxuICAgIGdldEJlaGF2aW91clNvdXJjZXM6ICgpID0+IGdldEJlaGF2aW91clNvdXJjZXMoYXBwLmRhdGFzdG9yZSksXG4gICAgZ2V0TmV3Um9vdExldmVsLCBjb25zdHJ1Y3ROb2RlLFxuICAgIGdldE5ld0luZGV4VGVtcGxhdGUsIGdldE5ld1JlY29yZFRlbXBsYXRlLFxuICAgIGdldE5ld0ZpZWxkLCB2YWxpZGF0ZUZpZWxkLCBhZGRGaWVsZCwgZmllbGRFcnJvcnMsXG4gICAgZ2V0TmV3UmVjb3JkVmFsaWRhdGlvblJ1bGUsIGNvbW1vblJlY29yZFZhbGlkYXRpb25SdWxlcywgXG4gICAgYWRkUmVjb3JkVmFsaWRhdGlvblJ1bGUsIGNyZWF0ZUFjdGlvbiwgY3JlYXRlVHJpZ2dlciwgdmFsaWRhdGVBY3Rpb25zLFxuICAgIHZhbGlkYXRlVHJpZ2dlciwgZ2V0TmV3QWdncmVnYXRlR3JvdXBUZW1wbGF0ZSxcbiAgICBnZXROZXdBZ2dyZWdhdGVUZW1wbGF0ZSwgY29uc3RydWN0SGVpcmFyY2h5LCBnZXROZXdTaW5nbGVSZWNvcmRUZW1wbGF0ZSxcbiAgICBhbGxUeXBlczphbGwsIHZhbGlkYXRlTm9kZSwgdmFsaWRhdGVBbGwsIHZhbGlkYXRlVHJpZ2dlcnNcbn0pO1xuXG5cbmV4cG9ydCBjb25zdCBnZXRUZW1wbGF0ZUFwaSA9IGFwcCA9PiBhcGkoYXBwKTtcblxuZXhwb3J0IGNvbnN0IGVycm9ycyA9IGNyZWF0ZU5vZGVFcnJvcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFRlbXBsYXRlQXBpO1xuIiwiaW1wb3J0IHtVU0VSU19MSVNUX0ZJTEUsIFxyXG4gICAgc3RyaXBVc2VyT2ZTZW5zaXRpdmVTdHVmZn0gZnJvbSBcIi4vYXV0aENvbW1vblwiO1xyXG5pbXBvcnQgeyQsIGFwaVdyYXBwZXIsIGV2ZW50c30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge21hcH0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5pbXBvcnQge3Blcm1pc3Npb259IGZyb20gXCIuL3Blcm1pc3Npb25zXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VXNlcnMgPSBhcHAgPT4gYXN5bmMgKCkgPT4gXHJcbiAgICBhcGlXcmFwcGVyKFxyXG4gICAgICAgIGFwcCxcclxuICAgICAgICBldmVudHMuYXV0aEFwaS5nZXRVc2VycywgXHJcbiAgICAgICAgcGVybWlzc2lvbi5saXN0VXNlcnMuaXNBdXRob3JpemVkLFxyXG4gICAgICAgIHt9LFxyXG4gICAgICAgIF9nZXRVc2VycywgYXBwKTtcclxuXHJcbmV4cG9ydCBjb25zdCBfZ2V0VXNlcnMgPSBhc3luYyBhcHAgPT4gXHJcbiAgICAkKGF3YWl0IGFwcC5kYXRhc3RvcmUubG9hZEpzb24oVVNFUlNfTElTVF9GSUxFKSwgW1xyXG4gICAgICAgIG1hcChzdHJpcFVzZXJPZlNlbnNpdGl2ZVN0dWZmKVxyXG4gICAgXSk7XHJcbiIsImltcG9ydCB7QUNDRVNTX0xFVkVMU19GSUxFfSBmcm9tIFwiLi9hdXRoQ29tbW9uXCI7XHJcbmltcG9ydCB7YXBpV3JhcHBlciwgZXZlbnRzfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7cGVybWlzc2lvbn0gZnJvbSBcIi4vcGVybWlzc2lvbnNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBsb2FkQWNjZXNzTGV2ZWxzID0gYXBwID0+IGFzeW5jICgpID0+IFxyXG4gICAgYXBpV3JhcHBlcihcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgZXZlbnRzLmF1dGhBcGkubG9hZEFjY2Vzc0xldmVscywgXHJcbiAgICAgICAgcGVybWlzc2lvbi5saXN0QWNjZXNzTGV2ZWxzLmlzQXV0aG9yaXplZCxcclxuICAgICAgICB7fSxcclxuICAgICAgICBfbG9hZEFjY2Vzc0xldmVscywgYXBwKTtcclxuXHJcbmV4cG9ydCBjb25zdCBfbG9hZEFjY2Vzc0xldmVscyA9IGFzeW5jIGFwcCAgPT4gXHJcbiAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLmxvYWRKc29uKEFDQ0VTU19MRVZFTFNfRklMRSk7IiwiaW1wb3J0IHtnZXRVc2Vyc30gZnJvbSBcIi4vZ2V0VXNlcnNcIjtcclxuaW1wb3J0IHtmaW5kLCBmaWx0ZXIsIHNvbWUsIFxyXG4gICAgICAgIG1hcCwgZmxhdHRlbn0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5pbXBvcnQge2dldFVzZXJCeU5hbWUsIHVzZXJBdXRoRmlsZSwgXHJcbiAgICBwYXJzZVRlbXBvcmFyeUNvZGV9IGZyb20gXCIuL2F1dGhDb21tb25cIjtcclxuaW1wb3J0IHtsb2FkQWNjZXNzTGV2ZWxzfSBmcm9tIFwiLi9sb2FkQWNjZXNzTGV2ZWxzXCI7XHJcbmltcG9ydCB7IGlzTm90aGluZ09yRW1wdHksICQsIGFwaVdyYXBwZXIsIGV2ZW50cyB9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHtnZW5lcmF0ZX0gZnJvbSBcInNob3J0aWRcIjtcclxuaW1wb3J0IHthbHdheXNBdXRob3JpemVkfSBmcm9tIFwiLi9wZXJtaXNzaW9uc1wiO1xyXG5cclxuY29uc3QgZHVtbXlIYXNoID0gXCIkYXJnb24yaSR2PTE5JG09NDA5Nix0PTMscD0xJFVaUm80MDlVWUJHakhKUzNDVjZVeHckclU4NHFVcVBlT1JGektZbVlZMGNlQkxEYVBPK0pXU0g0UGZOaUtYZklLa1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGF1dGhlbnRpY2F0ZSA9IGFwcCA9PiBhc3luYyAodXNlcm5hbWUsIHBhc3N3b3JkKSA9PiBcclxuICAgIGFwaVdyYXBwZXIoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGV2ZW50cy5hdXRoQXBpLmF1dGhlbnRpY2F0ZSwgXHJcbiAgICAgICAgYWx3YXlzQXV0aG9yaXplZCxcclxuICAgICAgICB7dXNlcm5hbWUsIHBhc3N3b3JkfSxcclxuICAgICAgICBfYXV0aGVudGljYXRlLCBhcHAsIHVzZXJuYW1lLCBwYXNzd29yZCk7XHJcblxyXG5leHBvcnQgY29uc3QgX2F1dGhlbnRpY2F0ZSA9IGFzeW5jIChhcHAsIHVzZXJuYW1lLCBwYXNzd29yZCkgPT4ge1xyXG5cclxuICAgIGlmKGlzTm90aGluZ09yRW1wdHkodXNlcm5hbWUpIHx8IGlzTm90aGluZ09yRW1wdHkocGFzc3dvcmQpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IGFsbFVzZXJzID0gYXdhaXQgZ2V0VXNlcnMoYXBwKSgpO1xyXG4gICAgbGV0IHVzZXIgPSBnZXRVc2VyQnlOYW1lKFxyXG4gICAgICAgICAgICAgICAgICAgIGFsbFVzZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgXHJcbiAgICBjb25zdCBub3RBVXNlciA9IFwibm90LWEtdXNlclwiO1xyXG4gICAgLy8gY29udGludWUgd2l0aCBub24tdXNlciAtIHNvIHRpbWUgdG8gdmVyaWZ5IHJlbWFpbnMgY29uc2lzdGVudFxyXG4gICAgLy8gd2l0aCB2ZXJpZmljYXRpb24gb2YgYSB2YWxpZCB1c2VyXHJcbiAgICBpZighdXNlciB8fCAhdXNlci5lbmFibGVkKSBcclxuICAgICAgICB1c2VyID0gbm90QVVzZXI7IFxyXG5cclxuICAgIGxldCB1c2VyQXV0aDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdXNlckF1dGggPSBhd2FpdCBhcHAuZGF0YXN0b3JlLmxvYWRKc29uKFxyXG4gICAgICAgICAgICB1c2VyQXV0aEZpbGUodXNlcm5hbWUpXHJcbiAgICAgICAgKTtcclxuICAgIH0gY2F0Y2goXykge1xyXG4gICAgICAgIHVzZXJBdXRoID0ge2FjY2Vzc0xldmVsczpbXSwgcGFzc3dvcmRIYXNoOmR1bW15SGFzaH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGVybWlzc2lvbnMgPSBhd2FpdCBidWlsZFVzZXJQZXJtaXNzaW9ucyhhcHAsIHVzZXIuYWNjZXNzTGV2ZWxzKTtcclxuXHJcbiAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGFwcC5jcnlwdG8udmVyaWZ5KFxyXG4gICAgICAgIHVzZXJBdXRoLnBhc3N3b3JkSGFzaCwgXHJcbiAgICAgICAgcGFzc3dvcmQpO1xyXG5cclxuICAgIGlmKHVzZXIgPT09IG5vdEFVc2VyKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIHJldHVybiB2ZXJpZmllZFxyXG4gICAgICAgICAgID8gey4uLnVzZXIsIHBlcm1pc3Npb25zLCB0ZW1wOmZhbHNlLCBpc1VzZXI6dHJ1ZX1cclxuICAgICAgICAgICA6IG51bGw7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXV0aGVudGljYXRlVGVtcG9yYXJ5QWNjZXNzID0gYXBwID0+IGFzeW5jICh0ZW1wQWNjZXNzQ29kZSkgPT4ge1xyXG5cclxuICAgIGlmKGlzTm90aGluZ09yRW1wdHkodGVtcEFjY2Vzc0NvZGUpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGNvbnN0IHRlbXAgPSBwYXJzZVRlbXBvcmFyeUNvZGUodGVtcEFjY2Vzc0NvZGUpO1xyXG4gICAgbGV0IHVzZXIgPSAkKGF3YWl0IGdldFVzZXJzKGFwcCkoKSxbXHJcbiAgICAgICAgZmluZCh1ID0+IHUudGVtcG9yYXJ5QWNjZXNzSWQgPT09IHRlbXAuaWQpXHJcbiAgICBdKTtcclxuXHJcbiAgICBjb25zdCBub3RBVXNlciA9IFwibm90LWEtdXNlclwiO1xyXG4gICAgaWYoIXVzZXIgfHwgIXVzZXIuZW5hYmxlZCkgXHJcbiAgICAgICAgdXNlciA9IG5vdEFVc2VyO1xyXG5cclxuICAgIGxldCB1c2VyQXV0aDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdXNlckF1dGggPSBhd2FpdCBhcHAuZGF0YXN0b3JlLmxvYWRKc29uKFxyXG4gICAgICAgICAgICB1c2VyQXV0aEZpbGUodXNlci5uYW1lKVxyXG4gICAgICAgICk7XHJcbiAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICB1c2VyQXV0aCA9IHtcclxuICAgICAgICAgICAgdGVtcG9yYXJ5QWNjZXNzSGFzaDpkdW1teUhhc2gsXHJcbiAgICAgICAgICAgIHRlbXBvcmFyeUFjY2Vzc0V4cGlyeUVwb2NoOihhd2FpdCBhcHAuZ2V0RXBvY2hUaW1lKCkgKyAxMDAwMClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHVzZXJBdXRoLnRlbXBvcmFyeUFjY2Vzc0V4cGlyeUVwb2NoIDwgYXdhaXQgYXBwLmdldEVwb2NoVGltZSgpKSBcclxuICAgICAgICB1c2VyID0gbm90QVVzZXI7XHJcblxyXG4gICAgY29uc3QgdGVtcENvZGUgPSAhdGVtcC5jb2RlID8gZ2VuZXJhdGUoKSA6IHRlbXAuY29kZTtcclxuICAgIGNvbnN0IHZlcmlmaWVkID0gIGF3YWl0IGFwcC5jcnlwdG8udmVyaWZ5KFxyXG4gICAgICAgIHVzZXJBdXRoLnRlbXBvcmFyeUFjY2Vzc0hhc2gsIFxyXG4gICAgICAgIHRlbXBDb2RlKTsgXHJcblxyXG4gICAgaWYodXNlciA9PT0gbm90QVVzZXIpIFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICByZXR1cm4gdmVyaWZpZWRcclxuICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgLi4udXNlciwgXHJcbiAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiBbXSwgXHJcbiAgICAgICAgICAgICAgIHRlbXA6dHJ1ZSxcclxuICAgICAgICAgICAgICAgaXNVc2VyOnRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIDogbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGJ1aWxkVXNlclBlcm1pc3Npb25zID0gYXN5bmMgKGFwcCwgdXNlckFjY2Vzc0xldmVscykgPT4ge1xyXG4gICAgY29uc3QgYWxsQWNjZXNzTGV2ZWxzID0gYXdhaXQgbG9hZEFjY2Vzc0xldmVscyhhcHApKCk7XHJcblxyXG4gICAgcmV0dXJuICQoYWxsQWNjZXNzTGV2ZWxzLmxldmVscywgW1xyXG4gICAgICAgIGZpbHRlcihsID0+IHNvbWUodWEgPT4gbC5uYW1lID09PSB1YSkodXNlckFjY2Vzc0xldmVscykpLFxyXG4gICAgICAgIG1hcChsID0+IGwucGVybWlzc2lvbnMpLFxyXG4gICAgICAgIGZsYXR0ZW5cclxuICAgIF0pO1xyXG59OyIsImltcG9ydCB7dGVtcENvZGVFeHBpcnlMZW5ndGgsIFVTRVJTX0xPQ0tfRklMRSxcclxuICAgIFVTRVJTX0xJU1RfRklMRSwgdXNlckF1dGhGaWxlLCBcclxuICAgIGdldFVzZXJCeU5hbWV9IGZyb20gXCIuL2F1dGhDb21tb25cIjtcclxuaW1wb3J0IHtnZW5lcmF0ZX0gZnJvbSBcInNob3J0aWRcIjtcclxuaW1wb3J0IHtnZXRMb2NrLCBpc05vbG9jaywgXHJcbiAgICByZWxlYXNlTG9ja30gZnJvbSBcIi4uL2NvbW1vbi9sb2NrXCI7XHJcbmltcG9ydCB7c3BsaXR9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHthcGlXcmFwcGVyLCBldmVudHN9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHthbHdheXNBdXRob3JpemVkfSBmcm9tIFwiLi4vYXV0aEFwaS9wZXJtaXNzaW9uc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRlbXBvcmFyeUFjY2VzcyA9IGFwcCA9PiBhc3luYyAodXNlck5hbWUpID0+IFxyXG4gICAgYXBpV3JhcHBlcihcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgZXZlbnRzLmF1dGhBcGkuY3JlYXRlVGVtcG9yYXJ5QWNjZXNzLCBcclxuICAgICAgICBhbHdheXNBdXRob3JpemVkLFxyXG4gICAgICAgIHt1c2VyTmFtZX0sXHJcbiAgICAgICAgX2NyZWF0ZVRlbXBvcmFyeUFjY2VzcywgYXBwLCB1c2VyTmFtZSk7XHJcblxyXG5leHBvcnQgY29uc3QgX2NyZWF0ZVRlbXBvcmFyeUFjY2VzcyA9IGFzeW5jIChhcHAsIHVzZXJOYW1lKSA9PiAge1xyXG5cclxuICAgIGNvbnN0IHRlbXBDb2RlID0gYXdhaXQgZ2V0VGVtcG9yYXJ5Q29kZShhcHApO1xyXG5cclxuICAgIGNvbnN0IGxvY2sgPSBhd2FpdCBnZXRMb2NrKFxyXG4gICAgICAgIGFwcCwgVVNFUlNfTE9DS19GSUxFLCAxMDAwLCAyXHJcbiAgICApO1xyXG5cclxuICAgIGlmKGlzTm9sb2NrKGxvY2spKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgdGVtcG9yYXJ5IGFjY2VzcywgY291bGQgbm90IGdldCBsb2NrIC0gdHJ5IGFnYWluXCIpO1xyXG4gICAgICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1c2VycyA9IGF3YWl0IGFwcC5kYXRhc3RvcmUubG9hZEpzb24oVVNFUlNfTElTVF9GSUxFKTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlciA9IGdldFVzZXJCeU5hbWUodXNlcnMsIHVzZXJOYW1lKTtcclxuICAgICAgICB1c2VyLnRlbXBvcmFyeUFjY2Vzc0lkID0gdGVtcENvZGUudGVtcG9yYXJ5QWNjZXNzSWQ7ICAgIFxyXG5cclxuICAgICAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLnVwZGF0ZUpzb24oXHJcbiAgICAgICAgICAgIFVTRVJTX0xJU1RfRklMRSwgXHJcbiAgICAgICAgICAgIHVzZXJzXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIGF3YWl0IHJlbGVhc2VMb2NrKGFwcCwgbG9jayk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHVzZXJBdXRoID0gYXdhaXQgYXBwLmRhdGFzdG9yZS5sb2FkSnNvbihcclxuICAgICAgICB1c2VyQXV0aEZpbGUodXNlck5hbWUpXHJcbiAgICApO1xyXG4gICAgdXNlckF1dGgudGVtcG9yYXJ5QWNjZXNzSGFzaCA9IFxyXG4gICAgICAgIHRlbXBDb2RlLnRlbXBvcmFyeUFjY2Vzc0hhc2g7XHJcblxyXG4gICAgdXNlckF1dGgudGVtcG9yYXJ5QWNjZXNzRXhwaXJ5RXBvY2ggPSBcclxuICAgICAgICB0ZW1wQ29kZS50ZW1wb3JhcnlBY2Nlc3NFeHBpcnlFcG9jaDsgXHJcblxyXG4gICAgYXdhaXQgYXBwLmRhdGFzdG9yZS51cGRhdGVKc29uKFxyXG4gICAgICAgIHVzZXJBdXRoRmlsZSh1c2VyTmFtZSksXHJcbiAgICAgICAgdXNlckF1dGhcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHRlbXBDb2RlLnRlbXBDb2RlO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0VGVtcG9yYXJ5Q29kZSA9IGFzeW5jIGFwcCA9PiB7XHJcbiAgICBjb25zdCB0ZW1wQ29kZSA9IFxyXG4gICAgICAgIGdlbmVyYXRlKCkgKyBcclxuICAgICAgICBnZW5lcmF0ZSgpICsgXHJcbiAgICAgICAgZ2VuZXJhdGUoKSArIFxyXG4gICAgICAgIGdlbmVyYXRlKCk7XHJcblxyXG4gICAgY29uc3QgdGVtcElkID0gZ2VuZXJhdGUoKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRlbXBvcmFyeUFjY2Vzc0hhc2g6IGF3YWl0IGFwcC5jcnlwdG8uaGFzaChcclxuICAgICAgICAgICAgdGVtcENvZGUsXHJcbiAgICAgICAgKSxcclxuICAgICAgICB0ZW1wb3JhcnlBY2Nlc3NFeHBpcnlFcG9jaDogXHJcbiAgICAgICAgICAgIChhd2FpdCBhcHAuZ2V0RXBvY2hUaW1lKCkpICsgdGVtcENvZGVFeHBpcnlMZW5ndGgsXHJcbiAgICAgICAgdGVtcENvZGU6IGB0bXA6JHt0ZW1wSWR9OiR7dGVtcENvZGV9YCxcclxuICAgICAgICB0ZW1wb3JhcnlBY2Nlc3NJZDogdGVtcElkXHJcbiAgICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvb2tzTGlrZVRlbXBvcmFyeUNvZGUgPSBjb2RlID0+XHJcbiAgICBjb2RlLnN0YXJ0c1dpdGgoXCJ0bXA6XCIpO1xyXG4iLCJpbXBvcnQge2FwcGx5UnVsZVNldCwgbWFrZXJ1bGV9IGZyb20gXCIuLi9jb21tb24vdmFsaWRhdGlvbkNvbW1vblwiO1xyXG5pbXBvcnQge21hcCwgdW5pcVdpdGgsXHJcbiAgICBmbGF0dGVuLCBmaWx0ZXJ9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHskLCBpbnNlbnNpdGl2ZUVxdWFscywgYXBpV3JhcHBlciwgZXZlbnRzLFxyXG4gICAgaXNOb25FbXB0eVN0cmluZywgYWxsfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7YWx3YXlzQXV0aG9yaXplZH0gZnJvbSBcIi4vcGVybWlzc2lvbnNcIjtcclxuXHJcbmNvbnN0IHVzZXJSdWxlcyA9IGFsbFVzZXJzID0+IFtcclxuICAgIG1ha2VydWxlKFwibmFtZVwiLCBcInVzZXJuYW1lIG11c3QgYmUgc2V0XCIsXHJcbiAgICAgICAgdSA9PiBpc05vbkVtcHR5U3RyaW5nKHUubmFtZSkpLFxyXG4gICAgbWFrZXJ1bGUoXCJhY2Nlc3NMZXZlbHNcIiwgXCJ1c2VyIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYWNjZXNzIGxldmVsXCIsXHJcbiAgICAgICAgdSA9PiB1LmFjY2Vzc0xldmVscy5sZW5ndGggPiAwKSxcclxuICAgIG1ha2VydWxlKFwibmFtZVwiLCBcInVzZXJuYW1lIG11c3QgYmUgdW5pcXVlXCIsXHJcbiAgICAgICAgdSA9PiBmaWx0ZXIodTIgPT4gaW5zZW5zaXRpdmVFcXVhbHModTIubmFtZSx1Lm5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgKGFsbFVzZXJzKS5sZW5ndGggPT09IDEpLFxyXG4gICAgbWFrZXJ1bGUoXCJhY2Nlc3NMZXZlbHNcIiwgXCJhY2Nlc3MgbGV2ZWxzIG11c3Qgb25seSBjb250YWluIHN0aW5nc1wiLFxyXG4gICAgICAgIHUgPT4gYWxsKGlzTm9uRW1wdHlTdHJpbmcpKHUuYWNjZXNzTGV2ZWxzKSlcclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVVzZXIgPSAoKSA9PiAoYWxsdXNlcnMsIHVzZXIpID0+IFxyXG4gICAgYXBwbHlSdWxlU2V0KHVzZXJSdWxlcyhhbGx1c2VycykpKHVzZXIpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlVXNlcnMgPSBhcHAgPT4gKGFsbFVzZXJzKSA9PiBcclxuICAgIGFwaVdyYXBwZXIoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGV2ZW50cy5hdXRoQXBpLnZhbGlkYXRlVXNlcnMsIFxyXG4gICAgICAgIGFsd2F5c0F1dGhvcml6ZWQsXHJcbiAgICAgICAge2FsbFVzZXJzfSxcclxuICAgICAgICBfdmFsaWRhdGVVc2VycywgYXBwLCBhbGxVc2Vycyk7XHJcblxyXG5leHBvcnQgY29uc3QgX3ZhbGlkYXRlVXNlcnMgPSAoYXBwLCBhbGxVc2VycykgPT4gXHJcbiAgICAkKGFsbFVzZXJzLCBbXHJcbiAgICAgICAgbWFwKGwgPT4gdmFsaWRhdGVVc2VyKGFwcCkoYWxsVXNlcnMsIGwpKSxcclxuICAgICAgICBmbGF0dGVuLFxyXG4gICAgICAgIHVuaXFXaXRoKCh4LHkpID0+IHguZmllbGQgPT09IHkuZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgeC5pdGVtID09PSB5Lml0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgeC5lcnJvciA9PT0geS5lcnJvcilcclxuICAgIF0pO1xyXG4iLCJpbXBvcnQge2FwaVdyYXBwZXJTeW5jLCBldmVudHN9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHtwZXJtaXNzaW9ufSBmcm9tIFwiLi9wZXJtaXNzaW9uc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldE5ld1VzZXIgPSBhcHAgPT4gKCkgPT4gXHJcbiAgICBhcGlXcmFwcGVyU3luYyhcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgZXZlbnRzLmF1dGhBcGkuZ2V0TmV3VXNlciwgXHJcbiAgICAgICAgcGVybWlzc2lvbi5jcmVhdGVVc2VyLmlzQXV0aG9yaXplZCxcclxuICAgICAgICB7fSxcclxuICAgICAgICBfZ2V0TmV3VXNlciwgYXBwKTtcclxuXHJcbmV4cG9ydCBjb25zdCBfZ2V0TmV3VXNlciA9IGFwcCA9PiAoe1xyXG4gICAgbmFtZTogXCJcIixcclxuICAgIGFjY2Vzc0xldmVsczogW10sXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgdGVtcG9yYXJ5QWNjZXNzSWQ6IFwiXCJcclxufSk7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0TmV3VXNlckF1dGggPSBhcHAgPT4gKCkgPT4gXHJcbiAgICBhcGlXcmFwcGVyU3luYyhcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgZXZlbnRzLmF1dGhBcGkuZ2V0TmV3VXNlckF1dGgsIFxyXG4gICAgICAgIHBlcm1pc3Npb24uY3JlYXRlVXNlci5pc0F1dGhvcml6ZWQsXHJcbiAgICAgICAge30sXHJcbiAgICAgICAgX2dldE5ld1VzZXJBdXRoLCBhcHApO1xyXG5cclxuZXhwb3J0IGNvbnN0IF9nZXROZXdVc2VyQXV0aCA9IGFwcCA9PiAoe1xyXG4gICAgcGFzc3dvcmRIYXNoOiBcIlwiLFxyXG4gICAgdGVtcG9yYXJ5QWNjZXNzSGFzaDogXCJcIixcclxuICAgIHRlbXBvcmFyeUFjY2Vzc0V4cGlyeUVwb2NoOiAwXHJcbn0pOyIsImltcG9ydCB7dXNlckF1dGhGaWxlLCBwYXJzZVRlbXBvcmFyeUNvZGV9IGZyb20gXCIuL2F1dGhDb21tb25cIjtcclxuaW1wb3J0IHtpc1NvbWV0aGluZywgJCwgYXBpV3JhcHBlciwgYXBpV3JhcHBlclN5bmMsIGV2ZW50c30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge2dldFVzZXJzfSBmcm9tIFwiLi9nZXRVc2Vyc1wiO1xyXG5pbXBvcnQge2ZpbmR9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHthbHdheXNBdXRob3JpemVkfSBmcm9tIFwiLi9wZXJtaXNzaW9uc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzVmFsaWRQYXNzd29yZCA9IGFwcCA9PiAocGFzc3dvcmQpID0+IFxyXG4gICAgYXBpV3JhcHBlclN5bmMoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGV2ZW50cy5hdXRoQXBpLmlzVmFsaWRQYXNzd29yZCwgXHJcbiAgICAgICAgYWx3YXlzQXV0aG9yaXplZCxcclxuICAgICAgICB7cGFzc3dvcmR9LFxyXG4gICAgICAgIF9pc1ZhbGlkUGFzc3dvcmQsIGFwcCwgcGFzc3dvcmQpO1xyXG5cclxuZXhwb3J0IGNvbnN0IF9pc1ZhbGlkUGFzc3dvcmQgPSAoYXBwLCBwYXNzd29yZCkgPT4ge1xyXG4gICAgcmV0dXJuIHNjb3JlUGFzc3dvcmQocGFzc3dvcmQpLnNjb3JlID4gMzA7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY2hhbmdlTXlQYXNzd29yZCA9IGFwcCA9PiBhc3luYyAoY3VycmVudFB3LCBuZXdwYXNzd29yZCkgPT4gXHJcbiAgICBhcGlXcmFwcGVyKFxyXG4gICAgICAgIGFwcCxcclxuICAgICAgICBldmVudHMuYXV0aEFwaS5jaGFuZ2VNeVBhc3N3b3JkLCBcclxuICAgICAgICBhbHdheXNBdXRob3JpemVkLFxyXG4gICAgICAgIHtjdXJyZW50UHcsIG5ld3Bhc3N3b3JkfSxcclxuICAgICAgICBfY2hhbmdlTXlQYXNzd29yZCwgYXBwLCBjdXJyZW50UHcsIG5ld3Bhc3N3b3JkKTtcclxuXHJcbmV4cG9ydCBjb25zdCBfY2hhbmdlTXlQYXNzd29yZCA9IGFzeW5jIChhcHAsIGN1cnJlbnRQdywgbmV3cGFzc3dvcmQpID0+IHtcclxuICAgIGNvbnN0IGV4aXN0aW5nQXV0aCA9IGF3YWl0IGFwcC5kYXRhc3RvcmUubG9hZEpzb24oXHJcbiAgICAgICAgdXNlckF1dGhGaWxlKGFwcC51c2VyLm5hbWUpXHJcbiAgICApO1xyXG5cclxuICAgIGlmKGlzU29tZXRoaW5nKGV4aXN0aW5nQXV0aC5wYXNzd29yZEhhc2gpKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBhcHAuY3J5cHRvLnZlcmlmeShcclxuICAgICAgICAgICAgZXhpc3RpbmdBdXRoLnBhc3N3b3JkSGFzaCwgXHJcbiAgICAgICAgICAgIGN1cnJlbnRQdyk7XHJcblxyXG4gICAgICAgIGlmKHZlcmlmaWVkKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGF3YWl0IGRvU2V0KFxyXG4gICAgICAgICAgICAgICAgYXBwLCBleGlzdGluZ0F1dGgsIFxyXG4gICAgICAgICAgICAgICAgYXBwLnVzZXIubmFtZSwgbmV3cGFzc3dvcmQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHNldFBhc3N3b3JkRnJvbVRlbXBvcmFyeUNvZGUgPSBhcHAgPT4gYXN5bmMgKHRlbXBDb2RlLCBuZXdwYXNzd29yZCkgPT4gXHJcbiAgICBhcGlXcmFwcGVyKFxyXG4gICAgICAgIGFwcCxcclxuICAgICAgICBldmVudHMuYXV0aEFwaS5zZXRQYXNzd29yZEZyb21UZW1wb3JhcnlDb2RlLFxyXG4gICAgICAgIGFsd2F5c0F1dGhvcml6ZWQsIFxyXG4gICAgICAgIHt0ZW1wQ29kZSwgbmV3cGFzc3dvcmR9LFxyXG4gICAgICAgIF9zZXRQYXNzd29yZEZyb21UZW1wb3JhcnlDb2RlLCBhcHAsIHRlbXBDb2RlLCBuZXdwYXNzd29yZCk7XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IF9zZXRQYXNzd29yZEZyb21UZW1wb3JhcnlDb2RlID0gYXN5bmMgKGFwcCwgdGVtcENvZGUsIG5ld3Bhc3N3b3JkKSA9PiB7XHJcblxyXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBhd2FpdCBhcHAuZ2V0RXBvY2hUaW1lKCk7XHJcblxyXG4gICAgY29uc3QgdGVtcCA9IHBhcnNlVGVtcG9yYXJ5Q29kZSh0ZW1wQ29kZSk7XHJcblxyXG4gICAgY29uc3QgdXNlciA9ICQoYXdhaXQgZ2V0VXNlcnMoYXBwKSgpLCBbXHJcbiAgICAgICAgZmluZCh1ID0+IHUudGVtcG9yYXJ5QWNjZXNzSWQgPT09IHRlbXAuaWQpXHJcbiAgICBdKTtcclxuXHJcbiAgICBpZighdXNlcilcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgZXhpc3RpbmdBdXRoID0gYXdhaXQgYXBwLmRhdGFzdG9yZS5sb2FkSnNvbihcclxuICAgICAgICB1c2VyQXV0aEZpbGUodXNlci5uYW1lKVxyXG4gICAgKTtcclxuXHJcbiAgICBpZihpc1NvbWV0aGluZyhleGlzdGluZ0F1dGgudGVtcG9yYXJ5QWNjZXNzSGFzaClcclxuICAgICAgICYmIGV4aXN0aW5nQXV0aC50ZW1wb3JhcnlBY2Nlc3NFeHBpcnlFcG9jaCA+IGN1cnJlbnRUaW1lKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcmlmaWVkID0gYXdhaXQgYXBwLmNyeXB0by52ZXJpZnkoXHJcbiAgICAgICAgICAgIGV4aXN0aW5nQXV0aC50ZW1wb3JhcnlBY2Nlc3NIYXNoLCBcclxuICAgICAgICAgICAgdGVtcC5jb2RlKTtcclxuXHJcbiAgICAgICAgaWYodmVyaWZpZWQpIHtcclxuICAgICAgICAgICAgYXdhaXQgZG9TZXQoXHJcbiAgICAgICAgICAgICAgICBhcHAsIGV4aXN0aW5nQXV0aCwgXHJcbiAgICAgICAgICAgICAgICB1c2VyLm5hbWUsIG5ld3Bhc3N3b3JkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5jb25zdCBkb1NldCA9IGFzeW5jIChhcHAsIGF1dGgsIHVzZXJuYW1lLCBuZXdwYXNzd29yZCkgPT4ge1xyXG4gICAgYXV0aC50ZW1wb3JhcnlBY2Nlc3NIYXNoID0gXCJcIjtcclxuICAgIGF1dGgudGVtcG9yYXJ5QWNjZXNzRXhwaXJ5RXBvY2ggPSAwO1xyXG4gICAgYXV0aC5wYXNzd29yZEhhc2ggPSBhd2FpdCBhcHAuY3J5cHRvLmhhc2goXHJcbiAgICAgICAgbmV3cGFzc3dvcmRcclxuICAgICk7XHJcbiAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLnVwZGF0ZUpzb24oXHJcbiAgICAgICAgdXNlckF1dGhGaWxlKHVzZXJuYW1lKSxcclxuICAgICAgICBhdXRoXHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNjb3JlUGFzc3dvcmQgPSAgKHBhc3N3b3JkKSA9PiBcclxuICAgIGFwaVdyYXBwZXJTeW5jKFxyXG4gICAgICAgIGFwcCxcclxuICAgICAgICBldmVudHMuYXV0aEFwaS5zY29yZVBhc3N3b3JkLCBcclxuICAgICAgICBhbHdheXNBdXRob3JpemVkLFxyXG4gICAgICAgIHtwYXNzd29yZH0sXHJcbiAgICAgICAgX3Njb3JlUGFzc3dvcmQsIHBhc3N3b3JkKTtcclxuXHJcbmV4cG9ydCBjb25zdCBfc2NvcmVQYXNzd29yZCA9IChwYXNzd29yZCkgPT4ge1xyXG5cclxuICAgIC8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ4MTcyL3Bhc3N3b3JkLXN0cmVuZ3RoLW1ldGVyXHJcbiAgICAvLyB0aGFuayB5b3UgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy80NjYxNy90bS1sdlxyXG5cclxuICAgIGxldCBzY29yZSA9IDA7XHJcbiAgICBpZiAoIXBhc3N3b3JkKVxyXG4gICAgICAgIHJldHVybiBzY29yZTtcclxuXHJcbiAgICAvLyBhd2FyZCBldmVyeSB1bmlxdWUgbGV0dGVyIHVudGlsIDUgcmVwZXRpdGlvbnNcclxuICAgIGxldCBsZXR0ZXJzID0gbmV3IE9iamVjdCgpO1xyXG4gICAgZm9yIChsZXQgaT0wOyBpPHBhc3N3b3JkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0dGVyc1twYXNzd29yZFtpXV0gPSAobGV0dGVyc1twYXNzd29yZFtpXV0gfHwgMCkgKyAxO1xyXG4gICAgICAgIHNjb3JlICs9IDUuMCAvIGxldHRlcnNbcGFzc3dvcmRbaV1dO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGJvbnVzIHBvaW50cyBmb3IgbWl4aW5nIGl0IHVwXHJcbiAgICBjb25zdCB2YXJpYXRpb25zID0ge1xyXG4gICAgICAgIGRpZ2l0czogL1xcZC8udGVzdChwYXNzd29yZCksXHJcbiAgICAgICAgbG93ZXI6IC9bYS16XS8udGVzdChwYXNzd29yZCksXHJcbiAgICAgICAgdXBwZXI6IC9bQS1aXS8udGVzdChwYXNzd29yZCksXHJcbiAgICAgICAgbm9uV29yZHM6IC9cXFcvLnRlc3QocGFzc3dvcmQpLFxyXG4gICAgfVxyXG5cclxuICAgIGxldCB2YXJpYXRpb25Db3VudCA9IDA7XHJcbiAgICBmb3IgKGxldCBjaGVjayBpbiB2YXJpYXRpb25zKSB7XHJcbiAgICAgICAgdmFyaWF0aW9uQ291bnQgKz0gKHZhcmlhdGlvbnNbY2hlY2tdID09IHRydWUpID8gMSA6IDA7XHJcbiAgICB9XHJcbiAgICBzY29yZSArPSAodmFyaWF0aW9uQ291bnQgLSAxKSAqIDEwO1xyXG5cclxuICAgIGNvbnN0IHN0cmVuZ3RoVGV4dCA9XHJcbiAgICAgICAgc2NvcmUgPiA4MCBcclxuICAgICAgICA/IFwic3Ryb25nXCJcclxuICAgICAgICA6IHNjb3JlID4gNjBcclxuICAgICAgICA/IFwiZ29vZFwiXHJcbiAgICAgICAgOiBzY29yZSA+PSAzMFxyXG4gICAgICAgID8gXCJ3ZWFrXCJcclxuICAgICAgICA6IFwidmVyeSB3ZWFrXCI7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzY29yZTogcGFyc2VJbnQoc2NvcmUpLCBcclxuICAgICAgICBzdHJlbmd0aFRleHRcclxuICAgIH07XHJcbn1cclxuXHJcbiIsImltcG9ydCB7dmFsaWRhdGVVc2VyfSBmcm9tIFwiLi92YWxpZGF0ZVVzZXJcIjtcclxuaW1wb3J0IHtnZXROZXdVc2VyQXV0aH0gZnJvbSBcIi4vZ2V0TmV3VXNlclwiO1xyXG5pbXBvcnQge2pvaW4sIHNvbWUsIGNsb25lfSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcbmltcG9ydCB7Z2V0TG9jaywgaXNOb2xvY2ssIHJlbGVhc2VMb2NrLCBhcGlXcmFwcGVyLCBldmVudHMsXHJcbiAgICBpbnNlbnNpdGl2ZUVxdWFscywgaXNOb25FbXB0eVN0cmluZ30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge1VTRVJTX0xPQ0tfRklMRSwgc3RyaXBVc2VyT2ZTZW5zaXRpdmVTdHVmZixcclxuICAgIFVTRVJTX0xJU1RfRklMRSwgdXNlckF1dGhGaWxlfSBmcm9tIFwiLi9hdXRoQ29tbW9uXCI7XHJcbmltcG9ydCB7Z2V0VGVtcG9yYXJ5Q29kZX0gZnJvbSBcIi4vY3JlYXRlVGVtcG9yYXJ5QWNjZXNzXCI7XHJcbmltcG9ydCB7aXNWYWxpZFBhc3N3b3JkfSBmcm9tIFwiLi9zZXRQYXNzd29yZFwiO1xyXG5pbXBvcnQge3Blcm1pc3Npb259IGZyb20gXCIuL3Blcm1pc3Npb25zXCI7XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlVXNlciA9IGFwcCA9PiBhc3luYyAodXNlciwgcGFzc3dvcmQ9bnVsbCkgPT4gXHJcbiAgICBhcGlXcmFwcGVyKFxyXG4gICAgICAgIGFwcCxcclxuICAgICAgICBldmVudHMuYXV0aEFwaS5jcmVhdGVVc2VyLCBcclxuICAgICAgICBwZXJtaXNzaW9uLmNyZWF0ZVVzZXIuaXNBdXRob3JpemVkLFxyXG4gICAgICAgIHt1c2VyLCBwYXNzd29yZH0sXHJcbiAgICAgICAgX2NyZWF0ZVVzZXIsIGFwcCwgdXNlciwgcGFzc3dvcmQpO1xyXG5cclxuZXhwb3J0IGNvbnN0IF9jcmVhdGVVc2VyID0gYXN5bmMgKGFwcCwgdXNlciwgcGFzc3dvcmQ9bnVsbCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IGxvY2sgPSBhd2FpdCBnZXRMb2NrKFxyXG4gICAgICAgIGFwcCwgVVNFUlNfTE9DS19GSUxFLCAxMDAwLCAyXHJcbiAgICApO1xyXG5cclxuICAgIGlmKGlzTm9sb2NrKGxvY2spKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgdXNlciwgY291bGQgbm90IGdldCBsb2NrIC0gdHJ5IGFnYWluXCIpO1xyXG4gICAgICAgIFxyXG4gICAgY29uc3QgdXNlcnMgPSBhd2FpdCBhcHAuZGF0YXN0b3JlLmxvYWRKc29uKFVTRVJTX0xJU1RfRklMRSk7XHJcblxyXG4gICAgY29uc3QgdXNlckVycm9ycyA9IHZhbGlkYXRlVXNlcihhcHApKFsuLi51c2Vycyx1c2VyXSwgdXNlcik7XHJcbiAgICBpZih1c2VyRXJyb3JzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBpcyBpbnZhbGlkLiBcIiArIGpvaW4oXCI7IFwiKSh1c2VyRXJyb3JzKSk7XHJcblxyXG4gICAgY29uc3Qge2F1dGgsIHRlbXBDb2RlLCB0ZW1wb3JhcnlBY2Nlc3NJZH0gPSBhd2FpdCBnZXRBY2Nlc3MoXHJcbiAgICAgICAgYXBwLCBwYXNzd29yZCk7XHJcbiAgICB1c2VyLnRlbXBDb2RlID0gdGVtcENvZGU7XHJcbiAgICB1c2VyLnRlbXBvcmFyeUFjY2Vzc0lkID0gdGVtcG9yYXJ5QWNjZXNzSWQ7XHJcbiAgICBcclxuICAgIGlmKHNvbWUodSA9PiBpbnNlbnNpdGl2ZUVxdWFscyh1Lm5hbWUsIHVzZXIubmFtZSkpKHVzZXJzKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIGFscmVhZHkgZXhpc3RzXCIpO1xyXG5cclxuICAgIHVzZXJzLnB1c2goXHJcbiAgICAgICAgc3RyaXBVc2VyT2ZTZW5zaXRpdmVTdHVmZih1c2VyKVxyXG4gICAgKTtcclxuXHJcbiAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLnVwZGF0ZUpzb24oXHJcbiAgICAgICAgVVNFUlNfTElTVF9GSUxFLCBcclxuICAgICAgICB1c2Vyc1xyXG4gICAgKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLmNyZWF0ZUpzb24oXHJcbiAgICAgICAgICAgIHVzZXJBdXRoRmlsZSh1c2VyLm5hbWUpLFxyXG4gICAgICAgICAgICBhdXRoXHJcbiAgICAgICAgKTtcclxuICAgIH0gY2F0Y2goXykge1xyXG4gICAgICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUudXBkYXRlSnNvbihcclxuICAgICAgICAgICAgdXNlckF1dGhGaWxlKHVzZXIubmFtZSksXHJcbiAgICAgICAgICAgIGF1dGhcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGF3YWl0IHJlbGVhc2VMb2NrKGFwcCwgbG9jayk7XHJcblxyXG4gICAgcmV0dXJuIHVzZXI7XHJcbn07XHJcblxyXG5jb25zdCBnZXRBY2Nlc3MgPSBhc3luYyAoYXBwLCBwYXNzd29yZCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IGF1dGggPSBnZXROZXdVc2VyQXV0aChhcHApKCk7XHJcblxyXG4gICAgaWYoaXNOb25FbXB0eVN0cmluZyhwYXNzd29yZCkpIHtcclxuICAgICAgICBpZihpc1ZhbGlkUGFzc3dvcmQocGFzc3dvcmQpKSB7XHJcbiAgICAgICAgICAgIGF1dGgucGFzc3dvcmRIYXNoID0gYXdhaXQgYXBwLmNyeXB0by5oYXNoKHBhc3N3b3JkKTtcclxuICAgICAgICAgICAgYXV0aC50ZW1wb3JhcnlBY2Nlc3NIYXNoID0gXCJcIjtcclxuICAgICAgICAgICAgYXV0aC50ZW1wb3JhcnlBY2Nlc3NJZCA9IFwiXCI7XHJcbiAgICAgICAgICAgIGF1dGgudGVtcG9yYXJ5QWNjZXNzRXhwaXJ5RXBvY2ggPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4ge2F1dGh9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhc3N3b3JkIGRvZXMgbm90IG1lZXQgcmVxdWlyZW1lbnRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgdGVtcEFjY2VzcyA9IGF3YWl0IGdldFRlbXBvcmFyeUNvZGUoYXBwKTtcclxuICAgICAgICBhdXRoLnRlbXBvcmFyeUFjY2Vzc0hhc2ggPSB0ZW1wQWNjZXNzLnRlbXBvcmFyeUFjY2Vzc0hhc2g7XHJcbiAgICAgICAgYXV0aC50ZW1wb3JhcnlBY2Nlc3NFeHBpcnlFcG9jaCA9IHRlbXBBY2Nlc3MudGVtcG9yYXJ5QWNjZXNzRXhwaXJ5RXBvY2g7XHJcbiAgICAgICAgYXV0aC5wYXNzd29yZEhhc2ggPSBcIlwiO1xyXG4gICAgICAgIHJldHVybiAoe1xyXG4gICAgICAgICAgICBhdXRoLCBcclxuICAgICAgICAgICAgdGVtcENvZGU6IHRlbXBBY2Nlc3MudGVtcENvZGUsIFxyXG4gICAgICAgICAgICB0ZW1wb3JhcnlBY2Nlc3NJZDp0ZW1wQWNjZXNzLnRlbXBvcmFyeUFjY2Vzc0lkXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtnZXRMb2NrLCBcclxuICAgIGlzTm9sb2NrLCByZWxlYXNlTG9ja30gZnJvbSBcIi4uL2NvbW1vbi9sb2NrXCI7XHJcbmltcG9ydCB7IFVTRVJTX0xPQ0tfRklMRSwgVVNFUlNfTElTVF9GSUxFLCBnZXRVc2VyQnlOYW1lIH0gZnJvbSBcIi4vYXV0aENvbW1vblwiO1xyXG5pbXBvcnQge2FwaVdyYXBwZXIsIGV2ZW50c30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge3Blcm1pc3Npb259IGZyb20gXCIuL3Blcm1pc3Npb25zXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZW5hYmxlVXNlciA9IGFwcCA9PiBhc3luYyB1c2VybmFtZSA9PlxyXG4gICAgYXBpV3JhcHBlcihcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgZXZlbnRzLmF1dGhBcGkuZW5hYmxlVXNlciwgXHJcbiAgICAgICAgcGVybWlzc2lvbi5lbmFibGVEaXNhYmxlVXNlci5pc0F1dGhvcml6ZWQsXHJcbiAgICAgICAge2FwcCwgdXNlcm5hbWV9LFxyXG4gICAgICAgIF9lbmFibGVVc2VyLCBhcHAsIHVzZXJuYW1lKTtcclxuXHJcbmV4cG9ydCBjb25zdCBkaXNhYmxlVXNlciA9IGFwcCA9PiBhc3luYyB1c2VybmFtZSA9PlxyXG4gICAgYXBpV3JhcHBlcihcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgZXZlbnRzLmF1dGhBcGkuZGlzYWJsZVVzZXIsIFxyXG4gICAgICAgIHBlcm1pc3Npb24uZW5hYmxlRGlzYWJsZVVzZXIuaXNBdXRob3JpemVkLFxyXG4gICAgICAgIHt1c2VybmFtZX0sXHJcbiAgICAgICAgX2Rpc2FibGVVc2VyLCBhcHAsIHVzZXJuYW1lKTtcclxuXHJcbmV4cG9ydCBjb25zdCBfZW5hYmxlVXNlciA9IGFzeW5jIChhcHAsIHVzZXJuYW1lKSA9PiBcclxuICAgIGF3YWl0IHRvZ2dsZVVzZXIoYXBwLCB1c2VybmFtZSwgdHJ1ZSk7XHJcblxyXG5leHBvcnQgY29uc3QgX2Rpc2FibGVVc2VyID0gYXN5bmMgKGFwcCwgdXNlcm5hbWUpID0+IFxyXG4gICAgYXdhaXQgdG9nZ2xlVXNlcihhcHAsIHVzZXJuYW1lLCBmYWxzZSk7XHJcblxyXG5jb25zdCB0b2dnbGVVc2VyID0gYXN5bmMgKGFwcCwgdXNlcm5hbWUsIGVuYWJsZWQpID0+IHtcclxuICAgIGNvbnN0IGxvY2sgPSBhd2FpdCBnZXRMb2NrKGFwcCwgVVNFUlNfTE9DS19GSUxFLCAxMDAwLCAxLCAwKTtcclxuXHJcbiAgICBjb25zdCBhY3Rpb25OYW1lID0gZW5hYmxlZCA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIjtcclxuXHJcbiAgICBpZihpc05vbG9jayhsb2NrKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCAke2FjdGlvbk5hbWV9IHVzZXIgLSBjYW5ub3QgZ2V0IGxvY2tgKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgYXBwLmRhdGFzdG9yZS5sb2FkSnNvbihVU0VSU19MSVNUX0ZJTEUpO1xyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBnZXRVc2VyQnlOYW1lKHVzZXJzLCB1c2VybmFtZSk7XHJcbiAgICAgICAgaWYoIXVzZXIpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdXNlciB0byAke2FjdGlvbk5hbWV9YCk7XHJcblxyXG4gICAgICAgIGlmKHVzZXIuZW5hYmxlZCA9PT0gIWVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdXNlci5lbmFibGVkID0gZW5hYmxlZDtcclxuICAgICAgICAgICAgYXdhaXQgYXBwLmRhdGFzdG9yZS51cGRhdGVKc29uKFVTRVJTX0xJU1RfRklMRSwgdXNlcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHJlbGVhc2VMb2NrKGFwcCwgbG9jayk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge2FwaVdyYXBwZXJTeW5jLCBldmVudHN9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHtwZXJtaXNzaW9ufSBmcm9tIFwiLi9wZXJtaXNzaW9uc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldE5ld0FjY2Vzc0xldmVsID0gYXBwID0+ICgpID0+IFxyXG4gICAgYXBpV3JhcHBlclN5bmMoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGV2ZW50cy5hdXRoQXBpLmdldE5ld0FjY2Vzc0xldmVsLCBcclxuICAgICAgICBwZXJtaXNzaW9uLndyaXRlQWNjZXNzTGV2ZWxzLmlzQXV0aG9yaXplZCxcclxuICAgICAgICB7fSxcclxuICAgICAgICBfZ2V0TmV3QWNjZXNzTGV2ZWwsIGFwcCk7XHJcblxyXG5leHBvcnQgY29uc3QgX2dldE5ld0FjY2Vzc0xldmVsID0gKCkgPT4gKHtcclxuICAgIG5hbWU6XCJcIixcclxuICAgIHBlcm1pc3Npb25zOiBbXVxyXG59KTtcclxuXHJcbiIsImltcG9ydCB7YXBwbHlSdWxlU2V0LCBtYWtlcnVsZSwgYXBwbHlSdWxlfSBmcm9tIFwiLi4vY29tbW9uL3ZhbGlkYXRpb25Db21tb25cIjtcclxuaW1wb3J0IHtwZXJtaXNzaW9uVHlwZXN9IGZyb20gXCIuL2F1dGhDb21tb25cIjtcclxuaW1wb3J0IHt2YWx1ZXMsIGluY2x1ZGVzLCBtYXAsIGNvbmNhdCwgaXNFbXB0eSwgdW5pcVdpdGgsXHJcbiAgICBmbGF0dGVuLCBmaWx0ZXJ9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHskLCBpc1NvbWV0aGluZywgaW5zZW5zaXRpdmVFcXVhbHMsXHJcbiAgICBpc05vbkVtcHR5U3RyaW5nLCBhcGlXcmFwcGVyU3luYywgZXZlbnRzfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7Z2V0Tm9kZX0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xyXG5pbXBvcnQge2Fsd2F5c0F1dGhvcml6ZWR9IGZyb20gXCIuL3Blcm1pc3Npb25zXCI7XHJcblxyXG5jb25zdCBpc0FsbG93ZWRUeXBlID0gdCA9PiBcclxuICAgICQocGVybWlzc2lvblR5cGVzLCBbXHJcbiAgICAgICAgdmFsdWVzLCBcclxuICAgICAgICBpbmNsdWRlcyh0KVxyXG4gICAgXSk7XHJcblxyXG5jb25zdCBpc1JlY29yZE9ySW5kZXhUeXBlID0gdCA9PiBcclxuICAgIGluY2x1ZGVzKFwicmVjb3JkXCIpKHQpIHx8XHJcbiAgICBpbmNsdWRlcyhcImluZGV4XCIpKHQpO1xyXG5cclxuXHJcbmNvbnN0IHBlcm1pc3Npb25SdWxlcyA9IGFwcCA9PiAoW1xyXG4gICAgbWFrZXJ1bGUoXCJ0eXBlXCIsIFwidHlwZSBtdXN0IGJlIG9uZSBvZiBhbGxvd2VkIHR5cGVzXCIsXHJcbiAgICAgICAgcCA9PiBpc0FsbG93ZWRUeXBlKHAudHlwZSkpLFxyXG4gICAgbWFrZXJ1bGUoXCJub2RlS2V5XCIsIFwicmVjb3JkIGFuZCBpbmRleCBwZXJtaXNzaW9ucyBtdXN0IGluY2x1ZGUgYSB2YWxpZCBub2RlS2V5XCIsXHJcbiAgICAgICAgcCA9PiAoIWlzUmVjb3JkT3JJbmRleFR5cGUocC50eXBlKSkgXHJcbiAgICAgICAgICAgICB8fCAgaXNTb21ldGhpbmcoZ2V0Tm9kZShhcHAuaGVpcmFyY2h5LCBwLm5vZGVLZXkpKSlcclxuXSk7XHJcblxyXG5jb25zdCBhcHBseVBlcm1pc3Npb25SdWxlcyA9IGFwcCA9PiBcclxuICAgIGFwcGx5UnVsZVNldChwZXJtaXNzaW9uUnVsZXMoYXBwKSk7XHJcblxyXG5jb25zdCBhY2Nlc3NMZXZlbFJ1bGVzID0gYWxsTGV2ZWxzID0+IChbXHJcbiAgICBtYWtlcnVsZShcIm5hbWVcIiwgXCJuYW1lIG11c3QgYmUgc2V0XCIsXHJcbiAgICAgICAgbCA9PiBpc05vbkVtcHR5U3RyaW5nKGwubmFtZSkpLFxyXG4gICAgbWFrZXJ1bGUoXCJuYW1lXCIsIFwiYWNjZXNzIGxldmVsIG5hbWVzIG11c3QgYmUgdW5pcXVlXCIsXHJcbiAgICAgICAgbCA9PiBpc0VtcHR5KGwubmFtZSkgXHJcbiAgICAgICAgICAgICB8fCBmaWx0ZXIoYSA9PiBpbnNlbnNpdGl2ZUVxdWFscyhsLm5hbWUsIGEubmFtZSkpKGFsbExldmVscykubGVuZ3RoID09PSAxKVxyXG5dKTtcclxuXHJcbmNvbnN0IGFwcGx5TGV2ZWxSdWxlcyA9IGFsbExldmVscyA9PlxyXG4gICAgYXBwbHlSdWxlU2V0KGFjY2Vzc0xldmVsUnVsZXMoYWxsTGV2ZWxzKSk7XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVBY2Nlc3NMZXZlbCA9IGFwcCA9PiAoYWxsTGV2ZWxzLCBsZXZlbCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IGVycnMgPSAkKGxldmVsLnBlcm1pc3Npb25zLCBbXHJcbiAgICAgICAgbWFwKGFwcGx5UGVybWlzc2lvblJ1bGVzKGFwcCkpLFxyXG4gICAgICAgIGZsYXR0ZW4sXHJcbiAgICAgICAgY29uY2F0KFxyXG4gICAgICAgICAgICBhcHBseUxldmVsUnVsZXMoYWxsTGV2ZWxzKShsZXZlbClcclxuICAgICAgICApXHJcbiAgICBdKTtcclxuXHJcbiAgICByZXR1cm4gZXJycztcclxuXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVBY2Nlc3NMZXZlbHMgPSBhcHAgPT4gYWxsTGV2ZWxzID0+IFxyXG4gICAgYXBpV3JhcHBlclN5bmMoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGV2ZW50cy5hdXRoQXBpLnZhbGlkYXRlQWNjZXNzTGV2ZWxzLCBcclxuICAgICAgICBhbHdheXNBdXRob3JpemVkLFxyXG4gICAgICAgIHthbGxMZXZlbHN9LFxyXG4gICAgICAgIF92YWxpZGF0ZUFjY2Vzc0xldmVscywgYXBwLCBhbGxMZXZlbHMpO1xyXG5cclxuZXhwb3J0IGNvbnN0IF92YWxpZGF0ZUFjY2Vzc0xldmVscyA9IChhcHAsIGFsbExldmVscykgPT4gXHJcbiAgICAkKGFsbExldmVscywgW1xyXG4gICAgICAgIG1hcChsID0+IHZhbGlkYXRlQWNjZXNzTGV2ZWwoYXBwKShhbGxMZXZlbHMsIGwpKSxcclxuICAgICAgICBmbGF0dGVuLFxyXG4gICAgICAgIHVuaXFXaXRoKCh4LHkpID0+IHguZmllbGQgPT09IHkuZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgeC5pdGVtID09PSB5Lml0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgeC5lcnJvciA9PT0geS5lcnJvcilcclxuICAgIF0pO1xyXG4iLCJpbXBvcnQge2dldExvY2ssIHJlbGVhc2VMb2NrLCAkLFxyXG4gICAgaXNOb2xvY2ssIGFwaVdyYXBwZXIsIGV2ZW50c30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge0FDQ0VTU19MRVZFTFNfTE9DS19GSUxFLCBcclxuICAgIEFDQ0VTU19MRVZFTFNfRklMRX0gZnJvbSBcIi4vYXV0aENvbW1vblwiO1xyXG5pbXBvcnQge2pvaW4sIG1hcH0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5pbXBvcnQge3ZhbGlkYXRlQWNjZXNzTGV2ZWxzfSBmcm9tIFwiLi92YWxpZGF0ZUFjY2Vzc0xldmVsc1wiO1xyXG5pbXBvcnQge3Blcm1pc3Npb259IGZyb20gXCIuL3Blcm1pc3Npb25zXCI7XHJcblxyXG5leHBvcnQgY29uc3Qgc2F2ZUFjY2Vzc0xldmVscyA9IGFwcCA9PiBhc3luYyAoYWNjZXNzTGV2ZWxzKSA9PiBcclxuICAgIGFwaVdyYXBwZXIoXHJcbiAgICAgICAgYXBwLFxyXG4gICAgICAgIGV2ZW50cy5hdXRoQXBpLnNhdmVBY2Nlc3NMZXZlbHMsIFxyXG4gICAgICAgIHBlcm1pc3Npb24ud3JpdGVBY2Nlc3NMZXZlbHMuaXNBdXRob3JpemVkLFxyXG4gICAgICAgIHthY2Nlc3NMZXZlbHN9LFxyXG4gICAgICAgIF9zYXZlQWNjZXNzTGV2ZWxzLCBhcHAsIGFjY2Vzc0xldmVscyk7XHJcblxyXG5leHBvcnQgY29uc3QgX3NhdmVBY2Nlc3NMZXZlbHMgPSBhc3luYyAoYXBwLCBhY2Nlc3NMZXZlbHMpID0+IHtcclxuICAgIFxyXG4gICAgY29uc3QgdmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRlQWNjZXNzTGV2ZWxzKGFwcCkoYWNjZXNzTGV2ZWxzLmxldmVscyk7XHJcbiAgICBpZih2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YXIgZXJycyA9ICQodmFsaWRhdGlvbkVycm9ycywgW1xyXG4gICAgICAgICAgICBtYXAoZSA9PiBlLmVycm9yKSxcclxuICAgICAgICAgICAgam9pbihcIiwgXCIpXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBcIkFjY2VzcyBMZXZlbHMgSW52YWxpZDogXCIgKyBlcnJzXHJcbiAgICAgICAgKTtcclxuICAgIH0gXHJcbiAgICBcclxuICAgIGNvbnN0IGxvY2sgPSBhd2FpdCBnZXRMb2NrKFxyXG4gICAgICAgIGFwcCwgQUNDRVNTX0xFVkVMU19MT0NLX0ZJTEUsIDIwMDAsIDIpO1xyXG5cclxuICAgIGlmKGlzTm9sb2NrKGxvY2spKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgbG9jayB0byBzYXZlIGFjY2VzcyBsZXZlbHNcIik7XHJcblxyXG4gICAgdHJ5e1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gYXdhaXQgYXBwLmRhdGFzdG9yZS5sb2FkSnNvbihBQ0NFU1NfTEVWRUxTX0ZJTEUpO1xyXG4gICAgICAgIGlmKGV4aXN0aW5nLnZlcnNpb24gIT09IGFjY2Vzc0xldmVscy52ZXJzaW9uKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2Nlc3MgbGV2ZWxzIGhhdmUgYWxyZWFkeSBiZWVuIHVwZGF0ZWQsIHNpbmNlIHlvdSBsb2FkZWRcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYWNjZXNzTGV2ZWxzLnZlcnNpb24rKztcclxuXHJcbiAgICAgICAgYXBwLmRhdGFzdG9yZS51cGRhdGVKc29uKEFDQ0VTU19MRVZFTFNfRklMRSwgYWNjZXNzTGV2ZWxzKTtcclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIGF3YWl0IHJlbGVhc2VMb2NrKGFwcCwgbG9jayk7XHJcbiAgICB9ICAgICAgICBcclxufSIsImltcG9ydCB7cGVybWlzc2lvbn0gZnJvbSBcIi4vcGVybWlzc2lvbnNcIjtcclxuaW1wb3J0IHtnZXRGbGF0dGVuZWRIaWVyYXJjaHksIFxyXG4gICAgaXNJbmRleCwgaXNSZWNvcmR9IGZyb20gXCIuLi90ZW1wbGF0ZUFwaS9oZWlyYXJjaHlcIjtcclxuaW1wb3J0IHtmaWx0ZXIsIHZhbHVlcywgZWFjaCwga2V5c30gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5pbXBvcnQgeyR9IGZyb20gXCIuLi9jb21tb25cIjtcclxuXHJcbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUZ1bGxQZXJtaXNzaW9ucyA9IGFwcCA9PiB7XHJcblxyXG4gICAgY29uc3QgYWxsTm9kZXMgPSBnZXRGbGF0dGVuZWRIaWVyYXJjaHkoYXBwLmhlaXJhcmNoeSk7XHJcbiAgICBjb25zdCBhY2Nlc3NMZXZlbCA9IHtwZXJtaXNzaW9uczpbXX07XHJcblxyXG4gICAgY29uc3QgcmVjb3JkTm9kZXMgPSAkKGFsbE5vZGVzLCBbXHJcbiAgICAgICAgZmlsdGVyKGlzUmVjb3JkKVxyXG4gICAgXSk7XHJcblxyXG4gICAgZm9yKGxldCBuIG9mIHJlY29yZE5vZGVzKSB7XHJcbiAgICAgICAgcGVybWlzc2lvbi5jcmVhdGVSZWNvcmQuYWRkKG4ubm9kZUtleSgpLCBhY2Nlc3NMZXZlbCk7XHJcbiAgICAgICAgcGVybWlzc2lvbi51cGRhdGVSZWNvcmQuYWRkKG4ubm9kZUtleSgpLCBhY2Nlc3NMZXZlbCk7XHJcbiAgICAgICAgcGVybWlzc2lvbi5kZWxldGVSZWNvcmQuYWRkKG4ubm9kZUtleSgpLCBhY2Nlc3NMZXZlbCk7XHJcbiAgICAgICAgcGVybWlzc2lvbi5yZWFkUmVjb3JkLmFkZChuLm5vZGVLZXkoKSwgYWNjZXNzTGV2ZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGluZGV4Tm9kZXMgPSAkKGFsbE5vZGVzLCBbXHJcbiAgICAgICAgZmlsdGVyKGlzSW5kZXgpXHJcbiAgICBdKTtcclxuXHJcbiAgICBmb3IobGV0IG4gb2YgaW5kZXhOb2Rlcykge1xyXG4gICAgICAgIHBlcm1pc3Npb24ucmVhZEluZGV4LmFkZChuLm5vZGVLZXkoKSwgYWNjZXNzTGV2ZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcihsZXQgYSBvZiBrZXlzKGFwcC5hY3Rpb25zKSkge1xyXG4gICAgICAgIHBlcm1pc3Npb24uZXhlY3V0ZUFjdGlvbi5hZGQoYSwgYWNjZXNzTGV2ZWwpO1xyXG4gICAgfVxyXG5cclxuICAgICQocGVybWlzc2lvbiwgW1xyXG4gICAgICAgIHZhbHVlcyxcclxuICAgICAgICBmaWx0ZXIocCA9PiAhcC5pc05vZGUpLFxyXG4gICAgICAgIGVhY2gocCA9PiBwLmFkZChhY2Nlc3NMZXZlbCkpXHJcbiAgICBdKTtcclxuXHJcbiAgICByZXR1cm4gYWNjZXNzTGV2ZWwucGVybWlzc2lvbnM7XHJcbn07IiwiaW1wb3J0IHtnZXRMb2NrLCBpc05vbG9jaywgcmVsZWFzZUxvY2ssICQsIFxyXG4gICAgYXBpV3JhcHBlciwgZXZlbnRzfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7VVNFUlNfTE9DS19GSUxFLCBBQ0NFU1NfTEVWRUxTX0ZJTEUsXHJcbiAgICBnZXRVc2VyQnlOYW1lLCBVU0VSU19MSVNUX0ZJTEV9IGZyb20gXCIuL2F1dGhDb21tb25cIjtcclxuaW1wb3J0IHtwZXJtaXNzaW9ufSBmcm9tIFwiLi9wZXJtaXNzaW9uc1wiO1xyXG5pbXBvcnQge2RpZmZlcmVuY2UsIG1hcCwgam9pbn0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNldFVzZXJBY2Nlc3NMZXZlbHMgPSBhcHAgPT4gYXN5bmMgKHVzZXJOYW1lLCBhY2Nlc3NMZXZlbHMpID0+IFxyXG4gICAgYXBpV3JhcHBlcihcclxuICAgICAgICBhcHAsXHJcbiAgICAgICAgZXZlbnRzLmF1dGhBcGkuc2V0VXNlckFjY2Vzc0xldmVscywgXHJcbiAgICAgICAgcGVybWlzc2lvbi5zZXRVc2VyQWNjZXNzTGV2ZWxzLmlzQXV0aG9yaXplZCxcclxuICAgICAgICB7dXNlck5hbWUsIGFjY2Vzc0xldmVsc30sXHJcbiAgICAgICAgX3NldFVzZXJBY2Nlc3NMZXZlbHMsIGFwcCwgdXNlck5hbWUsIGFjY2Vzc0xldmVscyk7XHJcblxyXG5leHBvcnQgY29uc3QgX3NldFVzZXJBY2Nlc3NMZXZlbHMgPSBhc3luYyAoYXBwLCB1c2VybmFtZSwgYWNjZXNzTGV2ZWxzKSA9PiB7XHJcbiAgICBjb25zdCBsb2NrID0gYXdhaXQgZ2V0TG9jayhhcHAsIFVTRVJTX0xPQ0tfRklMRSwgMTAwMCwgMSwgMCk7XHJcblxyXG4gICAgY29uc3QgYWN0dWFsQWNjZXNzTGV2ZWxzID0gJChcclxuICAgICAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLmxvYWRKc29uKEFDQ0VTU19MRVZFTFNfRklMRSksXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICBsID0+IGwubGV2ZWxzLFxyXG4gICAgICAgICAgICBtYXAobCA9PiBsLm5hbWUpXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgY29uc3QgbWlzc2luZyA9IGRpZmZlcmVuY2UoYWNjZXNzTGV2ZWxzKShhY3R1YWxBY2Nlc3NMZXZlbHMpO1xyXG4gICAgaWYobWlzc2luZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhY2Nlc3MgbGV2ZWxzIHN1cHBsaWVkOiBcIiArIGpvaW4oXCIsIFwiLCBtaXNzaW5nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoaXNOb2xvY2sobG9jaykpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBzZXQgdXNlciBhY2Nlc3MgbGV2ZWxzIGNhbm5vdCBnZXQgbG9ja2ApO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdXNlcnMgPSBhd2FpdCBhcHAuZGF0YXN0b3JlLmxvYWRKc29uKFVTRVJTX0xJU1RfRklMRSk7XHJcbiAgICAgICAgY29uc3QgdXNlciA9IGdldFVzZXJCeU5hbWUodXNlcnMsIHVzZXJuYW1lKTtcclxuICAgICAgICBpZighdXNlcilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCB1c2VyIHRvICR7YWN0aW9uTmFtZX1gKTtcclxuXHJcbiAgICAgICAgdXNlci5hY2Nlc3NMZXZlbHMgPSBhY2Nlc3NMZXZlbHM7XHJcbiAgICAgICAgYXdhaXQgYXBwLmRhdGFzdG9yZS51cGRhdGVKc29uKFVTRVJTX0xJU1RfRklMRSwgdXNlcnMpO1xyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgcmVsZWFzZUxvY2soYXBwLCBsb2NrKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7YXV0aGVudGljYXRlLCBcclxuICAgIGF1dGhlbnRpY2F0ZVRlbXBvcmFyeUFjY2Vzc30gZnJvbSBcIi4vYXV0aGVudGljYXRlXCI7XHJcbmltcG9ydCB7Y3JlYXRlVGVtcG9yYXJ5QWNjZXNzfSBmcm9tIFwiLi9jcmVhdGVUZW1wb3JhcnlBY2Nlc3NcIjtcclxuaW1wb3J0IHtjcmVhdGVVc2VyfSBmcm9tIFwiLi9jcmVhdGVVc2VyXCI7XHJcbmltcG9ydCB7ZW5hYmxlVXNlciwgZGlzYWJsZVVzZXJ9IGZyb20gXCIuL2VuYWJsZVVzZXJcIjtcclxuaW1wb3J0IHtsb2FkQWNjZXNzTGV2ZWxzfSBmcm9tIFwiLi9sb2FkQWNjZXNzTGV2ZWxzXCI7XHJcbmltcG9ydCB7Z2V0TmV3QWNjZXNzTGV2ZWx9IGZyb20gXCIuL2dldE5ld0FjY2Vzc0xldmVsXCI7XHJcbmltcG9ydCB7Z2V0TmV3VXNlciwgZ2V0TmV3VXNlckF1dGh9IGZyb20gXCIuL2dldE5ld1VzZXJcIjtcclxuaW1wb3J0IHtnZXRVc2Vyc30gZnJvbSBcIi4vZ2V0VXNlcnNcIjtcclxuaW1wb3J0IHtpc0F1dGhvcml6ZWR9IGZyb20gXCIuL2lzQXV0aG9yaXplZFwiO1xyXG5pbXBvcnQge3NhdmVBY2Nlc3NMZXZlbHN9IGZyb20gXCIuL3NhdmVBY2Nlc3NMZXZlbHNcIjtcclxuaW1wb3J0IHtjaGFuZ2VNeVBhc3N3b3JkLCBjaGFuZ2VQYXNzd29yZCxcclxuICAgIHNjb3JlUGFzc3dvcmQsIHNldFBhc3N3b3JkRnJvbVRlbXBvcmFyeUNvZGUsIFxyXG4gICAgaXNWYWxpZFBhc3N3b3JkfSBmcm9tIFwiLi9zZXRQYXNzd29yZFwiO1xyXG5pbXBvcnQge3ZhbGlkYXRlVXNlcn0gZnJvbSBcIi4vdmFsaWRhdGVVc2VyXCI7XHJcbmltcG9ydCB7dmFsaWRhdGVBY2Nlc3NMZXZlbHN9IGZyb20gXCIuL3ZhbGlkYXRlQWNjZXNzTGV2ZWxzXCI7XHJcbmltcG9ydCB7Z2VuZXJhdGVGdWxsUGVybWlzc2lvbnN9IGZyb20gXCIuL2dlbmVyYXRlRnVsbFBlcm1pc3Npb25zXCI7XHJcbmltcG9ydCB7c2V0VXNlckFjY2Vzc0xldmVsc30gZnJvbSBcIi4vc2V0VXNlckFjY2Vzc0xldmVsc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEF1dGhBcGkgPSBhcHAgPT4gKHtcclxuICAgIGF1dGhlbnRpY2F0ZTogYXV0aGVudGljYXRlKGFwcCksXHJcbiAgICBhdXRoZW50aWNhdGVUZW1wb3JhcnlBY2Nlc3M6IGF1dGhlbnRpY2F0ZVRlbXBvcmFyeUFjY2VzcyhhcHApLFxyXG4gICAgY3JlYXRlVGVtcG9yYXJ5QWNjZXNzOiBjcmVhdGVUZW1wb3JhcnlBY2Nlc3MoYXBwKSxcclxuICAgIGNyZWF0ZVVzZXI6IGNyZWF0ZVVzZXIoYXBwKSxcclxuICAgIGxvYWRBY2Nlc3NMZXZlbHM6IGxvYWRBY2Nlc3NMZXZlbHMoYXBwKSxcclxuICAgIGVuYWJsZVVzZXI6IGVuYWJsZVVzZXIoYXBwKSxcclxuICAgIGRpc2FibGVVc2VyOiBkaXNhYmxlVXNlcihhcHApLFxyXG4gICAgZ2V0TmV3QWNjZXNzTGV2ZWw6IGdldE5ld0FjY2Vzc0xldmVsKGFwcCksXHJcbiAgICBnZXROZXdVc2VyOiBnZXROZXdVc2VyKGFwcCksXHJcbiAgICBnZXROZXdVc2VyQXV0aDogZ2V0TmV3VXNlckF1dGgoYXBwKSxcclxuICAgIGdldFVzZXJzOiBnZXRVc2VycyhhcHApLFxyXG4gICAgc2F2ZUFjY2Vzc0xldmVsczogc2F2ZUFjY2Vzc0xldmVscyhhcHApLFxyXG4gICAgaXNBdXRob3JpemVkOiBpc0F1dGhvcml6ZWQoYXBwKSxcclxuICAgIGNoYW5nZU15UGFzc3dvcmQ6IGNoYW5nZU15UGFzc3dvcmQoYXBwKSxcclxuICAgIHNldFBhc3N3b3JkRnJvbVRlbXBvcmFyeUNvZGU6IHNldFBhc3N3b3JkRnJvbVRlbXBvcmFyeUNvZGUoYXBwKSxcclxuICAgIHNjb3JlUGFzc3dvcmQsXHJcbiAgICBpc1ZhbGlkUGFzc3dvcmQ6IGlzVmFsaWRQYXNzd29yZChhcHApLFxyXG4gICAgdmFsaWRhdGVVc2VyOiB2YWxpZGF0ZVVzZXIoYXBwKSxcclxuICAgIHZhbGlkYXRlQWNjZXNzTGV2ZWxzOiB2YWxpZGF0ZUFjY2Vzc0xldmVscyhhcHApLFxyXG4gICAgZ2VuZXJhdGVGdWxsUGVybWlzc2lvbnM6ICgpID0+IGdlbmVyYXRlRnVsbFBlcm1pc3Npb25zKGFwcCksXHJcbiAgICBzZXRVc2VyQWNjZXNzTGV2ZWxzOiBzZXRVc2VyQWNjZXNzTGV2ZWxzKGFwcClcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXRBdXRoQXBpOyIsImltcG9ydCB7cGVybWlzc2lvbn0gZnJvbSBcIi4uL2F1dGhBcGkvcGVybWlzc2lvbnNcIjtcclxuaW1wb3J0IHthcGlXcmFwcGVyU3luY30gZnJvbSBcIi4uL2NvbW1vbi9hcGlXcmFwcGVyXCI7XHJcbmltcG9ydCB7ZXZlbnRzfSBmcm9tIFwiLi4vY29tbW9uL2V2ZW50c1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGV4ZWN1dGVBY3Rpb24gPSBhcHAgPT4gKGFjdGlvbk5hbWUsIG9wdGlvbnMpID0+IHtcclxuICAgIGFwaVdyYXBwZXJTeW5jKFxyXG4gICAgICAgIGFwcCwgXHJcbiAgICAgICAgZXZlbnRzLmFjdGlvbnNBcGkuZXhlY3V0ZSxcclxuICAgICAgICBwZXJtaXNzaW9uLmV4ZWN1dGVBY3Rpb24uaXNBdXRob3JpemVkKGFjdGlvbk5hbWUpLFxyXG4gICAgICAgIHthY3Rpb25OYW1lLCBvcHRpb25zfSxcclxuICAgICAgICBhcHAuYWN0aW9uc1thY3Rpb25OYW1lXSwgb3B0aW9uc1xyXG4gICAgKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IF9leGVjdXRlQWN0aW9uID0gKGJlaGF2aW91clNvdXJjZXMsIGFjdGlvbiwgb3B0aW9ucykgPT4gXHJcbiAgICBiZWhhdmlvdXJTb3VyY2VzW2FjdGlvbi5iZWhhdmlvdXJTb3VyY2VdW2FjdGlvbi5iZWhhdmlvdXJOYW1lXShvcHRpb25zKTtcclxuIiwiaW1wb3J0IHtleGVjdXRlQWN0aW9ufSBmcm9tIFwiLi9leGVjdXRlXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0QWN0aW9uc0FwaSA9IGFwcCA9PiAoe1xyXG4gICAgZXhlY3V0ZTogZXhlY3V0ZUFjdGlvbihhcHApXHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2V0QWN0aW9uc0FwaTsiLCJpbXBvcnQge2hhc30gZnJvbSBcImxvZGFzaFwiO1xyXG5cclxuY29uc3QgcHVibGlzaCA9IGhhbmRsZXJzID0+IChldmVudE5hbWUsIGNvbnRleHQgPSB7fSkgPT4ge1xyXG4gICAgaWYoIWhhcyhoYW5kbGVycywgZXZlbnROYW1lKSkgcmV0dXJuO1xyXG5cclxuICAgIGZvcihsZXQgaGFuZGxlciBvZiBoYW5kbGVyc1tldmVudE5hbWVdKSB7XHJcbiAgICAgICAgaGFuZGxlcihldmVudE5hbWUsIGNvbnRleHQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuY29uc3Qgc3Vic2NyaWJlID0gaGFuZGxlcnMgPT4gKGV2ZW50TmFtZSwgaGFuZGxlcikgPT4ge1xyXG4gICAgaWYoIWhhcyhoYW5kbGVycywgZXZlbnROYW1lKSkge1xyXG4gICAgICAgIGhhbmRsZXJzW2V2ZW50TmFtZV0gPSBbXTtcclxuICAgIH1cclxuICAgIGhhbmRsZXJzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVFdmVudEFnZ3JlZ2F0b3IgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IHt9O1xyXG4gICAgY29uc3QgZXZlbnRBZ2dyZWdhdG9yID0gKHtcclxuICAgICAgICBwdWJsaXNoOiBwdWJsaXNoKGhhbmRsZXJzKSxcclxuICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZShoYW5kbGVycylcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGV2ZW50QWdncmVnYXRvcjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUV2ZW50QWdncmVnYXRvcjsiLCJpbXBvcnQgeyByZXRyeSB9IGZyb20gXCIuLi9jb21tb24vaW5kZXhcIjtcblxuY29uc3QgbG9hZEpzb24gPSBkYXRhc3RvcmUgPT4gYXN5bmMgKGtleSwgcmV0cmllcyA9IDUsIGRlbGF5ID0gNTAwKSA9PlxuICAgIGF3YWl0IHJldHJ5KEpTT04ucGFyc2UsIHJldHJpZXMsIGRlbGF5LCBhd2FpdCBkYXRhc3RvcmUubG9hZEZpbGUoa2V5KSk7XG5cbmNvbnN0IGNyZWF0ZUpzb24gPSBvcmlnaW5hbENyZWF0ZUZpbGUgPT4gYXN5bmMgKGtleSwgb2JqLCByZXRyaWVzID0gNSwgZGVsYXkgPSA1MDApID0+XG4gICAgYXdhaXQgcmV0cnkob3JpZ2luYWxDcmVhdGVGaWxlLCByZXRyaWVzLCBkZWxheSwga2V5LCBKU09OLnN0cmluZ2lmeShvYmopKTtcblxuY29uc3QgdXBkYXRlSnNvbiA9IGRhdGFzdG9yZSA9PiBhc3luYyAoa2V5LCBvYmosIHJldHJpZXMgPSA1LCBkZWxheSA9IDUwMCkgPT5cbiAgICBhd2FpdCByZXRyeSggZGF0YXN0b3JlLnVwZGF0ZUZpbGUsIHJldHJpZXMsIGRlbGF5LCBrZXksIEpTT04uc3RyaW5naWZ5KG9iaikpO1xuXG5jb25zdCBjcmVhdGVOZXdGaWxlID0gb3JpZ2luYWxDcmVhdGVGaWxlID0+IGFzeW5jIChwYXRoLCBjb250ZW50LCByZXRyaWVzID0gNSwgZGVsYXkgPSA1MDApID0+XG4gICAgYXdhaXQgcmV0cnkob3JpZ2luYWxDcmVhdGVGaWxlLCByZXRyaWVzLCBkZWxheSwgcGF0aCwgY29udGVudCk7XG5cbmV4cG9ydCBjb25zdCBzZXR1cERhdGFzdG9yZSA9IChkYXRhc3RvcmUpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbENyZWF0ZUZpbGUgPSBkYXRhc3RvcmUuY3JlYXRlRmlsZTtcbiAgICBkYXRhc3RvcmUubG9hZEpzb24gPSBsb2FkSnNvbihkYXRhc3RvcmUpO1xuICAgIGRhdGFzdG9yZS5jcmVhdGVKc29uID0gY3JlYXRlSnNvbihvcmlnaW5hbENyZWF0ZUZpbGUpO1xuICAgIGRhdGFzdG9yZS51cGRhdGVKc29uID0gdXBkYXRlSnNvbihkYXRhc3RvcmUpO1xuICAgIGRhdGFzdG9yZS5jcmVhdGVGaWxlID0gY3JlYXRlTmV3RmlsZShvcmlnaW5hbENyZWF0ZUZpbGUpO1xuICAgIGlmIChkYXRhc3RvcmUuY3JlYXRlRW1wdHlEYilcbiAgICAgICAgZGVsZXRlIGRhdGFzdG9yZS5jcmVhdGVFbXB0eURiO1xuICAgIHJldHVybiBkYXRhc3RvcmU7XG59O1xuXG5leHBvcnQge2NyZWF0ZUV2ZW50QWdncmVnYXRvcn0gZnJvbSBcIi4vZXZlbnRBZ2dyZWdhdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHNldHVwRGF0YXN0b3JlO1xuIiwiaW1wb3J0IHtpc0Z1bmN0aW9uLCBmaWx0ZXIsIG1hcCwgXHJcbiAgICAgICAgdW5pcUJ5LCBrZXlzLCBkaWZmZXJlbmNlLFxyXG4gICAgICAgIGpvaW4sIHJlZHVjZSwgZmluZH0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5pbXBvcnQgeyR9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHtfZXhlY3V0ZUFjdGlvbn0gZnJvbSBcIi4vZXhlY3V0ZVwiO1xyXG5pbXBvcnQge2NvbXBpbGVFeHByZXNzaW9uLCBjb21waWxlQ29kZX0gZnJvbSBcIkBueC1qcy9jb21waWxlci11dGlsXCI7XHJcblxyXG5leHBvcnQgY29uc3QgaW5pdGlhbGlzZUFjdGlvbnMgPSAoc3Vic2NyaWJlLCBiZWhhdmlvdXJTb3VyY2VzLCBhY3Rpb25zLCB0cmlnZ2VycykgPT4ge1xyXG4gICAgXHJcbiAgICB2YWxpZGF0ZVNvdXJjZXMoYmVoYXZpb3VyU291cmNlcywgYWN0aW9ucyk7XHJcbiAgICBzdWJzY3JpYmVUcmlnZ2VycyhzdWJzY3JpYmUsIGJlaGF2aW91clNvdXJjZXMsIGFjdGlvbnMsIHRyaWdnZXJzKTtcclxuICAgIHJldHVybiBjcmVhdGVBY3Rpb25zQ29sbGVjdGlvbihiZWhhdmlvdXJTb3VyY2VzLCBhY3Rpb25zKTtcclxuXHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVBY3Rpb25zQ29sbGVjdGlvbiA9IChiZWhhdmlvdXJTb3VyY2VzLCBhY3Rpb25zKSA9PlxyXG4gICAgJChhY3Rpb25zLFtcclxuICAgICAgICByZWR1Y2UoKGFsbCxhKSA9PiB7XHJcbiAgICAgICAgICAgIGFsbFthLm5hbWVdID0gb3B0cyA9PiBfZXhlY3V0ZUFjdGlvbihiZWhhdmlvdXJTb3VyY2VzLCBhLCBvcHRzKVxyXG4gICAgICAgICAgICByZXR1cm4gYWxsO1xyXG4gICAgICAgIH0sIHt9KVxyXG4gICAgXSk7XHJcblxyXG5jb25zdCBzdWJzY3JpYmVUcmlnZ2VycyA9IChzdWJzY3JpYmUsIGJlaGF2aW91clNvdXJjZXMsIGFjdGlvbnMsIHRyaWdnZXJzKSA9PiB7XHJcblxyXG4gICAgY29uc3QgY3JlYXRlT3B0aW9ucyA9IChvcHRpb25zQ3JlYXRvciwgZXZlbnRDb250ZXh0KSA9PiB7XHJcbiAgICAgICAgaWYoIW9wdGlvbnNDcmVhdG9yKSByZXR1cm4ge307XHJcbiAgICAgICAgY29uc3QgY3JlYXRlID0gY29tcGlsZUNvZGUob3B0aW9uc0NyZWF0b3IpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGUoe2NvbnRleHQ6ZXZlbnRDb250ZXh0fSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHNob3VsZFJ1blRyaWdnZXIgPSAodHJpZ2dlciwgZXZlbnRDb250ZXh0KSA9PiB7XHJcbiAgICAgICAgaWYoIXRyaWdnZXIuY29uZGl0aW9uKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjb25zdCBzaG91bGRSdW4gPSBjb21waWxlRXhwcmVzc2lvbih0cmlnZ2VyLmNvbmRpdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHNob3VsZFJ1bih7Y29udGV4dDpldmVudENvbnRleHR9KTtcclxuICAgIH07XHJcblxyXG4gICAgZm9yKGxldCB0cmlnIG9mIHRyaWdnZXJzKSB7XHJcbiAgICAgICAgc3Vic2NyaWJlKHRyaWcuZXZlbnROYW1lLCAoZXYsIGN0eCkgPT4ge1xyXG4gICAgICAgICAgICBpZihzaG91bGRSdW5UcmlnZ2VyKHRyaWcsIGN0eCkpIHtcclxuICAgICAgICAgICAgICAgIF9leGVjdXRlQWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIGJlaGF2aW91clNvdXJjZXMsIFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmQoYSA9PiBhLm5hbWUgPT09IHRyaWcuYWN0aW9uTmFtZSkoYWN0aW9ucyksXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlT3B0aW9ucyh0cmlnLm9wdGlvbnNDcmVhdG9yLCBjdHgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbmNvbnN0IHZhbGlkYXRlU291cmNlcyA9IChiZWhhdmlvdXJTb3VyY2VzLCBhY3Rpb25zKSA9PiB7XHJcblxyXG4gICAgY29uc3QgZGVjbGFyZWRTb3VyY2VzID0gJChhY3Rpb25zLCBbXHJcbiAgICAgICAgdW5pcUJ5KGEgPT4gYS5iZWhhdmlvdXJTb3VyY2UpLFxyXG4gICAgICAgIG1hcChhID0+IGEuYmVoYXZpb3VyU291cmNlKVxyXG4gICAgXSk7XHJcblxyXG4gICAgY29uc3Qgc3VwcGxpZWRTb3VyY2VzID0ga2V5cyhiZWhhdmlvdXJTb3VyY2VzKTtcclxuXHJcbiAgICBjb25zdCBtaXNzaW5nU291cmNlcyA9IGRpZmZlcmVuY2UoXHJcbiAgICAgICAgZGVjbGFyZWRTb3VyY2VzLCBzdXBwbGllZFNvdXJjZXNcclxuICAgICk7XHJcblxyXG4gICAgaWYobWlzc2luZ1NvdXJjZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlY2xhcmVkIGJlaGF2aW91ciBzb3VyY2VzIGFyZSBub3Qgc3VwcGxpZWQ6IFwiICsgam9pbihcIiwgXCIsIG1pc3NpbmdTb3VyY2VzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWlzc2luZ0JlaGF2aW91cnMgPSAkKGFjdGlvbnMsIFtcclxuICAgICAgICBmaWx0ZXIoYSA9PiAhaXNGdW5jdGlvbihiZWhhdmlvdXJTb3VyY2VzW2EuYmVoYXZpb3VyU291cmNlXVthLmJlaGF2aW91ck5hbWVdKSksXHJcbiAgICAgICAgbWFwKGEgPT4gYEFjdGlvbjogJHthLm5hbWV9IDogJHthLmJlaGF2aW91clNvdXJjZX0uJHthLmJlaGF2aW91ck5hbWV9YClcclxuICAgIF0pO1xyXG5cclxuICAgIGlmKG1pc3NpbmdCZWhhdmlvdXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGJlaGF2aW91cnM6IGNvdWxkIG5vdCBiZWhhdmlvdXIgZnVuY3Rpb25zOiBcIiArIGpvaW4oXCIsIFwiLCBtaXNzaW5nQmVoYXZpb3VycykpO1xyXG4gICAgfVxyXG59OyIsImltcG9ydCB7XHJcbiAgICBMT0NLX0ZJTEVOQU1FLCBUUkFOU0FDVElPTlNfRk9MREVSLCBpZFNlcCwgaXNVcGRhdGUsXHJcbiAgICBub2RlS2V5SGFzaEZyb21CdWlsZEZvbGRlciwgaXNCdWlsZEluZGV4Rm9sZGVyLCBnZXRUcmFuc2FjdGlvbklkLFxyXG4gICAgaXNEZWxldGUsIGlzQ3JlYXRlIH0gZnJvbSBcIi4vdHJhbnNhY3Rpb25zQ29tbW9uXCI7XHJcbmltcG9ydCB7am9pbktleSwgJCwgbm9uZSwgaXNTb21ldGhpbmd9IGZyb20gXCIuLi9jb21tb25cIjtcclxuaW1wb3J0IHtnZXRMYXN0UGFydEluS2V5LCBnZXROb2RlRnJvbU5vZGVLZXlIYXNofSBmcm9tIFwiLi4vdGVtcGxhdGVBcGkvaGVpcmFyY2h5XCI7XHJcbmltcG9ydCB7bWFwLCBmaWx0ZXIsIGdyb3VwQnksIHNwbGl0LFxyXG4gICAgc29tZSwgZmluZH0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5pbXBvcnQge19sb2FkfSBmcm9tIFwiLi4vcmVjb3JkQXBpL2xvYWRcIjtcclxuXHJcbmV4cG9ydCBjb25zdCByZXRyaWV2ZSA9IGFzeW5jIGFwcCA9PiB7XHJcbiAgICBcclxuICAgIGNvbnN0IHRyYW5zYWN0aW9uRmlsZXMgPSBhd2FpdCBhcHAuZGF0YXN0b3JlLmdldEZvbGRlckNvbnRlbnRzKFxyXG4gICAgICAgIFRSQU5TQUNUSU9OU19GT0xERVJcclxuICAgICk7XHJcblxyXG4gICAgbGV0IHRyYW5zYWN0aW9ucyA9IFtdO1xyXG5cclxuICAgIGlmKHNvbWUoaXNCdWlsZEluZGV4Rm9sZGVyKSh0cmFuc2FjdGlvbkZpbGVzKSkge1xyXG4gICAgICAgIGNvbnN0IGJ1aWxkSW5kZXhGb2xkZXIgPSBmaW5kKGlzQnVpbGRJbmRleEZvbGRlcikodHJhbnNhY3Rpb25GaWxlcyk7XHJcblxyXG4gICAgICAgIHRyYW5zYWN0aW9ucyA9IGF3YWl0IHJldHJpZXZlQnVpbGRJbmRleFRyYW5zYWN0aW9ucyhcclxuICAgICAgICAgICAgYXBwLCBcclxuICAgICAgICAgICAgam9pbktleShUUkFOU0FDVElPTlNfRk9MREVSLGJ1aWxkSW5kZXhGb2xkZXIpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZih0cmFuc2FjdGlvbnMubGVuZ3RoID4gMCkgcmV0dXJuIHRyYW5zYWN0aW9ucztcclxuICAgIFxyXG4gICAgcmV0dXJuIGF3YWl0IHJldHJpZXZlU3RhbmRhcmRUcmFuc2FjdGlvbnMoXHJcbiAgICAgICAgYXBwLCB0cmFuc2FjdGlvbkZpbGVzXHJcbiAgICApOyAgXHJcblxyXG59O1xyXG5cclxuY29uc3QgcmV0cmlldmVCdWlsZEluZGV4VHJhbnNhY3Rpb25zID0gYXN5bmMgKGFwcCwgYnVpbGRJbmRleEZvbGRlcikgPT4ge1xyXG5cclxuICAgIGNvbnN0IGNoaWxkRm9sZGVycyA9IGF3YWl0IGFwcC5kYXRhc3RvcmUuZ2V0Rm9sZGVyQ29udGVudHMoYnVpbGRJbmRleEZvbGRlcik7XHJcbiAgICBpZihjaGlsZEZvbGRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgLy8gY2xlYW51cFxyXG4gICAgICAgIGF3YWl0IGFwcC5kYXRhc3RvcmUuZGVsZXRlRm9sZGVyKGJ1aWxkSW5kZXhGb2xkZXIpO1xyXG4gICAgICAgIHJldHVybiBbXTsgICAgXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ2V0VHJhbnNhY3Rpb25GaWxlcyA9IGFzeW5jIChjaGlsZEZvbGRlckluZGV4PTApID0+IHtcclxuICAgICAgICBpZihjaGlsZEZvbGRlckluZGV4ID49IGNoaWxkRm9sZGVycy5sZW5ndGgpIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgY29uc3QgY2hpbGRGb2xkZXJLZXkgPSBqb2luS2V5KGJ1aWxkSW5kZXhGb2xkZXIsIGNoaWxkRm9sZGVyc1tjaGlsZEZvbGRlckluZGV4XSk7XHJcbiAgICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCBhcHAuZGF0YXN0b3JlLmdldEZvbGRlckNvbnRlbnRzKFxyXG4gICAgICAgICAgICBjaGlsZEZvbGRlcktleVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBhd2FpdCBhcHAuZGF0YXN0b3JlLmRlbGV0ZUZvbGRlcihjaGlsZEZvbGRlcktleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXRUcmFuc2FjdGlvbkZpbGVzKGNoaWxkRm9sZGVySW5kZXgrMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge2NoaWxkRm9sZGVyS2V5LCBmaWxlc307ICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbkZpbGVzID0gYXdhaXQgZ2V0VHJhbnNhY3Rpb25GaWxlcygpO1xyXG5cclxuICAgIGlmKHRyYW5zYWN0aW9uRmlsZXMuZmlsZXMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XHJcblxyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gJCh0cmFuc2FjdGlvbkZpbGVzLmZpbGVzLCBbXHJcbiAgICAgICAgbWFwKHBhcnNlVHJhbnNhY3Rpb25JZClcclxuICAgIF0pO1xyXG5cclxuICAgIGZvcihsZXQgdCBvZiB0cmFuc2FjdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkNvbnRlbnQgPSBhd2FpdCBhcHAuZGF0YXN0b3JlLmxvYWRKc29uKFxyXG4gICAgICAgICAgICBqb2luS2V5KFxyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25GaWxlcy5jaGlsZEZvbGRlcktleSwgXHJcbiAgICAgICAgICAgICAgICB0LmZ1bGxJZClcclxuICAgICAgICApO1xyXG4gICAgICAgIHQucmVjb3JkID0gYXdhaXQgX2xvYWQoYXBwLCB0cmFuc2FjdGlvbkNvbnRlbnQucmVjb3JkS2V5KTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFuc2FjdGlvbnMuaW5kZXhOb2RlID0gJChidWlsZEluZGV4Rm9sZGVyLCBbXHJcbiAgICAgICAgZ2V0TGFzdFBhcnRJbktleSxcclxuICAgICAgICBub2RlS2V5SGFzaEZyb21CdWlsZEZvbGRlcixcclxuICAgICAgICBnZXROb2RlRnJvbU5vZGVLZXlIYXNoKGFwcC5oZWlyYXJjaHkpXHJcbiAgICBdKTtcclxuXHJcbiAgICB0cmFuc2FjdGlvbnMuZm9sZGVyS2V5ID0gdHJhbnNhY3Rpb25GaWxlcy5jaGlsZEZvbGRlcktleTtcclxuXHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25zO1xyXG59XHJcblxyXG5jb25zdCByZXRyaWV2ZVN0YW5kYXJkVHJhbnNhY3Rpb25zID0gYXN5bmMgKGFwcCwgdHJhbnNhY3Rpb25GaWxlcykgPT4ge1xyXG4gICAgXHJcblxyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25JZHMgPSAkKHRyYW5zYWN0aW9uRmlsZXMsIFtcclxuICAgICAgICBmaWx0ZXIoZiA9PiBmICE9PSBMT0NLX0ZJTEVOQU1FIFxyXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0J1aWxkSW5kZXhGb2xkZXIoZikpLFxyXG4gICAgICAgIG1hcChwYXJzZVRyYW5zYWN0aW9uSWQpLFxyXG4gICAgXSk7XHJcblxyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25JZHNCeVJlY29yZCA9ICQodHJhbnNhY3Rpb25JZHMsIFtcclxuICAgICAgICBncm91cEJ5KFwicmVjb3JkSWRcIilcclxuICAgIF0pO1xyXG5cclxuICAgIGNvbnN0IGRlZHVwZWRUcmFuc2FjdGlvbnMgPSBbXTtcclxuXHJcbiAgICBjb25zdCB2ZXJpZnkgPSBhc3luYyB0ID0+IHtcclxuICAgICAgICBcclxuICAgICAgICBpZih0LnZlcmlmaWVkID09PSB0cnVlKSByZXR1cm4gdDtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBpZCA9IGdldFRyYW5zYWN0aW9uSWQoXHJcbiAgICAgICAgICAgIHQucmVjb3JkSWQsXHJcbiAgICAgICAgICAgIHQudHJhbnNhY3Rpb25UeXBlLFxyXG4gICAgICAgICAgICB0LnVuaXF1ZUlkKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IGFwcC5kYXRhc3RvcmUubG9hZEpzb24oXHJcbiAgICAgICAgICAgIGpvaW5LZXkoVFJBTlNBQ1RJT05TX0ZPTERFUiwgaWQpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYoaXNEZWxldGUodCkpIHtcclxuICAgICAgICAgICAgdC5yZWNvcmQgPSB0cmFuc2FjdGlvbi5yZWNvcmQ7XHJcbiAgICAgICAgICAgIHQudmVyaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcmVjID0gYXdhaXQgX2xvYWQoXHJcbiAgICAgICAgICAgIGFwcCxcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjb3JkS2V5XHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZihyZWMudHJhbnNhY3Rpb25JZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgdC5yZWNvcmQgPSByZWM7XHJcbiAgICAgICAgICAgIGlmKCEhdHJhbnNhY3Rpb24ub2xkUmVjb3JkKSBcclxuICAgICAgICAgICAgICAgIHQub2xkUmVjb3JkID0gdHJhbnNhY3Rpb24ub2xkUmVjb3JkO1xyXG4gICAgICAgICAgICB0LnZlcmlmaWVkID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0LnZlcmlmaWVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwaWNrT25lID0gYXN5bmMgKHRyYW5zLCBmb3JUeXBlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNGb3JUeXBlID0gZmlsdGVyKGZvclR5cGUpKHRyYW5zKTtcclxuICAgICAgICBpZih0cmFuc0ZvclR5cGUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBhd2FpdCB2ZXJpZnkodHJhbnNGb3JUeXBlWzBdKTtcclxuICAgICAgICAgICAgcmV0dXJuICh0LnZlcmlmaWVkID09PSB0cnVlID8gdCA6IG51bGwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvcihsZXQgdCBvZiB0cmFuc0ZvclR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHQgPSBhd2FpdCB2ZXJpZnkodCk7XHJcbiAgICAgICAgICAgICAgICBpZih0LnZlcmlmaWVkID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICBmb3IobGV0IHJlY29yZElkIGluIHRyYW5zYWN0aW9uSWRzQnlSZWNvcmQpIHtcclxuICAgICAgICBjb25zdCB0cmFuc0lkc0ZvclJlY29yZCA9IHRyYW5zYWN0aW9uSWRzQnlSZWNvcmRbcmVjb3JkSWRdO1xyXG4gICAgICAgIGlmKHRyYW5zSWRzRm9yUmVjb3JkLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gYXdhaXQgdmVyaWZ5KHRyYW5zSWRzRm9yUmVjb3JkWzBdKTtcclxuICAgICAgICAgICAgaWYodC52ZXJpZmllZClcclxuICAgICAgICAgICAgICAgIGRlZHVwZWRUcmFuc2FjdGlvbnMucHVzaCh0KTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHNvbWUoaXNEZWxldGUpKHRyYW5zSWRzRm9yUmVjb3JkKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gYXdhaXQgdmVyaWZ5KGZpbmQoaXNEZWxldGUpKHRyYW5zSWRzRm9yUmVjb3JkKSk7XHJcbiAgICAgICAgICAgIGlmKHQudmVyaWZpZWQpXHJcbiAgICAgICAgICAgICAgICBkZWR1cGVkVHJhbnNhY3Rpb25zLnB1c2godCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihzb21lKGlzVXBkYXRlKSh0cmFuc0lkc0ZvclJlY29yZCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdXBkID0gYXdhaXQgcGlja09uZSh0cmFuc0lkc0ZvclJlY29yZCwgaXNVcGRhdGUpO1xyXG4gICAgICAgICAgICBpZihpc1NvbWV0aGluZyh1cGQpICYmIHVwZC52ZXJpZmllZClcclxuICAgICAgICAgICAgICAgIGRlZHVwZWRUcmFuc2FjdGlvbnMucHVzaCh1cGQpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoc29tZShpc0NyZWF0ZSkodHJhbnNJZHNGb3JSZWNvcmQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNyZSA9IGF3YWl0IHBpY2tPbmUodHJhbnNJZHNGb3JSZWNvcmQsIGlzQ3JlYXRlKTtcclxuICAgICAgICAgICAgaWYoaXNTb21ldGhpbmcoY3JlKSlcclxuICAgICAgICAgICAgICAgIGRlZHVwZWRUcmFuc2FjdGlvbnMucHVzaChjcmUpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHVwbGljYXRlcyA9ICQodHJhbnNhY3Rpb25JZHMsIFtcclxuICAgICAgICBmaWx0ZXIodCA9PiBub25lKGRkdCA9PiBkZHQudW5pcXVlSWQgPT09IHQudW5pcXVlSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgKGRlZHVwZWRUcmFuc2FjdGlvbnMpKVxyXG4gICAgXSk7XHJcblxyXG4gICAgXHJcblxyXG4gICAgY29uc3QgZGVsZXRlUHJvbWlzZXMgPSBcclxuICAgICAgICBtYXAodCA9PiBhcHAuZGF0YXN0b3JlLmRlbGV0ZUZpbGUoXHJcbiAgICAgICAgICAgICAgICAgICAgam9pbktleShcclxuICAgICAgICAgICAgICAgICAgICAgICAgVFJBTlNBQ1RJT05TX0ZPTERFUixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VHJhbnNhY3Rpb25JZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQucmVjb3JkSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnRyYW5zYWN0aW9uVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQudW5pcXVlSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKShkdXBsaWNhdGVzKTtcclxuXHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChkZWxldGVQcm9taXNlcyk7XHJcbiAgICBcclxuICAgIHJldHVybiBkZWR1cGVkVHJhbnNhY3Rpb25zO1xyXG59XHJcblxyXG5jb25zdCBwYXJzZVRyYW5zYWN0aW9uSWQgPSBpZCA9PiB7XHJcbiAgICBjb25zdCBzcGxpdElkID0gc3BsaXQoaWRTZXApKGlkKTtcclxuICAgIHJldHVybiAoe1xyXG4gICAgICAgIHJlY29yZElkOiBzcGxpdElkWzBdLFxyXG4gICAgICAgIHRyYW5zYWN0aW9uVHlwZTogc3BsaXRJZFsxXSxcclxuICAgICAgICB1bmlxdWVJZDogc3BsaXRJZFsyXSxcclxuICAgICAgICBmdWxsSWQ6IGlkXHJcbiAgICB9KTtcclxufTsiLCJpbXBvcnQge2pvaW5LZXksIHNwbGl0S2V5LCBpc05vbkVtcHR5U3RyaW5nLFxyXG4gICAgaXNOb3RoaW5nLCAkLCBpc1NvbWV0aGluZ30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge29yZGVyQnl9IGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHtyZWR1Y2UsIGZpbmQsIGluY2x1ZGVzLCBmbGF0dGVuLCB1bmlvbixcclxuICAgICAgICBmaWx0ZXIsIGVhY2gsIG1hcH0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5pbXBvcnQge2dldEZsYXR0ZW5lZEhpZXJhcmNoeSwgZ2V0Tm9kZSwgZ2V0UmVjb3JkTm9kZUlkLFxyXG4gICAgICAgIGdldEV4YWN0Tm9kZUZvclBhdGgsIHJlY29yZE5vZGVJZElzQWxsb3dlZCxcclxuICAgICAgICBpc1JlY29yZCwgaXNHbG9iYWxJbmRleH0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2hlaXJhcmNoeVwiO1xyXG5pbXBvcnQgeyBpbmRleFR5cGVzIH0gZnJvbSBcIi4uL3RlbXBsYXRlQXBpL2luZGV4ZXNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRSZWxldmFudEFuY2VzdG9ySW5kZXhlcyA9IChhcHBIZWlyYXJjaHksIHJlY29yZCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IGtleSA9IHJlY29yZC5rZXk7XHJcbiAgICBjb25zdCBrZXlQYXJ0cyA9IHNwbGl0S2V5KGtleSk7XHJcbiAgICBjb25zdCBub2RlSWQgPSBnZXRSZWNvcmROb2RlSWQoa2V5KTtcclxuXHJcbiAgICBjb25zdCBmbGF0SGVpcmFyY2h5ID0gXHJcbiAgICAgICAgb3JkZXJCeShnZXRGbGF0dGVuZWRIaWVyYXJjaHkoYXBwSGVpcmFyY2h5KSxcclxuICAgICAgICAgICAgICAgIFtub2RlID0+IG5vZGUucGF0aFJlZ3goKS5sZW5ndGhdLFxyXG4gICAgICAgICAgICAgICAgW1wiZGVzY1wiXSk7XHJcblxyXG4gICAgY29uc3QgbWFrZWluZGV4Tm9kZUFuZEtleV9Gb3JBbmNlc3RvckluZGV4ID0gKGluZGV4Tm9kZSwgaW5kZXhLZXkpID0+IFxyXG4gICAgICAgIG1ha2VJbmRleE5vZGVBbmRLZXkoaW5kZXhOb2RlLCBqb2luS2V5KGluZGV4S2V5LCBpbmRleE5vZGUubmFtZSkpO1xyXG5cclxuICAgIGNvbnN0IHRyYXZlcnNlQW5jZXN0b3JJbmRleGVzSW5QYXRoID0gKCkgPT4gXHJcbiAgICAgICAgcmVkdWNlKChhY2MsIHBhcnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudEluZGV4S2V5ID0gam9pbktleShhY2MubGFzdEluZGV4S2V5LCBwYXJ0KTtcclxuICAgICAgICAgICAgYWNjLmxhc3RJbmRleEtleSA9IGN1cnJlbnRJbmRleEtleTtcclxuICAgICAgICAgICAgY29uc3QgdGVzdFBhdGhSZWd4ID0gcCA9PiBcclxuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoYCR7cC5wYXRoUmVneCgpfSRgKS50ZXN0KGN1cnJlbnRJbmRleEtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVNYXRjaCA9IGZpbmQodGVzdFBhdGhSZWd4KShmbGF0SGVpcmFyY2h5KSAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgaWYoaXNOb3RoaW5nKG5vZGVNYXRjaCkpIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKCFpc1JlY29yZChub2RlTWF0Y2gpIFxyXG4gICAgICAgICAgICAgICAgfHwgbm9kZU1hdGNoLmluZGV4ZXMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZXMgPSAkKG5vZGVNYXRjaC5pbmRleGVzLCBbXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIoaSA9PiBpLmluZGV4VHlwZSA9PT0gaW5kZXhUeXBlcy5hbmNlc3RvciAmJiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGkuYWxsb3dlZFJlY29yZE5vZGVJZHMubGVuZ3RoID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB8fCBpbmNsdWRlcyhub2RlSWQpKGkuYWxsb3dlZFJlY29yZE5vZGVJZHMpKSlcclxuICAgICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgICBlYWNoKHYgPT4gXHJcbiAgICAgICAgICAgICAgICBhY2Mubm9kZXNBbmRLZXlzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgbWFrZWluZGV4Tm9kZUFuZEtleV9Gb3JBbmNlc3RvckluZGV4KHYsIGN1cnJlbnRJbmRleEtleSkpKVxyXG4gICAgICAgICAgICAoaW5kZXhlcyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYWNjOyAgICAgICAgICAgICBcclxuICAgICAgICB9LCB7bGFzdEluZGV4S2V5OlwiXCIsIG5vZGVzQW5kS2V5czpbXX0pXHJcbiAgICAgICAgKGtleVBhcnRzKS5ub2Rlc0FuZEtleXM7XHJcbiAgICBcclxuICAgIGNvbnN0IHJvb3RJbmRleGVzID0gJChmbGF0SGVpcmFyY2h5LCBbXHJcbiAgICAgICAgZmlsdGVyKG4gPT4gaXNHbG9iYWxJbmRleChuKSAmJiByZWNvcmROb2RlSWRJc0FsbG93ZWQobikobm9kZUlkKSksXHJcbiAgICAgICAgbWFwKGkgPT4gbWFrZUluZGV4Tm9kZUFuZEtleShpLCBpLm5vZGVLZXkoKSkpXHJcbiAgICBdKTtcclxuXHJcbiAgICByZXR1cm4gdW5pb24odHJhdmVyc2VBbmNlc3RvckluZGV4ZXNJblBhdGgoKSkocm9vdEluZGV4ZXMpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFJlbGV2YW50UmV2ZXJzZVJlZmVyZW5jZUluZGV4ZXMgPSAoYXBwSGVpcmFyY2h5LCByZWNvcmQpID0+IFxyXG4gICAgJChyZWNvcmQua2V5LCBbXHJcbiAgICAgICAgZ2V0RXhhY3ROb2RlRm9yUGF0aChhcHBIZWlyYXJjaHkpLFxyXG4gICAgICAgIG4gPT4gbi5maWVsZHMsXHJcbiAgICAgICAgZmlsdGVyKGYgPT4gZi50eXBlID09PSBcInJlZmVyZW5jZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgaXNTb21ldGhpbmcocmVjb3JkW2YubmFtZV0pXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgaXNOb25FbXB0eVN0cmluZyhyZWNvcmRbZi5uYW1lXS5rZXkpKSxcclxuICAgICAgICBtYXAoZiA9PiAkKGYudHlwZU9wdGlvbnMucmV2ZXJzZUluZGV4Tm9kZUtleXMsW1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcChuID0+ICh7cmVjb3JkTm9kZTogZ2V0Tm9kZShhcHBIZWlyYXJjaHksbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6Zn0pKVxyXG4gICAgICAgICAgICAgICAgIF0pKSxcclxuICAgICAgICBmbGF0dGVuLFxyXG4gICAgICAgIG1hcChuID0+IG1ha2VJbmRleE5vZGVBbmRLZXkoXHJcbiAgICAgICAgICAgIG4ucmVjb3JkTm9kZSwgXHJcbiAgICAgICAgICAgIGpvaW5LZXkocmVjb3JkW24uZmllbGQubmFtZV0ua2V5LCBuLnJlY29yZE5vZGUubmFtZSkpKSxcclxuICAgIF0pO1xyXG5cclxuY29uc3QgbWFrZUluZGV4Tm9kZUFuZEtleSA9IChpbmRleE5vZGUsIGluZGV4S2V5KSA9PiAoe2luZGV4Tm9kZSwgaW5kZXhLZXl9KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldFJlbGV2YW50QW5jZXN0b3JJbmRleGVzO1xyXG4iLCJpbXBvcnQge2dldFNoYXJkTWFwS2V5LCBlbnN1cmVTaGFyZE5hbWVJc0luU2hhcmRNYXB9IGZyb20gXCIuL3NoYXJkaW5nXCI7XG5pbXBvcnQge2dldEluZGV4V3JpdGVyfSBmcm9tIFwiLi9zZXJpYWxpemVyXCI7XG5pbXBvcnQgeyBpc1NoYXJkZWRJbmRleCB9IGZyb20gXCIuLi90ZW1wbGF0ZUFwaS9oZWlyYXJjaHlcIjtcblxuXG5leHBvcnQgY29uc3QgYXBwbHlUb1NoYXJkID0gYXN5bmMgKGhlaXJhcmNoeSwgc3RvcmUsIGluZGV4S2V5LCBcbiAgICAgICAgaW5kZXhOb2RlLCBpbmRleFNoYXJkS2V5LCByZWNvcmRzVG9Xcml0ZSwga2V5c1RvUmVtb3ZlKSA9PiB7XG5cbiAgICBjb25zdCBjcmVhdGVJZk5vdEV4aXN0cyA9IHJlY29yZHNUb1dyaXRlLmxlbmd0aCA+IDA7IFxuICAgIGNvbnN0IHdyaXRlciA9IGF3YWl0IGdldFdyaXRlcihoZWlyYXJjaHksIHN0b3JlLCBpbmRleEtleSwgaW5kZXhTaGFyZEtleSwgaW5kZXhOb2RlLCBjcmVhdGVJZk5vdEV4aXN0cyk7XG4gICAgaWYod3JpdGVyID09PSBTSEFSRF9ERUxFVEVEKSByZXR1cm47XG4gICAgXG4gICAgd3JpdGVyLnVwZGF0ZUluZGV4KHJlY29yZHNUb1dyaXRlLCBrZXlzVG9SZW1vdmUpO1xuICAgIGF3YWl0IHN3YXBUZW1wRmlsZUluKHN0b3JlLCBpbmRleFNoYXJkS2V5KTsgXG5cbn1cblxuY29uc3QgU0hBUkRfREVMRVRFRCA9IFwiU0hBUkRfREVMRVRFRFwiO1xuY29uc3QgZ2V0V3JpdGVyID0gYXN5bmMgKGhlaXJhcmNoeSwgc3RvcmUsIGluZGV4S2V5LCBpbmRleGVkRGF0YUtleSwgaW5kZXhOb2RlLCBjcmVhdGVJZk5vdEV4aXN0cykgPT4ge1xuXG4gICAgbGV0IHJlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICByZWFkYWJsZVN0cmVhbSA9IGF3YWl0IHN0b3JlLnJlYWRhYmxlRmlsZVN0cmVhbShpbmRleGVkRGF0YUtleSk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGlmKGF3YWl0IHN0b3JlLmV4aXN0cyhpbmRleGVkRGF0YUtleSkpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihjcmVhdGVJZk5vdEV4aXN0cylcbiAgICAgICAgICAgICAgICBhd2FpdCBzdG9yZS5jcmVhdGVGaWxlKGluZGV4ZWREYXRhS2V5LCBcIlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gU0hBUkRfREVMRVRFRDtcbiAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtID0gYXdhaXQgc3RvcmUucmVhZGFibGVGaWxlU3RyZWFtKGluZGV4ZWREYXRhS2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGlzU2hhcmRlZEluZGV4KGluZGV4Tm9kZSkpIHtcbiAgICAgICAgYXdhaXQgZW5zdXJlU2hhcmROYW1lSXNJblNoYXJkTWFwKHN0b3JlLCBpbmRleEtleSwgaW5kZXhlZERhdGFLZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IHdyaXRhYmxlU3RyZWFtID0gYXdhaXQgc3RvcmUud3JpdGFibGVGaWxlU3RyZWFtKGluZGV4ZWREYXRhS2V5ICsgXCIudGVtcFwiKTtcbiAgICBcbiAgICByZXR1cm4gZ2V0SW5kZXhXcml0ZXIoXG4gICAgICAgIGhlaXJhcmNoeSwgaW5kZXhOb2RlLCBcbiAgICAgICAgKCkgPT4gcmVhZGFibGVTdHJlYW0ucmVhZCgpLFxuICAgICAgICAoYnVmZmVyKSA9PiB3cml0YWJsZVN0cmVhbS53cml0ZShidWZmZXIpXG4gICAgKTtcbn07XG5cbmNvbnN0IHN3YXBUZW1wRmlsZUluID0gYXN5bmMgKHN0b3JlLCBpbmRleGVkRGF0YUtleSwgaXNSZXRyeT1mYWxzZSkgPT4ge1xuICAgIGNvbnN0IHRlbXBGaWxlID0gaW5kZXhlZERhdGFLZXkgKyBcIi50ZW1wXCI7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgc3RvcmUuZGVsZXRlRmlsZShpbmRleGVkRGF0YUtleSk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIGlnbm9yZSBmYWlsdXJlLCBpbmNhc2UgaXQgaGFzIG5vdCBiZWVuIGNyZWF0ZWQgeWV0XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHN0b3JlLnJlbmFtZUZpbGUodGVtcEZpbGUsIGluZGV4ZWREYXRhS2V5KTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLy8gcmV0cnlpbmcgaW4gY2FzZSBkZWxldGUgZmFpbHVyZSB3YXMgZm9yIHNvbWUgb3RoZXIgcmVhc29uXG4gICAgICAgIGlmKCFpc1JldHJ5KSB7XG4gICAgICAgICAgICBhd2FpdCBzd2FwVGVtcEZpbGVJbihzdG9yZSwgaW5kZXhlZERhdGFLZXksIHRydWUpO1xuICAgICAgICB9XG5cbiAgICB9XG59IDsiLCJpbXBvcnQge2dldFJlbGV2YW50QW5jZXN0b3JJbmRleGVzLFxyXG4gICAgZ2V0UmVsZXZhbnRSZXZlcnNlUmVmZXJlbmNlSW5kZXhlc30gZnJvbSBcIi4uL2luZGV4aW5nL3JlbGV2YW50XCI7XHJcbmltcG9ydCB7ZXZhbHVhdGV9IGZyb20gXCIuLi9pbmRleGluZy9ldmFsdWF0ZVwiO1xyXG5pbXBvcnQgeyQkLCAkLCBpc1NvbWV0aGluZywgXHJcbiAgICAgICAgaXNOb25FbXB0eUFycmF5LCBqb2luS2V5LCBcclxuICAgICAgICBpc05vbkVtcHR5U3RyaW5nfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7ZmlsdGVyLCBtYXAsIGlzVW5kZWZpbmVkLCBpbmNsdWRlcyxcclxuICAgICAgICBmbGF0dGVuLCBpbnRlcnNlY3Rpb25CeSxcclxuICAgICAgICBpc0VxdWFsLCBwdWxsLCBrZXlzLCBcclxuICAgICAgICBkaWZmZXJlbmNlQnksIGRpZmZlcmVuY2V9IGZyb20gXCJsb2Rhc2gvZnBcIjtcclxuaW1wb3J0IHt1bmlvbn0gZnJvbSBcImxvZGFzaFwiO1xyXG5pbXBvcnQge2dldEluZGV4ZWREYXRhS2V5fSBmcm9tIFwiLi4vaW5kZXhpbmcvc2hhcmRpbmdcIjtcclxuaW1wb3J0IHtpc1VwZGF0ZSwgaXNDcmVhdGUsIFxyXG4gICAgICAgIGlzRGVsZXRlLCBpc0J1aWxkSW5kZXh9IGZyb20gXCIuL3RyYW5zYWN0aW9uc0NvbW1vblwiO1xyXG5pbXBvcnQgeyBhcHBseVRvU2hhcmQgfSBmcm9tIFwiLi4vaW5kZXhpbmcvYXBwbHlcIjtcclxuaW1wb3J0IHtnZXRBY3R1YWxLZXlPZlBhcmVudCxcclxuICAgICAgICBpc0dsb2JhbEluZGV4LCBmaWVsZFJldmVyc2VzUmVmZXJlbmNlVG9JbmRleCwgaXNSZWZlcmVuY2VJbmRleCxcclxuICAgICAgICBnZXRFeGFjdE5vZGVGb3JQYXRofSBmcm9tIFwiLi4vdGVtcGxhdGVBcGkvaGVpcmFyY2h5XCI7XHJcblxyXG5leHBvcnQgY29uc3QgZXhlY3V0ZVRyYW5zYWN0aW9ucyA9ICBhcHAgPT4gYXN5bmMgdHJhbnNhY3Rpb25zID0+IHtcclxuICAgIGNvbnN0IHJlY29yZHNCeVNoYXJkID0gbWFwcGVkUmVjb3Jkc0J5SW5kZXhTaGFyZChhcHAuaGVpcmFyY2h5LCB0cmFuc2FjdGlvbnMpOyAgICAgICAgIFxyXG5cclxuICAgIGZvcihsZXQgc2hhcmQgb2Yga2V5cyhyZWNvcmRzQnlTaGFyZCkpIHtcclxuICAgICAgICBhd2FpdCBhcHBseVRvU2hhcmQoXHJcbiAgICAgICAgICAgIGFwcC5oZWlyYXJjaHksIGFwcC5kYXRhc3RvcmUsXHJcbiAgICAgICAgICAgIHJlY29yZHNCeVNoYXJkW3NoYXJkXS5pbmRleEtleSxcclxuICAgICAgICAgICAgcmVjb3Jkc0J5U2hhcmRbc2hhcmRdLmluZGV4Tm9kZSxcclxuICAgICAgICAgICAgc2hhcmQsXHJcbiAgICAgICAgICAgIHJlY29yZHNCeVNoYXJkW3NoYXJkXS53cml0ZXMsXHJcbiAgICAgICAgICAgIHJlY29yZHNCeVNoYXJkW3NoYXJkXS5yZW1vdmVzXHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBtYXBwZWRSZWNvcmRzQnlJbmRleFNoYXJkID0gKGhlaXJhcmNoeSwgdHJhbnNhY3Rpb25zKSA9PiB7XHJcblxyXG4gICAgY29uc3QgdXBkYXRlcyA9IGdldFVwZGF0ZVRyYW5zYWN0aW9uc0J5U2hhcmQoXHJcbiAgICAgICAgaGVpcmFyY2h5LCB0cmFuc2FjdGlvbnNcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgY3JlYXRlZCA9IGdldENyZWF0ZVRyYW5zYWN0aW9uc0J5U2hhcmQoXHJcbiAgICAgICAgaGVpcmFyY2h5LCB0cmFuc2FjdGlvbnNcclxuICAgICk7XHJcbiAgICBjb25zdCBkZWxldGVzID0gZ2V0RGVsZXRlVHJhbnNhY3Rpb25zQnlTaGFyZChcclxuICAgICAgICBoZWlyYXJjaHksIHRyYW5zYWN0aW9uc1xyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBpbmRleEJ1aWxkID0gZ2V0QnVpbGRJbmRleFRyYW5zYWN0aW9uc0J5U2hhcmQoXHJcbiAgICAgICAgaGVpcmFyY2h5LFxyXG4gICAgICAgIHRyYW5zYWN0aW9uc1xyXG4gICAgKTtcclxuICAgIFxyXG4gICAgY29uc3QgdG9SZW1vdmUgPSBbXHJcbiAgICAgICAgLi4uZGVsZXRlcyxcclxuICAgICAgICAuLi51cGRhdGVzLnRvUmVtb3ZlXHJcbiAgICBdO1xyXG5cclxuICAgIGNvbnN0IHRvV3JpdGUgPSBbXHJcbiAgICAgICAgLi4uY3JlYXRlZCxcclxuICAgICAgICAuLi51cGRhdGVzLnRvV3JpdGUsXHJcbiAgICAgICAgLi4uaW5kZXhCdWlsZFxyXG4gICAgXTtcclxuXHJcbiAgICBjb25zdCB0cmFuc0J5U2hhcmQgPSB7fTtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsaXNlU2hhcmQgPSB0ID0+IHtcclxuICAgICAgICBpZihpc1VuZGVmaW5lZCh0cmFuc0J5U2hhcmRbdC5pbmRleFNoYXJkS2V5XSkpXHJcbiAgICAgICAgICAgIHRyYW5zQnlTaGFyZFt0LmluZGV4U2hhcmRLZXldID0ge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVzOltdLCBcclxuICAgICAgICAgICAgICAgIHJlbW92ZXM6W10sXHJcbiAgICAgICAgICAgICAgICBpbmRleEtleTp0LmluZGV4S2V5LFxyXG4gICAgICAgICAgICAgICAgaW5kZXhOb2RlS2V5OnQuaW5kZXhOb2RlS2V5LFxyXG4gICAgICAgICAgICAgICAgaW5kZXhOb2RlOnQuaW5kZXhOb2RlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yKGxldCB0cmFucyBvZiB0b1dyaXRlKSB7XHJcbiAgICAgICAgaW5pdGlhbGlzZVNoYXJkKHRyYW5zKTsgICAgICAgIFxyXG4gICAgICAgIHRyYW5zQnlTaGFyZFt0cmFucy5pbmRleFNoYXJkS2V5XS53cml0ZXMucHVzaChcclxuICAgICAgICAgICAgdHJhbnMubWFwcGVkUmVjb3JkLnJlc3VsdCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yKGxldCB0cmFucyBvZiB0b1JlbW92ZSkge1xyXG4gICAgICAgIGluaXRpYWxpc2VTaGFyZCh0cmFucyk7ICAgICAgICBcclxuICAgICAgICB0cmFuc0J5U2hhcmRbdHJhbnMuaW5kZXhTaGFyZEtleV0ucmVtb3Zlcy5wdXNoKFxyXG4gICAgICAgICAgICB0cmFucy5tYXBwZWRSZWNvcmQucmVzdWx0LmtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRyYW5zQnlTaGFyZDtcclxufSAgXHJcblxyXG5jb25zdCBnZXRVcGRhdGVUcmFuc2FjdGlvbnNCeVNoYXJkID0gKGhlaXJhcmNoeSwgdHJhbnNhY3Rpb25zKSA9PiB7XHJcbiAgICBjb25zdCB1cGRhdGVUcmFuc2FjdGlvbnMgPSAkKHRyYW5zYWN0aW9ucywgW2ZpbHRlcihpc1VwZGF0ZSldKTtcclxuXHJcbiAgICBjb25zdCBldmFsdWF0ZUluZGV4ID0gKHJlY29yZCwgaW5kZXhOb2RlQW5kUGF0aCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1hcHBlZFJlY29yZCA9IGV2YWx1YXRlKHJlY29yZCkoaW5kZXhOb2RlQW5kUGF0aC5pbmRleE5vZGUpO1xyXG4gICAgICAgIHJldHVybiAoe21hcHBlZFJlY29yZDptYXBwZWRSZWNvcmQsIFxyXG4gICAgICAgIGluZGV4Tm9kZTppbmRleE5vZGVBbmRQYXRoLmluZGV4Tm9kZSwgXHJcbiAgICAgICAgaW5kZXhLZXk6aW5kZXhOb2RlQW5kUGF0aC5pbmRleEtleSxcclxuICAgICAgICBpbmRleFNoYXJkS2V5OmdldEluZGV4ZWREYXRhS2V5KFxyXG4gICAgICAgICAgICBpbmRleE5vZGVBbmRQYXRoLmluZGV4Tm9kZSxcclxuICAgICAgICAgICAgaW5kZXhOb2RlQW5kUGF0aC5pbmRleEtleSxcclxuICAgICAgICAgICAgbWFwcGVkUmVjb3JkLnJlc3VsdClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBnZXRJbmRleE5vZGVzVG9BcHBseSA9IChpbmRleEZpbHRlcikgPT4gKHQsaW5kZXhlcykgPT4gXHJcbiAgICAgICAgJChpbmRleGVzLCBbXHJcbiAgICAgICAgICAgIG1hcChuID0+ICh7XHJcbiAgICAgICAgICAgICAgICBvbGQ6ZXZhbHVhdGVJbmRleCh0Lm9sZFJlY29yZCwgbiksXHJcbiAgICAgICAgICAgICAgICBuZXc6ZXZhbHVhdGVJbmRleCh0LnJlY29yZCwgbil9KSksXHJcbiAgICAgICAgICAgIGZpbHRlcihpbmRleEZpbHRlcilcclxuICAgICAgICBdKTtcclxuXHJcbiAgICBjb25zdCB0b1JlbW92ZUZpbHRlciA9IChuLCBpc1VucmVmZXJlbmNlZCkgPT4gXHJcbiAgICAgICAgbi5vbGQubWFwcGVkUmVjb3JkLnBhc3NlZEZpbHRlciA9PT0gdHJ1ZVxyXG4gICAgICAgICYmIChuLm5ldy5tYXBwZWRSZWNvcmQucGFzc2VkRmlsdGVyID09PSBmYWxzZVxyXG4gICAgICAgICAgICB8fCBpc1VucmVmZXJlbmNlZCk7XHJcblxyXG4gICAgY29uc3QgdG9BZGRGaWx0ZXIgPSAobiwgaXNOZXdseVJlZmVyZW5jZWQpID0+IFxyXG4gICAgICAgIChuLm9sZC5tYXBwZWRSZWNvcmQucGFzc2VkRmlsdGVyID09PSBmYWxzZVxyXG4gICAgICAgIHx8IGlzTmV3bHlSZWZlcmVuY2VkKVxyXG4gICAgICAgICYmIG4ubmV3Lm1hcHBlZFJlY29yZC5wYXNzZWRGaWx0ZXIgPT09IHRydWU7XHJcblxyXG4gICAgY29uc3QgdG9VcGRhdGVGaWx0ZXIgPSBuID0+IFxyXG4gICAgICAgIG4ubmV3Lm1hcHBlZFJlY29yZC5wYXNzZWRGaWx0ZXIgPT09IHRydWVcclxuICAgICAgICAmJiBuLm9sZC5tYXBwZWRSZWNvcmQucGFzc2VkRmlsdGVyID09PSB0cnVlXHJcbiAgICAgICAgJiYgIWlzRXF1YWwobi5vbGQubWFwcGVkUmVjb3JkLnJlc3VsdCwgXHJcbiAgICAgICAgICAgICAgICAgICAgbi5uZXcubWFwcGVkUmVjb3JkLnJlc3VsdCk7XHJcblxyXG4gICAgY29uc3QgdG9SZW1vdmUgPSBbXTtcclxuICAgIGNvbnN0IHRvV3JpdGUgPSBbXTtcclxuXHJcbiAgICBmb3IobGV0IHQgb2YgdXBkYXRlVHJhbnNhY3Rpb25zKSB7XHJcbiAgICAgICAgY29uc3QgYW5jZXN0b3JJZHhzID0gZ2V0UmVsZXZhbnRBbmNlc3RvckluZGV4ZXMoXHJcbiAgICAgICAgICAgIGhlaXJhcmNoeSwgdC5yZWNvcmQpO1xyXG5cclxuICAgICAgICBjb25zdCByZWZlcmVuY2VDaGFuZ2VzID0gZGlmZlJldmVyc2VSZWZGb3JVcGRhdGUoXHJcbiAgICAgICAgICAgIGhlaXJhcmNoeSwgdC5vbGRSZWNvcmQsIHQucmVjb3JkKTtcclxuXHJcbiAgICAgICAgLy8gb2xkIHJlY29yZHMgdG8gcmVtb3ZlIChmaWx0ZXJlZCBvdXQpXHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWRPdXRfdG9SZW1vdmUgPVxyXG4gICAgICAgICAgICB1bmlvbihcclxuICAgICAgICAgICAgICAgIGdldEluZGV4Tm9kZXNUb0FwcGx5KHRvUmVtb3ZlRmlsdGVyKSh0LCBhbmNlc3RvcklkeHMpLFxyXG4gICAgICAgICAgICAgICAgLy8gc3RpbGwgcmVmZXJlbmNlZCAtIGNoZWNrIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgZ2V0SW5kZXhOb2Rlc1RvQXBwbHkodG9SZW1vdmVGaWx0ZXIpKHQsIHJlZmVyZW5jZUNoYW5nZXMubm90Q2hhbmdlZCksXHJcbiAgICAgICAgICAgICAgICAvLyB1biByZWZlcmVuY2VkIC0gcmVtb3ZlIGlmIGluIHRoZXJlIGFscmVhZHlcclxuICAgICAgICAgICAgICAgIGdldEluZGV4Tm9kZXNUb0FwcGx5KG4gPT4gdG9SZW1vdmVGaWx0ZXIobix0cnVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHQsIHJlZmVyZW5jZUNoYW5nZXMudW5SZWZlcmVuY2VkKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBuZXcgcmVjb3JkcyB0byBhZGQgKGZpbHRlcmVkIGluKVxyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkSW5fdG9BZGQgPVxyXG4gICAgICAgICAgICB1bmlvbihcclxuICAgICAgICAgICAgICAgIGdldEluZGV4Tm9kZXNUb0FwcGx5KHRvQWRkRmlsdGVyKSh0LCBhbmNlc3RvcklkeHMpLFxyXG4gICAgICAgICAgICAgICAgLy8gbmV3bHkgcmVmZXJlbmNlZCAtIGNoZWNrIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgZ2V0SW5kZXhOb2Rlc1RvQXBwbHkobiA9PiB0b0FkZEZpbHRlcihuLHRydWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodCwgcmVmZXJlbmNlQ2hhbmdlcy5uZXdseVJlZmVyZW5jZWQpLFxyXG4gICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlIHVuY2hhbmdlZCAtIHJlcnVuIGZpbHRlciBpbiBjYXNlIHNvbWV0aGluZyBlbHNlIGNoYW5nZWRcclxuICAgICAgICAgICAgICAgIGdldEluZGV4Tm9kZXNUb0FwcGx5KHRvQWRkRmlsdGVyKSh0LCByZWZlcmVuY2VDaGFuZ2VzLm5vdENoYW5nZWQpLFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBjaGFuZ2VkID0gXHJcbiAgICAgICAgICAgIHVuaW9uKFxyXG4gICAgICAgICAgICAgICAgZ2V0SW5kZXhOb2Rlc1RvQXBwbHkodG9VcGRhdGVGaWx0ZXIpKHQsIGFuY2VzdG9ySWR4cyksXHJcbiAgICAgICAgICAgICAgICAvLyBzdGlsbCByZWZlcmVuY2VkIC0gcmVjaGVjayBmaWx0ZXJcclxuICAgICAgICAgICAgICAgIGdldEluZGV4Tm9kZXNUb0FwcGx5KHRvVXBkYXRlRmlsdGVyKSh0LCByZWZlcmVuY2VDaGFuZ2VzLm5vdENoYW5nZWQpLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHNoYXJkS2V5Q2hhbmdlZCA9ICQoY2hhbmdlZCxbXHJcbiAgICAgICAgICAgIGZpbHRlcihjID0+IGMub2xkLmluZGV4U2hhcmRLZXkgIT09IGMubmV3LmluZGV4U2hhcmRLZXkpXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNoYW5nZWRJblNhbWVTaGFyZCA9ICQoc2hhcmRLZXlDaGFuZ2VkLCBbXHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UoY2hhbmdlZClcclxuICAgICAgICBdKVxyXG5cclxuICAgICAgICBmb3IobGV0IHJlcyBvZiBzaGFyZEtleUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgcHVsbChyZXMpKGNoYW5nZWQpO1xyXG4gICAgICAgICAgICBmaWx0ZXJlZE91dF90b1JlbW92ZS5wdXNoKHJlcyk7XHJcbiAgICAgICAgICAgIGZpbHRlcmVkSW5fdG9BZGQucHVzaChyZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdG9SZW1vdmUucHVzaChcclxuICAgICAgICAgICAgJChmaWx0ZXJlZE91dF90b1JlbW92ZSxbXHJcbiAgICAgICAgICAgICAgICBtYXAoaSA9PiBpLm9sZClcclxuICAgICAgICAgICAgXSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0b1dyaXRlLnB1c2goXHJcbiAgICAgICAgICAgICQoZmlsdGVyZWRJbl90b0FkZCwgW1xyXG4gICAgICAgICAgICAgICAgbWFwKGkgPT4gaS5uZXcpXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdG9Xcml0ZS5wdXNoKFxyXG4gICAgICAgICAgICAkKGNoYW5nZWRJblNhbWVTaGFyZCwgW1xyXG4gICAgICAgICAgICAgICAgbWFwKGkgPT4gaS5uZXcpXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKHtcclxuICAgICAgICB0b1JlbW92ZTogZmxhdHRlbih0b1JlbW92ZSksXHJcbiAgICAgICAgdG9Xcml0ZTogZmxhdHRlbih0b1dyaXRlKVxyXG4gICAgfSk7XHJcbiAgICBcclxufTtcclxuXHJcbmNvbnN0IGdldEJ1aWxkSW5kZXhUcmFuc2FjdGlvbnNCeVNoYXJkID0gIChoZWlyYXJjaHksIHRyYW5zYWN0aW9ucykgPT4ge1xyXG4gICAgY29uc3QgYnVpbGRUcmFuc2FjdGlvbnMgPSAkKHRyYW5zYWN0aW9ucywgW2ZpbHRlcihpc0J1aWxkSW5kZXgpXSk7XHJcbiAgICBpZighaXNOb25FbXB0eUFycmF5KGJ1aWxkVHJhbnNhY3Rpb25zKSkgcmV0dXJuIFtdO1xyXG4gICAgY29uc3QgaW5kZXhOb2RlID0gdHJhbnNhY3Rpb25zLmluZGV4Tm9kZTtcclxuXHJcbiAgICBjb25zdCBnZXRJbmRleEtleXMgPSAodCkgPT4ge1xyXG4gICAgICAgIGlmKGlzR2xvYmFsSW5kZXgoaW5kZXhOb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW2luZGV4Tm9kZS5ub2RlS2V5KCldO1xyXG4gICAgICAgIH0gXHJcblxyXG4gICAgICAgIGlmKGlzUmVmZXJlbmNlSW5kZXgoaW5kZXhOb2RlKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZWNvcmROb2RlID0gZ2V0RXhhY3ROb2RlRm9yUGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaGVpcmFyY2h5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodC5yZWNvcmQua2V5KTtcclxuICAgICAgICAgICAgY29uc3QgcmVmRmllbGRzID0gJChyZWNvcmROb2RlLmZpZWxkcywgW1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyKGZpZWxkUmV2ZXJzZXNSZWZlcmVuY2VUb0luZGV4KGluZGV4Tm9kZSkpXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4S2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IobGV0IHJlZkZpZWxkIG9mIHJlZkZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVmVmFsdWUgPSB0LnJlY29yZFtyZWZGaWVsZC5uYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmKGlzU29tZXRoaW5nKHJlZlZhbHVlKSBcclxuICAgICAgICAgICAgICAgICAgICYmIGlzTm9uRW1wdHlTdHJpbmcocmVmVmFsdWUua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4S2V5ID0gam9pbktleShcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmVmFsdWUua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleE5vZGUubmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFpbmNsdWRlcyhpbmRleEtleSkoaW5kZXhLZXlzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhLZXlzLnB1c2goaW5kZXhLZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleEtleXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gW2pvaW5LZXkoXHJcbiAgICAgICAgICAgIGdldEFjdHVhbEtleU9mUGFyZW50KFxyXG4gICAgICAgICAgICAgICAgaW5kZXhOb2RlLnBhcmVudCgpLm5vZGVLZXkoKSxcclxuICAgICAgICAgICAgICAgIHQucmVjb3JkLmtleVxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBpbmRleE5vZGUubmFtZVxyXG4gICAgICAgICldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAkKGJ1aWxkVHJhbnNhY3Rpb25zLCBbXHJcbiAgICAgICAgbWFwKHQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXBwZWRSZWNvcmQgPSBldmFsdWF0ZSh0LnJlY29yZCkoaW5kZXhOb2RlKTtcclxuICAgICAgICAgICAgaWYoIW1hcHBlZFJlY29yZC5wYXNzZWRGaWx0ZXIpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleEtleXMgPSBnZXRJbmRleEtleXModCk7XHJcbiAgICAgICAgICAgIHJldHVybiAkKGluZGV4S2V5cywgW1xyXG4gICAgICAgICAgICAgICAgbWFwKGluZGV4S2V5ID0+ICh7bWFwcGVkUmVjb3JkLCBcclxuICAgICAgICAgICAgICAgIGluZGV4Tm9kZTppbmRleE5vZGUsIFxyXG4gICAgICAgICAgICAgICAgaW5kZXhLZXk6aW5kZXhLZXksXHJcbiAgICAgICAgICAgICAgICBpbmRleFNoYXJkS2V5OmdldEluZGV4ZWREYXRhS2V5KFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleEtleSxcclxuICAgICAgICAgICAgICAgICAgICBtYXBwZWRSZWNvcmQucmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGZsYXR0ZW4sXHJcbiAgICAgICAgZmlsdGVyKGlzU29tZXRoaW5nKVxyXG4gICAgXSk7XHJcbn1cclxuXHJcbmNvbnN0IGdldF9DcmVhdGVfRGVsZXRlX1RyYW5zYWN0aW9uc0J5U2hhcmQgPSBwcmVkID0+IChoZWlyYXJjaHksIHRyYW5zYWN0aW9ucykgPT4ge1xyXG4gICAgY29uc3QgY3JlYXRlVHJhbnNhY3Rpb25zID0gJCh0cmFuc2FjdGlvbnMsIFtmaWx0ZXIocHJlZCldKTtcclxuXHJcbiAgICBjb25zdCBnZXRJbmRleE5vZGVzVG9BcHBseSA9ICh0LGluZGV4ZXMpID0+IFxyXG4gICAgICAgICQoaW5kZXhlcywgW1xyXG4gICAgICAgICAgICBtYXAobiA9PiB7IFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkUmVjb3JkID0gZXZhbHVhdGUodC5yZWNvcmQpKG4uaW5kZXhOb2RlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoe21hcHBlZFJlY29yZCwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Tm9kZTpuLmluZGV4Tm9kZSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4S2V5Om4uaW5kZXhLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4U2hhcmRLZXk6Z2V0SW5kZXhlZERhdGFLZXkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmluZGV4Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uaW5kZXhLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWRSZWNvcmQucmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGZpbHRlcihuID0+IG4ubWFwcGVkUmVjb3JkLnBhc3NlZEZpbHRlcilcclxuICAgICAgICBdKTtcclxuXHJcbiAgICBjb25zdCBhbGxUb0FwcGx5ID0gW107XHJcblxyXG4gICAgZm9yKGxldCB0IG9mIGNyZWF0ZVRyYW5zYWN0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGFuY2VzdG9ySWR4cyA9IFxyXG4gICAgICAgICAgICBnZXRSZWxldmFudEFuY2VzdG9ySW5kZXhlcyhoZWlyYXJjaHksIHQucmVjb3JkKTtcclxuICAgICAgICBjb25zdCByZXZlcnNlUmVmID0gXHJcbiAgICAgICAgICAgIGdldFJlbGV2YW50UmV2ZXJzZVJlZmVyZW5jZUluZGV4ZXMoaGVpcmFyY2h5LCB0LnJlY29yZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYWxsVG9BcHBseS5wdXNoKFxyXG4gICAgICAgICAgICBnZXRJbmRleE5vZGVzVG9BcHBseSh0LCBhbmNlc3RvcklkeHMpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhbGxUb0FwcGx5LnB1c2goXHJcbiAgICAgICAgICAgIGdldEluZGV4Tm9kZXNUb0FwcGx5KHQsIHJldmVyc2VSZWYpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmxhdHRlbihhbGxUb0FwcGx5KTtcclxufVxyXG5cclxuY29uc3QgZ2V0RGVsZXRlVHJhbnNhY3Rpb25zQnlTaGFyZCA9IFxyXG4gICAgZ2V0X0NyZWF0ZV9EZWxldGVfVHJhbnNhY3Rpb25zQnlTaGFyZChpc0RlbGV0ZSk7XHJcblxyXG5jb25zdCBnZXRDcmVhdGVUcmFuc2FjdGlvbnNCeVNoYXJkID0gXHJcbiAgICBnZXRfQ3JlYXRlX0RlbGV0ZV9UcmFuc2FjdGlvbnNCeVNoYXJkKGlzQ3JlYXRlKTtcclxuXHJcbmNvbnN0IGRpZmZSZXZlcnNlUmVmRm9yVXBkYXRlID0gKGFwcEhlaXJhcmNoeSwgb2xkUmVjb3JkLCBuZXdSZWNvcmQpID0+IHtcclxuICAgIGNvbnN0IG9sZEluZGV4ZXMgPSBnZXRSZWxldmFudFJldmVyc2VSZWZlcmVuY2VJbmRleGVzKFxyXG4gICAgICAgIGFwcEhlaXJhcmNoeSwgb2xkUmVjb3JkXHJcbiAgICApO1xyXG4gICAgY29uc3QgbmV3SW5kZXhlcyA9IGdldFJlbGV2YW50UmV2ZXJzZVJlZmVyZW5jZUluZGV4ZXMoXHJcbiAgICAgICAgYXBwSGVpcmFyY2h5LCBuZXdSZWNvcmRcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgdW5SZWZlcmVuY2VkID0gZGlmZmVyZW5jZUJ5KFxyXG4gICAgICAgIGkgPT4gaS5pbmRleEtleSxcclxuICAgICAgICBvbGRJbmRleGVzLCBuZXdJbmRleGVzXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IG5ld2x5UmVmZXJlbmNlZCA9IGRpZmZlcmVuY2VCeShcclxuICAgICAgICBpID0+IGkuaW5kZXhLZXksXHJcbiAgICAgICAgbmV3SW5kZXhlcywgb2xkSW5kZXhlc1xyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBub3RDaGFuZ2VkID0gIGludGVyc2VjdGlvbkJ5KFxyXG4gICAgICAgIGkgPT4gaS5pbmRleEtleSxcclxuICAgICAgICBuZXdJbmRleGVzLCBvbGRJbmRleGVzXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiAge1xyXG4gICAgICAgIHVuUmVmZXJlbmNlZCxcclxuICAgICAgICBuZXdseVJlZmVyZW5jZWQsXHJcbiAgICAgICAgbm90Q2hhbmdlZFxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcbiIsImltcG9ydCB7cmV0cmlldmV9IGZyb20gXCIuL3JldHJpZXZlXCI7XHJcbmltcG9ydCB7ZXhlY3V0ZVRyYW5zYWN0aW9uc30gZnJvbSBcIi4vZXhlY3V0ZVwiO1xyXG5pbXBvcnQge21hcH0gZnJvbSBcImxvZGFzaC9mcFwiO1xyXG5pbXBvcnQge2dlbmVyYXRlfSBmcm9tIFwic2hvcnRpZFwiO1xyXG5pbXBvcnQgeyQsIGpvaW5LZXksIGdldExvY2ssIGlzTm9sb2NrLCByZWxlYXNlTG9ja30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5pbXBvcnQge0xPQ0tfRklMRV9LRVksIFRSQU5TQUNUSU9OU19GT0xERVIsIFxyXG4gICAgdGltZW91dE1pbGxpc2Vjb25kcywgcGFyc2VMb2NrRmlsZUNvbnRlbnQsIFxyXG4gICAgZ2V0TG9ja0ZpbGVDb250ZW50LCBnZXRUcmFuc2FjdGlvbklkLFxyXG4gICAgbWF4TG9ja1JldHJpZXN9IGZyb20gXCIuL3RyYW5zYWN0aW9uc0NvbW1vblwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNsZWFudXAgPSBhc3luYyBhcHAgPT4ge1xyXG5cclxuICAgIGNvbnN0IGxvY2sgPSBhd2FpdCBnZXRUcmFuc2FjdGlvbkxvY2soYXBwKTtcclxuICAgIGlmKGlzTm9sb2NrKGxvY2spKSByZXR1cm47XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBhd2FpdCByZXRyaWV2ZShhcHApO1xyXG4gICAgICAgIGlmKHRyYW5zYWN0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGVUcmFuc2FjdGlvbnMoYXBwKSh0cmFuc2FjdGlvbnMpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgZm9sZGVyID0gdHJhbnNhY3Rpb25zLmZvbGRlcktleSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2FjdGlvbnMuZm9sZGVyS2V5IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6IFRSQU5TQUNUSU9OU19GT0xERVI7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBkZWxldGVGaWxlcyA9ICQodHJhbnNhY3Rpb25zLCBbXHJcbiAgICAgICAgICAgICAgICBtYXAodCA9PiBqb2luS2V5KFxyXG4gICAgICAgICAgICAgICAgICAgIGZvbGRlcixcclxuICAgICAgICAgICAgICAgICAgICBnZXRUcmFuc2FjdGlvbklkKFxyXG4gICAgICAgICAgICAgICAgICAgIHQucmVjb3JkSWQsIHQudHJhbnNhY3Rpb25UeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHQudW5pcXVlSWQpXHJcbiAgICAgICAgICAgICAgICApKSxcclxuICAgICAgICAgICAgICAgIG1hcChhcHAuZGF0YXN0b3JlLmRlbGV0ZUZpbGUpXHJcbiAgICAgICAgICAgIF0pO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZGVsZXRlRmlsZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIGF3YWl0IHJlbGVhc2VMb2NrKGFwcCwgbG9jayk7XHJcbiAgICB9XHJcbiAgICBcclxufVxyXG5cclxuY29uc3QgZ2V0VHJhbnNhY3Rpb25Mb2NrID0gYXN5bmMgYXBwID0+IFxyXG4gICAgYXdhaXQgZ2V0TG9jayhcclxuICAgICAgICBhcHAsIExPQ0tfRklMRV9LRVksXHJcbiAgICAgICAgdGltZW91dE1pbGxpc2Vjb25kcywgbWF4TG9ja1JldHJpZXNcclxuICAgICk7IiwiXHJcbmV4cG9ydCBjb25zdCBnZXRCZWhhdmlvdXJTb3VyY2VzID0gYXN5bmMgZGF0YXN0b3JlID0+IFxyXG4gICAgYXdhaXQgZGF0YXN0b3JlLmxvYWRGaWxlKFwiLy5jb25maWcvYmVoYXZpb3VyU291cmNlcy5qc1wiKTtcclxuIiwiaW1wb3J0IHtjb25maWdGb2xkZXIsIGFwcERlZmluaXRpb25GaWxlLCAkfSBmcm9tIFwiLi4vY29tbW9uXCI7XHJcbmltcG9ydCB7VFJBTlNBQ1RJT05TX0ZPTERFUn0gZnJvbSBcIi4uL3RyYW5zYWN0aW9ucy90cmFuc2FjdGlvbnNDb21tb25cIjtcclxuaW1wb3J0IHtBVVRIX0ZPTERFUiwgVVNFUlNfTElTVF9GSUxFLCBBQ0NFU1NfTEVWRUxTX0ZJTEV9IGZyb20gXCIuLi9hdXRoQXBpL2F1dGhDb21tb25cIjtcclxuaW1wb3J0IHtpbml0aWFsaXNlUm9vdENvbGxlY3Rpb25zfSBmcm9tIFwiLi4vY29sbGVjdGlvbkFwaS9pbml0aWFsaXNlXCI7XHJcbmltcG9ydCB7aW5pdGlhbGlzZUluZGV4fSBmcm9tIFwiLi4vaW5kZXhpbmcvaW5pdGlhbGlzZUluZGV4XCI7XHJcbmltcG9ydCB7Z2V0RmxhdHRlbmVkSGllcmFyY2h5LCBpc0dsb2JhbEluZGV4fSBmcm9tIFwiLi4vdGVtcGxhdGVBcGkvaGVpcmFyY2h5XCI7XHJcbmltcG9ydCB7ZmlsdGVyfSBmcm9tIFwibG9kYXNoL2ZwXCI7XHJcblxyXG5leHBvcnQgY29uc3QgaW5pdGlhbGlzZURhdGEgPSBhc3luYyAoZGF0YXN0b3JlLCBhcHBsaWNhdGlvbkRlZmluaXRpb24pID0+IHtcclxuICAgIGF3YWl0IGRhdGFzdG9yZS5jcmVhdGVGb2xkZXIoY29uZmlnRm9sZGVyKTtcclxuICAgIGF3YWl0IGRhdGFzdG9yZS5jcmVhdGVKc29uKGFwcERlZmluaXRpb25GaWxlLCBhcHBsaWNhdGlvbkRlZmluaXRpb24pO1xyXG5cclxuICAgIGF3YWl0IGluaXRpYWxpc2VSb290Q29sbGVjdGlvbnMoZGF0YXN0b3JlLCBhcHBsaWNhdGlvbkRlZmluaXRpb24uaGVpcmFyY2h5KTtcclxuICAgIGF3YWl0IGluaXRpYWxpc2VSb290SW5kZXhlcyhkYXRhc3RvcmUsIGFwcGxpY2F0aW9uRGVmaW5pdGlvbi5oZWlyYXJjaHkpO1xyXG4gICAgYXdhaXQgZGF0YXN0b3JlLmNyZWF0ZUZvbGRlcihUUkFOU0FDVElPTlNfRk9MREVSKTtcclxuXHJcbiAgICBhd2FpdCBkYXRhc3RvcmUuY3JlYXRlRm9sZGVyKEFVVEhfRk9MREVSKTtcclxuXHJcbiAgICBhd2FpdCBkYXRhc3RvcmUuY3JlYXRlSnNvbihVU0VSU19MSVNUX0ZJTEUsIFtdKTtcclxuXHJcbiAgICBhd2FpdCBkYXRhc3RvcmUuY3JlYXRlSnNvbihBQ0NFU1NfTEVWRUxTX0ZJTEUsIHt2ZXJzaW9uOjAsbGV2ZWxzOltdfSk7XHJcbn1cclxuXHJcbmNvbnN0IGluaXRpYWxpc2VSb290SW5kZXhlcyA9IGFzeW5jIChkYXRhc3RvcmUsIGhlaXJhcmNoeSkgPT4ge1xyXG5cclxuICAgIGNvbnN0IGZsYXRoZWlyYXJjaHkgPSBnZXRGbGF0dGVuZWRIaWVyYXJjaHkoaGVpcmFyY2h5KTtcclxuICAgIGNvbnN0IGdsb2JhbEluZGV4ZXMgPSAkKGZsYXRoZWlyYXJjaHksIFtcclxuICAgICAgICBmaWx0ZXIoaXNHbG9iYWxJbmRleClcclxuICAgIF0pO1xyXG5cclxuICAgIGZvcihsZXQgaW5kZXggb2YgZ2xvYmFsSW5kZXhlcykge1xyXG4gICAgICAgIGlmKCFhd2FpdCBkYXRhc3RvcmUuZXhpc3RzKGluZGV4Lm5vZGVLZXkoKSkpXHJcbiAgICAgICAgICAgIGF3YWl0IGluaXRpYWxpc2VJbmRleChkYXRhc3RvcmUsIFwiXCIsIGluZGV4KTtcclxuICAgIH0gXHJcbn0iLCJpbXBvcnQge2lzTm90aGluZ30gZnJvbSBcIi4uL2NvbW1vblwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldERhdGFiYXNlTWFuYWdlciA9IGRhdGFiYXNlTWFuYWdlciA9PiAoe1xyXG4gICAgY3JlYXRlRW1wdHlNYXN0ZXJEYjogY3JlYXRlRW1wdHlNYXN0ZXJEYihkYXRhYmFzZU1hbmFnZXIpLFxyXG4gICAgY3JlYXRlRW1wdHlQcm9kdWN0U2V0RGI6IGNyZWF0ZUVtcHR5UHJvZHVjdFNldERiKGRhdGFiYXNlTWFuYWdlciksXHJcbiAgICBjcmVhdGVFbXB0eVByb2R1Y3RJbnN0YW5jZURiOiBjcmVhdGVFbXB0eVByb2R1Y3RJbnN0YW5jZURiKGRhdGFiYXNlTWFuYWdlciksXHJcbiAgICBnZXRQcm9kdWN0U2V0RGJSb290Q29uZmlnOiBkYXRhYmFzZU1hbmFnZXIuZ2V0UHJvZHVjdFNldERiUm9vdENvbmZpZyxcclxuICAgIGdldFByb2R1Y3RJbnN0YW5jZURiUm9vdENvbmZpZzogZGF0YWJhc2VNYW5hZ2VyLmdldFByb2R1Y3RJbnN0YW5jZURiUm9vdENvbmZpZyxcclxuICAgIG1hc3RlckRhdGFzdG9yZUNvbmZpZzogZ2V0TWFzdGVyRGF0YXN0b3JlQ29uZmlnKGRhdGFiYXNlTWFuYWdlciksXHJcbiAgICBnZXRQcm9kdWN0U2V0RGF0YXN0b3JlQ29uZmlnOiBnZXRQcm9kdWN0U2V0RGF0YXN0b3JlQ29uZmlnKGRhdGFiYXNlTWFuYWdlciksXHJcbiAgICBnZXRQcm9kdWN0SW5zdGFuY2VEYXRhc3RvcmVDb25maWc6IGdldFByb2R1Y3RJbnN0YW5jZURhdGFzdG9yZUNvbmZpZyhkYXRhYmFzZU1hbmFnZXIpXHJcbn0pO1xyXG5cclxuY29uc3QgZ2V0TWFzdGVyRGF0YXN0b3JlQ29uZmlnID0gZGF0YWJhc2VNYW5hZ2VyID0+IFxyXG4gICAgZGF0YWJhc2VNYW5hZ2VyLmdldERhdGFzdG9yZUNvbmZpZyhcclxuICAgICAgICBkYXRhYmFzZU1hbmFnZXIuZ2V0TWFzdGVyRGJSb290Q29uZmlnLFxyXG4gICAgICAgIFwibWFzdGVyXCJcclxuICAgICk7XHJcblxyXG5jb25zdCBnZXRQcm9kdWN0U2V0RGF0YXN0b3JlQ29uZmlnID0gZGF0YWJhc2VNYW5hZ2VyID0+IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGJSb290Q29uZmlnLCBwcm9kdWN0U2V0SWQpID0+IFxyXG4gICAgZGF0YWJhc2VNYW5hZ2VyLmdldERhdGFzdG9yZUNvbmZpZyhcclxuICAgICAgICBkYlJvb3RDb25maWcsIFwicHJvZHVjdHNldFwiLCBwcm9kdWN0U2V0SWRcclxuICAgICk7XHJcblxyXG5jb25zdCBnZXRQcm9kdWN0SW5zdGFuY2VEYXRhc3RvcmVDb25maWcgPSBkYXRhYmFzZU1hbmFnZXIgPT4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGJSb290Q29uZmlnLCBwcm9kdWN0U2V0SWQsIHByb2R1Y3RJZCwgcHJvZHVjdEluc3RhbmNlSWQpID0+IFxyXG4gICAgZGF0YWJhc2VNYW5hZ2VyLmdldERhdGFzdG9yZUNvbmZpZyhcclxuICAgICAgICBkYlJvb3RDb25maWcsIFwicHJvZHVjdGluc3RhbmNlXCIsXHJcbiAgICAgICAgcHJvZHVjdFNldElkLCBwcm9kdWN0SWQsIHByb2R1Y3RJbnN0YW5jZUlkXHJcbiAgICApO1xyXG5cclxuY29uc3QgY3JlYXRlRW1wdHlNYXN0ZXJEYiA9IGRhdGFiYXNlTWFuYWdlciA9PiBhc3luYyAoKSA9PiAgXHJcbiAgICBhd2FpdCBkYXRhYmFzZU1hbmFnZXIuY3JlYXRlRW1wdHlEYihcclxuICAgICAgICBkYXRhYmFzZU1hbmFnZXIuZ2V0TWFzdGVyRGJSb290Q29uZmlnKCksXHJcbiAgICAgICAgXCJtYXN0ZXJcIlxyXG4gICAgKTtcclxuXHJcblxyXG5jb25zdCBjcmVhdGVFbXB0eVByb2R1Y3RTZXREYiA9IGRhdGFiYXNlTWFuYWdlciA9PiBhc3luYyAocHJvZHVjdFNldElkKSA9PiB7XHJcbiAgICBcclxuICAgIGlmKGlzTm90aGluZyhwcm9kdWN0U2V0SWQpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNyZWF0ZURiOiBQcm9kdWN0IFNldCBJZCBub3Qgc3VwcGxpZWRcIik7XHJcbiAgICBcclxuICAgIHJldHVybiBhd2FpdCBkYXRhYmFzZU1hbmFnZXIuY3JlYXRlRW1wdHlEYihcclxuICAgICAgICBkYXRhYmFzZU1hbmFnZXIuZ2V0UHJvZHVjdFNldERiUm9vdENvbmZpZyhwcm9kdWN0U2V0SWQpLCBcclxuICAgICAgICBcInByb2R1Y3RzZXRcIiwgcHJvZHVjdFNldElkKTtcclxufVxyXG5cclxuXHJcbmNvbnN0IGNyZWF0ZUVtcHR5UHJvZHVjdEluc3RhbmNlRGIgPSBkYXRhYmFzZU1hbmFnZXIgPT4gYXN5bmMgKHByb2R1Y3RTZXRJZCwgcHJvZHVjdElkLCBwcm9kdWN0SW5zdGFuY2VJZCkgPT4ge1xyXG4gICAgXHJcbiAgICBpZihpc05vdGhpbmcocHJvZHVjdFNldElkKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcmVhdGVEYjogUHJvZHVjdCBTZXQgSWQgbm90IHN1cHBsaWVkXCIpO1xyXG4gICAgaWYoaXNOb3RoaW5nKHByb2R1Y3RJZCkpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3JlYXRlRGI6IFByb2R1Y3QgSWQgbm90IHN1cHBsaWVkXCIpO1xyXG4gICAgaWYoaXNOb3RoaW5nKHByb2R1Y3RJbnN0YW5jZUlkKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcmVhdGVEYjogUHJvZHVjdCBJbnN0YW5jZSBJZCBub3Qgc3VwcGxpZWRcIik7XHJcblxyXG4gICAgcmV0dXJuIGF3YWl0IGRhdGFiYXNlTWFuYWdlci5jcmVhdGVFbXB0eURiKFxyXG4gICAgICAgIGRhdGFiYXNlTWFuYWdlci5nZXRQcm9kdWN0SW5zdGFuY2VEYlJvb3RDb25maWcocHJvZHVjdFNldElkLCBwcm9kdWN0SWQsIHByb2R1Y3RJbnN0YW5jZUlkKSwgXHJcbiAgICAgICAgXCJwcm9kdWN0aW5zdGFuY2VcIiwgXHJcbiAgICAgICAgcHJvZHVjdFNldElkLCBwcm9kdWN0SWQsIHByb2R1Y3RJbnN0YW5jZUlkKTtcclxufVxyXG4iLCJpbXBvcnQgZ2V0UmVjb3JkQXBpIGZyb20gXCIuL3JlY29yZEFwaVwiO1xuaW1wb3J0IGdldENvbGxlY3Rpb25BcGkgZnJvbSBcIi4vY29sbGVjdGlvbkFwaVwiO1xuaW1wb3J0IGdldEluZGV4QXBpIGZyb20gXCIuL2luZGV4QXBpXCI7XG5pbXBvcnQgZ2V0VGVtcGxhdGVBcGkgZnJvbSBcIi4vdGVtcGxhdGVBcGlcIjtcbmltcG9ydCBnZXRBdXRoQXBpIGZyb20gXCIuL2F1dGhBcGlcIjtcbmltcG9ydCBnZXRBY3Rpb25zQXBpIGZyb20gXCIuL2FjdGlvbnNBcGlcIjtcbmltcG9ydCB7c2V0dXBEYXRhc3RvcmUsIGNyZWF0ZUV2ZW50QWdncmVnYXRvcn0gZnJvbSBcIi4vYXBwSW5pdGlhbGlzZVwiO1xuaW1wb3J0IHtpbml0aWFsaXNlQWN0aW9uc30gZnJvbSBcIi4vYWN0aW9uc0FwaS9pbml0aWFsaXNlXCJcbmltcG9ydCB7aXNTb21ldGhpbmd9IGZyb20gXCIuL2NvbW1vblwiO1xuaW1wb3J0IHtjbGVhbnVwfSBmcm9tIFwiLi90cmFuc2FjdGlvbnMvY2xlYW51cFwiO1xuaW1wb3J0IHtnZW5lcmF0ZUZ1bGxQZXJtaXNzaW9uc30gZnJvbSBcIi4vYXV0aEFwaS9nZW5lcmF0ZUZ1bGxQZXJtaXNzaW9uc1wiO1xuaW1wb3J0IHtnZXRBcHBsaWNhdGlvbkRlZmluaXRpb259IGZyb20gXCIuL3RlbXBsYXRlQXBpL2dldEFwcGxpY2F0aW9uRGVmaW5pdGlvblwiO1xuaW1wb3J0IGNvbW1vbiBmcm9tIFwiLi9jb21tb25cIjtcbmltcG9ydCB7Z2V0QmVoYXZpb3VyU291cmNlc30gZnJvbSBcIi4vdGVtcGxhdGVBcGkvZ2V0QmVoYXZpb3VyU291cmNlc1wiO1xuaW1wb3J0IGhpZXJhcmNoeSBmcm9tIFwiLi90ZW1wbGF0ZUFwaS9oZWlyYXJjaHlcIjtcblxuZXhwb3J0IGNvbnN0IGdldEFwcEFwaXMgPSBhc3luYyAoc3RvcmUsIGJlaGF2aW91clNvdXJjZXMgPSBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cFRyYW5zYWN0aW9ucyA9IG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRFcG9jaFRpbWUgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcnlwdG8gPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBEZWZpbml0aW9uID0gbnVsbCkgPT4ge1xuXG4gICAgc3RvcmUgPSBzZXR1cERhdGFzdG9yZShzdG9yZSk7XG4gICAgXG4gICAgaWYoIWFwcERlZmluaXRpb24pXG4gICAgICAgIGFwcERlZmluaXRpb24gPSBhd2FpdCBnZXRBcHBsaWNhdGlvbkRlZmluaXRpb24oc3RvcmUpKCk7XG5cbiAgICBpZighYmVoYXZpb3VyU291cmNlcylcbiAgICAgICAgYmVoYXZpb3VyU291cmNlcyA9IGF3YWl0IGdldEJlaGF2aW91clNvdXJjZXMoc3RvcmUpO1xuXG4gICAgY29uc3QgZXZlbnRBZ2dyZWdhdG9yID0gY3JlYXRlRXZlbnRBZ2dyZWdhdG9yKCk7XG5cbiAgICBjb25zdCBhcHAgPSB7XG4gICAgICAgIGRhdGFzdG9yZTpzdG9yZSxcbiAgICAgICAgY3J5cHRvLFxuICAgICAgICBwdWJsaXNoOmV2ZW50QWdncmVnYXRvci5wdWJsaXNoLFxuICAgICAgICBoZWlyYXJjaHk6YXBwRGVmaW5pdGlvbi5oZWlyYXJjaHksXG4gICAgICAgIGFjdGlvbnM6YXBwRGVmaW5pdGlvbi5hY3Rpb25zXG4gICAgfTtcblxuICAgIGNvbnN0IHRlbXBsYXRlQXBpID0gZ2V0VGVtcGxhdGVBcGkoYXBwKTsgICAgXG5cbiAgICBjb25zdCBhY3Rpb25zID0gaW5pdGlhbGlzZUFjdGlvbnMoXG4gICAgICAgIGV2ZW50QWdncmVnYXRvci5zdWJzY3JpYmUsXG4gICAgICAgIGJlaGF2aW91clNvdXJjZXMsXG4gICAgICAgIGFwcERlZmluaXRpb24uYWN0aW9ucyxcbiAgICAgICAgYXBwRGVmaW5pdGlvbi50cmlnZ2Vycyk7XG5cbiAgICBhcHAuY2xlYW51cFRyYW5zYWN0aW9ucyA9IGlzU29tZXRoaW5nKGNsZWFudXBUcmFuc2FjdGlvbnMpIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjbGVhbnVwVHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFzeW5jICgpID0+IGNsZWFudXAoYXBwKTtcblxuICAgIGFwcC5nZXRFcG9jaFRpbWUgPSBpc1NvbWV0aGluZyhnZXRFcG9jaFRpbWUpXG4gICAgICAgICAgICAgICAgICAgICAgID8gZ2V0RXBvY2hUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgIDogYXN5bmMgKCkgPT4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIGNvbnN0IHJlY29yZEFwaSA9IGdldFJlY29yZEFwaShhcHApO1xuICAgIGNvbnN0IGNvbGxlY3Rpb25BcGkgPSBnZXRDb2xsZWN0aW9uQXBpKGFwcCk7XG4gICAgY29uc3QgaW5kZXhBcGkgPSBnZXRJbmRleEFwaShhcHApO1xuICAgIGNvbnN0IGF1dGhBcGkgPSBnZXRBdXRoQXBpKGFwcCk7XG4gICAgY29uc3QgYWN0aW9uc0FwaSA9IGdldEFjdGlvbnNBcGkoYXBwKTtcblxuICAgIGNvbnN0IGF1dGhlbnRpY2F0ZUFzID0gYXN5bmMgKHVzZXJuYW1lLCBwYXNzd29yZCkgPT4ge1xuICAgICAgICBhcHAudXNlciA9IGF3YWl0IGF1dGhBcGkuYXV0aGVudGljYXRlKHVzZXJuYW1lLCBwYXNzd29yZCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHdpdGhGdWxsQWNjZXNzID0gKCkgPT4ge1xuICAgICAgICBhcHAudXNlciA9IHtcbiAgICAgICAgICAgIG5hbWU6IFwiYXBwXCIsXG4gICAgICAgICAgICBwZXJtaXNzaW9ucyA6IGdlbmVyYXRlRnVsbFBlcm1pc3Npb25zKGFwcCksXG4gICAgICAgICAgICBpc1VzZXI6ZmFsc2UsXG4gICAgICAgICAgICB0ZW1wOmZhbHNlXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYXNVc2VyID0gKHVzZXIpID0+IHtcbiAgICAgICAgYXBwLnVzZXIgPSB1c2VyXG4gICAgfTtcblxuICAgIHJldHVybiAoe1xuICAgICAgICByZWNvcmRBcGksIFxuICAgICAgICB0ZW1wbGF0ZUFwaSxcbiAgICAgICAgY29sbGVjdGlvbkFwaSxcbiAgICAgICAgaW5kZXhBcGksXG4gICAgICAgIGF1dGhBcGksXG4gICAgICAgIGFjdGlvbnNBcGksXG4gICAgICAgIHN1YnNjcmliZTogZXZlbnRBZ2dyZWdhdG9yLnN1YnNjcmliZSxcbiAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgYXV0aGVudGljYXRlQXMsXG4gICAgICAgIHdpdGhGdWxsQWNjZXNzLFxuICAgICAgICBhc1VzZXJcbiAgICB9KTtcbn07XG5cbmV4cG9ydCB7ZXZlbnRzLCBldmVudHNMaXN0fSBmcm9tIFwiLi9jb21tb24vZXZlbnRzXCI7XG5leHBvcnQge2dldFRlbXBsYXRlQXBpfSBmcm9tIFwiLi90ZW1wbGF0ZUFwaVwiO1xuZXhwb3J0IHtnZXRSZWNvcmRBcGl9IGZyb20gXCIuL3JlY29yZEFwaVwiO1xuZXhwb3J0IHtnZXRDb2xsZWN0aW9uQXBpfSBmcm9tIFwiLi9jb2xsZWN0aW9uQXBpXCI7XG5leHBvcnQge2dldEluZGV4QXBpfSBmcm9tIFwiLi9pbmRleEFwaVwiO1xuZXhwb3J0IHtzZXR1cERhdGFzdG9yZX0gZnJvbSBcIi4vYXBwSW5pdGlhbGlzZVwiO1xuZXhwb3J0IHtnZXRBY3Rpb25zQXBpfSBmcm9tIFwiLi9hY3Rpb25zQXBpXCI7XG5leHBvcnQge2luaXRpYWxpc2VEYXRhfSBmcm9tIFwiLi9hcHBJbml0aWFsaXNlL2luaXRpYWxpc2VEYXRhXCI7XG5leHBvcnQge2dldERhdGFiYXNlTWFuYWdlcn0gZnJvbSBcIi4vYXBwSW5pdGlhbGlzZS9kYXRhYmFzZU1hbmFnZXJcIjtcbmV4cG9ydCB7aGllcmFyY2h5fTtcbmV4cG9ydCB7Y29tbW9ufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0QXBwQXBpczsiXSwibmFtZXMiOlsidW5pb24iLCJyZWR1Y2UiLCJnZW5lcmF0ZSIsImlzVW5kZWZpbmVkIiwiY2xvbmVEZWVwIiwiZ2V0TG9jayIsIk5PX0xPQ0siLCJfIiwic3BsaXQiLCJyZWxlYXNlTG9jayIsImlzTm9sb2NrIiwiZmxvdyIsInRyaW0iLCJyZXBsYWNlIiwiaXNBcnJheSIsImpvaW4iLCJkcm9wUmlnaHQiLCJ0YWtlUmlnaHQiLCJoZWFkIiwiaXNOdWxsIiwiaXNOYU4iLCJpc0VtcHR5IiwiY29uc3RhbnQiLCJzb21lIiwiaXNTdHJpbmciLCJ0YWlsIiwiaW5jbHVkZXMiLCJzdGFydHNXaXRoIiwiZmluZEluZGV4IiwiaXNJbnRlZ2VyIiwiaXNEYXRlIiwidG9OdW1iZXIiLCJtYXAiLCJmaWx0ZXIiLCJpbmRleCIsImNvbXBpbGVFeHByZXNzaW9uIiwiY29tcGlsZUNvZGUiLCJjbG9uZSIsImtleXMiLCJpc0Z1bmN0aW9uIiwiY291bnRCeSIsImxhc3QiLCJmaW5kIiwidGFrZSIsImZpcnN0IiwiaW50ZXJzZWN0aW9uIiwiaGFzIiwibWVyZ2UiLCJtYXBWYWx1ZXMiLCJtYWtlcnVsZSIsImlzQm9vbGVhbiIsIm9wdGlvbnMiLCJ0eXBlQ29uc3RyYWludHMiLCJpc051bWJlciIsInBhdGgiLCJpc09iamVjdExpa2UiLCJhc3NpZ24iLCJhbGwiLCJnZXREZWZhdWx0T3B0aW9ucyIsInZhbGlkYXRlVHlwZUNvbnN0cmFpbnRzIiwiaXNPYmplY3QiLCJ2YWx1ZXMiLCJrZXlCeSIsImhlaXJhcmNoeSIsIm9yZGVyQnkiLCJjb25jYXQiLCJyZXZlcnNlIiwiZGlmZmVyZW5jZSIsIkJ1ZmZlciIsIlN0cmluZ0RlY29kZXIiLCJyZWFkSW5kZXgiLCJmbGF0dGVuIiwiZWFjaCIsInB1bGwiLCJ0aW1lb3V0TWlsbGlzZWNvbmRzIiwiZGVsZXRlUmVjb3JkIiwidmFsaWRhdGUiLCJkZWZhdWx0Q2FzZSIsImV2ZXJ5IiwiZmllbGRFcnJvcnMiLCJ1bmlxQnkiLCJhcGkiLCJjcmVhdGVUZW1wb3JhcnlBY2Nlc3MiLCJjcmVhdGVVc2VyIiwidW5pcVdpdGgiLCJzZXRVc2VyQWNjZXNzTGV2ZWxzIiwiZXhlY3V0ZUFjdGlvbiIsImJ1aWxkSW5kZXhGb2xkZXIiLCJncm91cEJ5IiwiaXNFcXVhbCIsImRpZmZlcmVuY2VCeSIsImludGVyc2VjdGlvbkJ5IiwiZ2V0QmVoYXZpb3VyU291cmNlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0lBRUEsTUFBTSxVQUFVLEdBQUcsQ0FBQyxLQUFLO0lBQ3pCLElBQUlBLFFBQUssQ0FBQyxDQUFDLFNBQVMsRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDL0MsS0FBSyxLQUFLLENBQUMsQ0FBQzs7SUFFWixNQUFNLE1BQU0sR0FBRyxNQUFNLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7SUFFcEMsTUFBTSxPQUFPLEdBQUc7SUFDaEIsSUFBSSxTQUFTLEdBQUc7SUFDaEIsUUFB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


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/flatpickr/dist/flatpickr.css":
/*!*****************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/flatpickr/dist/flatpickr.css ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".flatpickr-calendar {\n  background: transparent;\n  opacity: 0;\n  display: none;\n  text-align: center;\n  visibility: hidden;\n  padding: 0;\n  -webkit-animation: none;\n          animation: none;\n  direction: ltr;\n  border: 0;\n  font-size: 14px;\n  line-height: 24px;\n  border-radius: 5px;\n  position: absolute;\n  width: 307.875px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -ms-touch-action: manipulation;\n      touch-action: manipulation;\n  background: #fff;\n  -webkit-box-shadow: 1px 0 0 #e6e6e6, -1px 0 0 #e6e6e6, 0 1px 0 #e6e6e6, 0 -1px 0 #e6e6e6, 0 3px 13px rgba(0,0,0,0.08);\n          box-shadow: 1px 0 0 #e6e6e6, -1px 0 0 #e6e6e6, 0 1px 0 #e6e6e6, 0 -1px 0 #e6e6e6, 0 3px 13px rgba(0,0,0,0.08);\n}\n.flatpickr-calendar.open,\n.flatpickr-calendar.inline {\n  opacity: 1;\n  max-height: 640px;\n  visibility: visible;\n}\n.flatpickr-calendar.open {\n  display: inline-block;\n  z-index: 99999;\n}\n.flatpickr-calendar.animate.open {\n  -webkit-animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n          animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n}\n.flatpickr-calendar.inline {\n  display: block;\n  position: relative;\n  top: 2px;\n}\n.flatpickr-calendar.static {\n  position: absolute;\n  top: calc(100% + 2px);\n}\n.flatpickr-calendar.static.open {\n  z-index: 999;\n  display: block;\n}\n.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+1) .flatpickr-day.inRange:nth-child(7n+7) {\n  -webkit-box-shadow: none !important;\n          box-shadow: none !important;\n}\n.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+2) .flatpickr-day.inRange:nth-child(7n+1) {\n  -webkit-box-shadow: -2px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n          box-shadow: -2px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n}\n.flatpickr-calendar .hasWeeks .dayContainer,\n.flatpickr-calendar .hasTime .dayContainer {\n  border-bottom: 0;\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.flatpickr-calendar .hasWeeks .dayContainer {\n  border-left: 0;\n}\n.flatpickr-calendar.showTimeInput.hasTime .flatpickr-time {\n  height: 40px;\n  border-top: 1px solid #e6e6e6;\n}\n.flatpickr-calendar.noCalendar.hasTime .flatpickr-time {\n  height: auto;\n}\n.flatpickr-calendar:before,\n.flatpickr-calendar:after {\n  position: absolute;\n  display: block;\n  pointer-events: none;\n  border: solid transparent;\n  content: '';\n  height: 0;\n  width: 0;\n  left: 22px;\n}\n.flatpickr-calendar.rightMost:before,\n.flatpickr-calendar.rightMost:after {\n  left: auto;\n  right: 22px;\n}\n.flatpickr-calendar:before {\n  border-width: 5px;\n  margin: 0 -5px;\n}\n.flatpickr-calendar:after {\n  border-width: 4px;\n  margin: 0 -4px;\n}\n.flatpickr-calendar.arrowTop:before,\n.flatpickr-calendar.arrowTop:after {\n  bottom: 100%;\n}\n.flatpickr-calendar.arrowTop:before {\n  border-bottom-color: #e6e6e6;\n}\n.flatpickr-calendar.arrowTop:after {\n  border-bottom-color: #fff;\n}\n.flatpickr-calendar.arrowBottom:before,\n.flatpickr-calendar.arrowBottom:after {\n  top: 100%;\n}\n.flatpickr-calendar.arrowBottom:before {\n  border-top-color: #e6e6e6;\n}\n.flatpickr-calendar.arrowBottom:after {\n  border-top-color: #fff;\n}\n.flatpickr-calendar:focus {\n  outline: 0;\n}\n.flatpickr-wrapper {\n  position: relative;\n  display: inline-block;\n}\n.flatpickr-months {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.flatpickr-months .flatpickr-month {\n  background: transparent;\n  color: rgba(0,0,0,0.9);\n  fill: rgba(0,0,0,0.9);\n  height: 28px;\n  line-height: 1;\n  text-align: center;\n  position: relative;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  overflow: hidden;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n}\n.flatpickr-months .flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month {\n  text-decoration: none;\n  cursor: pointer;\n  position: absolute;\n  top: 0px;\n  line-height: 16px;\n  height: 28px;\n  padding: 10px;\n  z-index: 3;\n  color: rgba(0,0,0,0.9);\n  fill: rgba(0,0,0,0.9);\n}\n.flatpickr-months .flatpickr-prev-month.disabled,\n.flatpickr-months .flatpickr-next-month.disabled {\n  display: none;\n}\n.flatpickr-months .flatpickr-prev-month i,\n.flatpickr-months .flatpickr-next-month i {\n  position: relative;\n}\n.flatpickr-months .flatpickr-prev-month.flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-prev-month {\n/*\n      /*rtl:begin:ignore*/\n/*\n      */\n  left: 0;\n/*\n      /*rtl:end:ignore*/\n/*\n      */\n}\n/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month.flatpickr-next-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-next-month {\n/*\n      /*rtl:begin:ignore*/\n/*\n      */\n  right: 0;\n/*\n      /*rtl:end:ignore*/\n/*\n      */\n}\n/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month:hover,\n.flatpickr-months .flatpickr-next-month:hover {\n  color: #959ea9;\n}\n.flatpickr-months .flatpickr-prev-month:hover svg,\n.flatpickr-months .flatpickr-next-month:hover svg {\n  fill: #f64747;\n}\n.flatpickr-months .flatpickr-prev-month svg,\n.flatpickr-months .flatpickr-next-month svg {\n  width: 14px;\n  height: 14px;\n}\n.flatpickr-months .flatpickr-prev-month svg path,\n.flatpickr-months .flatpickr-next-month svg path {\n  -webkit-transition: fill 0.1s;\n  transition: fill 0.1s;\n  fill: inherit;\n}\n.numInputWrapper {\n  position: relative;\n  height: auto;\n}\n.numInputWrapper input,\n.numInputWrapper span {\n  display: inline-block;\n}\n.numInputWrapper input {\n  width: 100%;\n}\n.numInputWrapper input::-ms-clear {\n  display: none;\n}\n.numInputWrapper input::-webkit-outer-spin-button,\n.numInputWrapper input::-webkit-inner-spin-button {\n  margin: 0;\n  -webkit-appearance: none;\n}\n.numInputWrapper span {\n  position: absolute;\n  right: 0;\n  width: 14px;\n  padding: 0 4px 0 2px;\n  height: 50%;\n  line-height: 50%;\n  opacity: 0;\n  cursor: pointer;\n  border: 1px solid rgba(57,57,57,0.15);\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.numInputWrapper span:hover {\n  background: rgba(0,0,0,0.1);\n}\n.numInputWrapper span:active {\n  background: rgba(0,0,0,0.2);\n}\n.numInputWrapper span:after {\n  display: block;\n  content: \"\";\n  position: absolute;\n}\n.numInputWrapper span.arrowUp {\n  top: 0;\n  border-bottom: 0;\n}\n.numInputWrapper span.arrowUp:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-bottom: 4px solid rgba(57,57,57,0.6);\n  top: 26%;\n}\n.numInputWrapper span.arrowDown {\n  top: 50%;\n}\n.numInputWrapper span.arrowDown:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 4px solid rgba(57,57,57,0.6);\n  top: 40%;\n}\n.numInputWrapper span svg {\n  width: inherit;\n  height: auto;\n}\n.numInputWrapper span svg path {\n  fill: rgba(0,0,0,0.5);\n}\n.numInputWrapper:hover {\n  background: rgba(0,0,0,0.05);\n}\n.numInputWrapper:hover span {\n  opacity: 1;\n}\n.flatpickr-current-month {\n  font-size: 135%;\n  line-height: inherit;\n  font-weight: 300;\n  color: inherit;\n  position: absolute;\n  width: 75%;\n  left: 12.5%;\n  padding: 6.16px 0 0 0;\n  line-height: 1;\n  height: 28px;\n  display: inline-block;\n  text-align: center;\n  -webkit-transform: translate3d(0px, 0px, 0px);\n          transform: translate3d(0px, 0px, 0px);\n}\n.flatpickr-current-month span.cur-month {\n  font-family: inherit;\n  font-weight: 700;\n  color: inherit;\n  display: inline-block;\n  margin-left: 0.5ch;\n  padding: 0;\n}\n.flatpickr-current-month span.cur-month:hover {\n  background: rgba(0,0,0,0.05);\n}\n.flatpickr-current-month .numInputWrapper {\n  width: 6ch;\n  width: 7ch\\0;\n  display: inline-block;\n}\n.flatpickr-current-month .numInputWrapper span.arrowUp:after {\n  border-bottom-color: rgba(0,0,0,0.9);\n}\n.flatpickr-current-month .numInputWrapper span.arrowDown:after {\n  border-top-color: rgba(0,0,0,0.9);\n}\n.flatpickr-current-month input.cur-year {\n  background: transparent;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: inherit;\n  cursor: text;\n  padding: 0 0 0 0.5ch;\n  margin: 0;\n  display: inline-block;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: 300;\n  line-height: inherit;\n  height: auto;\n  border: 0;\n  border-radius: 0;\n  vertical-align: initial;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n}\n.flatpickr-current-month input.cur-year:focus {\n  outline: 0;\n}\n.flatpickr-current-month input.cur-year[disabled],\n.flatpickr-current-month input.cur-year[disabled]:hover {\n  font-size: 100%;\n  color: rgba(0,0,0,0.5);\n  background: transparent;\n  pointer-events: none;\n}\n.flatpickr-weekdays {\n  background: transparent;\n  text-align: center;\n  overflow: hidden;\n  width: 100%;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  height: 28px;\n}\n.flatpickr-weekdays .flatpickr-weekdaycontainer {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n}\nspan.flatpickr-weekday {\n  cursor: default;\n  font-size: 90%;\n  background: transparent;\n  color: rgba(0,0,0,0.54);\n  line-height: 1;\n  margin: 0;\n  text-align: center;\n  display: block;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  font-weight: bolder;\n}\n.dayContainer,\n.flatpickr-weeks {\n  padding: 1px 0 0 0;\n}\n.flatpickr-days {\n  position: relative;\n  overflow: hidden;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: start;\n  -webkit-align-items: flex-start;\n      -ms-flex-align: start;\n          align-items: flex-start;\n  width: 307.875px;\n}\n.flatpickr-days:focus {\n  outline: 0;\n}\n.dayContainer {\n  padding: 0;\n  outline: 0;\n  text-align: left;\n  width: 307.875px;\n  min-width: 307.875px;\n  max-width: 307.875px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  display: inline-block;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n          flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  -ms-flex-pack: justify;\n  -webkit-justify-content: space-around;\n          justify-content: space-around;\n  -webkit-transform: translate3d(0px, 0px, 0px);\n          transform: translate3d(0px, 0px, 0px);\n  opacity: 1;\n}\n.dayContainer + .dayContainer {\n  -webkit-box-shadow: -1px 0 0 #e6e6e6;\n          box-shadow: -1px 0 0 #e6e6e6;\n}\n.flatpickr-day {\n  background: none;\n  border: 1px solid transparent;\n  border-radius: 150px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #393939;\n  cursor: pointer;\n  font-weight: 400;\n  width: 14.2857143%;\n  -webkit-flex-basis: 14.2857143%;\n      -ms-flex-preferred-size: 14.2857143%;\n          flex-basis: 14.2857143%;\n  max-width: 39px;\n  height: 39px;\n  line-height: 39px;\n  margin: 0;\n  display: inline-block;\n  position: relative;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  text-align: center;\n}\n.flatpickr-day.inRange,\n.flatpickr-day.prevMonthDay.inRange,\n.flatpickr-day.nextMonthDay.inRange,\n.flatpickr-day.today.inRange,\n.flatpickr-day.prevMonthDay.today.inRange,\n.flatpickr-day.nextMonthDay.today.inRange,\n.flatpickr-day:hover,\n.flatpickr-day.prevMonthDay:hover,\n.flatpickr-day.nextMonthDay:hover,\n.flatpickr-day:focus,\n.flatpickr-day.prevMonthDay:focus,\n.flatpickr-day.nextMonthDay:focus {\n  cursor: pointer;\n  outline: 0;\n  background: #e6e6e6;\n  border-color: #e6e6e6;\n}\n.flatpickr-day.today {\n  border-color: #959ea9;\n}\n.flatpickr-day.today:hover,\n.flatpickr-day.today:focus {\n  border-color: #959ea9;\n  background: #959ea9;\n  color: #fff;\n}\n.flatpickr-day.selected,\n.flatpickr-day.startRange,\n.flatpickr-day.endRange,\n.flatpickr-day.selected.inRange,\n.flatpickr-day.startRange.inRange,\n.flatpickr-day.endRange.inRange,\n.flatpickr-day.selected:focus,\n.flatpickr-day.startRange:focus,\n.flatpickr-day.endRange:focus,\n.flatpickr-day.selected:hover,\n.flatpickr-day.startRange:hover,\n.flatpickr-day.endRange:hover,\n.flatpickr-day.selected.prevMonthDay,\n.flatpickr-day.startRange.prevMonthDay,\n.flatpickr-day.endRange.prevMonthDay,\n.flatpickr-day.selected.nextMonthDay,\n.flatpickr-day.startRange.nextMonthDay,\n.flatpickr-day.endRange.nextMonthDay {\n  background: #569ff7;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  color: #fff;\n  border-color: #569ff7;\n}\n.flatpickr-day.selected.startRange,\n.flatpickr-day.startRange.startRange,\n.flatpickr-day.endRange.startRange {\n  border-radius: 50px 0 0 50px;\n}\n.flatpickr-day.selected.endRange,\n.flatpickr-day.startRange.endRange,\n.flatpickr-day.endRange.endRange {\n  border-radius: 0 50px 50px 0;\n}\n.flatpickr-day.selected.startRange + .endRange:not(:nth-child(7n+1)),\n.flatpickr-day.startRange.startRange + .endRange:not(:nth-child(7n+1)),\n.flatpickr-day.endRange.startRange + .endRange:not(:nth-child(7n+1)) {\n  -webkit-box-shadow: -10px 0 0 #569ff7;\n          box-shadow: -10px 0 0 #569ff7;\n}\n.flatpickr-day.selected.startRange.endRange,\n.flatpickr-day.startRange.startRange.endRange,\n.flatpickr-day.endRange.startRange.endRange {\n  border-radius: 50px;\n}\n.flatpickr-day.inRange {\n  border-radius: 0;\n  -webkit-box-shadow: -5px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n          box-shadow: -5px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n}\n.flatpickr-day.disabled,\n.flatpickr-day.disabled:hover,\n.flatpickr-day.prevMonthDay,\n.flatpickr-day.nextMonthDay,\n.flatpickr-day.notAllowed,\n.flatpickr-day.notAllowed.prevMonthDay,\n.flatpickr-day.notAllowed.nextMonthDay {\n  color: rgba(57,57,57,0.3);\n  background: transparent;\n  border-color: transparent;\n  cursor: default;\n}\n.flatpickr-day.disabled,\n.flatpickr-day.disabled:hover {\n  cursor: not-allowed;\n  color: rgba(57,57,57,0.1);\n}\n.flatpickr-day.week.selected {\n  border-radius: 0;\n  -webkit-box-shadow: -5px 0 0 #569ff7, 5px 0 0 #569ff7;\n          box-shadow: -5px 0 0 #569ff7, 5px 0 0 #569ff7;\n}\n.flatpickr-day.hidden {\n  visibility: hidden;\n}\n.rangeMode .flatpickr-day {\n  margin-top: 1px;\n}\n.flatpickr-weekwrapper {\n  display: inline-block;\n  float: left;\n}\n.flatpickr-weekwrapper .flatpickr-weeks {\n  padding: 0 12px;\n  -webkit-box-shadow: 1px 0 0 #e6e6e6;\n          box-shadow: 1px 0 0 #e6e6e6;\n}\n.flatpickr-weekwrapper .flatpickr-weekday {\n  float: none;\n  width: 100%;\n  line-height: 28px;\n}\n.flatpickr-weekwrapper span.flatpickr-day,\n.flatpickr-weekwrapper span.flatpickr-day:hover {\n  display: block;\n  width: 100%;\n  max-width: none;\n  color: rgba(57,57,57,0.3);\n  background: transparent;\n  cursor: default;\n  border: none;\n}\n.flatpickr-innerContainer {\n  display: block;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  overflow: hidden;\n}\n.flatpickr-rContainer {\n  display: inline-block;\n  padding: 0;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.flatpickr-time {\n  text-align: center;\n  outline: 0;\n  display: block;\n  height: 0;\n  line-height: 40px;\n  max-height: 40px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  overflow: hidden;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.flatpickr-time:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n.flatpickr-time .numInputWrapper {\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  width: 40%;\n  height: 40px;\n  float: left;\n}\n.flatpickr-time .numInputWrapper span.arrowUp:after {\n  border-bottom-color: #393939;\n}\n.flatpickr-time .numInputWrapper span.arrowDown:after {\n  border-top-color: #393939;\n}\n.flatpickr-time.hasSeconds .numInputWrapper {\n  width: 26%;\n}\n.flatpickr-time.time24hr .numInputWrapper {\n  width: 49%;\n}\n.flatpickr-time input {\n  background: transparent;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  border: 0;\n  border-radius: 0;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n  height: inherit;\n  line-height: inherit;\n  color: #393939;\n  font-size: 14px;\n  position: relative;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n}\n.flatpickr-time input.flatpickr-hour {\n  font-weight: bold;\n}\n.flatpickr-time input.flatpickr-minute,\n.flatpickr-time input.flatpickr-second {\n  font-weight: 400;\n}\n.flatpickr-time input:focus {\n  outline: 0;\n  border: 0;\n}\n.flatpickr-time .flatpickr-time-separator,\n.flatpickr-time .flatpickr-am-pm {\n  height: inherit;\n  display: inline-block;\n  float: left;\n  line-height: inherit;\n  color: #393939;\n  font-weight: bold;\n  width: 2%;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-align-self: center;\n      -ms-flex-item-align: center;\n          align-self: center;\n}\n.flatpickr-time .flatpickr-am-pm {\n  outline: 0;\n  width: 18%;\n  cursor: pointer;\n  text-align: center;\n  font-weight: 400;\n}\n.flatpickr-time input:hover,\n.flatpickr-time .flatpickr-am-pm:hover,\n.flatpickr-time input:focus,\n.flatpickr-time .flatpickr-am-pm:focus {\n  background: #eee;\n}\n.flatpickr-input[readonly] {\n  cursor: pointer;\n}\n@-webkit-keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    -webkit-transform: translate3d(0, -20px, 0);\n            transform: translate3d(0, -20px, 0);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translate3d(0, 0, 0);\n            transform: translate3d(0, 0, 0);\n  }\n}\n@keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    -webkit-transform: translate3d(0, -20px, 0);\n            transform: translate3d(0, -20px, 0);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translate3d(0, 0, 0);\n            transform: translate3d(0, 0, 0);\n  }\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/App.svelte.css":
/*!******************************************************!*\
  !*** ./node_modules/css-loader!./src/App.svelte.css ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".app-root.svelte-rqgp85{height:100%;width:100%;font-family:\"Nunito\", Helvetica, Arial, sans-serif}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/NoPackage.svelte.css":
/*!************************************************************!*\
  !*** ./node_modules/css-loader!./src/NoPackage.svelte.css ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".root.svelte-siv2n6{position:fixed;margin:0 auto;text-align:center;top:20%;width:100%}.inner.svelte-siv2n6{display:inline-block;margin:auto}.logo.svelte-siv2n6{width:300px;margin-bottom:40px}.root.svelte-siv2n6 .option{width:250px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/PackageRoot.svelte.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader!./src/PackageRoot.svelte.css ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".root.svelte-1rxbdcd{height:100%}.content.svelte-1rxbdcd{position:fixed;height:100%;background-color:var(--white);margin:0}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/Button.svelte.css":
/*!****************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/Button.svelte.css ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "button.svelte-2mdb6s{border-radius:var(--borderradius);border-style:solid;padding:7px 15px}.primary.svelte-2mdb6s{background-color:var(--primary100);border-color:var(--primary100);color:var(--white)}.primary.svelte-2mdb6s:hover{background-color:var(--primary75);border-color:var(--primary75)}.primary.svelte-2mdb6s:active{background-color:var(--primarydark);border-color:var(--primarydark)}.primary-outline.svelte-2mdb6s{background-color:var(--white);border-color:var(--primary100);color:var(--primary100)}.primary-outline.svelte-2mdb6s:hover{background-color:var(--primary10)}.primary-outline.svelte-2mdb6s:pressed{background-color:var(--primary25)}.secondary.svelte-2mdb6s{background-color:var(--secondary100);border-color:var(--secondary100);color:var(--white)}.secondary.svelte-2mdb6s:hover{background-color:var(--secondary75);border-color:var(--secondary75)}.secondary.svelte-2mdb6s:pressed{background-color:var(--secondarydark);border-color:var(--secondarydark)}.secondary-outline.svelte-2mdb6s{background-color:var(--white);border-color:var(--secondary100);color:var(--secondary100)}.secondary-outline.svelte-2mdb6s:hover{background-color:var(--secondary10)}.secondary-outline.svelte-2mdb6s:pressed{background-color:var(--secondary25)}.success.svelte-2mdb6s{background-color:var(--success100);border-color:var(--success100);color:var(--white)}.success.svelte-2mdb6s:hover{background-color:var(--success75);border-color:var(--success75)}.success.svelte-2mdb6s:pressed{background-color:var(--successdark);border-color:var(--successdark)}.success-outline.svelte-2mdb6s{background-color:var(--white);border-color:var(--success100);color:var(--success100)}.success-outline.svelte-2mdb6s:hover{background-color:var(--success10)}.success-outline.svelte-2mdb6s:pressed{background-color:var(--success25)}.deletion.svelte-2mdb6s{background-color:var(--deletion100);border-color:var(--deletion100);color:var(--white)}.deletion.svelte-2mdb6s:hover{background-color:var(--deletion75);border-color:var(--deletion75)}.deletion.svelte-2mdb6s:pressed{background-color:var(--deletiondark);border-color:var(--deletiondark)}.deletion-outline.svelte-2mdb6s{background-color:var(--white);border-color:var(--deletion100);color:var(--deletion100)}.deletion-outline.svelte-2mdb6s:hover{background-color:var(--deletion10)}.deletion-outline.svelte-2mdb6s:pressed{background-color:var(--deletion25)}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/CodeArea.svelte.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/CodeArea.svelte.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "textarea.svelte-1ooq0hh{padding:3px;background:var(--darkslate);color:var(--white);font-family:'Courier New', Courier, monospace;width:95%;height:100px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/ComingSoon.svelte.css":
/*!********************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/ComingSoon.svelte.css ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "h4.svelte-o0id5a{margin-top:20px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/DatePicker.svelte.css":
/*!********************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/DatePicker.svelte.css ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".container.svelte-1pf9x5k{display:grid;grid-template-columns:[label] 100px [control] auto;margin:20px 0px}.label.svelte-1pf9x5k{grid-column-start:label;align-self:center}.control.svelte-1pf9x5k{grid-column-start:control;align-self:center;margin:0}input.svelte-1pf9x5k{width:300px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/Dropdown.svelte.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/Dropdown.svelte.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".container.svelte-bm0783{display:grid;grid-template-columns:[label] 100px [control] auto;margin:20px 0px}.label.svelte-bm0783{grid-column-start:label;align-self:center}.control.svelte-bm0783{grid-column-start:control;align-self:center;margin:0}select.svelte-bm0783{width:300px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/DropdownButton.svelte.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/DropdownButton.svelte.css ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".dropdown-background.svelte-179p8ge{position:fixed;top:0;left:0;width:100vw;height:100vh}.root.svelte-179p8ge{cursor:pointer;z-index:1}.dropdown-content.svelte-179p8ge{position:absolute;background-color:var(--white);min-width:160px;box-shadow:0px 8px 16px 0px rgba(0,0,0,0.2);z-index:1;font-weight:normal;border-style:solid;border-width:1px;border-color:var(--secondary10)}.dropdown-content.svelte-179p8ge:not(:focus){display:none}.action-row.svelte-179p8ge{padding:7px 10px;cursor:pointer}.action-row.svelte-179p8ge:hover{background-color:var(--primary100);color:var(--white)}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/ErrorsBox.svelte.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/ErrorsBox.svelte.css ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".error-container.svelte-6bvkk9{padding:10px;border-style:solid;border-color:var(--deletion100);border-radius:var(--borderradius);background:var(--deletion75)}.error-row.svelte-6bvkk9{padding:5px 0px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/Modal.svelte.css":
/*!***************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/Modal.svelte.css ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".root.svelte-n9lkn5{position:fixed;top:0;left:0;width:100vw;height:100vh;grid-template-columns:[leftCol] 10px [midCol] auto [rightCol] 10px;grid-template-rows:[topRow] 10px [midRow] auto [bottomRow] 10px;background-color:var(--secondary10);backdrop-filter:blur(5px)}.content.svelte-n9lkn5{margin:auto;padding:10px;background-color:var(--white);border-style:solid;border-width:1px;border-radius:var(--borderradius);border-color:var(--darkslate);box-shadow:5px 2px 9px 0px var(--secondary75);display:inline-block;grid-column-start:midCol;grid-row-start:midRow}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/NumberBox.svelte.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/NumberBox.svelte.css ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".container.svelte-umifqh{display:grid;grid-template-columns:[label] 100px [control] auto;margin:20px 0px}.label.svelte-umifqh{grid-column-start:label;align-self:center}.control.svelte-umifqh{grid-column-start:control;align-self:center;margin:0}input.svelte-umifqh{width:300px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/Textbox.svelte.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/Textbox.svelte.css ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".container.svelte-umifqh{display:grid;grid-template-columns:[label] 100px [control] auto;margin:20px 0px}.label.svelte-umifqh{grid-column-start:label;align-self:center}.control.svelte-umifqh{grid-column-start:control;align-self:center;margin:0}input.svelte-umifqh{width:300px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/common/ValuesList.svelte.css":
/*!********************************************************************!*\
  !*** ./node_modules/css-loader!./src/common/ValuesList.svelte.css ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".container.svelte-1guzwer{display:grid;grid-template-columns:[label] 100px [control] auto;margin:20px 0px}.label.svelte-1guzwer{grid-column-start:label;align-self:center}.control.svelte-1guzwer{grid-column-start:control;align-self:center;margin:0}textarea.svelte-1guzwer{width:300px;height:300px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/database/ActionsHeader.svelte.css":
/*!*************************************************************************!*\
  !*** ./node_modules/css-loader!./src/database/ActionsHeader.svelte.css ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".root.svelte-160njkp{padding:5px;top:0;width:100%}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/database/DatabaseRoot.svelte.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader!./src/database/DatabaseRoot.svelte.css ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".root.svelte-z7gm0t{display:flex;height:100%;position:relative}.hierarchy.svelte-z7gm0t{flex:0 1 auto;background-color:var(--primary10);overflow-y:auto;height:100%}.node-container.svelte-z7gm0t{flex:1 1 auto;display:flex;flex-direction:column}.actions-header.svelte-z7gm0t{flex:0 1 auto}.node-view.svelte-z7gm0t{overflow-y:auto;flex:1 1 auto}.hierarchy-title-row.svelte-z7gm0t{padding:15px 7px;font-size:11pt;display:flex;font-weight:bold}.hierarchy-title.svelte-z7gm0t{flex:auto 1 1}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/database/FieldView.svelte.css":
/*!*********************************************************************!*\
  !*** ./node_modules/css-loader!./src/database/FieldView.svelte.css ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".actions.svelte-16y4fgx{float:right;padding:10px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/database/HierarchyRow.svelte.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader!./src/database/HierarchyRow.svelte.css ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".root.svelte-1rctf7f{display:block;font-size:13pt;width:100%;cursor:pointer}.title.svelte-1rctf7f{font:var(--bodytext);padding-top:10px;padding-right:5px;padding-bottom:10px;color:var(--secondary100)}.title.svelte-1rctf7f:hover{background-color:var(--secondary10)}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/database/IndexView.svelte.css":
/*!*********************************************************************!*\
  !*** ./node_modules/css-loader!./src/database/IndexView.svelte.css ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".root.svelte-1fkfoam{height:100%;padding:15px}.allowed-records.svelte-1fkfoam{margin:20px 0px}.allowed-records.svelte-1fkfoam>span.svelte-1fkfoam{margin-right:30px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/database/RecordView.svelte.css":
/*!**********************************************************************!*\
  !*** ./node_modules/css-loader!./src/database/RecordView.svelte.css ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".root.svelte-gq7l8x{height:100%;padding:15px}.fields-table.svelte-gq7l8x{margin:10px;border-collapse:collapse}.add-field-button.svelte-gq7l8x{margin-left:15px;cursor:pointer}.edit-button.svelte-gq7l8x{cursor:pointer;color:var(--white)}.edit-button.svelte-gq7l8x:hover{color:var(--secondary75)}th.svelte-gq7l8x{text-align:left}td.svelte-gq7l8x{padding:5px 30px 5px 0px;margin:0}thead.svelte-gq7l8x>tr.svelte-gq7l8x{border-width:0px 0px 1px 0px;border-style:solid;border-color:var(--secondary75);margin-bottom:20px}tbody.svelte-gq7l8x>tr.svelte-gq7l8x{border-width:0px 0px 1px 0px;border-style:solid;border-color:var(--primary10)}tbody.svelte-gq7l8x>tr.svelte-gq7l8x:hover{background-color:var(--primary10)}tbody.svelte-gq7l8x>tr:hover .edit-button.svelte-gq7l8x{color:var(--secondary75)}.index-container.svelte-gq7l8x{border-style:solid;border-width:0 0 1px 0;border-color:var(--secondary25);padding:10px;margin-bottom:5px}.index-label.svelte-gq7l8x{color:var(--slate)}.index-name.svelte-gq7l8x{font-weight:bold;color:var(--primary100)}.index-container.svelte-gq7l8x code.svelte-gq7l8x{margin:0;display:inline;background-color:var(--primary10);color:var(--secondary100);padding:3px}.index-field-row.svelte-gq7l8x{margin-top:7px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/fonts.css":
/*!*************************************************!*\
  !*** ./node_modules/css-loader!./src/fonts.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var escape = __webpack_require__(/*! ../node_modules/css-loader/lib/url/escape.js */ "./node_modules/css-loader/lib/url/escape.js");
exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/* latin-ext */\r\n@font-face {\r\n    font-family: 'Lato';\r\n    font-weight: 400;\r\n    src: local('Lato Regular'), local('Lato-Regular'), url(" + escape(__webpack_require__(/*! ./assets/lato-latin-ext.woff2 */ "./src/assets/lato-latin-ext.woff2")) + ") format('woff2');\r\n    unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\r\n}\r\n  /* latin */\r\n@font-face {\r\n    font-family: 'Lato';\r\n    font-weight: 400;\r\n    src: local('Lato Regular'), local('Lato-Regular'), url(" + escape(__webpack_require__(/*! ./assets/lato-latin.woff2 */ "./src/assets/lato-latin.woff2")) + ") format('woff2');\r\n    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\r\n}\r\n  \r\n\r\n/* Black latin-ext */\r\n@font-face {\r\n    font-family: 'Lato Black';\r\n    font-weight: 900;\r\n    src: local('Lato Regular'), local('Lato-Regular'), url(" + escape(__webpack_require__(/*! ./assets/lato-latin-ext.woff2 */ "./src/assets/lato-latin-ext.woff2")) + ") format('woff2');\r\n    unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\r\n}\r\n  /* Black latin */\r\n@font-face {\r\n    font-family: 'Lato Black';\r\n    font-weight: 900;\r\n    src: local('Lato Regular'), local('Lato-Regular'), url(" + escape(__webpack_require__(/*! ./assets/lato-latin.woff2 */ "./src/assets/lato-latin.woff2")) + ") format('woff2');\r\n    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\r\n}\r\n\r\n/* Bold latin-ext */\r\n@font-face {\r\n    font-family: 'Lato Bold';\r\n    font-weight: 700;\r\n    src: local('Lato Regular'), local('Lato-Regular'), url(" + escape(__webpack_require__(/*! ./assets/lato-latin-ext.woff2 */ "./src/assets/lato-latin-ext.woff2")) + ") format('woff2');\r\n    unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\r\n}\r\n  /* Bold latin */\r\n@font-face {\r\n    font-family: 'Lato Bold';\r\n    font-weight: 700;\r\n    src: local('Lato Regular'), local('Lato-Regular'), url(" + escape(__webpack_require__(/*! ./assets/lato-latin.woff2 */ "./src/assets/lato-latin.woff2")) + ") format('woff2');\r\n    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\r\n}\r\n\r\n/* Semi Bold latin-ext */\r\n@font-face {\r\n    font-family: 'Lato Semi Bold';\r\n    font-weight: 600;\r\n    src: local('Lato Regular'), local('Lato-Regular'), url(" + escape(__webpack_require__(/*! ./assets/lato-latin-ext.woff2 */ "./src/assets/lato-latin-ext.woff2")) + ") format('woff2');\r\n    unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\r\n}\r\n  /* Semi Bold latin */\r\n@font-face {\r\n    font-family: 'Lato Semi Bold';\r\n    font-weight: 600;\r\n    src: local('Lato Regular'), local('Lato-Regular'), url(" + escape(__webpack_require__(/*! ./assets/lato-latin.woff2 */ "./src/assets/lato-latin.woff2")) + ") format('woff2');\r\n    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\r\n}\r\n  ", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/global.css":
/*!**************************************************!*\
  !*** ./node_modules/css-loader!./src/global.css ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ":root {\r\n    --primary100: #454CA0FF;\r\n    --primary75: #454CA0BF;\r\n    --primary25: #454CA040;\r\n    --primary10: #454CA01A;\r\n    --primarydark: #3F448A;\r\n    \r\n    --secondary100: #162B4DFF;\r\n    --secondary75: #162B4DBF;\r\n    --secondary25: #162B4D40;\r\n    --secondary10: #162B4D1A;\r\n    --secondarydark: #3F448A;\r\n\r\n    --tertiary: #F2F5F7;\r\n    \r\n    --success100: #49C39EFF;\r\n    --success75: #49C39EBF;\r\n    --success25: #49C39E40;\r\n    --success10: #49C39E1A;\r\n    --successdark: #44B492;\r\n    \r\n    --deletion100: #F2545BFF;\r\n    --deletion75: #F2545BBF;\r\n    --deletion25: #F2545B40;\r\n    --deletion10: #F2545B1A;\r\n    --deletiondark: #CF4046;\r\n\r\n    --white: #FFFFFF;\r\n    --darkslate: #5C6B82;\r\n    --slate: #8B95A6;\r\n\r\n    --borderradius: 2px 2px 2px 2px;\r\n\r\n    --fontblack: \"Lato Black\";\r\n    --fontbold: \"Lato Bold\";\r\n    --fontsemibold: \"Lato Semi Bold\";\r\n    --fontnormal: \"Lato\";\r\n\r\n    --bodytext: var(--fontnormal) \"regular\" var(--secondary100) 16pt;\r\n    --bigbodytext: var(--fontnormal) \"regular\" var(--secondary100) 20pt;\r\n    --smallbodytext: var(--fontnormal) \"regular\" var(--secondary100) 12pt;\r\n    --lightbodytext: var(--fontnormal) \"regular\" var(--darkslate) 16pt;\r\n    --heavybodytext: var(--fontbold) \"regular\" var(--secondary100) 16pt;\r\n    --quotation: var(--fontnormal) \"italics\" var(--darkslate) 16pt;\r\n    --smallheavybodytext: var(--fontbold) \"regular\" var(--secondary100) 14pt;\r\n\r\n}\r\n\r\nhtml, body {\r\n    font-family: var(--fontnormal);\r\n    color: var(--secondary100);\r\n    padding: 0;\r\n    margin: 0;\r\n}\r\n\r\nh1 {\r\n    font-family: var(--fontblack);\r\n    font-size: 36pt;\r\n    color: var(--secondary100);\r\n}\r\n\r\nh2 {\r\n    font-family: var(--fontbold);\r\n    font-size: 30pt;\r\n    color: var(--secondary100);\r\n}\r\n\r\nh3 {\r\n    font-family: var(--fontbold);\r\n    font-size: 24pt;\r\n    color: var(--darkslate);\r\n}\r\n\r\nh4 {\r\n    font-family: var(--fontsemibold);\r\n    font-size: 18pt;\r\n    color: var(--secondary100);\r\n}\r\n\r\nh5 {\r\n    font-family: var(--fontblack);\r\n    font-size: 14pt;\r\n    color: var(--secondary100);\r\n}\r\n\r\nh5 {\r\n    font-family: var(--fontblack);\r\n    font-size: 12pt;\r\n    color: var(--darkslate);\r\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/nav/Nav.svelte.css":
/*!**********************************************************!*\
  !*** ./node_modules/css-loader!./src/nav/Nav.svelte.css ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".nav.svelte-n1ql72{height:100%;position:fixed;left:0px;background-color:var(--secondary100);color:var(--darkslate)}.nav.svelte-n1ql72>img.svelte-n1ql72{width:100%;margin-bottom:30px;margin-top:5px;margin-left:0px}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/nav/NavItem.svelte.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader!./src/nav/NavItem.svelte.css ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".nav-item.svelte-1mmcju5{padding:0px 5px;display:block;padding:10px;color:var(--slate);cursor:pointer}.inner.svelte-1mmcju5{padding:0px 20px 10px 0px;display:inline-block}.nav-item.svelte-1mmcju5:hover{background-color:var(--primary25)}.icon.svelte-1mmcju5{font-size:0.9em;display:inline-block;position:relative;top:5px;margin-right:5px}.active.svelte-1mmcju5>div.svelte-1mmcju5{background-color:var(--primary10);color:var(--secondary100)}.active.svelte-1mmcju5>div.svelte-1mmcju5:hover{background-color:var(--slate);color:var(--secondary100)}.active.svelte-1mmcju5{background-color:white}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/css-loader/lib/url/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/css-loader/lib/url/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function escape(url) {
    if (typeof url !== 'string') {
        return url
    }
    // If url is already wrapped in quotes, remove them
    if (/^['"].*['"]$/.test(url)) {
        url = url.slice(1, -1);
    }
    // Should url be wrapped?
    // See https://drafts.csswg.org/css-values-3/#urls
    if (/["'() \t\n]/.test(url)) {
        return '"' + url.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"'
    }

    return url
}


/***/ }),

/***/ "./node_modules/feather-icons/dist/feather.js":
/*!****************************************************!*\
  !*** ./node_modules/feather-icons/dist/feather.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/icons.json":
/*!*************************!*\
  !*** ./dist/icons.json ***!
  \*************************/
/*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, aperture, archive, arrow-down-circle, arrow-down-left, arrow-down-right, arrow-down, arrow-left-circle, arrow-left, arrow-right-circle, arrow-right, arrow-up-circle, arrow-up-left, arrow-up-right, arrow-up, at-sign, award, bar-chart-2, bar-chart, battery-charging, battery, bell-off, bell, bluetooth, bold, book-open, book, bookmark, box, briefcase, calendar, camera-off, camera, cast, check-circle, check-square, check, chevron-down, chevron-left, chevron-right, chevron-up, chevrons-down, chevrons-left, chevrons-right, chevrons-up, chrome, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-off, cloud-rain, cloud-snow, cloud, code, codepen, codesandbox, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, dollar-sign, download-cloud, download, droplet, edit-2, edit-3, edit, external-link, eye-off, eye, facebook, fast-forward, feather, figma, file-minus, file-plus, file-text, file, film, filter, flag, folder-minus, folder-plus, folder, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, grid, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, info, instagram, italic, key, layers, layout, life-buoy, link-2, link, linkedin, list, loader, lock, log-in, log-out, mail, map-pin, map, maximize-2, maximize, meh, menu, message-circle, message-square, mic-off, mic, minimize-2, minimize, minus-circle, minus-square, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation-2, navigation, octagon, package, paperclip, pause-circle, pause, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, pie-chart, play-circle, play, plus-circle, plus-square, plus, pocket, power, printer, radio, refresh-ccw, refresh-cw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, server, settings, share-2, share, shield-off, shield, shopping-bag, shopping-cart, shuffle, sidebar, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, square, star, stop-circle, sun, sunrise, sunset, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, trash-2, trash, trello, trending-down, trending-up, triangle, truck, tv, twitter, type, umbrella, underline, unlock, upload-cloud, upload, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume-1, volume-2, volume-x, volume, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */
/***/ (function(module) {

module.exports = {"activity":"<polyline points=\"22 12 18 12 15 21 9 3 6 12 2 12\"></polyline>","airplay":"<path d=\"M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1\"></path><polygon points=\"12 15 17 21 7 21 12 15\"></polygon>","alert-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"12\"></line><line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"16\"></line>","alert-octagon":"<polygon points=\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\"></polygon><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"12\"></line><line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"16\"></line>","alert-triangle":"<path d=\"M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z\"></path><line x1=\"12\" y1=\"9\" x2=\"12\" y2=\"13\"></line><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"17\"></line>","align-center":"<line x1=\"18\" y1=\"10\" x2=\"6\" y2=\"10\"></line><line x1=\"21\" y1=\"6\" x2=\"3\" y2=\"6\"></line><line x1=\"21\" y1=\"14\" x2=\"3\" y2=\"14\"></line><line x1=\"18\" y1=\"18\" x2=\"6\" y2=\"18\"></line>","align-justify":"<line x1=\"21\" y1=\"10\" x2=\"3\" y2=\"10\"></line><line x1=\"21\" y1=\"6\" x2=\"3\" y2=\"6\"></line><line x1=\"21\" y1=\"14\" x2=\"3\" y2=\"14\"></line><line x1=\"21\" y1=\"18\" x2=\"3\" y2=\"18\"></line>","align-left":"<line x1=\"17\" y1=\"10\" x2=\"3\" y2=\"10\"></line><line x1=\"21\" y1=\"6\" x2=\"3\" y2=\"6\"></line><line x1=\"21\" y1=\"14\" x2=\"3\" y2=\"14\"></line><line x1=\"17\" y1=\"18\" x2=\"3\" y2=\"18\"></line>","align-right":"<line x1=\"21\" y1=\"10\" x2=\"7\" y2=\"10\"></line><line x1=\"21\" y1=\"6\" x2=\"3\" y2=\"6\"></line><line x1=\"21\" y1=\"14\" x2=\"3\" y2=\"14\"></line><line x1=\"21\" y1=\"18\" x2=\"7\" y2=\"18\"></line>","anchor":"<circle cx=\"12\" cy=\"5\" r=\"3\"></circle><line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"8\"></line><path d=\"M5 12H2a10 10 0 0 0 20 0h-3\"></path>","aperture":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"14.31\" y1=\"8\" x2=\"20.05\" y2=\"17.94\"></line><line x1=\"9.69\" y1=\"8\" x2=\"21.17\" y2=\"8\"></line><line x1=\"7.38\" y1=\"12\" x2=\"13.12\" y2=\"2.06\"></line><line x1=\"9.69\" y1=\"16\" x2=\"3.95\" y2=\"6.06\"></line><line x1=\"14.31\" y1=\"16\" x2=\"2.83\" y2=\"16\"></line><line x1=\"16.62\" y1=\"12\" x2=\"10.88\" y2=\"21.94\"></line>","archive":"<polyline points=\"21 8 21 21 3 21 3 8\"></polyline><rect x=\"1\" y=\"3\" width=\"22\" height=\"5\"></rect><line x1=\"10\" y1=\"12\" x2=\"14\" y2=\"12\"></line>","arrow-down-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polyline points=\"8 12 12 16 16 12\"></polyline><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"16\"></line>","arrow-down-left":"<line x1=\"17\" y1=\"7\" x2=\"7\" y2=\"17\"></line><polyline points=\"17 17 7 17 7 7\"></polyline>","arrow-down-right":"<line x1=\"7\" y1=\"7\" x2=\"17\" y2=\"17\"></line><polyline points=\"17 7 17 17 7 17\"></polyline>","arrow-down":"<line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"></line><polyline points=\"19 12 12 19 5 12\"></polyline>","arrow-left-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polyline points=\"12 8 8 12 12 16\"></polyline><line x1=\"16\" y1=\"12\" x2=\"8\" y2=\"12\"></line>","arrow-left":"<line x1=\"19\" y1=\"12\" x2=\"5\" y2=\"12\"></line><polyline points=\"12 19 5 12 12 5\"></polyline>","arrow-right-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polyline points=\"12 16 16 12 12 8\"></polyline><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","arrow-right":"<line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"></line><polyline points=\"12 5 19 12 12 19\"></polyline>","arrow-up-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polyline points=\"16 12 12 8 8 12\"></polyline><line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"8\"></line>","arrow-up-left":"<line x1=\"17\" y1=\"17\" x2=\"7\" y2=\"7\"></line><polyline points=\"7 17 7 7 17 7\"></polyline>","arrow-up-right":"<line x1=\"7\" y1=\"17\" x2=\"17\" y2=\"7\"></line><polyline points=\"7 7 17 7 17 17\"></polyline>","arrow-up":"<line x1=\"12\" y1=\"19\" x2=\"12\" y2=\"5\"></line><polyline points=\"5 12 12 5 19 12\"></polyline>","at-sign":"<circle cx=\"12\" cy=\"12\" r=\"4\"></circle><path d=\"M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94\"></path>","award":"<circle cx=\"12\" cy=\"8\" r=\"7\"></circle><polyline points=\"8.21 13.89 7 23 12 20 17 23 15.79 13.88\"></polyline>","bar-chart-2":"<line x1=\"18\" y1=\"20\" x2=\"18\" y2=\"10\"></line><line x1=\"12\" y1=\"20\" x2=\"12\" y2=\"4\"></line><line x1=\"6\" y1=\"20\" x2=\"6\" y2=\"14\"></line>","bar-chart":"<line x1=\"12\" y1=\"20\" x2=\"12\" y2=\"10\"></line><line x1=\"18\" y1=\"20\" x2=\"18\" y2=\"4\"></line><line x1=\"6\" y1=\"20\" x2=\"6\" y2=\"16\"></line>","battery-charging":"<path d=\"M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19\"></path><line x1=\"23\" y1=\"13\" x2=\"23\" y2=\"11\"></line><polyline points=\"11 6 7 12 13 12 9 18\"></polyline>","battery":"<rect x=\"1\" y=\"6\" width=\"18\" height=\"12\" rx=\"2\" ry=\"2\"></rect><line x1=\"23\" y1=\"13\" x2=\"23\" y2=\"11\"></line>","bell-off":"<path d=\"M13.73 21a2 2 0 0 1-3.46 0\"></path><path d=\"M18.63 13A17.89 17.89 0 0 1 18 8\"></path><path d=\"M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14\"></path><path d=\"M18 8a6 6 0 0 0-9.33-5\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","bell":"<path d=\"M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9\"></path><path d=\"M13.73 21a2 2 0 0 1-3.46 0\"></path>","bluetooth":"<polyline points=\"6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5\"></polyline>","bold":"<path d=\"M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z\"></path><path d=\"M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z\"></path>","book-open":"<path d=\"M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z\"></path><path d=\"M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z\"></path>","book":"<path d=\"M4 19.5A2.5 2.5 0 0 1 6.5 17H20\"></path><path d=\"M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z\"></path>","bookmark":"<path d=\"M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z\"></path>","box":"<path d=\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\"></path><polyline points=\"3.27 6.96 12 12.01 20.73 6.96\"></polyline><line x1=\"12\" y1=\"22.08\" x2=\"12\" y2=\"12\"></line>","briefcase":"<rect x=\"2\" y=\"7\" width=\"20\" height=\"14\" rx=\"2\" ry=\"2\"></rect><path d=\"M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16\"></path>","calendar":"<rect x=\"3\" y=\"4\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"16\" y1=\"2\" x2=\"16\" y2=\"6\"></line><line x1=\"8\" y1=\"2\" x2=\"8\" y2=\"6\"></line><line x1=\"3\" y1=\"10\" x2=\"21\" y2=\"10\"></line>","camera-off":"<line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line><path d=\"M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56\"></path>","camera":"<path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"></path><circle cx=\"12\" cy=\"13\" r=\"4\"></circle>","cast":"<path d=\"M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6\"></path><line x1=\"2\" y1=\"20\" x2=\"2\" y2=\"20\"></line>","check-circle":"<path d=\"M22 11.08V12a10 10 0 1 1-5.93-9.14\"></path><polyline points=\"22 4 12 14.01 9 11.01\"></polyline>","check-square":"<polyline points=\"9 11 12 14 22 4\"></polyline><path d=\"M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11\"></path>","check":"<polyline points=\"20 6 9 17 4 12\"></polyline>","chevron-down":"<polyline points=\"6 9 12 15 18 9\"></polyline>","chevron-left":"<polyline points=\"15 18 9 12 15 6\"></polyline>","chevron-right":"<polyline points=\"9 18 15 12 9 6\"></polyline>","chevron-up":"<polyline points=\"18 15 12 9 6 15\"></polyline>","chevrons-down":"<polyline points=\"7 13 12 18 17 13\"></polyline><polyline points=\"7 6 12 11 17 6\"></polyline>","chevrons-left":"<polyline points=\"11 17 6 12 11 7\"></polyline><polyline points=\"18 17 13 12 18 7\"></polyline>","chevrons-right":"<polyline points=\"13 17 18 12 13 7\"></polyline><polyline points=\"6 17 11 12 6 7\"></polyline>","chevrons-up":"<polyline points=\"17 11 12 6 7 11\"></polyline><polyline points=\"17 18 12 13 7 18\"></polyline>","chrome":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><circle cx=\"12\" cy=\"12\" r=\"4\"></circle><line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\"></line><line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\"></line><line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\"></line>","circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle>","clipboard":"<path d=\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\"></path><rect x=\"8\" y=\"2\" width=\"8\" height=\"4\" rx=\"1\" ry=\"1\"></rect>","clock":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polyline points=\"12 6 12 12 16 14\"></polyline>","cloud-drizzle":"<line x1=\"8\" y1=\"19\" x2=\"8\" y2=\"21\"></line><line x1=\"8\" y1=\"13\" x2=\"8\" y2=\"15\"></line><line x1=\"16\" y1=\"19\" x2=\"16\" y2=\"21\"></line><line x1=\"16\" y1=\"13\" x2=\"16\" y2=\"15\"></line><line x1=\"12\" y1=\"21\" x2=\"12\" y2=\"23\"></line><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"17\"></line><path d=\"M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25\"></path>","cloud-lightning":"<path d=\"M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9\"></path><polyline points=\"13 11 9 17 15 17 11 23\"></polyline>","cloud-off":"<path d=\"M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","cloud-rain":"<line x1=\"16\" y1=\"13\" x2=\"16\" y2=\"21\"></line><line x1=\"8\" y1=\"13\" x2=\"8\" y2=\"21\"></line><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"23\"></line><path d=\"M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25\"></path>","cloud-snow":"<path d=\"M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25\"></path><line x1=\"8\" y1=\"16\" x2=\"8\" y2=\"16\"></line><line x1=\"8\" y1=\"20\" x2=\"8\" y2=\"20\"></line><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"18\"></line><line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"22\"></line><line x1=\"16\" y1=\"16\" x2=\"16\" y2=\"16\"></line><line x1=\"16\" y1=\"20\" x2=\"16\" y2=\"20\"></line>","cloud":"<path d=\"M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z\"></path>","code":"<polyline points=\"16 18 22 12 16 6\"></polyline><polyline points=\"8 6 2 12 8 18\"></polyline>","codepen":"<polygon points=\"12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2\"></polygon><line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"15.5\"></line><polyline points=\"22 8.5 12 15.5 2 8.5\"></polyline><polyline points=\"2 15.5 12 8.5 22 15.5\"></polyline><line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"8.5\"></line>","codesandbox":"<path d=\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\"></path><polyline points=\"7.5 4.21 12 6.81 16.5 4.21\"></polyline><polyline points=\"7.5 19.79 7.5 14.6 3 12\"></polyline><polyline points=\"21 12 16.5 14.6 16.5 19.79\"></polyline><polyline points=\"3.27 6.96 12 12.01 20.73 6.96\"></polyline><line x1=\"12\" y1=\"22.08\" x2=\"12\" y2=\"12\"></line>","coffee":"<path d=\"M18 8h1a4 4 0 0 1 0 8h-1\"></path><path d=\"M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z\"></path><line x1=\"6\" y1=\"1\" x2=\"6\" y2=\"4\"></line><line x1=\"10\" y1=\"1\" x2=\"10\" y2=\"4\"></line><line x1=\"14\" y1=\"1\" x2=\"14\" y2=\"4\"></line>","columns":"<path d=\"M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18\"></path>","command":"<path d=\"M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z\"></path>","compass":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polygon points=\"16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76\"></polygon>","copy":"<rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path>","corner-down-left":"<polyline points=\"9 10 4 15 9 20\"></polyline><path d=\"M20 4v7a4 4 0 0 1-4 4H4\"></path>","corner-down-right":"<polyline points=\"15 10 20 15 15 20\"></polyline><path d=\"M4 4v7a4 4 0 0 0 4 4h12\"></path>","corner-left-down":"<polyline points=\"14 15 9 20 4 15\"></polyline><path d=\"M20 4h-7a4 4 0 0 0-4 4v12\"></path>","corner-left-up":"<polyline points=\"14 9 9 4 4 9\"></polyline><path d=\"M20 20h-7a4 4 0 0 1-4-4V4\"></path>","corner-right-down":"<polyline points=\"10 15 15 20 20 15\"></polyline><path d=\"M4 4h7a4 4 0 0 1 4 4v12\"></path>","corner-right-up":"<polyline points=\"10 9 15 4 20 9\"></polyline><path d=\"M4 20h7a4 4 0 0 0 4-4V4\"></path>","corner-up-left":"<polyline points=\"9 14 4 9 9 4\"></polyline><path d=\"M20 20v-7a4 4 0 0 0-4-4H4\"></path>","corner-up-right":"<polyline points=\"15 14 20 9 15 4\"></polyline><path d=\"M4 20v-7a4 4 0 0 1 4-4h12\"></path>","cpu":"<rect x=\"4\" y=\"4\" width=\"16\" height=\"16\" rx=\"2\" ry=\"2\"></rect><rect x=\"9\" y=\"9\" width=\"6\" height=\"6\"></rect><line x1=\"9\" y1=\"1\" x2=\"9\" y2=\"4\"></line><line x1=\"15\" y1=\"1\" x2=\"15\" y2=\"4\"></line><line x1=\"9\" y1=\"20\" x2=\"9\" y2=\"23\"></line><line x1=\"15\" y1=\"20\" x2=\"15\" y2=\"23\"></line><line x1=\"20\" y1=\"9\" x2=\"23\" y2=\"9\"></line><line x1=\"20\" y1=\"14\" x2=\"23\" y2=\"14\"></line><line x1=\"1\" y1=\"9\" x2=\"4\" y2=\"9\"></line><line x1=\"1\" y1=\"14\" x2=\"4\" y2=\"14\"></line>","credit-card":"<rect x=\"1\" y=\"4\" width=\"22\" height=\"16\" rx=\"2\" ry=\"2\"></rect><line x1=\"1\" y1=\"10\" x2=\"23\" y2=\"10\"></line>","crop":"<path d=\"M6.13 1L6 16a2 2 0 0 0 2 2h15\"></path><path d=\"M1 6.13L16 6a2 2 0 0 1 2 2v15\"></path>","crosshair":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"22\" y1=\"12\" x2=\"18\" y2=\"12\"></line><line x1=\"6\" y1=\"12\" x2=\"2\" y2=\"12\"></line><line x1=\"12\" y1=\"6\" x2=\"12\" y2=\"2\"></line><line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"18\"></line>","database":"<ellipse cx=\"12\" cy=\"5\" rx=\"9\" ry=\"3\"></ellipse><path d=\"M21 12c0 1.66-4 3-9 3s-9-1.34-9-3\"></path><path d=\"M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5\"></path>","delete":"<path d=\"M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z\"></path><line x1=\"18\" y1=\"9\" x2=\"12\" y2=\"15\"></line><line x1=\"12\" y1=\"9\" x2=\"18\" y2=\"15\"></line>","disc":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><circle cx=\"12\" cy=\"12\" r=\"3\"></circle>","dollar-sign":"<line x1=\"12\" y1=\"1\" x2=\"12\" y2=\"23\"></line><path d=\"M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6\"></path>","download-cloud":"<polyline points=\"8 17 12 21 16 17\"></polyline><line x1=\"12\" y1=\"12\" x2=\"12\" y2=\"21\"></line><path d=\"M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29\"></path>","download":"<path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"></path><polyline points=\"7 10 12 15 17 10\"></polyline><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"></line>","droplet":"<path d=\"M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z\"></path>","edit-2":"<path d=\"M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z\"></path>","edit-3":"<path d=\"M12 20h9\"></path><path d=\"M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z\"></path>","edit":"<path d=\"M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7\"></path><path d=\"M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z\"></path>","external-link":"<path d=\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"></path><polyline points=\"15 3 21 3 21 9\"></polyline><line x1=\"10\" y1=\"14\" x2=\"21\" y2=\"3\"></line>","eye-off":"<path d=\"M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","eye":"<path d=\"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\"></path><circle cx=\"12\" cy=\"12\" r=\"3\"></circle>","facebook":"<path d=\"M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z\"></path>","fast-forward":"<polygon points=\"13 19 22 12 13 5 13 19\"></polygon><polygon points=\"2 19 11 12 2 5 2 19\"></polygon>","feather":"<path d=\"M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z\"></path><line x1=\"16\" y1=\"8\" x2=\"2\" y2=\"22\"></line><line x1=\"17.5\" y1=\"15\" x2=\"9\" y2=\"15\"></line>","figma":"<path d=\"M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z\"></path><path d=\"M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z\"></path><path d=\"M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z\"></path><path d=\"M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z\"></path><path d=\"M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z\"></path>","file-minus":"<path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"></line>","file-plus":"<path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"></line><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"></line>","file-text":"<path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"></path><polyline points=\"14 2 14 8 20 8\"></polyline><line x1=\"16\" y1=\"13\" x2=\"8\" y2=\"13\"></line><line x1=\"16\" y1=\"17\" x2=\"8\" y2=\"17\"></line><polyline points=\"10 9 9 9 8 9\"></polyline>","file":"<path d=\"M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z\"></path><polyline points=\"13 2 13 9 20 9\"></polyline>","film":"<rect x=\"2\" y=\"2\" width=\"20\" height=\"20\" rx=\"2.18\" ry=\"2.18\"></rect><line x1=\"7\" y1=\"2\" x2=\"7\" y2=\"22\"></line><line x1=\"17\" y1=\"2\" x2=\"17\" y2=\"22\"></line><line x1=\"2\" y1=\"12\" x2=\"22\" y2=\"12\"></line><line x1=\"2\" y1=\"7\" x2=\"7\" y2=\"7\"></line><line x1=\"2\" y1=\"17\" x2=\"7\" y2=\"17\"></line><line x1=\"17\" y1=\"17\" x2=\"22\" y2=\"17\"></line><line x1=\"17\" y1=\"7\" x2=\"22\" y2=\"7\"></line>","filter":"<polygon points=\"22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3\"></polygon>","flag":"<path d=\"M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z\"></path><line x1=\"4\" y1=\"22\" x2=\"4\" y2=\"15\"></line>","folder-minus":"<path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"></path><line x1=\"9\" y1=\"14\" x2=\"15\" y2=\"14\"></line>","folder-plus":"<path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"></path><line x1=\"12\" y1=\"11\" x2=\"12\" y2=\"17\"></line><line x1=\"9\" y1=\"14\" x2=\"15\" y2=\"14\"></line>","folder":"<path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"></path>","frown":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><path d=\"M16 16s-1.5-2-4-2-4 2-4 2\"></path><line x1=\"9\" y1=\"9\" x2=\"9.01\" y2=\"9\"></line><line x1=\"15\" y1=\"9\" x2=\"15.01\" y2=\"9\"></line>","gift":"<polyline points=\"20 12 20 22 4 22 4 12\"></polyline><rect x=\"2\" y=\"7\" width=\"20\" height=\"5\"></rect><line x1=\"12\" y1=\"22\" x2=\"12\" y2=\"7\"></line><path d=\"M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z\"></path><path d=\"M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z\"></path>","git-branch":"<line x1=\"6\" y1=\"3\" x2=\"6\" y2=\"15\"></line><circle cx=\"18\" cy=\"6\" r=\"3\"></circle><circle cx=\"6\" cy=\"18\" r=\"3\"></circle><path d=\"M18 9a9 9 0 0 1-9 9\"></path>","git-commit":"<circle cx=\"12\" cy=\"12\" r=\"4\"></circle><line x1=\"1.05\" y1=\"12\" x2=\"7\" y2=\"12\"></line><line x1=\"17.01\" y1=\"12\" x2=\"22.96\" y2=\"12\"></line>","git-merge":"<circle cx=\"18\" cy=\"18\" r=\"3\"></circle><circle cx=\"6\" cy=\"6\" r=\"3\"></circle><path d=\"M6 21V9a9 9 0 0 0 9 9\"></path>","git-pull-request":"<circle cx=\"18\" cy=\"18\" r=\"3\"></circle><circle cx=\"6\" cy=\"6\" r=\"3\"></circle><path d=\"M13 6h3a2 2 0 0 1 2 2v7\"></path><line x1=\"6\" y1=\"9\" x2=\"6\" y2=\"21\"></line>","github":"<path d=\"M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22\"></path>","gitlab":"<path d=\"M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z\"></path>","globe":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"2\" y1=\"12\" x2=\"22\" y2=\"12\"></line><path d=\"M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z\"></path>","grid":"<rect x=\"3\" y=\"3\" width=\"7\" height=\"7\"></rect><rect x=\"14\" y=\"3\" width=\"7\" height=\"7\"></rect><rect x=\"14\" y=\"14\" width=\"7\" height=\"7\"></rect><rect x=\"3\" y=\"14\" width=\"7\" height=\"7\"></rect>","hard-drive":"<line x1=\"22\" y1=\"12\" x2=\"2\" y2=\"12\"></line><path d=\"M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z\"></path><line x1=\"6\" y1=\"16\" x2=\"6\" y2=\"16\"></line><line x1=\"10\" y1=\"16\" x2=\"10\" y2=\"16\"></line>","hash":"<line x1=\"4\" y1=\"9\" x2=\"20\" y2=\"9\"></line><line x1=\"4\" y1=\"15\" x2=\"20\" y2=\"15\"></line><line x1=\"10\" y1=\"3\" x2=\"8\" y2=\"21\"></line><line x1=\"16\" y1=\"3\" x2=\"14\" y2=\"21\"></line>","headphones":"<path d=\"M3 18v-6a9 9 0 0 1 18 0v6\"></path><path d=\"M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z\"></path>","heart":"<path d=\"M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z\"></path>","help-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><path d=\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\"></path><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"17\"></line>","hexagon":"<path d=\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\"></path>","home":"<path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"></path><polyline points=\"9 22 9 12 15 12 15 22\"></polyline>","image":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><circle cx=\"8.5\" cy=\"8.5\" r=\"1.5\"></circle><polyline points=\"21 15 16 10 5 21\"></polyline>","inbox":"<polyline points=\"22 12 16 12 14 15 10 15 8 12 2 12\"></polyline><path d=\"M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z\"></path>","info":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"12\"></line><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"8\"></line>","instagram":"<rect x=\"2\" y=\"2\" width=\"20\" height=\"20\" rx=\"5\" ry=\"5\"></rect><path d=\"M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z\"></path><line x1=\"17.5\" y1=\"6.5\" x2=\"17.5\" y2=\"6.5\"></line>","italic":"<line x1=\"19\" y1=\"4\" x2=\"10\" y2=\"4\"></line><line x1=\"14\" y1=\"20\" x2=\"5\" y2=\"20\"></line><line x1=\"15\" y1=\"4\" x2=\"9\" y2=\"20\"></line>","key":"<path d=\"M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4\"></path>","layers":"<polygon points=\"12 2 2 7 12 12 22 7 12 2\"></polygon><polyline points=\"2 17 12 22 22 17\"></polyline><polyline points=\"2 12 12 17 22 12\"></polyline>","layout":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"3\" y1=\"9\" x2=\"21\" y2=\"9\"></line><line x1=\"9\" y1=\"21\" x2=\"9\" y2=\"9\"></line>","life-buoy":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><circle cx=\"12\" cy=\"12\" r=\"4\"></circle><line x1=\"4.93\" y1=\"4.93\" x2=\"9.17\" y2=\"9.17\"></line><line x1=\"14.83\" y1=\"14.83\" x2=\"19.07\" y2=\"19.07\"></line><line x1=\"14.83\" y1=\"9.17\" x2=\"19.07\" y2=\"4.93\"></line><line x1=\"14.83\" y1=\"9.17\" x2=\"18.36\" y2=\"5.64\"></line><line x1=\"4.93\" y1=\"19.07\" x2=\"9.17\" y2=\"14.83\"></line>","link-2":"<path d=\"M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3\"></path><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","link":"<path d=\"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71\"></path><path d=\"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71\"></path>","linkedin":"<path d=\"M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z\"></path><rect x=\"2\" y=\"9\" width=\"4\" height=\"12\"></rect><circle cx=\"4\" cy=\"4\" r=\"2\"></circle>","list":"<line x1=\"8\" y1=\"6\" x2=\"21\" y2=\"6\"></line><line x1=\"8\" y1=\"12\" x2=\"21\" y2=\"12\"></line><line x1=\"8\" y1=\"18\" x2=\"21\" y2=\"18\"></line><line x1=\"3\" y1=\"6\" x2=\"3\" y2=\"6\"></line><line x1=\"3\" y1=\"12\" x2=\"3\" y2=\"12\"></line><line x1=\"3\" y1=\"18\" x2=\"3\" y2=\"18\"></line>","loader":"<line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"6\"></line><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"22\"></line><line x1=\"4.93\" y1=\"4.93\" x2=\"7.76\" y2=\"7.76\"></line><line x1=\"16.24\" y1=\"16.24\" x2=\"19.07\" y2=\"19.07\"></line><line x1=\"2\" y1=\"12\" x2=\"6\" y2=\"12\"></line><line x1=\"18\" y1=\"12\" x2=\"22\" y2=\"12\"></line><line x1=\"4.93\" y1=\"19.07\" x2=\"7.76\" y2=\"16.24\"></line><line x1=\"16.24\" y1=\"7.76\" x2=\"19.07\" y2=\"4.93\"></line>","lock":"<rect x=\"3\" y=\"11\" width=\"18\" height=\"11\" rx=\"2\" ry=\"2\"></rect><path d=\"M7 11V7a5 5 0 0 1 10 0v4\"></path>","log-in":"<path d=\"M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4\"></path><polyline points=\"10 17 15 12 10 7\"></polyline><line x1=\"15\" y1=\"12\" x2=\"3\" y2=\"12\"></line>","log-out":"<path d=\"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4\"></path><polyline points=\"16 17 21 12 16 7\"></polyline><line x1=\"21\" y1=\"12\" x2=\"9\" y2=\"12\"></line>","mail":"<path d=\"M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z\"></path><polyline points=\"22,6 12,13 2,6\"></polyline>","map-pin":"<path d=\"M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z\"></path><circle cx=\"12\" cy=\"10\" r=\"3\"></circle>","map":"<polygon points=\"1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6\"></polygon><line x1=\"8\" y1=\"2\" x2=\"8\" y2=\"18\"></line><line x1=\"16\" y1=\"6\" x2=\"16\" y2=\"22\"></line>","maximize-2":"<polyline points=\"15 3 21 3 21 9\"></polyline><polyline points=\"9 21 3 21 3 15\"></polyline><line x1=\"21\" y1=\"3\" x2=\"14\" y2=\"10\"></line><line x1=\"3\" y1=\"21\" x2=\"10\" y2=\"14\"></line>","maximize":"<path d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\"></path>","meh":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"8\" y1=\"15\" x2=\"16\" y2=\"15\"></line><line x1=\"9\" y1=\"9\" x2=\"9.01\" y2=\"9\"></line><line x1=\"15\" y1=\"9\" x2=\"15.01\" y2=\"9\"></line>","menu":"<line x1=\"3\" y1=\"12\" x2=\"21\" y2=\"12\"></line><line x1=\"3\" y1=\"6\" x2=\"21\" y2=\"6\"></line><line x1=\"3\" y1=\"18\" x2=\"21\" y2=\"18\"></line>","message-circle":"<path d=\"M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z\"></path>","message-square":"<path d=\"M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z\"></path>","mic-off":"<line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line><path d=\"M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6\"></path><path d=\"M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23\"></path><line x1=\"12\" y1=\"19\" x2=\"12\" y2=\"23\"></line><line x1=\"8\" y1=\"23\" x2=\"16\" y2=\"23\"></line>","mic":"<path d=\"M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z\"></path><path d=\"M19 10v2a7 7 0 0 1-14 0v-2\"></path><line x1=\"12\" y1=\"19\" x2=\"12\" y2=\"23\"></line><line x1=\"8\" y1=\"23\" x2=\"16\" y2=\"23\"></line>","minimize-2":"<polyline points=\"4 14 10 14 10 20\"></polyline><polyline points=\"20 10 14 10 14 4\"></polyline><line x1=\"14\" y1=\"10\" x2=\"21\" y2=\"3\"></line><line x1=\"3\" y1=\"21\" x2=\"10\" y2=\"14\"></line>","minimize":"<path d=\"M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3\"></path>","minus-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","minus-square":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","minus":"<line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"></line>","monitor":"<rect x=\"2\" y=\"3\" width=\"20\" height=\"14\" rx=\"2\" ry=\"2\"></rect><line x1=\"8\" y1=\"21\" x2=\"16\" y2=\"21\"></line><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"21\"></line>","moon":"<path d=\"M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z\"></path>","more-horizontal":"<circle cx=\"12\" cy=\"12\" r=\"1\"></circle><circle cx=\"19\" cy=\"12\" r=\"1\"></circle><circle cx=\"5\" cy=\"12\" r=\"1\"></circle>","more-vertical":"<circle cx=\"12\" cy=\"12\" r=\"1\"></circle><circle cx=\"12\" cy=\"5\" r=\"1\"></circle><circle cx=\"12\" cy=\"19\" r=\"1\"></circle>","mouse-pointer":"<path d=\"M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z\"></path><path d=\"M13 13l6 6\"></path>","move":"<polyline points=\"5 9 2 12 5 15\"></polyline><polyline points=\"9 5 12 2 15 5\"></polyline><polyline points=\"15 19 12 22 9 19\"></polyline><polyline points=\"19 9 22 12 19 15\"></polyline><line x1=\"2\" y1=\"12\" x2=\"22\" y2=\"12\"></line><line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"22\"></line>","music":"<path d=\"M9 18V5l12-2v13\"></path><circle cx=\"6\" cy=\"18\" r=\"3\"></circle><circle cx=\"18\" cy=\"16\" r=\"3\"></circle>","navigation-2":"<polygon points=\"12 2 19 21 12 17 5 21 12 2\"></polygon>","navigation":"<polygon points=\"3 11 22 2 13 21 11 13 3 11\"></polygon>","octagon":"<polygon points=\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\"></polygon>","package":"<line x1=\"16.5\" y1=\"9.4\" x2=\"7.5\" y2=\"4.21\"></line><path d=\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\"></path><polyline points=\"3.27 6.96 12 12.01 20.73 6.96\"></polyline><line x1=\"12\" y1=\"22.08\" x2=\"12\" y2=\"12\"></line>","paperclip":"<path d=\"M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48\"></path>","pause-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"10\" y1=\"15\" x2=\"10\" y2=\"9\"></line><line x1=\"14\" y1=\"15\" x2=\"14\" y2=\"9\"></line>","pause":"<rect x=\"6\" y=\"4\" width=\"4\" height=\"16\"></rect><rect x=\"14\" y=\"4\" width=\"4\" height=\"16\"></rect>","pen-tool":"<path d=\"M12 19l7-7 3 3-7 7-3-3z\"></path><path d=\"M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z\"></path><path d=\"M2 2l7.586 7.586\"></path><circle cx=\"11\" cy=\"11\" r=\"2\"></circle>","percent":"<line x1=\"19\" y1=\"5\" x2=\"5\" y2=\"19\"></line><circle cx=\"6.5\" cy=\"6.5\" r=\"2.5\"></circle><circle cx=\"17.5\" cy=\"17.5\" r=\"2.5\"></circle>","phone-call":"<path d=\"M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","phone-forwarded":"<polyline points=\"19 1 23 5 19 9\"></polyline><line x1=\"15\" y1=\"5\" x2=\"23\" y2=\"5\"></line><path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","phone-incoming":"<polyline points=\"16 2 16 8 22 8\"></polyline><line x1=\"23\" y1=\"1\" x2=\"16\" y2=\"8\"></line><path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","phone-missed":"<line x1=\"23\" y1=\"1\" x2=\"17\" y2=\"7\"></line><line x1=\"17\" y1=\"1\" x2=\"23\" y2=\"7\"></line><path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","phone-off":"<path d=\"M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91\"></path><line x1=\"23\" y1=\"1\" x2=\"1\" y2=\"23\"></line>","phone-outgoing":"<polyline points=\"23 7 23 1 17 1\"></polyline><line x1=\"16\" y1=\"8\" x2=\"23\" y2=\"1\"></line><path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","phone":"<path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\"></path>","pie-chart":"<path d=\"M21.21 15.89A10 10 0 1 1 8 2.83\"></path><path d=\"M22 12A10 10 0 0 0 12 2v10z\"></path>","play-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><polygon points=\"10 8 16 12 10 16 10 8\"></polygon>","play":"<polygon points=\"5 3 19 12 5 21 5 3\"></polygon>","plus-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"16\"></line><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","plus-square":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"16\"></line><line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\"></line>","plus":"<line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"></line><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"></line>","pocket":"<path d=\"M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z\"></path><polyline points=\"8 10 12 14 16 10\"></polyline>","power":"<path d=\"M18.36 6.64a9 9 0 1 1-12.73 0\"></path><line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"12\"></line>","printer":"<polyline points=\"6 9 6 2 18 2 18 9\"></polyline><path d=\"M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2\"></path><rect x=\"6\" y=\"14\" width=\"12\" height=\"8\"></rect>","radio":"<circle cx=\"12\" cy=\"12\" r=\"2\"></circle><path d=\"M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14\"></path>","refresh-ccw":"<polyline points=\"1 4 1 10 7 10\"></polyline><polyline points=\"23 20 23 14 17 14\"></polyline><path d=\"M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15\"></path>","refresh-cw":"<polyline points=\"23 4 23 10 17 10\"></polyline><polyline points=\"1 20 1 14 7 14\"></polyline><path d=\"M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15\"></path>","repeat":"<polyline points=\"17 1 21 5 17 9\"></polyline><path d=\"M3 11V9a4 4 0 0 1 4-4h14\"></path><polyline points=\"7 23 3 19 7 15\"></polyline><path d=\"M21 13v2a4 4 0 0 1-4 4H3\"></path>","rewind":"<polygon points=\"11 19 2 12 11 5 11 19\"></polygon><polygon points=\"22 19 13 12 22 5 22 19\"></polygon>","rotate-ccw":"<polyline points=\"1 4 1 10 7 10\"></polyline><path d=\"M3.51 15a9 9 0 1 0 2.13-9.36L1 10\"></path>","rotate-cw":"<polyline points=\"23 4 23 10 17 10\"></polyline><path d=\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\"></path>","rss":"<path d=\"M4 11a9 9 0 0 1 9 9\"></path><path d=\"M4 4a16 16 0 0 1 16 16\"></path><circle cx=\"5\" cy=\"19\" r=\"1\"></circle>","save":"<path d=\"M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z\"></path><polyline points=\"17 21 17 13 7 13 7 21\"></polyline><polyline points=\"7 3 7 8 15 8\"></polyline>","scissors":"<circle cx=\"6\" cy=\"6\" r=\"3\"></circle><circle cx=\"6\" cy=\"18\" r=\"3\"></circle><line x1=\"20\" y1=\"4\" x2=\"8.12\" y2=\"15.88\"></line><line x1=\"14.47\" y1=\"14.48\" x2=\"20\" y2=\"20\"></line><line x1=\"8.12\" y1=\"8.12\" x2=\"12\" y2=\"12\"></line>","search":"<circle cx=\"11\" cy=\"11\" r=\"8\"></circle><line x1=\"21\" y1=\"21\" x2=\"16.65\" y2=\"16.65\"></line>","send":"<line x1=\"22\" y1=\"2\" x2=\"11\" y2=\"13\"></line><polygon points=\"22 2 15 22 11 13 2 9 22 2\"></polygon>","server":"<rect x=\"2\" y=\"2\" width=\"20\" height=\"8\" rx=\"2\" ry=\"2\"></rect><rect x=\"2\" y=\"14\" width=\"20\" height=\"8\" rx=\"2\" ry=\"2\"></rect><line x1=\"6\" y1=\"6\" x2=\"6\" y2=\"6\"></line><line x1=\"6\" y1=\"18\" x2=\"6\" y2=\"18\"></line>","settings":"<circle cx=\"12\" cy=\"12\" r=\"3\"></circle><path d=\"M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z\"></path>","share-2":"<circle cx=\"18\" cy=\"5\" r=\"3\"></circle><circle cx=\"6\" cy=\"12\" r=\"3\"></circle><circle cx=\"18\" cy=\"19\" r=\"3\"></circle><line x1=\"8.59\" y1=\"13.51\" x2=\"15.42\" y2=\"17.49\"></line><line x1=\"15.41\" y1=\"6.51\" x2=\"8.59\" y2=\"10.49\"></line>","share":"<path d=\"M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8\"></path><polyline points=\"16 6 12 2 8 6\"></polyline><line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"15\"></line>","shield-off":"<path d=\"M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18\"></path><path d=\"M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","shield":"<path d=\"M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z\"></path>","shopping-bag":"<path d=\"M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z\"></path><line x1=\"3\" y1=\"6\" x2=\"21\" y2=\"6\"></line><path d=\"M16 10a4 4 0 0 1-8 0\"></path>","shopping-cart":"<circle cx=\"9\" cy=\"21\" r=\"1\"></circle><circle cx=\"20\" cy=\"21\" r=\"1\"></circle><path d=\"M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6\"></path>","shuffle":"<polyline points=\"16 3 21 3 21 8\"></polyline><line x1=\"4\" y1=\"20\" x2=\"21\" y2=\"3\"></line><polyline points=\"21 16 21 21 16 21\"></polyline><line x1=\"15\" y1=\"15\" x2=\"21\" y2=\"21\"></line><line x1=\"4\" y1=\"4\" x2=\"9\" y2=\"9\"></line>","sidebar":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"9\" y1=\"3\" x2=\"9\" y2=\"21\"></line>","skip-back":"<polygon points=\"19 20 9 12 19 4 19 20\"></polygon><line x1=\"5\" y1=\"19\" x2=\"5\" y2=\"5\"></line>","skip-forward":"<polygon points=\"5 4 15 12 5 20 5 4\"></polygon><line x1=\"19\" y1=\"5\" x2=\"19\" y2=\"19\"></line>","slack":"<path d=\"M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z\"></path><path d=\"M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z\"></path><path d=\"M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z\"></path><path d=\"M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z\"></path><path d=\"M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z\"></path><path d=\"M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z\"></path><path d=\"M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z\"></path><path d=\"M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z\"></path>","slash":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"4.93\" y1=\"4.93\" x2=\"19.07\" y2=\"19.07\"></line>","sliders":"<line x1=\"4\" y1=\"21\" x2=\"4\" y2=\"14\"></line><line x1=\"4\" y1=\"10\" x2=\"4\" y2=\"3\"></line><line x1=\"12\" y1=\"21\" x2=\"12\" y2=\"12\"></line><line x1=\"12\" y1=\"8\" x2=\"12\" y2=\"3\"></line><line x1=\"20\" y1=\"21\" x2=\"20\" y2=\"16\"></line><line x1=\"20\" y1=\"12\" x2=\"20\" y2=\"3\"></line><line x1=\"1\" y1=\"14\" x2=\"7\" y2=\"14\"></line><line x1=\"9\" y1=\"8\" x2=\"15\" y2=\"8\"></line><line x1=\"17\" y1=\"16\" x2=\"23\" y2=\"16\"></line>","smartphone":"<rect x=\"5\" y=\"2\" width=\"14\" height=\"20\" rx=\"2\" ry=\"2\"></rect><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"18\"></line>","smile":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><path d=\"M8 14s1.5 2 4 2 4-2 4-2\"></path><line x1=\"9\" y1=\"9\" x2=\"9.01\" y2=\"9\"></line><line x1=\"15\" y1=\"9\" x2=\"15.01\" y2=\"9\"></line>","speaker":"<rect x=\"4\" y=\"2\" width=\"16\" height=\"20\" rx=\"2\" ry=\"2\"></rect><circle cx=\"12\" cy=\"14\" r=\"4\"></circle><line x1=\"12\" y1=\"6\" x2=\"12\" y2=\"6\"></line>","square":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect>","star":"<polygon points=\"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2\"></polygon>","stop-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><rect x=\"9\" y=\"9\" width=\"6\" height=\"6\"></rect>","sun":"<circle cx=\"12\" cy=\"12\" r=\"5\"></circle><line x1=\"12\" y1=\"1\" x2=\"12\" y2=\"3\"></line><line x1=\"12\" y1=\"21\" x2=\"12\" y2=\"23\"></line><line x1=\"4.22\" y1=\"4.22\" x2=\"5.64\" y2=\"5.64\"></line><line x1=\"18.36\" y1=\"18.36\" x2=\"19.78\" y2=\"19.78\"></line><line x1=\"1\" y1=\"12\" x2=\"3\" y2=\"12\"></line><line x1=\"21\" y1=\"12\" x2=\"23\" y2=\"12\"></line><line x1=\"4.22\" y1=\"19.78\" x2=\"5.64\" y2=\"18.36\"></line><line x1=\"18.36\" y1=\"5.64\" x2=\"19.78\" y2=\"4.22\"></line>","sunrise":"<path d=\"M17 18a5 5 0 0 0-10 0\"></path><line x1=\"12\" y1=\"2\" x2=\"12\" y2=\"9\"></line><line x1=\"4.22\" y1=\"10.22\" x2=\"5.64\" y2=\"11.64\"></line><line x1=\"1\" y1=\"18\" x2=\"3\" y2=\"18\"></line><line x1=\"21\" y1=\"18\" x2=\"23\" y2=\"18\"></line><line x1=\"18.36\" y1=\"11.64\" x2=\"19.78\" y2=\"10.22\"></line><line x1=\"23\" y1=\"22\" x2=\"1\" y2=\"22\"></line><polyline points=\"8 6 12 2 16 6\"></polyline>","sunset":"<path d=\"M17 18a5 5 0 0 0-10 0\"></path><line x1=\"12\" y1=\"9\" x2=\"12\" y2=\"2\"></line><line x1=\"4.22\" y1=\"10.22\" x2=\"5.64\" y2=\"11.64\"></line><line x1=\"1\" y1=\"18\" x2=\"3\" y2=\"18\"></line><line x1=\"21\" y1=\"18\" x2=\"23\" y2=\"18\"></line><line x1=\"18.36\" y1=\"11.64\" x2=\"19.78\" y2=\"10.22\"></line><line x1=\"23\" y1=\"22\" x2=\"1\" y2=\"22\"></line><polyline points=\"16 5 12 9 8 5\"></polyline>","tablet":"<rect x=\"4\" y=\"2\" width=\"16\" height=\"20\" rx=\"2\" ry=\"2\" transform=\"rotate(180 12 12)\"></rect><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"18\"></line>","tag":"<path d=\"M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z\"></path><line x1=\"7\" y1=\"7\" x2=\"7\" y2=\"7\"></line>","target":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><circle cx=\"12\" cy=\"12\" r=\"6\"></circle><circle cx=\"12\" cy=\"12\" r=\"2\"></circle>","terminal":"<polyline points=\"4 17 10 11 4 5\"></polyline><line x1=\"12\" y1=\"19\" x2=\"20\" y2=\"19\"></line>","thermometer":"<path d=\"M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z\"></path>","thumbs-down":"<path d=\"M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17\"></path>","thumbs-up":"<path d=\"M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3\"></path>","toggle-left":"<rect x=\"1\" y=\"5\" width=\"22\" height=\"14\" rx=\"7\" ry=\"7\"></rect><circle cx=\"8\" cy=\"12\" r=\"3\"></circle>","toggle-right":"<rect x=\"1\" y=\"5\" width=\"22\" height=\"14\" rx=\"7\" ry=\"7\"></rect><circle cx=\"16\" cy=\"12\" r=\"3\"></circle>","trash-2":"<polyline points=\"3 6 5 6 21 6\"></polyline><path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path><line x1=\"10\" y1=\"11\" x2=\"10\" y2=\"17\"></line><line x1=\"14\" y1=\"11\" x2=\"14\" y2=\"17\"></line>","trash":"<polyline points=\"3 6 5 6 21 6\"></polyline><path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path>","trello":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><rect x=\"7\" y=\"7\" width=\"3\" height=\"9\"></rect><rect x=\"14\" y=\"7\" width=\"3\" height=\"5\"></rect>","trending-down":"<polyline points=\"23 18 13.5 8.5 8.5 13.5 1 6\"></polyline><polyline points=\"17 18 23 18 23 12\"></polyline>","trending-up":"<polyline points=\"23 6 13.5 15.5 8.5 10.5 1 18\"></polyline><polyline points=\"17 6 23 6 23 12\"></polyline>","triangle":"<path d=\"M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z\"></path>","truck":"<rect x=\"1\" y=\"3\" width=\"15\" height=\"13\"></rect><polygon points=\"16 8 20 8 23 11 23 16 16 16 16 8\"></polygon><circle cx=\"5.5\" cy=\"18.5\" r=\"2.5\"></circle><circle cx=\"18.5\" cy=\"18.5\" r=\"2.5\"></circle>","tv":"<rect x=\"2\" y=\"7\" width=\"20\" height=\"15\" rx=\"2\" ry=\"2\"></rect><polyline points=\"17 2 12 7 7 2\"></polyline>","twitter":"<path d=\"M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z\"></path>","type":"<polyline points=\"4 7 4 4 20 4 20 7\"></polyline><line x1=\"9\" y1=\"20\" x2=\"15\" y2=\"20\"></line><line x1=\"12\" y1=\"4\" x2=\"12\" y2=\"20\"></line>","umbrella":"<path d=\"M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7\"></path>","underline":"<path d=\"M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3\"></path><line x1=\"4\" y1=\"21\" x2=\"20\" y2=\"21\"></line>","unlock":"<rect x=\"3\" y=\"11\" width=\"18\" height=\"11\" rx=\"2\" ry=\"2\"></rect><path d=\"M7 11V7a5 5 0 0 1 9.9-1\"></path>","upload-cloud":"<polyline points=\"16 16 12 12 8 16\"></polyline><line x1=\"12\" y1=\"12\" x2=\"12\" y2=\"21\"></line><path d=\"M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3\"></path><polyline points=\"16 16 12 12 8 16\"></polyline>","upload":"<path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"></path><polyline points=\"17 8 12 3 7 8\"></polyline><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"></line>","user-check":"<path d=\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"8.5\" cy=\"7\" r=\"4\"></circle><polyline points=\"17 11 19 13 23 9\"></polyline>","user-minus":"<path d=\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"8.5\" cy=\"7\" r=\"4\"></circle><line x1=\"23\" y1=\"11\" x2=\"17\" y2=\"11\"></line>","user-plus":"<path d=\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"8.5\" cy=\"7\" r=\"4\"></circle><line x1=\"20\" y1=\"8\" x2=\"20\" y2=\"14\"></line><line x1=\"23\" y1=\"11\" x2=\"17\" y2=\"11\"></line>","user-x":"<path d=\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"8.5\" cy=\"7\" r=\"4\"></circle><line x1=\"18\" y1=\"8\" x2=\"23\" y2=\"13\"></line><line x1=\"23\" y1=\"8\" x2=\"18\" y2=\"13\"></line>","user":"<path d=\"M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2\"></path><circle cx=\"12\" cy=\"7\" r=\"4\"></circle>","users":"<path d=\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\"></path><circle cx=\"9\" cy=\"7\" r=\"4\"></circle><path d=\"M23 21v-2a4 4 0 0 0-3-3.87\"></path><path d=\"M16 3.13a4 4 0 0 1 0 7.75\"></path>","video-off":"<path d=\"M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","video":"<polygon points=\"23 7 16 12 23 17 23 7\"></polygon><rect x=\"1\" y=\"5\" width=\"15\" height=\"14\" rx=\"2\" ry=\"2\"></rect>","voicemail":"<circle cx=\"5.5\" cy=\"11.5\" r=\"4.5\"></circle><circle cx=\"18.5\" cy=\"11.5\" r=\"4.5\"></circle><line x1=\"5.5\" y1=\"16\" x2=\"18.5\" y2=\"16\"></line>","volume-1":"<polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon><path d=\"M15.54 8.46a5 5 0 0 1 0 7.07\"></path>","volume-2":"<polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon><path d=\"M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07\"></path>","volume-x":"<polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon><line x1=\"23\" y1=\"9\" x2=\"17\" y2=\"15\"></line><line x1=\"17\" y1=\"9\" x2=\"23\" y2=\"15\"></line>","volume":"<polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>","watch":"<circle cx=\"12\" cy=\"12\" r=\"7\"></circle><polyline points=\"12 9 12 12 13.5 13.5\"></polyline><path d=\"M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83\"></path>","wifi-off":"<line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line><path d=\"M16.72 11.06A10.94 10.94 0 0 1 19 12.55\"></path><path d=\"M5 12.55a10.94 10.94 0 0 1 5.17-2.39\"></path><path d=\"M10.71 5.05A16 16 0 0 1 22.58 9\"></path><path d=\"M1.42 9a15.91 15.91 0 0 1 4.7-2.88\"></path><path d=\"M8.53 16.11a6 6 0 0 1 6.95 0\"></path><line x1=\"12\" y1=\"20\" x2=\"12\" y2=\"20\"></line>","wifi":"<path d=\"M5 12.55a11 11 0 0 1 14.08 0\"></path><path d=\"M1.42 9a16 16 0 0 1 21.16 0\"></path><path d=\"M8.53 16.11a6 6 0 0 1 6.95 0\"></path><line x1=\"12\" y1=\"20\" x2=\"12\" y2=\"20\"></line>","wind":"<path d=\"M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2\"></path>","x-circle":"<circle cx=\"12\" cy=\"12\" r=\"10\"></circle><line x1=\"15\" y1=\"9\" x2=\"9\" y2=\"15\"></line><line x1=\"9\" y1=\"9\" x2=\"15\" y2=\"15\"></line>","x-octagon":"<polygon points=\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\"></polygon><line x1=\"15\" y1=\"9\" x2=\"9\" y2=\"15\"></line><line x1=\"9\" y1=\"9\" x2=\"15\" y2=\"15\"></line>","x-square":"<rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"9\" y1=\"9\" x2=\"15\" y2=\"15\"></line><line x1=\"15\" y1=\"9\" x2=\"9\" y2=\"15\"></line>","x":"<line x1=\"18\" y1=\"6\" x2=\"6\" y2=\"18\"></line><line x1=\"6\" y1=\"6\" x2=\"18\" y2=\"18\"></line>","youtube":"<path d=\"M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z\"></path><polygon points=\"9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02\"></polygon>","zap-off":"<polyline points=\"12.41 6.75 13 2 10.57 4.92\"></polyline><polyline points=\"18.57 12.91 21 10 15.66 10\"></polyline><polyline points=\"8 8 3 14 12 14 11 22 16 16\"></polyline><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line>","zap":"<polygon points=\"13 2 3 14 12 14 11 22 21 10 12 10 13 2\"></polygon>","zoom-in":"<circle cx=\"11\" cy=\"11\" r=\"8\"></circle><line x1=\"21\" y1=\"21\" x2=\"16.65\" y2=\"16.65\"></line><line x1=\"11\" y1=\"8\" x2=\"11\" y2=\"14\"></line><line x1=\"8\" y1=\"11\" x2=\"14\" y2=\"11\"></line>","zoom-out":"<circle cx=\"11\" cy=\"11\" r=\"8\"></circle><line x1=\"21\" y1=\"21\" x2=\"16.65\" y2=\"16.65\"></line><line x1=\"8\" y1=\"11\" x2=\"14\" y2=\"11\"></line>"};

/***/ }),

/***/ "./node_modules/classnames/dedupe.js":
/*!*******************************************!*\
  !*** ./node_modules/classnames/dedupe.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var classNames = (function () {
		// don't inherit from Object so we can skip hasOwnProperty check later
		// http://stackoverflow.com/questions/15518328/creating-js-object-with-object-createnull#answer-21079232
		function StorageObject() {}
		StorageObject.prototype = Object.create(null);

		function _parseArray (resultSet, array) {
			var length = array.length;

			for (var i = 0; i < length; ++i) {
				_parse(resultSet, array[i]);
			}
		}

		var hasOwn = {}.hasOwnProperty;

		function _parseNumber (resultSet, num) {
			resultSet[num] = true;
		}

		function _parseObject (resultSet, object) {
			for (var k in object) {
				if (hasOwn.call(object, k)) {
					// set value to false instead of deleting it to avoid changing object structure
					// https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/#de-referencing-misconceptions
					resultSet[k] = !!object[k];
				}
			}
		}

		var SPACE = /\s+/;
		function _parseString (resultSet, str) {
			var array = str.split(SPACE);
			var length = array.length;

			for (var i = 0; i < length; ++i) {
				resultSet[array[i]] = true;
			}
		}

		function _parse (resultSet, arg) {
			if (!arg) return;
			var argType = typeof arg;

			// 'foo bar'
			if (argType === 'string') {
				_parseString(resultSet, arg);

			// ['foo', 'bar', ...]
			} else if (Array.isArray(arg)) {
				_parseArray(resultSet, arg);

			// { 'foo': true, ... }
			} else if (argType === 'object') {
				_parseObject(resultSet, arg);

			// '130'
			} else if (argType === 'number') {
				_parseNumber(resultSet, arg);
			}
		}

		function _classNames () {
			// don't leak arguments
			// https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
			var len = arguments.length;
			var args = Array(len);
			for (var i = 0; i < len; i++) {
				args[i] = arguments[i];
			}

			var classSet = new StorageObject();
			_parseArray(classSet, args);

			var list = [];

			for (var k in classSet) {
				if (classSet[k]) {
					list.push(k)
				}
			}

			return list.join(' ');
		}

		return _classNames;
	})();

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "./node_modules/core-js/fn/array/from.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/fn/array/from.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/core-js/modules/es6.string.iterator.js");
__webpack_require__(/*! ../../modules/es6.array.from */ "./node_modules/core-js/modules/es6.array.from.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").Array.from;


/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-includes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_classof.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_classof.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.6' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_create-property.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_create-property.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_defined.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_html.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_iobject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-array-iter.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-call.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-call.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-define.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iter-detect.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-detect.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iterators.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_library.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-create.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dps.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gpo.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_shared-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_shared.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/modules/_string-at.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-at.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-iobject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_wks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/modules/core.get-iterator-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.from.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.from.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.iterator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./src/default-attrs.json":
/*!********************************!*\
  !*** ./src/default-attrs.json ***!
  \********************************/
/*! exports provided: xmlns, width, height, viewBox, fill, stroke, stroke-width, stroke-linecap, stroke-linejoin, default */
/***/ (function(module) {

module.exports = {"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","stroke-width":2,"stroke-linecap":"round","stroke-linejoin":"round"};

/***/ }),

/***/ "./src/icon.js":
/*!*********************!*\
  !*** ./src/icon.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dedupe = __webpack_require__(/*! classnames/dedupe */ "./node_modules/classnames/dedupe.js");

var _dedupe2 = _interopRequireDefault(_dedupe);

var _defaultAttrs = __webpack_require__(/*! ./default-attrs.json */ "./src/default-attrs.json");

var _defaultAttrs2 = _interopRequireDefault(_defaultAttrs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Icon = function () {
  function Icon(name, contents) {
    var tags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, Icon);

    this.name = name;
    this.contents = contents;
    this.tags = tags;
    this.attrs = _extends({}, _defaultAttrs2.default, { class: 'feather feather-' + name });
  }

  /**
   * Create an SVG string.
   * @param {Object} attrs
   * @returns {string}
   */


  _createClass(Icon, [{
    key: 'toSvg',
    value: function toSvg() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var combinedAttrs = _extends({}, this.attrs, attrs, { class: (0, _dedupe2.default)(this.attrs.class, attrs.class) });

      return '<svg ' + attrsToString(combinedAttrs) + '>' + this.contents + '</svg>';
    }

    /**
     * Return string representation of an `Icon`.
     *
     * Added for backward compatibility. If old code expects `feather.icons.<name>`
     * to be a string, `toString()` will get implicitly called.
     *
     * @returns {string}
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.contents;
    }
  }]);

  return Icon;
}();

/**
 * Convert attributes object to string of HTML attributes.
 * @param {Object} attrs
 * @returns {string}
 */


function attrsToString(attrs) {
  return Object.keys(attrs).map(function (key) {
    return key + '="' + attrs[key] + '"';
  }).join(' ');
}

exports.default = Icon;

/***/ }),

/***/ "./src/icons.js":
/*!**********************!*\
  !*** ./src/icons.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _icon = __webpack_require__(/*! ./icon */ "./src/icon.js");

var _icon2 = _interopRequireDefault(_icon);

var _icons = __webpack_require__(/*! ../dist/icons.json */ "./dist/icons.json");

var _icons2 = _interopRequireDefault(_icons);

var _tags = __webpack_require__(/*! ./tags.json */ "./src/tags.json");

var _tags2 = _interopRequireDefault(_tags);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = Object.keys(_icons2.default).map(function (key) {
  return new _icon2.default(key, _icons2.default[key], _tags2.default[key]);
}).reduce(function (object, icon) {
  object[icon.name] = icon;
  return object;
}, {});

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");

var _icons2 = _interopRequireDefault(_icons);

var _toSvg = __webpack_require__(/*! ./to-svg */ "./src/to-svg.js");

var _toSvg2 = _interopRequireDefault(_toSvg);

var _replace = __webpack_require__(/*! ./replace */ "./src/replace.js");

var _replace2 = _interopRequireDefault(_replace);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = { icons: _icons2.default, toSvg: _toSvg2.default, replace: _replace2.default };

/***/ }),

/***/ "./src/replace.js":
/*!************************!*\
  !*** ./src/replace.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint-env browser */


var _dedupe = __webpack_require__(/*! classnames/dedupe */ "./node_modules/classnames/dedupe.js");

var _dedupe2 = _interopRequireDefault(_dedupe);

var _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");

var _icons2 = _interopRequireDefault(_icons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Replace all HTML elements that have a `data-feather` attribute with SVG markup
 * corresponding to the element's `data-feather` attribute value.
 * @param {Object} attrs
 */
function replace() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (typeof document === 'undefined') {
    throw new Error('`feather.replace()` only works in a browser environment.');
  }

  var elementsToReplace = document.querySelectorAll('[data-feather]');

  Array.from(elementsToReplace).forEach(function (element) {
    return replaceElement(element, attrs);
  });
}

/**
 * Replace a single HTML element with SVG markup
 * corresponding to the element's `data-feather` attribute value.
 * @param {HTMLElement} element
 * @param {Object} attrs
 */
function replaceElement(element) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var elementAttrs = getAttrs(element);
  var name = elementAttrs['data-feather'];
  delete elementAttrs['data-feather'];

  var svgString = _icons2.default[name].toSvg(_extends({}, attrs, elementAttrs, { class: (0, _dedupe2.default)(attrs.class, elementAttrs.class) }));
  var svgDocument = new DOMParser().parseFromString(svgString, 'image/svg+xml');
  var svgElement = svgDocument.querySelector('svg');

  element.parentNode.replaceChild(svgElement, element);
}

/**
 * Get the attributes of an HTML element.
 * @param {HTMLElement} element
 * @returns {Object}
 */
function getAttrs(element) {
  return Array.from(element.attributes).reduce(function (attrs, attr) {
    attrs[attr.name] = attr.value;
    return attrs;
  }, {});
}

exports.default = replace;

/***/ }),

/***/ "./src/tags.json":
/*!***********************!*\
  !*** ./src/tags.json ***!
  \***********************/
/*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, at-sign, award, aperture, bell, bell-off, bluetooth, book-open, book, bookmark, briefcase, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-rain, cloud-snow, cloud, codepen, codesandbox, coffee, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, credit-card, crop, crosshair, database, delete, disc, dollar-sign, droplet, edit, edit-2, edit-3, eye, eye-off, external-link, facebook, fast-forward, figma, film, folder-minus, folder-plus, folder, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, global, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, instagram, key, life-bouy, linkedin, lock, log-in, log-out, mail, map-pin, map, maximize, maximize-2, meh, menu, message-circle, message-square, mic-off, mic, minimize, minimize-2, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, navigation, navigation-2, octagon, package, paperclip, pause, pause-circle, pen-tool, play, play-circle, plus, plus-circle, plus-square, pocket, power, radio, rewind, rss, save, search, send, settings, shield, shield-off, shopping-bag, shopping-cart, shuffle, skip-back, skip-forward, slash, sliders, smile, speaker, star, sun, sunrise, sunset, tag, target, terminal, thumbs-down, thumbs-up, toggle-left, toggle-right, trash, trash-2, triangle, truck, twitter, umbrella, video-off, video, voicemail, volume, volume-1, volume-2, volume-x, watch, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, default */
/***/ (function(module) {

module.exports = {"activity":["pulse","health","action","motion"],"airplay":["stream","cast","mirroring"],"alert-circle":["warning"],"alert-octagon":["warning"],"alert-triangle":["warning"],"at-sign":["mention"],"award":["achievement","badge"],"aperture":["camera","photo"],"bell":["alarm","notification"],"bell-off":["alarm","notification","silent"],"bluetooth":["wireless"],"book-open":["read"],"book":["read","dictionary","booklet","magazine"],"bookmark":["read","clip","marker","tag"],"briefcase":["work","bag","baggage","folder"],"clipboard":["copy"],"clock":["time","watch","alarm"],"cloud-drizzle":["weather","shower"],"cloud-lightning":["weather","bolt"],"cloud-rain":["weather"],"cloud-snow":["weather","blizzard"],"cloud":["weather"],"codepen":["logo"],"codesandbox":["logo"],"coffee":["drink","cup","mug","tea","cafe","hot","beverage"],"command":["keyboard","cmd"],"compass":["navigation","safari","travel"],"copy":["clone","duplicate"],"corner-down-left":["arrow"],"corner-down-right":["arrow"],"corner-left-down":["arrow"],"corner-left-up":["arrow"],"corner-right-down":["arrow"],"corner-right-up":["arrow"],"corner-up-left":["arrow"],"corner-up-right":["arrow"],"credit-card":["purchase","payment","cc"],"crop":["photo","image"],"crosshair":["aim","target"],"database":["storage"],"delete":["remove"],"disc":["album","cd","dvd","music"],"dollar-sign":["currency","money","payment"],"droplet":["water"],"edit":["pencil","change"],"edit-2":["pencil","change"],"edit-3":["pencil","change"],"eye":["view","watch"],"eye-off":["view","watch"],"external-link":["outbound"],"facebook":["logo"],"fast-forward":["music"],"figma":["logo","design","tool"],"film":["movie","video"],"folder-minus":["directory"],"folder-plus":["directory"],"folder":["directory"],"frown":["emoji","face","bad","sad","emotion"],"gift":["present","box","birthday","party"],"git-branch":["code","version control"],"git-commit":["code","version control"],"git-merge":["code","version control"],"git-pull-request":["code","version control"],"github":["logo","version control"],"gitlab":["logo","version control"],"global":["world","browser","language","translate"],"hard-drive":["computer","server"],"hash":["hashtag","number","pound"],"headphones":["music","audio"],"heart":["like","love"],"help-circle":["question mark"],"hexagon":["shape","node.js","logo"],"home":["house"],"image":["picture"],"inbox":["email"],"instagram":["logo","camera"],"key":["password","login","authentication"],"life-bouy":["help","life ring","support"],"linkedin":["logo"],"lock":["security","password"],"log-in":["sign in","arrow"],"log-out":["sign out","arrow"],"mail":["email"],"map-pin":["location","navigation","travel","marker"],"map":["location","navigation","travel"],"maximize":["fullscreen"],"maximize-2":["fullscreen","arrows"],"meh":["emoji","face","neutral","emotion"],"menu":["bars","navigation","hamburger"],"message-circle":["comment","chat"],"message-square":["comment","chat"],"mic-off":["record"],"mic":["record"],"minimize":["exit fullscreen"],"minimize-2":["exit fullscreen","arrows"],"monitor":["tv"],"moon":["dark","night"],"more-horizontal":["ellipsis"],"more-vertical":["ellipsis"],"mouse-pointer":["arrow","cursor"],"move":["arrows"],"navigation":["location","travel"],"navigation-2":["location","travel"],"octagon":["stop"],"package":["box"],"paperclip":["attachment"],"pause":["music","stop"],"pause-circle":["music","stop"],"pen-tool":["vector","drawing"],"play":["music","start"],"play-circle":["music","start"],"plus":["add","new"],"plus-circle":["add","new"],"plus-square":["add","new"],"pocket":["logo","save"],"power":["on","off"],"radio":["signal"],"rewind":["music"],"rss":["feed","subscribe"],"save":["floppy disk"],"search":["find","magnifier","magnifying glass"],"send":["message","mail","paper airplane"],"settings":["cog","edit","gear","preferences"],"shield":["security"],"shield-off":["security"],"shopping-bag":["ecommerce","cart","purchase","store"],"shopping-cart":["ecommerce","cart","purchase","store"],"shuffle":["music"],"skip-back":["music"],"skip-forward":["music"],"slash":["ban","no"],"sliders":["settings","controls"],"smile":["emoji","face","happy","good","emotion"],"speaker":["music"],"star":["bookmark","favorite","like"],"sun":["brightness","weather","light"],"sunrise":["weather"],"sunset":["weather"],"tag":["label"],"target":["bullseye"],"terminal":["code","command line"],"thumbs-down":["dislike","bad"],"thumbs-up":["like","good"],"toggle-left":["on","off","switch"],"toggle-right":["on","off","switch"],"trash":["garbage","delete","remove"],"trash-2":["garbage","delete","remove"],"triangle":["delta"],"truck":["delivery","van","shipping"],"twitter":["logo"],"umbrella":["rain","weather"],"video-off":["camera","movie","film"],"video":["camera","movie","film"],"voicemail":["phone"],"volume":["music","sound","mute"],"volume-1":["music","sound"],"volume-2":["music","sound"],"volume-x":["music","sound","mute"],"watch":["clock","time"],"wind":["weather","air"],"x-circle":["cancel","close","delete","remove","times"],"x-octagon":["delete","stop","alert","warning","times"],"x-square":["cancel","close","delete","remove","times"],"x":["cancel","close","delete","remove","times"],"youtube":["logo","video","play"],"zap-off":["flash","camera","lightning"],"zap":["flash","camera","lightning"]};

/***/ }),

/***/ "./src/to-svg.js":
/*!***********************!*\
  !*** ./src/to-svg.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");

var _icons2 = _interopRequireDefault(_icons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create an SVG string.
 * @deprecated
 * @param {string} name
 * @param {Object} attrs
 * @returns {string}
 */
function toSvg(name) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  console.warn('feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.');

  if (!name) {
    throw new Error('The required `key` (icon name) parameter is missing.');
  }

  if (!_icons2.default[name]) {
    throw new Error('No icon matching \'' + name + '\'. See the complete list of icons at https://feathericons.com');
  }

  return _icons2.default[name].toSvg(attrs);
}

exports.default = toSvg;

/***/ }),

/***/ 0:
/*!**************************************************!*\
  !*** multi core-js/fn/array/from ./src/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! core-js/fn/array/from */"./node_modules/core-js/fn/array/from.js");
module.exports = __webpack_require__(/*! /home/travis/build/feathericons/feather/src/index.js */"./src/index.js");


/***/ })

/******/ });
});
//# sourceMappingURL=feather.js.map

/***/ }),

/***/ "./node_modules/flatpickr/dist/flatpickr.css":
/*!***************************************************!*\
  !*** ./node_modules/flatpickr/dist/flatpickr.css ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../css-loader!./flatpickr.css */ "./node_modules/css-loader/index.js!./node_modules/flatpickr/dist/flatpickr.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/flatpickr/dist/flatpickr.js":
/*!**************************************************!*\
  !*** ./node_modules/flatpickr/dist/flatpickr.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* flatpickr v4.5.7, @license MIT */
(function (global, factory) {
     true ? module.exports = factory() :
    undefined;
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var HOOKS = [
        "onChange",
        "onClose",
        "onDayCreate",
        "onDestroy",
        "onKeyDown",
        "onMonthChange",
        "onOpen",
        "onParseConfig",
        "onReady",
        "onValueUpdate",
        "onYearChange",
        "onPreCalendarPosition",
    ];
    var defaults = {
        _disable: [],
        _enable: [],
        allowInput: false,
        altFormat: "F j, Y",
        altInput: false,
        altInputClass: "form-control input",
        animate: typeof window === "object" &&
            window.navigator.userAgent.indexOf("MSIE") === -1,
        ariaDateFormat: "F j, Y",
        clickOpens: true,
        closeOnSelect: true,
        conjunction: ", ",
        dateFormat: "Y-m-d",
        defaultHour: 12,
        defaultMinute: 0,
        defaultSeconds: 0,
        disable: [],
        disableMobile: false,
        enable: [],
        enableSeconds: false,
        enableTime: false,
        errorHandler: function (err) {
            return typeof console !== "undefined" && console.warn(err);
        },
        getWeek: function (givenDate) {
            var date = new Date(givenDate.getTime());
            date.setHours(0, 0, 0, 0);
            // Thursday in current week decides the year.
            date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
            // January 4 is always in week 1.
            var week1 = new Date(date.getFullYear(), 0, 4);
            // Adjust to Thursday in week 1 and count number of weeks from date to week1.
            return (1 +
                Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                    3 +
                    ((week1.getDay() + 6) % 7)) /
                    7));
        },
        hourIncrement: 1,
        ignoredFocusElements: [],
        inline: false,
        locale: "default",
        minuteIncrement: 5,
        mode: "single",
        nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
        noCalendar: false,
        now: new Date(),
        onChange: [],
        onClose: [],
        onDayCreate: [],
        onDestroy: [],
        onKeyDown: [],
        onMonthChange: [],
        onOpen: [],
        onParseConfig: [],
        onReady: [],
        onValueUpdate: [],
        onYearChange: [],
        onPreCalendarPosition: [],
        plugins: [],
        position: "auto",
        positionElement: undefined,
        prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
        shorthandCurrentMonth: false,
        showMonths: 1,
        static: false,
        time_24hr: false,
        weekNumbers: false,
        wrap: false
    };

    var english = {
        weekdays: {
            shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            longhand: [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
            ]
        },
        months: {
            shorthand: [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ],
            longhand: [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
            ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function (nth) {
            var s = nth % 100;
            if (s > 3 && s < 21)
                return "th";
            switch (s % 10) {
                case 1:
                    return "st";
                case 2:
                    return "nd";
                case 3:
                    return "rd";
                default:
                    return "th";
            }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year"
    };

    var pad = function (number) { return ("0" + number).slice(-2); };
    var int = function (bool) { return (bool === true ? 1 : 0); };
    /* istanbul ignore next */
    function debounce(func, wait, immediate) {
        if (immediate === void 0) { immediate = false; }
        var timeout;
        return function () {
            var context = this, args = arguments;
            timeout !== null && clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                timeout = null;
                if (!immediate)
                    func.apply(context, args);
            }, wait);
            if (immediate && !timeout)
                func.apply(context, args);
        };
    }
    var arrayify = function (obj) {
        return obj instanceof Array ? obj : [obj];
    };

    function toggleClass(elem, className, bool) {
        if (bool === true)
            return elem.classList.add(className);
        elem.classList.remove(className);
    }
    function createElement(tag, className, content) {
        var e = window.document.createElement(tag);
        className = className || "";
        content = content || "";
        e.className = className;
        if (content !== undefined)
            e.textContent = content;
        return e;
    }
    function clearNode(node) {
        while (node.firstChild)
            node.removeChild(node.firstChild);
    }
    function findParent(node, condition) {
        if (condition(node))
            return node;
        else if (node.parentNode)
            return findParent(node.parentNode, condition);
        return undefined; // nothing found
    }
    function createNumberInput(inputClassName, opts) {
        var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
            numInput.type = "number";
        }
        else {
            numInput.type = "text";
            numInput.pattern = "\\d*";
        }
        if (opts !== undefined)
            for (var key in opts)
                numInput.setAttribute(key, opts[key]);
        wrapper.appendChild(numInput);
        wrapper.appendChild(arrowUp);
        wrapper.appendChild(arrowDown);
        return wrapper;
    }
    function getEventTarget(event) {
        if (typeof event.composedPath === "function") {
            var path = event.composedPath();
            return path[0];
        }
        return event.target;
    }

    var do_nothing = function () { return undefined; };
    var monthToStr = function (monthNumber, shorthand, locale) { return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]; };
    var revFormat = {
        D: do_nothing,
        F: function (dateObj, monthName, locale) {
            dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        H: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        J: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        K: function (dateObj, amPM, locale) {
            dateObj.setHours((dateObj.getHours() % 12) +
                12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M: function (dateObj, shortMonth, locale) {
            dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        U: function (_, unixSeconds) { return new Date(parseFloat(unixSeconds) * 1000); },
        W: function (dateObj, weekNum) {
            var weekNumber = parseInt(weekNum);
            return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
        },
        Y: function (dateObj, year) {
            dateObj.setFullYear(parseFloat(year));
        },
        Z: function (_, ISODate) { return new Date(ISODate); },
        d: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        h: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        i: function (dateObj, minutes) {
            dateObj.setMinutes(parseFloat(minutes));
        },
        j: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        l: do_nothing,
        m: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        n: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        s: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        u: function (_, unixMillSeconds) {
            return new Date(parseFloat(unixMillSeconds));
        },
        w: do_nothing,
        y: function (dateObj, year) {
            dateObj.setFullYear(2000 + parseFloat(year));
        }
    };
    var tokenRegex = {
        D: "(\\w+)",
        F: "(\\w+)",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "(\\w+)",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "(\\w+)",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})"
    };
    var formats = {
        // get the date in UTC
        Z: function (date) { return date.toISOString(); },
        // weekday name, short, e.g. Thu
        D: function (date, locale, options) {
            return locale.weekdays.shorthand[formats.w(date, locale, options)];
        },
        // full month name e.g. January
        F: function (date, locale, options) {
            return monthToStr(formats.n(date, locale, options) - 1, false, locale);
        },
        // padded hour 1-12
        G: function (date, locale, options) {
            return pad(formats.h(date, locale, options));
        },
        // hours with leading zero e.g. 03
        H: function (date) { return pad(date.getHours()); },
        // day (1-30) with ordinal suffix e.g. 1st, 2nd
        J: function (date, locale) {
            return locale.ordinal !== undefined
                ? date.getDate() + locale.ordinal(date.getDate())
                : date.getDate();
        },
        // AM/PM
        K: function (date, locale) { return locale.amPM[int(date.getHours() > 11)]; },
        // shorthand month e.g. Jan, Sep, Oct, etc
        M: function (date, locale) {
            return monthToStr(date.getMonth(), true, locale);
        },
        // seconds 00-59
        S: function (date) { return pad(date.getSeconds()); },
        // unix timestamp
        U: function (date) { return date.getTime() / 1000; },
        W: function (date, _, options) {
            return options.getWeek(date);
        },
        // full year e.g. 2016
        Y: function (date) { return date.getFullYear(); },
        // day in month, padded (01-30)
        d: function (date) { return pad(date.getDate()); },
        // hour from 1-12 (am/pm)
        h: function (date) { return (date.getHours() % 12 ? date.getHours() % 12 : 12); },
        // minutes, padded with leading zero e.g. 09
        i: function (date) { return pad(date.getMinutes()); },
        // day in month (1-30)
        j: function (date) { return date.getDate(); },
        // weekday name, full, e.g. Thursday
        l: function (date, locale) {
            return locale.weekdays.longhand[date.getDay()];
        },
        // padded month number (01-12)
        m: function (date) { return pad(date.getMonth() + 1); },
        // the month number (1-12)
        n: function (date) { return date.getMonth() + 1; },
        // seconds 0-59
        s: function (date) { return date.getSeconds(); },
        // Unix Milliseconds
        u: function (date) { return date.getTime(); },
        // number of the day of the week
        w: function (date) { return date.getDay(); },
        // last two digits of year e.g. 16 for 2016
        y: function (date) { return String(date.getFullYear()).substring(2); }
    };

    var createDateFormatter = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (dateObj, frmt, overrideLocale) {
            var locale = overrideLocale || l10n;
            if (config.formatDate !== undefined) {
                return config.formatDate(dateObj, frmt, locale);
            }
            return frmt
                .split("")
                .map(function (c, i, arr) {
                return formats[c] && arr[i - 1] !== "\\"
                    ? formats[c](dateObj, locale, config)
                    : c !== "\\"
                        ? c
                        : "";
            })
                .join("");
        };
    };
    var createDateParser = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (date, givenFormat, timeless, customLocale) {
            if (date !== 0 && !date)
                return undefined;
            var locale = customLocale || l10n;
            var parsedDate;
            var date_orig = date;
            if (date instanceof Date)
                parsedDate = new Date(date.getTime());
            else if (typeof date !== "string" &&
                date.toFixed !== undefined // timestamp
            )
                // create a copy
                parsedDate = new Date(date);
            else if (typeof date === "string") {
                // date string
                var format = givenFormat || (config || defaults).dateFormat;
                var datestr = String(date).trim();
                if (datestr === "today") {
                    parsedDate = new Date();
                    timeless = true;
                }
                else if (/Z$/.test(datestr) ||
                    /GMT$/.test(datestr) // datestrings w/ timezone
                )
                    parsedDate = new Date(date);
                else if (config && config.parseDate)
                    parsedDate = config.parseDate(date, format);
                else {
                    parsedDate =
                        !config || !config.noCalendar
                            ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                            : new Date(new Date().setHours(0, 0, 0, 0));
                    var matched = void 0, ops = [];
                    for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                        var token_1 = format[i];
                        var isBackSlash = token_1 === "\\";
                        var escaped = format[i - 1] === "\\" || isBackSlash;
                        if (tokenRegex[token_1] && !escaped) {
                            regexStr += tokenRegex[token_1];
                            var match = new RegExp(regexStr).exec(date);
                            if (match && (matched = true)) {
                                ops[token_1 !== "Y" ? "push" : "unshift"]({
                                    fn: revFormat[token_1],
                                    val: match[++matchIndex]
                                });
                            }
                        }
                        else if (!isBackSlash)
                            regexStr += "."; // don't really care
                        ops.forEach(function (_a) {
                            var fn = _a.fn, val = _a.val;
                            return (parsedDate = fn(parsedDate, val, locale) || parsedDate);
                        });
                    }
                    parsedDate = matched ? parsedDate : undefined;
                }
            }
            /* istanbul ignore next */
            if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
                config.errorHandler(new Error("Invalid date provided: " + date_orig));
                return undefined;
            }
            if (timeless === true)
                parsedDate.setHours(0, 0, 0, 0);
            return parsedDate;
        };
    };
    /**
     * Compute the difference in dates, measured in ms
     */
    function compareDates(date1, date2, timeless) {
        if (timeless === void 0) { timeless = true; }
        if (timeless !== false) {
            return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
                new Date(date2.getTime()).setHours(0, 0, 0, 0));
        }
        return date1.getTime() - date2.getTime();
    }
    var isBetween = function (ts, ts1, ts2) {
        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
    };
    var duration = {
        DAY: 86400000
    };

    if (typeof Object.assign !== "function") {
        Object.assign = function (target) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!target) {
                throw TypeError("Cannot convert undefined or null to object");
            }
            var _loop_1 = function (source) {
                if (source) {
                    Object.keys(source).forEach(function (key) { return (target[key] = source[key]); });
                }
            };
            for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
                var source = args_1[_a];
                _loop_1(source);
            }
            return target;
        };
    }

    var DEBOUNCED_CHANGE_MS = 300;
    function FlatpickrInstance(element, instanceConfig) {
        var self = {
            config: __assign({}, flatpickr.defaultConfig),
            l10n: english
        };
        self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        self._handlers = [];
        self._bind = bind;
        self._setHoursFromDate = setHoursFromDate;
        self._positionCalendar = positionCalendar;
        self.changeMonth = changeMonth;
        self.changeYear = changeYear;
        self.clear = clear;
        self.close = close;
        self._createElement = createElement;
        self.destroy = destroy;
        self.isEnabled = isEnabled;
        self.jumpToDate = jumpToDate;
        self.open = open;
        self.redraw = redraw;
        self.set = set;
        self.setDate = setDate;
        self.toggle = toggle;
        function setupHelperFunctions() {
            self.utils = {
                getDaysInMonth: function (month, yr) {
                    if (month === void 0) { month = self.currentMonth; }
                    if (yr === void 0) { yr = self.currentYear; }
                    if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                        return 29;
                    return self.l10n.daysInMonth[month];
                }
            };
        }
        function init() {
            self.element = self.input = element;
            self.isOpen = false;
            parseConfig();
            setupLocale();
            setupInputs();
            setupDates();
            setupHelperFunctions();
            if (!self.isMobile)
                build();
            bindEvents();
            if (self.selectedDates.length || self.config.noCalendar) {
                if (self.config.enableTime) {
                    setHoursFromDate(self.config.noCalendar
                        ? self.latestSelectedDateObj || self.config.minDate
                        : undefined);
                }
                updateValue(false);
            }
            setCalendarWidth();
            self.showTimeInput =
                self.selectedDates.length > 0 || self.config.noCalendar;
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            /* TODO: investigate this further
        
              Currently, there is weird positioning behavior in safari causing pages
              to scroll up. https://github.com/chmln/flatpickr/issues/563
        
              However, most browsers are not Safari and positioning is expensive when used
              in scale. https://github.com/chmln/flatpickr/issues/1096
            */
            if (!self.isMobile && isSafari) {
                positionCalendar();
            }
            triggerEvent("onReady");
        }
        function bindToInstance(fn) {
            return fn.bind(self);
        }
        function setCalendarWidth() {
            var config = self.config;
            if (config.weekNumbers === false && config.showMonths === 1)
                return;
            else if (config.noCalendar !== true) {
                window.requestAnimationFrame(function () {
                    if (self.calendarContainer !== undefined) {
                        self.calendarContainer.style.visibility = "hidden";
                        self.calendarContainer.style.display = "block";
                    }
                    if (self.daysContainer !== undefined) {
                        var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                        self.daysContainer.style.width = daysWidth + "px";
                        self.calendarContainer.style.width =
                            daysWidth +
                                (self.weekWrapper !== undefined
                                    ? self.weekWrapper.offsetWidth
                                    : 0) +
                                "px";
                        self.calendarContainer.style.removeProperty("visibility");
                        self.calendarContainer.style.removeProperty("display");
                    }
                });
            }
        }
        /**
         * The handler for all events targeting the time inputs
         */
        function updateTime(e) {
            if (self.selectedDates.length === 0) {
                setDefaultTime();
            }
            if (e !== undefined && e.type !== "blur") {
                timeWrapper(e);
            }
            var prevValue = self._input.value;
            setHoursFromInputs();
            updateValue();
            if (self._input.value !== prevValue) {
                self._debouncedChange();
            }
        }
        function ampm2military(hour, amPM) {
            return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);
        }
        function military2ampm(hour) {
            switch (hour % 24) {
                case 0:
                case 12:
                    return 12;
                default:
                    return hour % 12;
            }
        }
        /**
         * Syncs the selected date object time with user's time input
         */
        function setHoursFromInputs() {
            if (self.hourElement === undefined || self.minuteElement === undefined)
                return;
            var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
                ? (parseInt(self.secondElement.value, 10) || 0) % 60
                : 0;
            if (self.amPM !== undefined) {
                hours = ampm2military(hours, self.amPM.textContent);
            }
            var limitMinHours = self.config.minTime !== undefined ||
                (self.config.minDate &&
                    self.minDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                        0);
            var limitMaxHours = self.config.maxTime !== undefined ||
                (self.config.maxDate &&
                    self.maxDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                        0);
            if (limitMaxHours) {
                var maxTime = self.config.maxTime !== undefined
                    ? self.config.maxTime
                    : self.config.maxDate;
                hours = Math.min(hours, maxTime.getHours());
                if (hours === maxTime.getHours())
                    minutes = Math.min(minutes, maxTime.getMinutes());
                if (minutes === maxTime.getMinutes())
                    seconds = Math.min(seconds, maxTime.getSeconds());
            }
            if (limitMinHours) {
                var minTime = self.config.minTime !== undefined
                    ? self.config.minTime
                    : self.config.minDate;
                hours = Math.max(hours, minTime.getHours());
                if (hours === minTime.getHours())
                    minutes = Math.max(minutes, minTime.getMinutes());
                if (minutes === minTime.getMinutes())
                    seconds = Math.max(seconds, minTime.getSeconds());
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Syncs time input values with a date
         */
        function setHoursFromDate(dateObj) {
            var date = dateObj || self.latestSelectedDateObj;
            if (date)
                setHours(date.getHours(), date.getMinutes(), date.getSeconds());
        }
        function setDefaultHours() {
            var hours = self.config.defaultHour;
            var minutes = self.config.defaultMinute;
            var seconds = self.config.defaultSeconds;
            if (self.config.minDate !== undefined) {
                var min_hr = self.config.minDate.getHours();
                var min_minutes = self.config.minDate.getMinutes();
                hours = Math.max(hours, min_hr);
                if (hours === min_hr)
                    minutes = Math.max(min_minutes, minutes);
                if (hours === min_hr && minutes === min_minutes)
                    seconds = self.config.minDate.getSeconds();
            }
            if (self.config.maxDate !== undefined) {
                var max_hr = self.config.maxDate.getHours();
                var max_minutes = self.config.maxDate.getMinutes();
                hours = Math.min(hours, max_hr);
                if (hours === max_hr)
                    minutes = Math.min(max_minutes, minutes);
                if (hours === max_hr && minutes === max_minutes)
                    seconds = self.config.maxDate.getSeconds();
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Sets the hours, minutes, and optionally seconds
         * of the latest selected date object and the
         * corresponding time inputs
         * @param {Number} hours the hour. whether its military
         *                 or am-pm gets inferred from config
         * @param {Number} minutes the minutes
         * @param {Number} seconds the seconds (optional)
         */
        function setHours(hours, minutes, seconds) {
            if (self.latestSelectedDateObj !== undefined) {
                self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
            }
            if (!self.hourElement || !self.minuteElement || self.isMobile)
                return;
            self.hourElement.value = pad(!self.config.time_24hr
                ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)
                : hours);
            self.minuteElement.value = pad(minutes);
            if (self.amPM !== undefined)
                self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
            if (self.secondElement !== undefined)
                self.secondElement.value = pad(seconds);
        }
        /**
         * Handles the year input and incrementing events
         * @param {Event} event the keyup or increment event
         */
        function onYearInput(event) {
            var year = parseInt(event.target.value) + (event.delta || 0);
            if (year / 1000 > 1 ||
                (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
                changeYear(year);
            }
        }
        /**
         * Essentially addEventListener + tracking
         * @param {Element} element the element to addEventListener to
         * @param {String} event the event name
         * @param {Function} handler the event handler
         */
        function bind(element, event, handler, options) {
            if (event instanceof Array)
                return event.forEach(function (ev) { return bind(element, ev, handler, options); });
            if (element instanceof Array)
                return element.forEach(function (el) { return bind(el, event, handler, options); });
            element.addEventListener(event, handler, options);
            self._handlers.push({
                element: element,
                event: event,
                handler: handler,
                options: options
            });
        }
        /**
         * A mousedown handler which mimics click.
         * Minimizes latency, since we don't need to wait for mouseup in most cases.
         * Also, avoids handling right clicks.
         *
         * @param {Function} handler the event handler
         */
        function onClick(handler) {
            return function (evt) {
                evt.which === 1 && handler(evt);
            };
        }
        function triggerChange() {
            triggerEvent("onChange");
        }
        /**
         * Adds all the necessary event listeners
         */
        function bindEvents() {
            if (self.config.wrap) {
                ["open", "close", "toggle", "clear"].forEach(function (evt) {
                    Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                        return bind(el, "click", self[evt]);
                    });
                });
            }
            if (self.isMobile) {
                setupMobile();
                return;
            }
            var debouncedResize = debounce(onResize, 50);
            self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
            if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
                bind(self.daysContainer, "mouseover", function (e) {
                    if (self.config.mode === "range")
                        onMouseOver(e.target);
                });
            bind(window.document.body, "keydown", onKeyDown);
            if (!self.config.static)
                bind(self._input, "keydown", onKeyDown);
            if (!self.config.inline && !self.config.static)
                bind(window, "resize", debouncedResize);
            if (window.ontouchstart !== undefined)
                bind(window.document, "click", documentClick);
            else
                bind(window.document, "mousedown", onClick(documentClick));
            bind(window.document, "focus", documentClick, { capture: true });
            if (self.config.clickOpens === true) {
                bind(self._input, "focus", self.open);
                bind(self._input, "mousedown", onClick(self.open));
            }
            if (self.daysContainer !== undefined) {
                bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
                bind(self.monthNav, ["keyup", "increment"], onYearInput);
                bind(self.daysContainer, "mousedown", onClick(selectDate));
            }
            if (self.timeContainer !== undefined &&
                self.minuteElement !== undefined &&
                self.hourElement !== undefined) {
                var selText = function (e) {
                    return e.target.select();
                };
                bind(self.timeContainer, ["increment"], updateTime);
                bind(self.timeContainer, "blur", updateTime, { capture: true });
                bind(self.timeContainer, "mousedown", onClick(timeIncrement));
                bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
                if (self.secondElement !== undefined)
                    bind(self.secondElement, "focus", function () { return self.secondElement && self.secondElement.select(); });
                if (self.amPM !== undefined) {
                    bind(self.amPM, "mousedown", onClick(function (e) {
                        updateTime(e);
                        triggerChange();
                    }));
                }
            }
        }
        /**
         * Set the calendar view to a particular date.
         * @param {Date} jumpDate the date to set the view to
         */
        function jumpToDate(jumpDate) {
            var jumpTo = jumpDate !== undefined
                ? self.parseDate(jumpDate)
                : self.latestSelectedDateObj ||
                    (self.config.minDate && self.config.minDate > self.now
                        ? self.config.minDate
                        : self.config.maxDate && self.config.maxDate < self.now
                            ? self.config.maxDate
                            : self.now);
            try {
                if (jumpTo !== undefined) {
                    self.currentYear = jumpTo.getFullYear();
                    self.currentMonth = jumpTo.getMonth();
                }
            }
            catch (e) {
                /* istanbul ignore next */
                e.message = "Invalid date supplied: " + jumpTo;
                self.config.errorHandler(e);
            }
            self.redraw();
        }
        /**
         * The up/down arrow handler for time inputs
         * @param {Event} e the click event
         */
        function timeIncrement(e) {
            if (~e.target.className.indexOf("arrow"))
                incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
        }
        /**
         * Increments/decrements the value of input associ-
         * ated with the up/down arrow by dispatching an
         * "increment" event on the input.
         *
         * @param {Event} e the click event
         * @param {Number} delta the diff (usually 1 or -1)
         * @param {Element} inputElem the input element
         */
        function incrementNumInput(e, delta, inputElem) {
            var target = e && e.target;
            var input = inputElem ||
                (target && target.parentNode && target.parentNode.firstChild);
            var event = createEvent("increment");
            event.delta = delta;
            input && input.dispatchEvent(event);
        }
        function build() {
            var fragment = window.document.createDocumentFragment();
            self.calendarContainer = createElement("div", "flatpickr-calendar");
            self.calendarContainer.tabIndex = -1;
            if (!self.config.noCalendar) {
                fragment.appendChild(buildMonthNav());
                self.innerContainer = createElement("div", "flatpickr-innerContainer");
                if (self.config.weekNumbers) {
                    var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                    self.innerContainer.appendChild(weekWrapper);
                    self.weekNumbers = weekNumbers;
                    self.weekWrapper = weekWrapper;
                }
                self.rContainer = createElement("div", "flatpickr-rContainer");
                self.rContainer.appendChild(buildWeekdays());
                if (!self.daysContainer) {
                    self.daysContainer = createElement("div", "flatpickr-days");
                    self.daysContainer.tabIndex = -1;
                }
                buildDays();
                self.rContainer.appendChild(self.daysContainer);
                self.innerContainer.appendChild(self.rContainer);
                fragment.appendChild(self.innerContainer);
            }
            if (self.config.enableTime) {
                fragment.appendChild(buildTime());
            }
            toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
            toggleClass(self.calendarContainer, "animate", self.config.animate === true);
            toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
            self.calendarContainer.appendChild(fragment);
            var customAppend = self.config.appendTo !== undefined &&
                self.config.appendTo.nodeType !== undefined;
            if (self.config.inline || self.config.static) {
                self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
                if (self.config.inline) {
                    if (!customAppend && self.element.parentNode)
                        self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                    else if (self.config.appendTo !== undefined)
                        self.config.appendTo.appendChild(self.calendarContainer);
                }
                if (self.config.static) {
                    var wrapper = createElement("div", "flatpickr-wrapper");
                    if (self.element.parentNode)
                        self.element.parentNode.insertBefore(wrapper, self.element);
                    wrapper.appendChild(self.element);
                    if (self.altInput)
                        wrapper.appendChild(self.altInput);
                    wrapper.appendChild(self.calendarContainer);
                }
            }
            if (!self.config.static && !self.config.inline)
                (self.config.appendTo !== undefined
                    ? self.config.appendTo
                    : window.document.body).appendChild(self.calendarContainer);
        }
        function createDay(className, date, dayNumber, i) {
            var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
            dayElement.dateObj = date;
            dayElement.$i = i;
            dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
            if (className.indexOf("hidden") === -1 &&
                compareDates(date, self.now) === 0) {
                self.todayDateElem = dayElement;
                dayElement.classList.add("today");
                dayElement.setAttribute("aria-current", "date");
            }
            if (dateIsEnabled) {
                dayElement.tabIndex = -1;
                if (isDateSelected(date)) {
                    dayElement.classList.add("selected");
                    self.selectedDateElem = dayElement;
                    if (self.config.mode === "range") {
                        toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                            compareDates(date, self.selectedDates[0], true) === 0);
                        toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                            compareDates(date, self.selectedDates[1], true) === 0);
                        if (className === "nextMonthDay")
                            dayElement.classList.add("inRange");
                    }
                }
            }
            else {
                dayElement.classList.add("disabled");
            }
            if (self.config.mode === "range") {
                if (isDateInRange(date) && !isDateSelected(date))
                    dayElement.classList.add("inRange");
            }
            if (self.weekNumbers &&
                self.config.showMonths === 1 &&
                className !== "prevMonthDay" &&
                dayNumber % 7 === 1) {
                self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
            }
            triggerEvent("onDayCreate", dayElement);
            return dayElement;
        }
        function focusOnDayElem(targetNode) {
            targetNode.focus();
            if (self.config.mode === "range")
                onMouseOver(targetNode);
        }
        function getFirstAvailableDay(delta) {
            var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            for (var m = startMonth; m != endMonth; m += delta) {
                var month = self.daysContainer.children[m];
                var startIndex = delta > 0 ? 0 : month.children.length - 1;
                var endIndex = delta > 0 ? month.children.length : -1;
                for (var i = startIndex; i != endIndex; i += delta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                        return c;
                }
            }
            return undefined;
        }
        function getNextAvailableDay(current, delta) {
            var givenMonth = current.className.indexOf("Month") === -1
                ? current.dateObj.getMonth()
                : self.currentMonth;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            var loopDelta = delta > 0 ? 1 : -1;
            for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
                var month = self.daysContainer.children[m];
                var startIndex = givenMonth - self.currentMonth === m
                    ? current.$i + delta
                    : delta < 0
                        ? month.children.length - 1
                        : 0;
                var numMonthDays = month.children.length;
                for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 &&
                        isEnabled(c.dateObj) &&
                        Math.abs(current.$i - i) >= Math.abs(delta))
                        return focusOnDayElem(c);
                }
            }
            self.changeMonth(loopDelta);
            focusOnDay(getFirstAvailableDay(loopDelta), 0);
            return undefined;
        }
        function focusOnDay(current, offset) {
            var dayFocused = isInView(document.activeElement || document.body);
            var startElem = current !== undefined
                ? current
                : dayFocused
                    ? document.activeElement
                    : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                        ? self.selectedDateElem
                        : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                            ? self.todayDateElem
                            : getFirstAvailableDay(offset > 0 ? 1 : -1);
            if (startElem === undefined)
                return self._input.focus();
            if (!dayFocused)
                return focusOnDayElem(startElem);
            getNextAvailableDay(startElem, offset);
        }
        function buildMonthDays(year, month) {
            var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
            var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
            var daysInMonth = self.utils.getDaysInMonth(month), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
            var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
            // prepend days from the ending of previous month
            for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
                days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
            }
            // Start at 1 since there is no 0th day
            for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
                days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
            }
            // append days from the next month
            for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
                (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
                days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
            }
            //updateNavigationCurrentMonth();
            var dayContainer = createElement("div", "dayContainer");
            dayContainer.appendChild(days);
            return dayContainer;
        }
        function buildDays() {
            if (self.daysContainer === undefined) {
                return;
            }
            clearNode(self.daysContainer);
            // TODO: week numbers for each month
            if (self.weekNumbers)
                clearNode(self.weekNumbers);
            var frag = document.createDocumentFragment();
            for (var i = 0; i < self.config.showMonths; i++) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
            }
            self.daysContainer.appendChild(frag);
            self.days = self.daysContainer.firstChild;
            if (self.config.mode === "range" && self.selectedDates.length === 1) {
                onMouseOver();
            }
        }
        function buildMonth() {
            var container = createElement("div", "flatpickr-month");
            var monthNavFragment = window.document.createDocumentFragment();
            var monthElement = createElement("span", "cur-month");
            var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
            var yearElement = yearInput.getElementsByTagName("input")[0];
            yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
            if (self.config.minDate) {
                yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
            }
            if (self.config.maxDate) {
                yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
                yearElement.disabled =
                    !!self.config.minDate &&
                        self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
            }
            var currentMonth = createElement("div", "flatpickr-current-month");
            currentMonth.appendChild(monthElement);
            currentMonth.appendChild(yearInput);
            monthNavFragment.appendChild(currentMonth);
            container.appendChild(monthNavFragment);
            return {
                container: container,
                yearElement: yearElement,
                monthElement: monthElement
            };
        }
        function buildMonths() {
            clearNode(self.monthNav);
            self.monthNav.appendChild(self.prevMonthNav);
            if (self.config.showMonths) {
                self.yearElements = [];
                self.monthElements = [];
            }
            for (var m = self.config.showMonths; m--;) {
                var month = buildMonth();
                self.yearElements.push(month.yearElement);
                self.monthElements.push(month.monthElement);
                self.monthNav.appendChild(month.container);
            }
            self.monthNav.appendChild(self.nextMonthNav);
        }
        function buildMonthNav() {
            self.monthNav = createElement("div", "flatpickr-months");
            self.yearElements = [];
            self.monthElements = [];
            self.prevMonthNav = createElement("span", "flatpickr-prev-month");
            self.prevMonthNav.innerHTML = self.config.prevArrow;
            self.nextMonthNav = createElement("span", "flatpickr-next-month");
            self.nextMonthNav.innerHTML = self.config.nextArrow;
            buildMonths();
            Object.defineProperty(self, "_hidePrevMonthArrow", {
                get: function () { return self.__hidePrevMonthArrow; },
                set: function (bool) {
                    if (self.__hidePrevMonthArrow !== bool) {
                        toggleClass(self.prevMonthNav, "disabled", bool);
                        self.__hidePrevMonthArrow = bool;
                    }
                }
            });
            Object.defineProperty(self, "_hideNextMonthArrow", {
                get: function () { return self.__hideNextMonthArrow; },
                set: function (bool) {
                    if (self.__hideNextMonthArrow !== bool) {
                        toggleClass(self.nextMonthNav, "disabled", bool);
                        self.__hideNextMonthArrow = bool;
                    }
                }
            });
            self.currentYearElement = self.yearElements[0];
            updateNavigationCurrentMonth();
            return self.monthNav;
        }
        function buildTime() {
            self.calendarContainer.classList.add("hasTime");
            if (self.config.noCalendar)
                self.calendarContainer.classList.add("noCalendar");
            self.timeContainer = createElement("div", "flatpickr-time");
            self.timeContainer.tabIndex = -1;
            var separator = createElement("span", "flatpickr-time-separator", ":");
            var hourInput = createNumberInput("flatpickr-hour");
            self.hourElement = hourInput.getElementsByTagName("input")[0];
            var minuteInput = createNumberInput("flatpickr-minute");
            self.minuteElement = minuteInput.getElementsByTagName("input")[0];
            self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
            self.hourElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getHours()
                : self.config.time_24hr
                    ? self.config.defaultHour
                    : military2ampm(self.config.defaultHour));
            self.minuteElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getMinutes()
                : self.config.defaultMinute);
            self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
            self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
            self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
            self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
            self.minuteElement.setAttribute("min", "0");
            self.minuteElement.setAttribute("max", "59");
            self.timeContainer.appendChild(hourInput);
            self.timeContainer.appendChild(separator);
            self.timeContainer.appendChild(minuteInput);
            if (self.config.time_24hr)
                self.timeContainer.classList.add("time24hr");
            if (self.config.enableSeconds) {
                self.timeContainer.classList.add("hasSeconds");
                var secondInput = createNumberInput("flatpickr-second");
                self.secondElement = secondInput.getElementsByTagName("input")[0];
                self.secondElement.value = pad(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getSeconds()
                    : self.config.defaultSeconds);
                self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
                self.secondElement.setAttribute("min", "0");
                self.secondElement.setAttribute("max", "59");
                self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
                self.timeContainer.appendChild(secondInput);
            }
            if (!self.config.time_24hr) {
                // add self.amPM if appropriate
                self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj
                    ? self.hourElement.value
                    : self.config.defaultHour) > 11)]);
                self.amPM.title = self.l10n.toggleTitle;
                self.amPM.tabIndex = -1;
                self.timeContainer.appendChild(self.amPM);
            }
            return self.timeContainer;
        }
        function buildWeekdays() {
            if (!self.weekdayContainer)
                self.weekdayContainer = createElement("div", "flatpickr-weekdays");
            else
                clearNode(self.weekdayContainer);
            for (var i = self.config.showMonths; i--;) {
                var container = createElement("div", "flatpickr-weekdaycontainer");
                self.weekdayContainer.appendChild(container);
            }
            updateWeekdays();
            return self.weekdayContainer;
        }
        function updateWeekdays() {
            var firstDayOfWeek = self.l10n.firstDayOfWeek;
            var weekdays = self.l10n.weekdays.shorthand.slice();
            if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
                weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
            }
            for (var i = self.config.showMonths; i--;) {
                self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
            }
        }
        /* istanbul ignore next */
        function buildWeeks() {
            self.calendarContainer.classList.add("hasWeeks");
            var weekWrapper = createElement("div", "flatpickr-weekwrapper");
            weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
            var weekNumbers = createElement("div", "flatpickr-weeks");
            weekWrapper.appendChild(weekNumbers);
            return {
                weekWrapper: weekWrapper,
                weekNumbers: weekNumbers
            };
        }
        function changeMonth(value, is_offset) {
            if (is_offset === void 0) { is_offset = true; }
            var delta = is_offset ? value : value - self.currentMonth;
            if ((delta < 0 && self._hidePrevMonthArrow === true) ||
                (delta > 0 && self._hideNextMonthArrow === true))
                return;
            self.currentMonth += delta;
            if (self.currentMonth < 0 || self.currentMonth > 11) {
                self.currentYear += self.currentMonth > 11 ? 1 : -1;
                self.currentMonth = (self.currentMonth + 12) % 12;
                triggerEvent("onYearChange");
            }
            buildDays();
            triggerEvent("onMonthChange");
            updateNavigationCurrentMonth();
        }
        function clear(triggerChangeEvent, toInitial) {
            if (triggerChangeEvent === void 0) { triggerChangeEvent = true; }
            if (toInitial === void 0) { toInitial = true; }
            self.input.value = "";
            if (self.altInput !== undefined)
                self.altInput.value = "";
            if (self.mobileInput !== undefined)
                self.mobileInput.value = "";
            self.selectedDates = [];
            self.latestSelectedDateObj = undefined;
            if (toInitial === true) {
                self.currentYear = self._initialDate.getFullYear();
                self.currentMonth = self._initialDate.getMonth();
            }
            self.showTimeInput = false;
            if (self.config.enableTime === true) {
                setDefaultHours();
            }
            self.redraw();
            if (triggerChangeEvent)
                // triggerChangeEvent is true (default) or an Event
                triggerEvent("onChange");
        }
        function close() {
            self.isOpen = false;
            if (!self.isMobile) {
                if (self.calendarContainer !== undefined) {
                    self.calendarContainer.classList.remove("open");
                }
                if (self._input !== undefined) {
                    self._input.classList.remove("active");
                }
            }
            triggerEvent("onClose");
        }
        function destroy() {
            if (self.config !== undefined)
                triggerEvent("onDestroy");
            for (var i = self._handlers.length; i--;) {
                var h = self._handlers[i];
                h.element.removeEventListener(h.event, h.handler, h.options);
            }
            self._handlers = [];
            if (self.mobileInput) {
                if (self.mobileInput.parentNode)
                    self.mobileInput.parentNode.removeChild(self.mobileInput);
                self.mobileInput = undefined;
            }
            else if (self.calendarContainer && self.calendarContainer.parentNode) {
                if (self.config.static && self.calendarContainer.parentNode) {
                    var wrapper = self.calendarContainer.parentNode;
                    wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                    if (wrapper.parentNode) {
                        while (wrapper.firstChild)
                            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                        wrapper.parentNode.removeChild(wrapper);
                    }
                }
                else
                    self.calendarContainer.parentNode.removeChild(self.calendarContainer);
            }
            if (self.altInput) {
                self.input.type = "text";
                if (self.altInput.parentNode)
                    self.altInput.parentNode.removeChild(self.altInput);
                delete self.altInput;
            }
            if (self.input) {
                self.input.type = self.input._type;
                self.input.classList.remove("flatpickr-input");
                self.input.removeAttribute("readonly");
                self.input.value = "";
            }
            [
                "_showTimeInput",
                "latestSelectedDateObj",
                "_hideNextMonthArrow",
                "_hidePrevMonthArrow",
                "__hideNextMonthArrow",
                "__hidePrevMonthArrow",
                "isMobile",
                "isOpen",
                "selectedDateElem",
                "minDateHasTime",
                "maxDateHasTime",
                "days",
                "daysContainer",
                "_input",
                "_positionElement",
                "innerContainer",
                "rContainer",
                "monthNav",
                "todayDateElem",
                "calendarContainer",
                "weekdayContainer",
                "prevMonthNav",
                "nextMonthNav",
                "currentMonthElement",
                "currentYearElement",
                "navigationCurrentMonth",
                "selectedDateElem",
                "config",
            ].forEach(function (k) {
                try {
                    delete self[k];
                }
                catch (_) { }
            });
        }
        function isCalendarElem(elem) {
            if (self.config.appendTo && self.config.appendTo.contains(elem))
                return true;
            return self.calendarContainer.contains(elem);
        }
        function documentClick(e) {
            if (self.isOpen && !self.config.inline) {
                var eventTarget_1 = getEventTarget(e);
                var isCalendarElement = isCalendarElem(eventTarget_1);
                var isInput = eventTarget_1 === self.input ||
                    eventTarget_1 === self.altInput ||
                    self.element.contains(eventTarget_1) ||
                    // web components
                    // e.path is not present in all browsers. circumventing typechecks
                    (e.path &&
                        e.path.indexOf &&
                        (~e.path.indexOf(self.input) ||
                            ~e.path.indexOf(self.altInput)));
                var lostFocus = e.type === "blur"
                    ? isInput &&
                        e.relatedTarget &&
                        !isCalendarElem(e.relatedTarget)
                    : !isInput &&
                        !isCalendarElement &&
                        !isCalendarElem(e.relatedTarget);
                var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
                    return elem.contains(eventTarget_1);
                });
                if (lostFocus && isIgnored) {
                    self.close();
                    if (self.config.mode === "range" && self.selectedDates.length === 1) {
                        self.clear(false);
                        self.redraw();
                    }
                }
            }
        }
        function changeYear(newYear) {
            if (!newYear ||
                (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
                (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
                return;
            var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
            self.currentYear = newYearNum || self.currentYear;
            if (self.config.maxDate &&
                self.currentYear === self.config.maxDate.getFullYear()) {
                self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
            }
            else if (self.config.minDate &&
                self.currentYear === self.config.minDate.getFullYear()) {
                self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
            }
            if (isNewYear) {
                self.redraw();
                triggerEvent("onYearChange");
            }
        }
        function isEnabled(date, timeless) {
            if (timeless === void 0) { timeless = true; }
            var dateToCheck = self.parseDate(date, undefined, timeless); // timeless
            if ((self.config.minDate &&
                dateToCheck &&
                compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
                (self.config.maxDate &&
                    dateToCheck &&
                    compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
                return false;
            if (self.config.enable.length === 0 && self.config.disable.length === 0)
                return true;
            if (dateToCheck === undefined)
                return false;
            var bool = self.config.enable.length > 0, array = bool ? self.config.enable : self.config.disable;
            for (var i = 0, d = void 0; i < array.length; i++) {
                d = array[i];
                if (typeof d === "function" &&
                    d(dateToCheck) // disabled by function
                )
                    return bool;
                else if (d instanceof Date &&
                    dateToCheck !== undefined &&
                    d.getTime() === dateToCheck.getTime())
                    // disabled by date
                    return bool;
                else if (typeof d === "string" && dateToCheck !== undefined) {
                    // disabled by date string
                    var parsed = self.parseDate(d, undefined, true);
                    return parsed && parsed.getTime() === dateToCheck.getTime()
                        ? bool
                        : !bool;
                }
                else if (
                // disabled by range
                typeof d === "object" &&
                    dateToCheck !== undefined &&
                    d.from &&
                    d.to &&
                    dateToCheck.getTime() >= d.from.getTime() &&
                    dateToCheck.getTime() <= d.to.getTime())
                    return bool;
            }
            return !bool;
        }
        function isInView(elem) {
            if (self.daysContainer !== undefined)
                return (elem.className.indexOf("hidden") === -1 &&
                    self.daysContainer.contains(elem));
            return false;
        }
        function onKeyDown(e) {
            // e.key                      e.keyCode
            // "Backspace"                        8
            // "Tab"                              9
            // "Enter"                           13
            // "Escape"     (IE "Esc")           27
            // "ArrowLeft"  (IE "Left")          37
            // "ArrowUp"    (IE "Up")            38
            // "ArrowRight" (IE "Right")         39
            // "ArrowDown"  (IE "Down")          40
            // "Delete"     (IE "Del")           46
            var isInput = e.target === self._input;
            var allowInput = self.config.allowInput;
            var allowKeydown = self.isOpen && (!allowInput || !isInput);
            var allowInlineKeydown = self.config.inline && isInput && !allowInput;
            if (e.keyCode === 13 && isInput) {
                if (allowInput) {
                    self.setDate(self._input.value, true, e.target === self.altInput
                        ? self.config.altFormat
                        : self.config.dateFormat);
                    return e.target.blur();
                }
                else
                    self.open();
            }
            else if (isCalendarElem(e.target) ||
                allowKeydown ||
                allowInlineKeydown) {
                var isTimeObj = !!self.timeContainer &&
                    self.timeContainer.contains(e.target);
                switch (e.keyCode) {
                    case 13:
                        if (isTimeObj) {
                            updateTime();
                            focusAndClose();
                        }
                        else
                            selectDate(e);
                        break;
                    case 27: // escape
                        e.preventDefault();
                        focusAndClose();
                        break;
                    case 8:
                    case 46:
                        if (isInput && !self.config.allowInput) {
                            e.preventDefault();
                            self.clear();
                        }
                        break;
                    case 37:
                    case 39:
                        if (!isTimeObj) {
                            e.preventDefault();
                            if (self.daysContainer !== undefined &&
                                (allowInput === false ||
                                    (document.activeElement && isInView(document.activeElement)))) {
                                var delta_1 = e.keyCode === 39 ? 1 : -1;
                                if (!e.ctrlKey)
                                    focusOnDay(undefined, delta_1);
                                else {
                                    e.stopPropagation();
                                    changeMonth(delta_1);
                                    focusOnDay(getFirstAvailableDay(1), 0);
                                }
                            }
                        }
                        else if (self.hourElement)
                            self.hourElement.focus();
                        break;
                    case 38:
                    case 40:
                        e.preventDefault();
                        var delta = e.keyCode === 40 ? 1 : -1;
                        if ((self.daysContainer && e.target.$i !== undefined) ||
                            e.target === self.input) {
                            if (e.ctrlKey) {
                                e.stopPropagation();
                                changeYear(self.currentYear - delta);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            }
                            else if (!isTimeObj)
                                focusOnDay(undefined, delta * 7);
                        }
                        else if (self.config.enableTime) {
                            if (!isTimeObj && self.hourElement)
                                self.hourElement.focus();
                            updateTime(e);
                            self._debouncedChange();
                        }
                        break;
                    case 9:
                        if (isTimeObj) {
                            var elems = [
                                self.hourElement,
                                self.minuteElement,
                                self.secondElement,
                                self.amPM,
                            ].filter(function (x) { return x; });
                            var i = elems.indexOf(e.target);
                            if (i !== -1) {
                                var target = elems[i + (e.shiftKey ? -1 : 1)];
                                if (target !== undefined) {
                                    e.preventDefault();
                                    target.focus();
                                }
                                else if (e.shiftKey) {
                                    e.preventDefault();
                                    self._input.focus();
                                }
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
            if (self.amPM !== undefined && e.target === self.amPM) {
                switch (e.key) {
                    case self.l10n.amPM[0].charAt(0):
                    case self.l10n.amPM[0].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[0];
                        setHoursFromInputs();
                        updateValue();
                        break;
                    case self.l10n.amPM[1].charAt(0):
                    case self.l10n.amPM[1].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[1];
                        setHoursFromInputs();
                        updateValue();
                        break;
                }
            }
            triggerEvent("onKeyDown", e);
        }
        function onMouseOver(elem) {
            if (self.selectedDates.length !== 1 ||
                (elem &&
                    (!elem.classList.contains("flatpickr-day") ||
                        elem.classList.contains("disabled"))))
                return;
            var hoverDate = elem
                ? elem.dateObj.getTime()
                : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime()), lastDate = self.daysContainer.lastChild
                .lastChild.dateObj.getTime();
            var containsDisabled = false;
            var minRange = 0, maxRange = 0;
            for (var t = rangeStartDate; t < lastDate; t += duration.DAY) {
                if (!isEnabled(new Date(t), true)) {
                    containsDisabled =
                        containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                    if (t < initialDate && (!minRange || t > minRange))
                        minRange = t;
                    else if (t > initialDate && (!maxRange || t < maxRange))
                        maxRange = t;
                }
            }
            for (var m = 0; m < self.config.showMonths; m++) {
                var month = self.daysContainer.children[m];
                var prevMonth = self.daysContainer.children[m - 1];
                var _loop_1 = function (i, l) {
                    var dayElem = month.children[i], date = dayElem.dateObj;
                    var timestamp = date.getTime();
                    var outOfRange = (minRange > 0 && timestamp < minRange) ||
                        (maxRange > 0 && timestamp > maxRange);
                    if (outOfRange) {
                        dayElem.classList.add("notAllowed");
                        ["inRange", "startRange", "endRange"].forEach(function (c) {
                            dayElem.classList.remove(c);
                        });
                        return "continue";
                    }
                    else if (containsDisabled && !outOfRange)
                        return "continue";
                    ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                        dayElem.classList.remove(c);
                    });
                    if (elem !== undefined) {
                        elem.classList.add(hoverDate < self.selectedDates[0].getTime()
                            ? "startRange"
                            : "endRange");
                        if (month.contains(elem) ||
                            !(m > 0 &&
                                prevMonth &&
                                prevMonth.lastChild.dateObj.getTime() >= timestamp)) {
                            if (initialDate < hoverDate && timestamp === initialDate)
                                dayElem.classList.add("startRange");
                            else if (initialDate > hoverDate && timestamp === initialDate)
                                dayElem.classList.add("endRange");
                            if (timestamp >= minRange &&
                                (maxRange === 0 || timestamp <= maxRange) &&
                                isBetween(timestamp, initialDate, hoverDate))
                                dayElem.classList.add("inRange");
                        }
                    }
                };
                for (var i = 0, l = month.children.length; i < l; i++) {
                    _loop_1(i, l);
                }
            }
        }
        function onResize() {
            if (self.isOpen && !self.config.static && !self.config.inline)
                positionCalendar();
        }
        function setDefaultTime() {
            self.setDate(self.config.minDate !== undefined
                ? new Date(self.config.minDate.getTime())
                : new Date(), false);
            setDefaultHours();
            updateValue();
        }
        function open(e, positionElement) {
            if (positionElement === void 0) { positionElement = self._positionElement; }
            if (self.isMobile === true) {
                if (e) {
                    e.preventDefault();
                    e.target && e.target.blur();
                }
                if (self.mobileInput !== undefined) {
                    self.mobileInput.focus();
                    self.mobileInput.click();
                }
                triggerEvent("onOpen");
                return;
            }
            if (self._input.disabled || self.config.inline)
                return;
            var wasOpen = self.isOpen;
            self.isOpen = true;
            if (!wasOpen) {
                self.calendarContainer.classList.add("open");
                self._input.classList.add("active");
                triggerEvent("onOpen");
                positionCalendar(positionElement);
            }
            if (self.config.enableTime === true && self.config.noCalendar === true) {
                if (self.selectedDates.length === 0) {
                    setDefaultTime();
                }
                if (self.config.allowInput === false &&
                    (e === undefined ||
                        !self.timeContainer.contains(e.relatedTarget))) {
                    setTimeout(function () { return self.hourElement.select(); }, 50);
                }
            }
        }
        function minMaxDateSetter(type) {
            return function (date) {
                var dateObj = (self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat));
                var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
                if (dateObj !== undefined) {
                    self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                        dateObj.getHours() > 0 ||
                            dateObj.getMinutes() > 0 ||
                            dateObj.getSeconds() > 0;
                }
                if (self.selectedDates) {
                    self.selectedDates = self.selectedDates.filter(function (d) { return isEnabled(d); });
                    if (!self.selectedDates.length && type === "min")
                        setHoursFromDate(dateObj);
                    updateValue();
                }
                if (self.daysContainer) {
                    redraw();
                    if (dateObj !== undefined)
                        self.currentYearElement[type] = dateObj.getFullYear().toString();
                    else
                        self.currentYearElement.removeAttribute(type);
                    self.currentYearElement.disabled =
                        !!inverseDateObj &&
                            dateObj !== undefined &&
                            inverseDateObj.getFullYear() === dateObj.getFullYear();
                }
            };
        }
        function parseConfig() {
            var boolOpts = [
                "wrap",
                "weekNumbers",
                "allowInput",
                "clickOpens",
                "time_24hr",
                "enableTime",
                "noCalendar",
                "altInput",
                "shorthandCurrentMonth",
                "inline",
                "static",
                "enableSeconds",
                "disableMobile",
            ];
            var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
            var formats = {};
            self.config.parseDate = userConfig.parseDate;
            self.config.formatDate = userConfig.formatDate;
            Object.defineProperty(self.config, "enable", {
                get: function () { return self.config._enable; },
                set: function (dates) {
                    self.config._enable = parseDateRules(dates);
                }
            });
            Object.defineProperty(self.config, "disable", {
                get: function () { return self.config._disable; },
                set: function (dates) {
                    self.config._disable = parseDateRules(dates);
                }
            });
            var timeMode = userConfig.mode === "time";
            if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
                formats.dateFormat =
                    userConfig.noCalendar || timeMode
                        ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                        : flatpickr.defaultConfig.dateFormat +
                            " H:i" +
                            (userConfig.enableSeconds ? ":S" : "");
            }
            if (userConfig.altInput &&
                (userConfig.enableTime || timeMode) &&
                !userConfig.altFormat) {
                formats.altFormat =
                    userConfig.noCalendar || timeMode
                        ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                        : flatpickr.defaultConfig.altFormat +
                            (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
            }
            Object.defineProperty(self.config, "minDate", {
                get: function () { return self.config._minDate; },
                set: minMaxDateSetter("min")
            });
            Object.defineProperty(self.config, "maxDate", {
                get: function () { return self.config._maxDate; },
                set: minMaxDateSetter("max")
            });
            var minMaxTimeSetter = function (type) { return function (val) {
                self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");
            }; };
            Object.defineProperty(self.config, "minTime", {
                get: function () { return self.config._minTime; },
                set: minMaxTimeSetter("min")
            });
            Object.defineProperty(self.config, "maxTime", {
                get: function () { return self.config._maxTime; },
                set: minMaxTimeSetter("max")
            });
            if (userConfig.mode === "time") {
                self.config.noCalendar = true;
                self.config.enableTime = true;
            }
            Object.assign(self.config, formats, userConfig);
            for (var i = 0; i < boolOpts.length; i++)
                self.config[boolOpts[i]] =
                    self.config[boolOpts[i]] === true ||
                        self.config[boolOpts[i]] === "true";
            HOOKS.filter(function (hook) { return self.config[hook] !== undefined; }).forEach(function (hook) {
                self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
            });
            self.isMobile =
                !self.config.disableMobile &&
                    !self.config.inline &&
                    self.config.mode === "single" &&
                    !self.config.disable.length &&
                    !self.config.enable.length &&
                    !self.config.weekNumbers &&
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            for (var i = 0; i < self.config.plugins.length; i++) {
                var pluginConf = self.config.plugins[i](self) || {};
                for (var key in pluginConf) {
                    if (HOOKS.indexOf(key) > -1) {
                        self.config[key] = arrayify(pluginConf[key])
                            .map(bindToInstance)
                            .concat(self.config[key]);
                    }
                    else if (typeof userConfig[key] === "undefined")
                        self.config[key] = pluginConf[key];
                }
            }
            triggerEvent("onParseConfig");
        }
        function setupLocale() {
            if (typeof self.config.locale !== "object" &&
                typeof flatpickr.l10ns[self.config.locale] === "undefined")
                self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
            self.l10n = __assign({}, flatpickr.l10ns["default"], (typeof self.config.locale === "object"
                ? self.config.locale
                : self.config.locale !== "default"
                    ? flatpickr.l10ns[self.config.locale]
                    : undefined));
            tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
            self.formatDate = createDateFormatter(self);
            self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        }
        function positionCalendar(customPositionElement) {
            if (self.calendarContainer === undefined)
                return;
            triggerEvent("onPreCalendarPosition");
            var positionElement = customPositionElement || self._positionElement;
            var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function (acc, child) { return acc + child.offsetHeight; }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
                (configPosVertical !== "below" &&
                    distanceFromBottom < calendarHeight &&
                    inputBounds.top > calendarHeight);
            var top = window.pageYOffset +
                inputBounds.top +
                (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
            toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
            toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
            if (self.config.inline)
                return;
            var left = window.pageXOffset +
                inputBounds.left -
                (configPosHorizontal != null && configPosHorizontal === "center"
                    ? (calendarWidth - inputBounds.width) / 2
                    : 0);
            var right = window.document.body.offsetWidth - inputBounds.right;
            var rightMost = left + calendarWidth > window.document.body.offsetWidth;
            var centerMost = right + calendarWidth > window.document.body.offsetWidth;
            toggleClass(self.calendarContainer, "rightMost", rightMost);
            if (self.config.static)
                return;
            self.calendarContainer.style.top = top + "px";
            if (!rightMost) {
                self.calendarContainer.style.left = left + "px";
                self.calendarContainer.style.right = "auto";
            }
            else if (!centerMost) {
                self.calendarContainer.style.left = "auto";
                self.calendarContainer.style.right = right + "px";
            }
            else {
                var doc = document.styleSheets[0];
                // some testing environments don't have css support
                if (doc === undefined)
                    return;
                var bodyWidth = window.document.body.offsetWidth;
                var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
                var centerBefore = ".flatpickr-calendar.centerMost:before";
                var centerAfter = ".flatpickr-calendar.centerMost:after";
                var centerIndex = doc.cssRules.length;
                var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
                toggleClass(self.calendarContainer, "rightMost", false);
                toggleClass(self.calendarContainer, "centerMost", true);
                doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
                self.calendarContainer.style.left = centerLeft + "px";
                self.calendarContainer.style.right = "auto";
            }
        }
        function redraw() {
            if (self.config.noCalendar || self.isMobile)
                return;
            updateNavigationCurrentMonth();
            buildDays();
        }
        function focusAndClose() {
            self._input.focus();
            if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
                navigator.msMaxTouchPoints !== undefined) {
                // hack - bugs in the way IE handles focus keeps the calendar open
                setTimeout(self.close, 0);
            }
            else {
                self.close();
            }
        }
        function selectDate(e) {
            e.preventDefault();
            e.stopPropagation();
            var isSelectable = function (day) {
                return day.classList &&
                    day.classList.contains("flatpickr-day") &&
                    !day.classList.contains("disabled") &&
                    !day.classList.contains("notAllowed");
            };
            var t = findParent(e.target, isSelectable);
            if (t === undefined)
                return;
            var target = t;
            var selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
            var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
                selectedDate.getMonth() >
                    self.currentMonth + self.config.showMonths - 1) &&
                self.config.mode !== "range";
            self.selectedDateElem = target;
            if (self.config.mode === "single")
                self.selectedDates = [selectedDate];
            else if (self.config.mode === "multiple") {
                var selectedIndex = isDateSelected(selectedDate);
                if (selectedIndex)
                    self.selectedDates.splice(parseInt(selectedIndex), 1);
                else
                    self.selectedDates.push(selectedDate);
            }
            else if (self.config.mode === "range") {
                if (self.selectedDates.length === 2) {
                    self.clear(false, false);
                }
                self.latestSelectedDateObj = selectedDate;
                self.selectedDates.push(selectedDate);
                // unless selecting same date twice, sort ascendingly
                if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                    self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
            }
            setHoursFromInputs();
            if (shouldChangeMonth) {
                var isNewYear = self.currentYear !== selectedDate.getFullYear();
                self.currentYear = selectedDate.getFullYear();
                self.currentMonth = selectedDate.getMonth();
                if (isNewYear)
                    triggerEvent("onYearChange");
                triggerEvent("onMonthChange");
            }
            updateNavigationCurrentMonth();
            buildDays();
            updateValue();
            if (self.config.enableTime)
                setTimeout(function () { return (self.showTimeInput = true); }, 50);
            // maintain focus
            if (!shouldChangeMonth &&
                self.config.mode !== "range" &&
                self.config.showMonths === 1)
                focusOnDayElem(target);
            else if (self.selectedDateElem !== undefined &&
                self.hourElement === undefined) {
                self.selectedDateElem && self.selectedDateElem.focus();
            }
            if (self.hourElement !== undefined)
                self.hourElement !== undefined && self.hourElement.focus();
            if (self.config.closeOnSelect) {
                var single = self.config.mode === "single" && !self.config.enableTime;
                var range = self.config.mode === "range" &&
                    self.selectedDates.length === 2 &&
                    !self.config.enableTime;
                if (single || range) {
                    focusAndClose();
                }
            }
            triggerChange();
        }
        var CALLBACKS = {
            locale: [setupLocale, updateWeekdays],
            showMonths: [buildMonths, setCalendarWidth, buildWeekdays]
        };
        function set(option, value) {
            if (option !== null && typeof option === "object")
                Object.assign(self.config, option);
            else {
                self.config[option] = value;
                if (CALLBACKS[option] !== undefined)
                    CALLBACKS[option].forEach(function (x) { return x(); });
                else if (HOOKS.indexOf(option) > -1)
                    self.config[option] = arrayify(value);
            }
            self.redraw();
            updateValue(false);
        }
        function setSelectedDate(inputDate, format) {
            var dates = [];
            if (inputDate instanceof Array)
                dates = inputDate.map(function (d) { return self.parseDate(d, format); });
            else if (inputDate instanceof Date || typeof inputDate === "number")
                dates = [self.parseDate(inputDate, format)];
            else if (typeof inputDate === "string") {
                switch (self.config.mode) {
                    case "single":
                    case "time":
                        dates = [self.parseDate(inputDate, format)];
                        break;
                    case "multiple":
                        dates = inputDate
                            .split(self.config.conjunction)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    case "range":
                        dates = inputDate
                            .split(self.l10n.rangeSeparator)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    default:
                        break;
                }
            }
            else
                self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
            self.selectedDates = dates.filter(function (d) { return d instanceof Date && isEnabled(d, false); });
            if (self.config.mode === "range")
                self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
        }
        function setDate(date, triggerChange, format) {
            if (triggerChange === void 0) { triggerChange = false; }
            if (format === void 0) { format = self.config.dateFormat; }
            if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
                return self.clear(triggerChange);
            setSelectedDate(date, format);
            self.showTimeInput = self.selectedDates.length > 0;
            self.latestSelectedDateObj = self.selectedDates[0];
            self.redraw();
            jumpToDate();
            setHoursFromDate();
            updateValue(triggerChange);
            if (triggerChange)
                triggerEvent("onChange");
        }
        function parseDateRules(arr) {
            return arr
                .slice()
                .map(function (rule) {
                if (typeof rule === "string" ||
                    typeof rule === "number" ||
                    rule instanceof Date) {
                    return self.parseDate(rule, undefined, true);
                }
                else if (rule &&
                    typeof rule === "object" &&
                    rule.from &&
                    rule.to)
                    return {
                        from: self.parseDate(rule.from, undefined),
                        to: self.parseDate(rule.to, undefined)
                    };
                return rule;
            })
                .filter(function (x) { return x; }); // remove falsy values
        }
        function setupDates() {
            self.selectedDates = [];
            self.now = self.parseDate(self.config.now) || new Date();
            // Workaround IE11 setting placeholder as the input's value
            var preloadedDate = self.config.defaultDate ||
                ((self.input.nodeName === "INPUT" ||
                    self.input.nodeName === "TEXTAREA") &&
                    self.input.placeholder &&
                    self.input.value === self.input.placeholder
                    ? null
                    : self.input.value);
            if (preloadedDate)
                setSelectedDate(preloadedDate, self.config.dateFormat);
            self._initialDate =
                self.selectedDates.length > 0
                    ? self.selectedDates[0]
                    : self.config.minDate &&
                        self.config.minDate.getTime() > self.now.getTime()
                        ? self.config.minDate
                        : self.config.maxDate &&
                            self.config.maxDate.getTime() < self.now.getTime()
                            ? self.config.maxDate
                            : self.now;
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
            if (self.selectedDates.length > 0)
                self.latestSelectedDateObj = self.selectedDates[0];
            if (self.config.minTime !== undefined)
                self.config.minTime = self.parseDate(self.config.minTime, "H:i");
            if (self.config.maxTime !== undefined)
                self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
            self.minDateHasTime =
                !!self.config.minDate &&
                    (self.config.minDate.getHours() > 0 ||
                        self.config.minDate.getMinutes() > 0 ||
                        self.config.minDate.getSeconds() > 0);
            self.maxDateHasTime =
                !!self.config.maxDate &&
                    (self.config.maxDate.getHours() > 0 ||
                        self.config.maxDate.getMinutes() > 0 ||
                        self.config.maxDate.getSeconds() > 0);
            Object.defineProperty(self, "showTimeInput", {
                get: function () { return self._showTimeInput; },
                set: function (bool) {
                    self._showTimeInput = bool;
                    if (self.calendarContainer)
                        toggleClass(self.calendarContainer, "showTimeInput", bool);
                    self.isOpen && positionCalendar();
                }
            });
        }
        function setupInputs() {
            self.input = self.config.wrap
                ? element.querySelector("[data-input]")
                : element;
            /* istanbul ignore next */
            if (!self.input) {
                self.config.errorHandler(new Error("Invalid input element specified"));
                return;
            }
            // hack: store previous type to restore it after destroy()
            self.input._type = self.input.type;
            self.input.type = "text";
            self.input.classList.add("flatpickr-input");
            self._input = self.input;
            if (self.config.altInput) {
                // replicate self.element
                self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass);
                self._input = self.altInput;
                self.altInput.placeholder = self.input.placeholder;
                self.altInput.disabled = self.input.disabled;
                self.altInput.required = self.input.required;
                self.altInput.tabIndex = self.input.tabIndex;
                self.altInput.type = "text";
                self.input.setAttribute("type", "hidden");
                if (!self.config.static && self.input.parentNode)
                    self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
            }
            if (!self.config.allowInput)
                self._input.setAttribute("readonly", "readonly");
            self._positionElement = self.config.positionElement || self._input;
        }
        function setupMobile() {
            var inputType = self.config.enableTime
                ? self.config.noCalendar
                    ? "time"
                    : "datetime-local"
                : "date";
            self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
            self.mobileInput.step = self.input.getAttribute("step") || "any";
            self.mobileInput.tabIndex = 1;
            self.mobileInput.type = inputType;
            self.mobileInput.disabled = self.input.disabled;
            self.mobileInput.required = self.input.required;
            self.mobileInput.placeholder = self.input.placeholder;
            self.mobileFormatStr =
                inputType === "datetime-local"
                    ? "Y-m-d\\TH:i:S"
                    : inputType === "date"
                        ? "Y-m-d"
                        : "H:i:S";
            if (self.selectedDates.length > 0) {
                self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
            }
            if (self.config.minDate)
                self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
            if (self.config.maxDate)
                self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
            self.input.type = "hidden";
            if (self.altInput !== undefined)
                self.altInput.type = "hidden";
            try {
                if (self.input.parentNode)
                    self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
            }
            catch (_a) { }
            bind(self.mobileInput, "change", function (e) {
                self.setDate(e.target.value, false, self.mobileFormatStr);
                triggerEvent("onChange");
                triggerEvent("onClose");
            });
        }
        function toggle(e) {
            if (self.isOpen === true)
                return self.close();
            self.open(e);
        }
        function triggerEvent(event, data) {
            // If the instance has been destroyed already, all hooks have been removed
            if (self.config === undefined)
                return;
            var hooks = self.config[event];
            if (hooks !== undefined && hooks.length > 0) {
                for (var i = 0; hooks[i] && i < hooks.length; i++)
                    hooks[i](self.selectedDates, self.input.value, self, data);
            }
            if (event === "onChange") {
                self.input.dispatchEvent(createEvent("change"));
                // many front-end frameworks bind to the input event
                self.input.dispatchEvent(createEvent("input"));
            }
        }
        function createEvent(name) {
            var e = document.createEvent("Event");
            e.initEvent(name, true, true);
            return e;
        }
        function isDateSelected(date) {
            for (var i = 0; i < self.selectedDates.length; i++) {
                if (compareDates(self.selectedDates[i], date) === 0)
                    return "" + i;
            }
            return false;
        }
        function isDateInRange(date) {
            if (self.config.mode !== "range" || self.selectedDates.length < 2)
                return false;
            return (compareDates(date, self.selectedDates[0]) >= 0 &&
                compareDates(date, self.selectedDates[1]) <= 0);
        }
        function updateNavigationCurrentMonth() {
            if (self.config.noCalendar || self.isMobile || !self.monthNav)
                return;
            self.yearElements.forEach(function (yearElement, i) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                self.monthElements[i].textContent =
                    monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) +
                        " ";
                yearElement.value = d.getFullYear().toString();
            });
            self._hidePrevMonthArrow =
                self.config.minDate !== undefined &&
                    (self.currentYear === self.config.minDate.getFullYear()
                        ? self.currentMonth <= self.config.minDate.getMonth()
                        : self.currentYear < self.config.minDate.getFullYear());
            self._hideNextMonthArrow =
                self.config.maxDate !== undefined &&
                    (self.currentYear === self.config.maxDate.getFullYear()
                        ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                        : self.currentYear > self.config.maxDate.getFullYear());
        }
        function getDateStr(format) {
            return self.selectedDates
                .map(function (dObj) { return self.formatDate(dObj, format); })
                .filter(function (d, i, arr) {
                return self.config.mode !== "range" ||
                    self.config.enableTime ||
                    arr.indexOf(d) === i;
            })
                .join(self.config.mode !== "range"
                ? self.config.conjunction
                : self.l10n.rangeSeparator);
        }
        /**
         * Updates the values of inputs associated with the calendar
         */
        function updateValue(triggerChange) {
            if (triggerChange === void 0) { triggerChange = true; }
            if (self.selectedDates.length === 0)
                return self.clear(triggerChange);
            if (self.mobileInput !== undefined && self.mobileFormatStr) {
                self.mobileInput.value =
                    self.latestSelectedDateObj !== undefined
                        ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                        : "";
            }
            self.input.value = getDateStr(self.config.dateFormat);
            if (self.altInput !== undefined) {
                self.altInput.value = getDateStr(self.config.altFormat);
            }
            if (triggerChange !== false)
                triggerEvent("onValueUpdate");
        }
        function onMonthNavClick(e) {
            e.preventDefault();
            var isPrevMonth = self.prevMonthNav.contains(e.target);
            var isNextMonth = self.nextMonthNav.contains(e.target);
            if (isPrevMonth || isNextMonth) {
                changeMonth(isPrevMonth ? -1 : 1);
            }
            else if (self.yearElements.indexOf(e.target) >= 0) {
                e.target.select();
            }
            else if (e.target.classList.contains("arrowUp")) {
                self.changeYear(self.currentYear + 1);
            }
            else if (e.target.classList.contains("arrowDown")) {
                self.changeYear(self.currentYear - 1);
            }
        }
        function timeWrapper(e) {
            e.preventDefault();
            var isKeyDown = e.type === "keydown", input = e.target;
            if (self.amPM !== undefined && e.target === self.amPM) {
                self.amPM.textContent =
                    self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
            }
            var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
                (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
            var newValue = curValue + step * delta;
            if (typeof input.value !== "undefined" && input.value.length === 2) {
                var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
                if (newValue < min) {
                    newValue =
                        max +
                            newValue +
                            int(!isHourElem) +
                            (int(isHourElem) && int(!self.amPM));
                    if (isMinuteElem)
                        incrementNumInput(undefined, -1, self.hourElement);
                }
                else if (newValue > max) {
                    newValue =
                        input === self.hourElement ? newValue - max - int(!self.amPM) : min;
                    if (isMinuteElem)
                        incrementNumInput(undefined, 1, self.hourElement);
                }
                if (self.amPM &&
                    isHourElem &&
                    (step === 1
                        ? newValue + curValue === 23
                        : Math.abs(newValue - curValue) > step)) {
                    self.amPM.textContent =
                        self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
                }
                input.value = pad(newValue);
            }
        }
        init();
        return self;
    }
    /* istanbul ignore next */
    function _flatpickr(nodeList, config) {
        // static list
        var nodes = Array.prototype.slice
            .call(nodeList)
            .filter(function (x) { return x instanceof HTMLElement; });
        var instances = [];
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            try {
                if (node.getAttribute("data-fp-omit") !== null)
                    continue;
                if (node._flatpickr !== undefined) {
                    node._flatpickr.destroy();
                    node._flatpickr = undefined;
                }
                node._flatpickr = FlatpickrInstance(node, config || {});
                instances.push(node._flatpickr);
            }
            catch (e) {
                console.error(e);
            }
        }
        return instances.length === 1 ? instances[0] : instances;
    }
    /* istanbul ignore next */
    if (typeof HTMLElement !== "undefined") {
        // browser env
        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
        HTMLElement.prototype.flatpickr = function (config) {
            return _flatpickr([this], config);
        };
    }
    /* istanbul ignore next */
    var flatpickr = function (selector, config) {
        if (typeof selector === "string") {
            return _flatpickr(window.document.querySelectorAll(selector), config);
        }
        else if (selector instanceof Node) {
            return _flatpickr([selector], config);
        }
        else {
            return _flatpickr(selector, config);
        }
    };
    /* istanbul ignore next */
    flatpickr.defaultConfig = defaults;
    flatpickr.l10ns = {
        en: __assign({}, english),
        "default": __assign({}, english)
    };
    flatpickr.localize = function (l10n) {
        flatpickr.l10ns["default"] = __assign({}, flatpickr.l10ns["default"], l10n);
    };
    flatpickr.setDefaults = function (config) {
        flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config);
    };
    flatpickr.parseDate = createDateParser({});
    flatpickr.formatDate = createDateFormatter({});
    flatpickr.compareDates = compareDates;
    /* istanbul ignore next */
    if (typeof jQuery !== "undefined") {
        jQuery.fn.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
    }
    Date.prototype.fp_incr = function (days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
    };
    if (typeof window !== "undefined") {
        window.flatpickr = flatpickr;
    }

    return flatpickr;

}));


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/lodash/fp.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/fp.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ./lodash.min */ "./node_modules/lodash/lodash.min.js").runInContext();
module.exports = __webpack_require__(/*! ./fp/_baseConvert */ "./node_modules/lodash/fp/_baseConvert.js")(_, _);


/***/ }),

/***/ "./node_modules/lodash/fp/_baseConvert.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/fp/_baseConvert.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mapping = __webpack_require__(/*! ./_mapping */ "./node_modules/lodash/fp/_mapping.js"),
    fallbackHolder = __webpack_require__(/*! ./placeholder */ "./node_modules/lodash/fp/placeholder.js");

/** Built-in value reference. */
var push = Array.prototype.push;

/**
 * Creates a function, with an arity of `n`, that invokes `func` with the
 * arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} n The arity of the new function.
 * @returns {Function} Returns the new function.
 */
function baseArity(func, n) {
  return n == 2
    ? function(a, b) { return func.apply(undefined, arguments); }
    : function(a) { return func.apply(undefined, arguments); };
}

/**
 * Creates a function that invokes `func`, with up to `n` arguments, ignoring
 * any additional arguments.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @param {number} n The arity cap.
 * @returns {Function} Returns the new function.
 */
function baseAry(func, n) {
  return n == 2
    ? function(a, b) { return func(a, b); }
    : function(a) { return func(a); };
}

/**
 * Creates a clone of `array`.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the cloned array.
 */
function cloneArray(array) {
  var length = array ? array.length : 0,
      result = Array(length);

  while (length--) {
    result[length] = array[length];
  }
  return result;
}

/**
 * Creates a function that clones a given object using the assignment `func`.
 *
 * @private
 * @param {Function} func The assignment function.
 * @returns {Function} Returns the new cloner function.
 */
function createCloner(func) {
  return function(object) {
    return func({}, object);
  };
}

/**
 * A specialized version of `_.spread` which flattens the spread array into
 * the arguments of the invoked `func`.
 *
 * @private
 * @param {Function} func The function to spread arguments over.
 * @param {number} start The start position of the spread.
 * @returns {Function} Returns the new function.
 */
function flatSpread(func, start) {
  return function() {
    var length = arguments.length,
        lastIndex = length - 1,
        args = Array(length);

    while (length--) {
      args[length] = arguments[length];
    }
    var array = args[start],
        otherArgs = args.slice(0, start);

    if (array) {
      push.apply(otherArgs, array);
    }
    if (start != lastIndex) {
      push.apply(otherArgs, args.slice(start + 1));
    }
    return func.apply(this, otherArgs);
  };
}

/**
 * Creates a function that wraps `func` and uses `cloner` to clone the first
 * argument it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} cloner The function to clone arguments.
 * @returns {Function} Returns the new immutable function.
 */
function wrapImmutable(func, cloner) {
  return function() {
    var length = arguments.length;
    if (!length) {
      return;
    }
    var args = Array(length);
    while (length--) {
      args[length] = arguments[length];
    }
    var result = args[0] = cloner.apply(undefined, args);
    func.apply(undefined, args);
    return result;
  };
}

/**
 * The base implementation of `convert` which accepts a `util` object of methods
 * required to perform conversions.
 *
 * @param {Object} util The util object.
 * @param {string} name The name of the function to convert.
 * @param {Function} func The function to convert.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.cap=true] Specify capping iteratee arguments.
 * @param {boolean} [options.curry=true] Specify currying.
 * @param {boolean} [options.fixed=true] Specify fixed arity.
 * @param {boolean} [options.immutable=true] Specify immutable operations.
 * @param {boolean} [options.rearg=true] Specify rearranging arguments.
 * @returns {Function|Object} Returns the converted function or object.
 */
function baseConvert(util, name, func, options) {
  var isLib = typeof name == 'function',
      isObj = name === Object(name);

  if (isObj) {
    options = func;
    func = name;
    name = undefined;
  }
  if (func == null) {
    throw new TypeError;
  }
  options || (options = {});

  var config = {
    'cap': 'cap' in options ? options.cap : true,
    'curry': 'curry' in options ? options.curry : true,
    'fixed': 'fixed' in options ? options.fixed : true,
    'immutable': 'immutable' in options ? options.immutable : true,
    'rearg': 'rearg' in options ? options.rearg : true
  };

  var defaultHolder = isLib ? func : fallbackHolder,
      forceCurry = ('curry' in options) && options.curry,
      forceFixed = ('fixed' in options) && options.fixed,
      forceRearg = ('rearg' in options) && options.rearg,
      pristine = isLib ? func.runInContext() : undefined;

  var helpers = isLib ? func : {
    'ary': util.ary,
    'assign': util.assign,
    'clone': util.clone,
    'curry': util.curry,
    'forEach': util.forEach,
    'isArray': util.isArray,
    'isError': util.isError,
    'isFunction': util.isFunction,
    'isWeakMap': util.isWeakMap,
    'iteratee': util.iteratee,
    'keys': util.keys,
    'rearg': util.rearg,
    'toInteger': util.toInteger,
    'toPath': util.toPath
  };

  var ary = helpers.ary,
      assign = helpers.assign,
      clone = helpers.clone,
      curry = helpers.curry,
      each = helpers.forEach,
      isArray = helpers.isArray,
      isError = helpers.isError,
      isFunction = helpers.isFunction,
      isWeakMap = helpers.isWeakMap,
      keys = helpers.keys,
      rearg = helpers.rearg,
      toInteger = helpers.toInteger,
      toPath = helpers.toPath;

  var aryMethodKeys = keys(mapping.aryMethod);

  var wrappers = {
    'castArray': function(castArray) {
      return function() {
        var value = arguments[0];
        return isArray(value)
          ? castArray(cloneArray(value))
          : castArray.apply(undefined, arguments);
      };
    },
    'iteratee': function(iteratee) {
      return function() {
        var func = arguments[0],
            arity = arguments[1],
            result = iteratee(func, arity),
            length = result.length;

        if (config.cap && typeof arity == 'number') {
          arity = arity > 2 ? (arity - 2) : 1;
          return (length && length <= arity) ? result : baseAry(result, arity);
        }
        return result;
      };
    },
    'mixin': function(mixin) {
      return function(source) {
        var func = this;
        if (!isFunction(func)) {
          return mixin(func, Object(source));
        }
        var pairs = [];
        each(keys(source), function(key) {
          if (isFunction(source[key])) {
            pairs.push([key, func.prototype[key]]);
          }
        });

        mixin(func, Object(source));

        each(pairs, function(pair) {
          var value = pair[1];
          if (isFunction(value)) {
            func.prototype[pair[0]] = value;
          } else {
            delete func.prototype[pair[0]];
          }
        });
        return func;
      };
    },
    'nthArg': function(nthArg) {
      return function(n) {
        var arity = n < 0 ? 1 : (toInteger(n) + 1);
        return curry(nthArg(n), arity);
      };
    },
    'rearg': function(rearg) {
      return function(func, indexes) {
        var arity = indexes ? indexes.length : 0;
        return curry(rearg(func, indexes), arity);
      };
    },
    'runInContext': function(runInContext) {
      return function(context) {
        return baseConvert(util, runInContext(context), options);
      };
    }
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Casts `func` to a function with an arity capped iteratee if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @returns {Function} Returns the cast function.
   */
  function castCap(name, func) {
    if (config.cap) {
      var indexes = mapping.iterateeRearg[name];
      if (indexes) {
        return iterateeRearg(func, indexes);
      }
      var n = !isLib && mapping.iterateeAry[name];
      if (n) {
        return iterateeAry(func, n);
      }
    }
    return func;
  }

  /**
   * Casts `func` to a curried function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity of `func`.
   * @returns {Function} Returns the cast function.
   */
  function castCurry(name, func, n) {
    return (forceCurry || (config.curry && n > 1))
      ? curry(func, n)
      : func;
  }

  /**
   * Casts `func` to a fixed arity function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity cap.
   * @returns {Function} Returns the cast function.
   */
  function castFixed(name, func, n) {
    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {
      var data = mapping.methodSpread[name],
          start = data && data.start;

      return start  === undefined ? ary(func, n) : flatSpread(func, start);
    }
    return func;
  }

  /**
   * Casts `func` to an rearged function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity of `func`.
   * @returns {Function} Returns the cast function.
   */
  function castRearg(name, func, n) {
    return (config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]))
      ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n])
      : func;
  }

  /**
   * Creates a clone of `object` by `path`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {Array|string} path The path to clone by.
   * @returns {Object} Returns the cloned object.
   */
  function cloneByPath(object, path) {
    path = toPath(path);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        result = clone(Object(object)),
        nested = result;

    while (nested != null && ++index < length) {
      var key = path[index],
          value = nested[key];

      if (value != null &&
          !(isFunction(value) || isError(value) || isWeakMap(value))) {
        nested[key] = clone(index == lastIndex ? value : Object(value));
      }
      nested = nested[key];
    }
    return result;
  }

  /**
   * Converts `lodash` to an immutable auto-curried iteratee-first data-last
   * version with conversion `options` applied.
   *
   * @param {Object} [options] The options object. See `baseConvert` for more details.
   * @returns {Function} Returns the converted `lodash`.
   */
  function convertLib(options) {
    return _.runInContext.convert(options)(undefined);
  }

  /**
   * Create a converter function for `func` of `name`.
   *
   * @param {string} name The name of the function to convert.
   * @param {Function} func The function to convert.
   * @returns {Function} Returns the new converter function.
   */
  function createConverter(name, func) {
    var realName = mapping.aliasToReal[name] || name,
        methodName = mapping.remap[realName] || realName,
        oldOptions = options;

    return function(options) {
      var newUtil = isLib ? pristine : helpers,
          newFunc = isLib ? pristine[methodName] : func,
          newOptions = assign(assign({}, oldOptions), options);

      return baseConvert(newUtil, realName, newFunc, newOptions);
    };
  }

  /**
   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`
   * arguments, ignoring any additional arguments.
   *
   * @private
   * @param {Function} func The function to cap iteratee arguments for.
   * @param {number} n The arity cap.
   * @returns {Function} Returns the new function.
   */
  function iterateeAry(func, n) {
    return overArg(func, function(func) {
      return typeof func == 'function' ? baseAry(func, n) : func;
    });
  }

  /**
   * Creates a function that wraps `func` to invoke its iteratee with arguments
   * arranged according to the specified `indexes` where the argument value at
   * the first index is provided as the first argument, the argument value at
   * the second index is provided as the second argument, and so on.
   *
   * @private
   * @param {Function} func The function to rearrange iteratee arguments for.
   * @param {number[]} indexes The arranged argument indexes.
   * @returns {Function} Returns the new function.
   */
  function iterateeRearg(func, indexes) {
    return overArg(func, function(func) {
      var n = indexes.length;
      return baseArity(rearg(baseAry(func, n), indexes), n);
    });
  }

  /**
   * Creates a function that invokes `func` with its first argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function() {
      var length = arguments.length;
      if (!length) {
        return func();
      }
      var args = Array(length);
      while (length--) {
        args[length] = arguments[length];
      }
      var index = config.rearg ? 0 : (length - 1);
      args[index] = transform(args[index]);
      return func.apply(undefined, args);
    };
  }

  /**
   * Creates a function that wraps `func` and applys the conversions
   * rules by `name`.
   *
   * @private
   * @param {string} name The name of the function to wrap.
   * @param {Function} func The function to wrap.
   * @returns {Function} Returns the converted function.
   */
  function wrap(name, func, placeholder) {
    var result,
        realName = mapping.aliasToReal[name] || name,
        wrapped = func,
        wrapper = wrappers[realName];

    if (wrapper) {
      wrapped = wrapper(func);
    }
    else if (config.immutable) {
      if (mapping.mutate.array[realName]) {
        wrapped = wrapImmutable(func, cloneArray);
      }
      else if (mapping.mutate.object[realName]) {
        wrapped = wrapImmutable(func, createCloner(func));
      }
      else if (mapping.mutate.set[realName]) {
        wrapped = wrapImmutable(func, cloneByPath);
      }
    }
    each(aryMethodKeys, function(aryKey) {
      each(mapping.aryMethod[aryKey], function(otherName) {
        if (realName == otherName) {
          var data = mapping.methodSpread[realName],
              afterRearg = data && data.afterRearg;

          result = afterRearg
            ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey)
            : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);

          result = castCap(realName, result);
          result = castCurry(realName, result, aryKey);
          return false;
        }
      });
      return !result;
    });

    result || (result = wrapped);
    if (result == func) {
      result = forceCurry ? curry(result, 1) : function() {
        return func.apply(this, arguments);
      };
    }
    result.convert = createConverter(realName, func);
    result.placeholder = func.placeholder = placeholder;

    return result;
  }

  /*--------------------------------------------------------------------------*/

  if (!isObj) {
    return wrap(name, func, defaultHolder);
  }
  var _ = func;

  // Convert methods by ary cap.
  var pairs = [];
  each(aryMethodKeys, function(aryKey) {
    each(mapping.aryMethod[aryKey], function(key) {
      var func = _[mapping.remap[key] || key];
      if (func) {
        pairs.push([key, wrap(key, func, _)]);
      }
    });
  });

  // Convert remaining methods.
  each(keys(_), function(key) {
    var func = _[key];
    if (typeof func == 'function') {
      var length = pairs.length;
      while (length--) {
        if (pairs[length][0] == key) {
          return;
        }
      }
      func.convert = createConverter(key, func);
      pairs.push([key, func]);
    }
  });

  // Assign to `_` leaving `_.prototype` unchanged to allow chaining.
  each(pairs, function(pair) {
    _[pair[0]] = pair[1];
  });

  _.convert = convertLib;
  _.placeholder = _;

  // Assign aliases.
  each(keys(_), function(key) {
    each(mapping.realToAlias[key] || [], function(alias) {
      _[alias] = _[key];
    });
  });

  return _;
}

module.exports = baseConvert;


/***/ }),

/***/ "./node_modules/lodash/fp/_mapping.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/fp/_mapping.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to map aliases to their real names. */
exports.aliasToReal = {

  // Lodash aliases.
  'each': 'forEach',
  'eachRight': 'forEachRight',
  'entries': 'toPairs',
  'entriesIn': 'toPairsIn',
  'extend': 'assignIn',
  'extendAll': 'assignInAll',
  'extendAllWith': 'assignInAllWith',
  'extendWith': 'assignInWith',
  'first': 'head',

  // Methods that are curried variants of others.
  'conforms': 'conformsTo',
  'matches': 'isMatch',
  'property': 'get',

  // Ramda aliases.
  '__': 'placeholder',
  'F': 'stubFalse',
  'T': 'stubTrue',
  'all': 'every',
  'allPass': 'overEvery',
  'always': 'constant',
  'any': 'some',
  'anyPass': 'overSome',
  'apply': 'spread',
  'assoc': 'set',
  'assocPath': 'set',
  'complement': 'negate',
  'compose': 'flowRight',
  'contains': 'includes',
  'dissoc': 'unset',
  'dissocPath': 'unset',
  'dropLast': 'dropRight',
  'dropLastWhile': 'dropRightWhile',
  'equals': 'isEqual',
  'identical': 'eq',
  'indexBy': 'keyBy',
  'init': 'initial',
  'invertObj': 'invert',
  'juxt': 'over',
  'omitAll': 'omit',
  'nAry': 'ary',
  'path': 'get',
  'pathEq': 'matchesProperty',
  'pathOr': 'getOr',
  'paths': 'at',
  'pickAll': 'pick',
  'pipe': 'flow',
  'pluck': 'map',
  'prop': 'get',
  'propEq': 'matchesProperty',
  'propOr': 'getOr',
  'props': 'at',
  'symmetricDifference': 'xor',
  'symmetricDifferenceBy': 'xorBy',
  'symmetricDifferenceWith': 'xorWith',
  'takeLast': 'takeRight',
  'takeLastWhile': 'takeRightWhile',
  'unapply': 'rest',
  'unnest': 'flatten',
  'useWith': 'overArgs',
  'where': 'conformsTo',
  'whereEq': 'isMatch',
  'zipObj': 'zipObject'
};

/** Used to map ary to method names. */
exports.aryMethod = {
  '1': [
    'assignAll', 'assignInAll', 'attempt', 'castArray', 'ceil', 'create',
    'curry', 'curryRight', 'defaultsAll', 'defaultsDeepAll', 'floor', 'flow',
    'flowRight', 'fromPairs', 'invert', 'iteratee', 'memoize', 'method', 'mergeAll',
    'methodOf', 'mixin', 'nthArg', 'over', 'overEvery', 'overSome','rest', 'reverse',
    'round', 'runInContext', 'spread', 'template', 'trim', 'trimEnd', 'trimStart',
    'uniqueId', 'words', 'zipAll'
  ],
  '2': [
    'add', 'after', 'ary', 'assign', 'assignAllWith', 'assignIn', 'assignInAllWith',
    'at', 'before', 'bind', 'bindAll', 'bindKey', 'chunk', 'cloneDeepWith',
    'cloneWith', 'concat', 'conformsTo', 'countBy', 'curryN', 'curryRightN',
    'debounce', 'defaults', 'defaultsDeep', 'defaultTo', 'delay', 'difference',
    'divide', 'drop', 'dropRight', 'dropRightWhile', 'dropWhile', 'endsWith', 'eq',
    'every', 'filter', 'find', 'findIndex', 'findKey', 'findLast', 'findLastIndex',
    'findLastKey', 'flatMap', 'flatMapDeep', 'flattenDepth', 'forEach',
    'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'get',
    'groupBy', 'gt', 'gte', 'has', 'hasIn', 'includes', 'indexOf', 'intersection',
    'invertBy', 'invoke', 'invokeMap', 'isEqual', 'isMatch', 'join', 'keyBy',
    'lastIndexOf', 'lt', 'lte', 'map', 'mapKeys', 'mapValues', 'matchesProperty',
    'maxBy', 'meanBy', 'merge', 'mergeAllWith', 'minBy', 'multiply', 'nth', 'omit',
    'omitBy', 'overArgs', 'pad', 'padEnd', 'padStart', 'parseInt', 'partial',
    'partialRight', 'partition', 'pick', 'pickBy', 'propertyOf', 'pull', 'pullAll',
    'pullAt', 'random', 'range', 'rangeRight', 'rearg', 'reject', 'remove',
    'repeat', 'restFrom', 'result', 'sampleSize', 'some', 'sortBy', 'sortedIndex',
    'sortedIndexOf', 'sortedLastIndex', 'sortedLastIndexOf', 'sortedUniqBy',
    'split', 'spreadFrom', 'startsWith', 'subtract', 'sumBy', 'take', 'takeRight',
    'takeRightWhile', 'takeWhile', 'tap', 'throttle', 'thru', 'times', 'trimChars',
    'trimCharsEnd', 'trimCharsStart', 'truncate', 'union', 'uniqBy', 'uniqWith',
    'unset', 'unzipWith', 'without', 'wrap', 'xor', 'zip', 'zipObject',
    'zipObjectDeep'
  ],
  '3': [
    'assignInWith', 'assignWith', 'clamp', 'differenceBy', 'differenceWith',
    'findFrom', 'findIndexFrom', 'findLastFrom', 'findLastIndexFrom', 'getOr',
    'includesFrom', 'indexOfFrom', 'inRange', 'intersectionBy', 'intersectionWith',
    'invokeArgs', 'invokeArgsMap', 'isEqualWith', 'isMatchWith', 'flatMapDepth',
    'lastIndexOfFrom', 'mergeWith', 'orderBy', 'padChars', 'padCharsEnd',
    'padCharsStart', 'pullAllBy', 'pullAllWith', 'rangeStep', 'rangeStepRight',
    'reduce', 'reduceRight', 'replace', 'set', 'slice', 'sortedIndexBy',
    'sortedLastIndexBy', 'transform', 'unionBy', 'unionWith', 'update', 'xorBy',
    'xorWith', 'zipWith'
  ],
  '4': [
    'fill', 'setWith', 'updateWith'
  ]
};

/** Used to map ary to rearg configs. */
exports.aryRearg = {
  '2': [1, 0],
  '3': [2, 0, 1],
  '4': [3, 2, 0, 1]
};

/** Used to map method names to their iteratee ary. */
exports.iterateeAry = {
  'dropRightWhile': 1,
  'dropWhile': 1,
  'every': 1,
  'filter': 1,
  'find': 1,
  'findFrom': 1,
  'findIndex': 1,
  'findIndexFrom': 1,
  'findKey': 1,
  'findLast': 1,
  'findLastFrom': 1,
  'findLastIndex': 1,
  'findLastIndexFrom': 1,
  'findLastKey': 1,
  'flatMap': 1,
  'flatMapDeep': 1,
  'flatMapDepth': 1,
  'forEach': 1,
  'forEachRight': 1,
  'forIn': 1,
  'forInRight': 1,
  'forOwn': 1,
  'forOwnRight': 1,
  'map': 1,
  'mapKeys': 1,
  'mapValues': 1,
  'partition': 1,
  'reduce': 2,
  'reduceRight': 2,
  'reject': 1,
  'remove': 1,
  'some': 1,
  'takeRightWhile': 1,
  'takeWhile': 1,
  'times': 1,
  'transform': 2
};

/** Used to map method names to iteratee rearg configs. */
exports.iterateeRearg = {
  'mapKeys': [1],
  'reduceRight': [1, 0]
};

/** Used to map method names to rearg configs. */
exports.methodRearg = {
  'assignInAllWith': [1, 0],
  'assignInWith': [1, 2, 0],
  'assignAllWith': [1, 0],
  'assignWith': [1, 2, 0],
  'differenceBy': [1, 2, 0],
  'differenceWith': [1, 2, 0],
  'getOr': [2, 1, 0],
  'intersectionBy': [1, 2, 0],
  'intersectionWith': [1, 2, 0],
  'isEqualWith': [1, 2, 0],
  'isMatchWith': [2, 1, 0],
  'mergeAllWith': [1, 0],
  'mergeWith': [1, 2, 0],
  'padChars': [2, 1, 0],
  'padCharsEnd': [2, 1, 0],
  'padCharsStart': [2, 1, 0],
  'pullAllBy': [2, 1, 0],
  'pullAllWith': [2, 1, 0],
  'rangeStep': [1, 2, 0],
  'rangeStepRight': [1, 2, 0],
  'setWith': [3, 1, 2, 0],
  'sortedIndexBy': [2, 1, 0],
  'sortedLastIndexBy': [2, 1, 0],
  'unionBy': [1, 2, 0],
  'unionWith': [1, 2, 0],
  'updateWith': [3, 1, 2, 0],
  'xorBy': [1, 2, 0],
  'xorWith': [1, 2, 0],
  'zipWith': [1, 2, 0]
};

/** Used to map method names to spread configs. */
exports.methodSpread = {
  'assignAll': { 'start': 0 },
  'assignAllWith': { 'start': 0 },
  'assignInAll': { 'start': 0 },
  'assignInAllWith': { 'start': 0 },
  'defaultsAll': { 'start': 0 },
  'defaultsDeepAll': { 'start': 0 },
  'invokeArgs': { 'start': 2 },
  'invokeArgsMap': { 'start': 2 },
  'mergeAll': { 'start': 0 },
  'mergeAllWith': { 'start': 0 },
  'partial': { 'start': 1 },
  'partialRight': { 'start': 1 },
  'without': { 'start': 1 },
  'zipAll': { 'start': 0 }
};

/** Used to identify methods which mutate arrays or objects. */
exports.mutate = {
  'array': {
    'fill': true,
    'pull': true,
    'pullAll': true,
    'pullAllBy': true,
    'pullAllWith': true,
    'pullAt': true,
    'remove': true,
    'reverse': true
  },
  'object': {
    'assign': true,
    'assignAll': true,
    'assignAllWith': true,
    'assignIn': true,
    'assignInAll': true,
    'assignInAllWith': true,
    'assignInWith': true,
    'assignWith': true,
    'defaults': true,
    'defaultsAll': true,
    'defaultsDeep': true,
    'defaultsDeepAll': true,
    'merge': true,
    'mergeAll': true,
    'mergeAllWith': true,
    'mergeWith': true,
  },
  'set': {
    'set': true,
    'setWith': true,
    'unset': true,
    'update': true,
    'updateWith': true
  }
};

/** Used to map real names to their aliases. */
exports.realToAlias = (function() {
  var hasOwnProperty = Object.prototype.hasOwnProperty,
      object = exports.aliasToReal,
      result = {};

  for (var key in object) {
    var value = object[key];
    if (hasOwnProperty.call(result, value)) {
      result[value].push(key);
    } else {
      result[value] = [key];
    }
  }
  return result;
}());

/** Used to map method names to other names. */
exports.remap = {
  'assignAll': 'assign',
  'assignAllWith': 'assignWith',
  'assignInAll': 'assignIn',
  'assignInAllWith': 'assignInWith',
  'curryN': 'curry',
  'curryRightN': 'curryRight',
  'defaultsAll': 'defaults',
  'defaultsDeepAll': 'defaultsDeep',
  'findFrom': 'find',
  'findIndexFrom': 'findIndex',
  'findLastFrom': 'findLast',
  'findLastIndexFrom': 'findLastIndex',
  'getOr': 'get',
  'includesFrom': 'includes',
  'indexOfFrom': 'indexOf',
  'invokeArgs': 'invoke',
  'invokeArgsMap': 'invokeMap',
  'lastIndexOfFrom': 'lastIndexOf',
  'mergeAll': 'merge',
  'mergeAllWith': 'mergeWith',
  'padChars': 'pad',
  'padCharsEnd': 'padEnd',
  'padCharsStart': 'padStart',
  'propertyOf': 'get',
  'rangeStep': 'range',
  'rangeStepRight': 'rangeRight',
  'restFrom': 'rest',
  'spreadFrom': 'spread',
  'trimChars': 'trim',
  'trimCharsEnd': 'trimEnd',
  'trimCharsStart': 'trimStart',
  'zipAll': 'zip'
};

/** Used to track methods that skip fixing their arity. */
exports.skipFixed = {
  'castArray': true,
  'flow': true,
  'flowRight': true,
  'iteratee': true,
  'mixin': true,
  'rearg': true,
  'runInContext': true
};

/** Used to track methods that skip rearranging arguments. */
exports.skipRearg = {
  'add': true,
  'assign': true,
  'assignIn': true,
  'bind': true,
  'bindKey': true,
  'concat': true,
  'difference': true,
  'divide': true,
  'eq': true,
  'gt': true,
  'gte': true,
  'isEqual': true,
  'lt': true,
  'lte': true,
  'matchesProperty': true,
  'merge': true,
  'multiply': true,
  'overArgs': true,
  'partial': true,
  'partialRight': true,
  'propertyOf': true,
  'random': true,
  'range': true,
  'rangeRight': true,
  'subtract': true,
  'zip': true,
  'zipObject': true,
  'zipObjectDeep': true
};


/***/ }),

/***/ "./node_modules/lodash/fp/placeholder.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/fp/placeholder.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The default argument placeholder value for methods.
 *
 * @type {Object}
 */
module.exports = {};


/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.11';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });

        return result;
      }

      if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });

        return result;
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        if (isObject(srcValue)) {
          stack || (stack = new Stack);
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = (lodashFunc.name + ''),
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/lodash.min.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/lodash.min.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 */
;(function(){function n(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function t(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function r(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&false!==t(n[r],r,n););return n}function e(n,t){for(var r=null==n?0:n.length;r--&&false!==t(n[r],r,n););return n}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return false;
return true}function i(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function o(n,t){return!(null==n||!n.length)&&-1<v(n,t,0)}function f(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return true;return false}function c(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function a(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];return n}function l(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);
return r}function s(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function h(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return true;return false}function p(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,false}),e}function _(n,t,r,e){var u=n.length;for(r+=e?1:-1;e?r--:++r<u;)if(t(n[r],r,n))return r;return-1}function v(n,t,r){if(t===t)n:{--r;for(var e=n.length;++r<e;)if(n[r]===t){n=r;break n}n=-1}else n=_(n,d,r);return n}function g(n,t,r,e){
--r;for(var u=n.length;++r<u;)if(e(n[r],t))return r;return-1}function d(n){return n!==n}function y(n,t){var r=null==n?0:n.length;return r?m(n,t)/r:F}function b(n){return function(t){return null==t?T:t[n]}}function x(n){return function(t){return null==n?T:n[t]}}function j(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=false,n):t(r,n,u,i)}),r}function w(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;return n}function m(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==T&&(r=r===T?i:r+i)}return r;
}function A(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function k(n,t){return c(t,function(t){return[t,n[t]]})}function E(n){return function(t){return n(t)}}function S(n,t){return c(t,function(t){return n[t]})}function O(n,t){return n.has(t)}function I(n,t){for(var r=-1,e=n.length;++r<e&&-1<v(t,n[r],0););return r}function R(n,t){for(var r=n.length;r--&&-1<v(t,n[r],0););return r}function z(n){return"\\"+Ln[n]}function W(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n];
}),r}function U(n,t){return function(r){return n(t(r))}}function B(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&"__lodash_placeholder__"!==o||(n[r]="__lodash_placeholder__",i[u++]=r)}return i}function L(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function C(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function D(n){if(Rn.test(n)){for(var t=On.lastIndex=0;On.test(n);)++t;n=t}else n=Qn(n);return n}function M(n){return Rn.test(n)?n.match(On)||[]:n.split("");
}var T,$=1/0,F=NaN,N=[["ary",128],["bind",1],["bindKey",2],["curry",8],["curryRight",16],["flip",512],["partial",32],["partialRight",64],["rearg",256]],P=/\b__p\+='';/g,Z=/\b(__p\+=)''\+/g,q=/(__e\(.*?\)|\b__t\))\+'';/g,V=/&(?:amp|lt|gt|quot|#39);/g,K=/[&<>"']/g,G=RegExp(V.source),H=RegExp(K.source),J=/<%-([\s\S]+?)%>/g,Y=/<%([\s\S]+?)%>/g,Q=/<%=([\s\S]+?)%>/g,X=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,nn=/^\w*$/,tn=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,rn=/[\\^$.*+?()[\]{}|]/g,en=RegExp(rn.source),un=/^\s+|\s+$/g,on=/^\s+/,fn=/\s+$/,cn=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,an=/\{\n\/\* \[wrapped with (.+)\] \*/,ln=/,? & /,sn=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,hn=/\\(\\)?/g,pn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,_n=/\w*$/,vn=/^[-+]0x[0-9a-f]+$/i,gn=/^0b[01]+$/i,dn=/^\[object .+?Constructor\]$/,yn=/^0o[0-7]+$/i,bn=/^(?:0|[1-9]\d*)$/,xn=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,jn=/($^)/,wn=/['\n\r\u2028\u2029\\]/g,mn="[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*",An="(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])"+mn,kn="(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",En=RegExp("['\u2019]","g"),Sn=RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]","g"),On=RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|"+kn+mn,"g"),In=RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])|\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])|\\d+",An].join("|"),"g"),Rn=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"),zn=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Wn="Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),Un={};
Un["[object Float32Array]"]=Un["[object Float64Array]"]=Un["[object Int8Array]"]=Un["[object Int16Array]"]=Un["[object Int32Array]"]=Un["[object Uint8Array]"]=Un["[object Uint8ClampedArray]"]=Un["[object Uint16Array]"]=Un["[object Uint32Array]"]=true,Un["[object Arguments]"]=Un["[object Array]"]=Un["[object ArrayBuffer]"]=Un["[object Boolean]"]=Un["[object DataView]"]=Un["[object Date]"]=Un["[object Error]"]=Un["[object Function]"]=Un["[object Map]"]=Un["[object Number]"]=Un["[object Object]"]=Un["[object RegExp]"]=Un["[object Set]"]=Un["[object String]"]=Un["[object WeakMap]"]=false;
var Bn={};Bn["[object Arguments]"]=Bn["[object Array]"]=Bn["[object ArrayBuffer]"]=Bn["[object DataView]"]=Bn["[object Boolean]"]=Bn["[object Date]"]=Bn["[object Float32Array]"]=Bn["[object Float64Array]"]=Bn["[object Int8Array]"]=Bn["[object Int16Array]"]=Bn["[object Int32Array]"]=Bn["[object Map]"]=Bn["[object Number]"]=Bn["[object Object]"]=Bn["[object RegExp]"]=Bn["[object Set]"]=Bn["[object String]"]=Bn["[object Symbol]"]=Bn["[object Uint8Array]"]=Bn["[object Uint8ClampedArray]"]=Bn["[object Uint16Array]"]=Bn["[object Uint32Array]"]=true,
Bn["[object Error]"]=Bn["[object Function]"]=Bn["[object WeakMap]"]=false;var Ln={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Cn=parseFloat,Dn=parseInt,Mn=typeof global=="object"&&global&&global.Object===Object&&global,Tn=typeof self=="object"&&self&&self.Object===Object&&self,$n=Mn||Tn||Function("return this")(),Fn= true&&exports&&!exports.nodeType&&exports,Nn=Fn&&typeof module=="object"&&module&&!module.nodeType&&module,Pn=Nn&&Nn.exports===Fn,Zn=Pn&&Mn.process,qn=function(){
try{var n=Nn&&Nn.require&&Nn.require("util").types;return n?n:Zn&&Zn.binding&&Zn.binding("util")}catch(n){}}(),Vn=qn&&qn.isArrayBuffer,Kn=qn&&qn.isDate,Gn=qn&&qn.isMap,Hn=qn&&qn.isRegExp,Jn=qn&&qn.isSet,Yn=qn&&qn.isTypedArray,Qn=b("length"),Xn=x({"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e",
"\xcc":"I","\xcd":"I","\xce":"I","\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a",
"\u0106":"C","\u0108":"C","\u010a":"C","\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g","\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I",
"\u0129":"i","\u012b":"i","\u012d":"i","\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O","\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r",
"\u0159":"r","\u015a":"S","\u015c":"S","\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ",
"\u0133":"ij","\u0152":"Oe","\u0153":"oe","\u0149":"'n","\u017f":"s"}),nt=x({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}),tt=x({"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"}),rt=function x(mn){function An(n){if(yu(n)&&!ff(n)&&!(n instanceof Ln)){if(n instanceof On)return n;if(oi.call(n,"__wrapped__"))return Fe(n)}return new On(n)}function kn(){}function On(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=T}function Ln(n){
this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=4294967295,this.__views__=[]}function Mn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Tn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Fn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Nn(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new Fn;++t<r;)this.add(n[t]);
}function Zn(n){this.size=(this.__data__=new Tn(n)).size}function qn(n,t){var r,e=ff(n),u=!e&&of(n),i=!e&&!u&&af(n),o=!e&&!u&&!i&&_f(n),u=(e=e||u||i||o)?A(n.length,ni):[],f=u.length;for(r in n)!t&&!oi.call(n,r)||e&&("length"==r||i&&("offset"==r||"parent"==r)||o&&("buffer"==r||"byteLength"==r||"byteOffset"==r)||Se(r,f))||u.push(r);return u}function Qn(n){var t=n.length;return t?n[ir(0,t-1)]:T}function et(n,t){return De(Lr(n),pt(t,0,n.length))}function ut(n){return De(Lr(n))}function it(n,t,r){(r===T||lu(n[t],r))&&(r!==T||t in n)||st(n,t,r);
}function ot(n,t,r){var e=n[t];oi.call(n,t)&&lu(e,r)&&(r!==T||t in n)||st(n,t,r)}function ft(n,t){for(var r=n.length;r--;)if(lu(n[r][0],t))return r;return-1}function ct(n,t,r,e){return uo(n,function(n,u,i){t(e,n,r(n),i)}),e}function at(n,t){return n&&Cr(t,Wu(t),n)}function lt(n,t){return n&&Cr(t,Uu(t),n)}function st(n,t,r){"__proto__"==t&&Ai?Ai(n,t,{configurable:true,enumerable:true,value:r,writable:true}):n[t]=r}function ht(n,t){for(var r=-1,e=t.length,u=Ku(e),i=null==n;++r<e;)u[r]=i?T:Ru(n,t[r]);return u;
}function pt(n,t,r){return n===n&&(r!==T&&(n=n<=r?n:r),t!==T&&(n=n>=t?n:t)),n}function _t(n,t,e,u,i,o){var f,c=1&t,a=2&t,l=4&t;if(e&&(f=i?e(n,u,i,o):e(n)),f!==T)return f;if(!du(n))return n;if(u=ff(n)){if(f=me(n),!c)return Lr(n,f)}else{var s=vo(n),h="[object Function]"==s||"[object GeneratorFunction]"==s;if(af(n))return Ir(n,c);if("[object Object]"==s||"[object Arguments]"==s||h&&!i){if(f=a||h?{}:Ae(n),!c)return a?Mr(n,lt(f,n)):Dr(n,at(f,n))}else{if(!Bn[s])return i?n:{};f=ke(n,s,c)}}if(o||(o=new Zn),
i=o.get(n))return i;if(o.set(n,f),pf(n))return n.forEach(function(r){f.add(_t(r,t,e,r,n,o))}),f;if(sf(n))return n.forEach(function(r,u){f.set(u,_t(r,t,e,u,n,o))}),f;var a=l?a?ve:_e:a?Uu:Wu,p=u?T:a(n);return r(p||n,function(r,u){p&&(u=r,r=n[u]),ot(f,u,_t(r,t,e,u,n,o))}),f}function vt(n){var t=Wu(n);return function(r){return gt(r,n,t)}}function gt(n,t,r){var e=r.length;if(null==n)return!e;for(n=Qu(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===T&&!(u in n)||!i(o))return false}return true}function dt(n,t,r){if(typeof n!="function")throw new ti("Expected a function");
return bo(function(){n.apply(T,r)},t)}function yt(n,t,r,e){var u=-1,i=o,a=true,l=n.length,s=[],h=t.length;if(!l)return s;r&&(t=c(t,E(r))),e?(i=f,a=false):200<=t.length&&(i=O,a=false,t=new Nn(t));n:for(;++u<l;){var p=n[u],_=null==r?p:r(p),p=e||0!==p?p:0;if(a&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function bt(n,t){var r=true;return uo(n,function(n,e,u){return r=!!t(n,e,u)}),r}function xt(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===T?o===o&&!wu(o):r(o,f)))var f=o,c=i;
}return c}function jt(n,t){var r=[];return uo(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function wt(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Ee),u||(u=[]);++i<o;){var f=n[i];0<t&&r(f)?1<t?wt(f,t-1,r,e,u):a(u,f):e||(u[u.length]=f)}return u}function mt(n,t){return n&&oo(n,t,Wu)}function At(n,t){return n&&fo(n,t,Wu)}function kt(n,t){return i(t,function(t){return _u(n[t])})}function Et(n,t){t=Sr(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[Me(t[r++])];return r&&r==e?n:T}function St(n,t,r){return t=t(n),
ff(n)?t:a(t,r(n))}function Ot(n){if(null==n)return n===T?"[object Undefined]":"[object Null]";if(mi&&mi in Qu(n)){var t=oi.call(n,mi),r=n[mi];try{n[mi]=T;var e=true}catch(n){}var u=ai.call(n);e&&(t?n[mi]=r:delete n[mi]),n=u}else n=ai.call(n);return n}function It(n,t){return n>t}function Rt(n,t){return null!=n&&oi.call(n,t)}function zt(n,t){return null!=n&&t in Qu(n)}function Wt(n,t,r){for(var e=r?f:o,u=n[0].length,i=n.length,a=i,l=Ku(i),s=1/0,h=[];a--;){var p=n[a];a&&t&&(p=c(p,E(t))),s=Ci(p.length,s),
l[a]=!r&&(t||120<=u&&120<=p.length)?new Nn(a&&p):T}var p=n[0],_=-1,v=l[0];n:for(;++_<u&&h.length<s;){var g=p[_],d=t?t(g):g,g=r||0!==g?g:0;if(v?!O(v,d):!e(h,d,r)){for(a=i;--a;){var y=l[a];if(y?!O(y,d):!e(n[a],d,r))continue n}v&&v.push(d),h.push(g)}}return h}function Ut(n,t,r,e){return mt(n,function(n,u,i){t(e,r(n),u,i)}),e}function Bt(t,r,e){return r=Sr(r,t),t=2>r.length?t:Et(t,hr(r,0,-1)),r=null==t?t:t[Me(Ve(r))],null==r?T:n(r,t,e)}function Lt(n){return yu(n)&&"[object Arguments]"==Ot(n)}function Ct(n){
return yu(n)&&"[object ArrayBuffer]"==Ot(n)}function Dt(n){return yu(n)&&"[object Date]"==Ot(n)}function Mt(n,t,r,e,u){if(n===t)return true;if(null==n||null==t||!yu(n)&&!yu(t))return n!==n&&t!==t;n:{var i=ff(n),o=ff(t),f=i?"[object Array]":vo(n),c=o?"[object Array]":vo(t),f="[object Arguments]"==f?"[object Object]":f,c="[object Arguments]"==c?"[object Object]":c,a="[object Object]"==f,o="[object Object]"==c;if((c=f==c)&&af(n)){if(!af(t)){t=false;break n}i=true,a=false}if(c&&!a)u||(u=new Zn),t=i||_f(n)?se(n,t,r,e,Mt,u):he(n,t,f,r,e,Mt,u);else{
if(!(1&r)&&(i=a&&oi.call(n,"__wrapped__"),f=o&&oi.call(t,"__wrapped__"),i||f)){n=i?n.value():n,t=f?t.value():t,u||(u=new Zn),t=Mt(n,t,r,e,u);break n}if(c)t:if(u||(u=new Zn),i=1&r,f=_e(n),o=f.length,c=_e(t).length,o==c||i){for(a=o;a--;){var l=f[a];if(!(i?l in t:oi.call(t,l))){t=false;break t}}if((c=u.get(n))&&u.get(t))t=c==t;else{c=true,u.set(n,t),u.set(t,n);for(var s=i;++a<o;){var l=f[a],h=n[l],p=t[l];if(e)var _=i?e(p,h,l,t,n,u):e(h,p,l,n,t,u);if(_===T?h!==p&&!Mt(h,p,r,e,u):!_){c=false;break}s||(s="constructor"==l);
}c&&!s&&(r=n.constructor,e=t.constructor,r!=e&&"constructor"in n&&"constructor"in t&&!(typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)&&(c=false)),u.delete(n),u.delete(t),t=c}}else t=false;else t=false}}return t}function Tt(n){return yu(n)&&"[object Map]"==vo(n)}function $t(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=Qu(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return false}for(;++u<i;){var f=r[u],c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===T&&!(c in n))return false;
}else{if(f=new Zn,e)var s=e(a,l,c,n,t,f);if(s===T?!Mt(l,a,3,e,f):!s)return false}}return true}function Ft(n){return!(!du(n)||ci&&ci in n)&&(_u(n)?hi:dn).test(Te(n))}function Nt(n){return yu(n)&&"[object RegExp]"==Ot(n)}function Pt(n){return yu(n)&&"[object Set]"==vo(n)}function Zt(n){return yu(n)&&gu(n.length)&&!!Un[Ot(n)]}function qt(n){return typeof n=="function"?n:null==n?$u:typeof n=="object"?ff(n)?Jt(n[0],n[1]):Ht(n):Zu(n)}function Vt(n){if(!ze(n))return Bi(n);var t,r=[];for(t in Qu(n))oi.call(n,t)&&"constructor"!=t&&r.push(t);
return r}function Kt(n,t){return n<t}function Gt(n,t){var r=-1,e=su(n)?Ku(n.length):[];return uo(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Ht(n){var t=xe(n);return 1==t.length&&t[0][2]?We(t[0][0],t[0][1]):function(r){return r===n||$t(r,n,t)}}function Jt(n,t){return Ie(n)&&t===t&&!du(t)?We(Me(n),t):function(r){var e=Ru(r,n);return e===T&&e===t?zu(r,n):Mt(t,e,3)}}function Yt(n,t,r,e,u){n!==t&&oo(t,function(i,o){if(du(i)){u||(u=new Zn);var f=u,c=Be(n,o),a=Be(t,o),l=f.get(a);if(!l){var l=e?e(c,a,o+"",n,t,f):T,s=l===T;
if(s){var h=ff(a),p=!h&&af(a),_=!h&&!p&&_f(a),l=a;h||p||_?ff(c)?l=c:hu(c)?l=Lr(c):p?(s=false,l=Ir(a,true)):_?(s=false,l=zr(a,true)):l=[]:xu(a)||of(a)?(l=c,of(c)?l=Ou(c):du(c)&&!_u(c)||(l=Ae(a))):s=false}s&&(f.set(a,l),Yt(l,a,r,e,f),f.delete(a))}it(n,o,l)}else f=e?e(Be(n,o),i,o+"",n,t,u):T,f===T&&(f=i),it(n,o,f)},Uu)}function Qt(n,t){var r=n.length;if(r)return t+=0>t?r:0,Se(t,r)?n[t]:T}function Xt(n,t,r){var e=-1;return t=c(t.length?t:[$u],E(ye())),n=Gt(n,function(n,r,u){return{a:c(t,function(t){return t(n)}),
b:++e,c:n}}),w(n,function(n,t){var e;n:{e=-1;for(var u=n.a,i=t.a,o=u.length,f=r.length;++e<o;){var c=Wr(u[e],i[e]);if(c){if(e>=f){e=c;break n}e=c*("desc"==r[e]?-1:1);break n}}e=n.b-t.b}return e})}function nr(n,t){return tr(n,t,function(t,r){return zu(n,r)})}function tr(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=Et(n,o);r(f,o)&&lr(i,Sr(o,n),f)}return i}function rr(n){return function(t){return Et(t,n)}}function er(n,t,r,e){var u=e?g:v,i=-1,o=t.length,f=n;for(n===t&&(t=Lr(t)),r&&(f=c(n,E(r)));++i<o;)for(var a=0,l=t[i],l=r?r(l):l;-1<(a=u(f,l,a,e));)f!==n&&xi.call(f,a,1),
xi.call(n,a,1);return n}function ur(n,t){for(var r=n?t.length:0,e=r-1;r--;){var u=t[r];if(r==e||u!==i){var i=u;Se(u)?xi.call(n,u,1):xr(n,u)}}return n}function ir(n,t){return n+Ii(Ti()*(t-n+1))}function or(n,t){var r="";if(!n||1>t||9007199254740991<t)return r;do t%2&&(r+=n),(t=Ii(t/2))&&(n+=n);while(t);return r}function fr(n,t){return xo(Ue(n,t,$u),n+"")}function cr(n){return Qn(Lu(n))}function ar(n,t){var r=Lu(n);return De(r,pt(t,0,r.length))}function lr(n,t,r,e){if(!du(n))return n;t=Sr(t,n);for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){
var c=Me(t[u]),a=r;if(u!=o){var l=f[c],a=e?e(l,c,f):T;a===T&&(a=du(l)?l:Se(t[u+1])?[]:{})}ot(f,c,a),f=f[c]}return n}function sr(n){return De(Lu(n))}function hr(n,t,r){var e=-1,u=n.length;for(0>t&&(t=-t>u?0:u+t),r=r>u?u:r,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,r=Ku(u);++e<u;)r[e]=n[e+t];return r}function pr(n,t){var r;return uo(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function _r(n,t,r){var e=0,u=null==n?e:n.length;if(typeof t=="number"&&t===t&&2147483647>=u){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!wu(o)&&(r?o<=t:o<t)?e=i+1:u=i;
}return u}return vr(n,t,$u,r)}function vr(n,t,r,e){t=r(t);for(var u=0,i=null==n?0:n.length,o=t!==t,f=null===t,c=wu(t),a=t===T;u<i;){var l=Ii((u+i)/2),s=r(n[l]),h=s!==T,p=null===s,_=s===s,v=wu(s);(o?e||_:a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):p||v?0:e?s<=t:s<t)?u=l+1:i=l}return Ci(i,4294967294)}function gr(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r],f=t?t(o):o;if(!r||!lu(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function dr(n){return typeof n=="number"?n:wu(n)?F:+n}function yr(n){
if(typeof n=="string")return n;if(ff(n))return c(n,yr)+"";if(wu(n))return ro?ro.call(n):"";var t=n+"";return"0"==t&&1/n==-$?"-0":t}function br(n,t,r){var e=-1,u=o,i=n.length,c=true,a=[],l=a;if(r)c=false,u=f;else if(200<=i){if(u=t?null:so(n))return L(u);c=false,u=O,l=new Nn}else l=t?[]:a;n:for(;++e<i;){var s=n[e],h=t?t(s):s,s=r||0!==s?s:0;if(c&&h===h){for(var p=l.length;p--;)if(l[p]===h)continue n;t&&l.push(h),a.push(s)}else u(l,h,r)||(l!==a&&l.push(h),a.push(s))}return a}function xr(n,t){return t=Sr(t,n),
n=2>t.length?n:Et(n,hr(t,0,-1)),null==n||delete n[Me(Ve(t))]}function jr(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?hr(n,e?0:i,e?i+1:u):hr(n,e?i+1:0,e?u:i)}function wr(n,t){var r=n;return r instanceof Ln&&(r=r.value()),l(t,function(n,t){return t.func.apply(t.thisArg,a([n],t.args))},r)}function mr(n,t,r){var e=n.length;if(2>e)return e?br(n[0]):[];for(var u=-1,i=Ku(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=yt(i[u]||o,n[f],t,r));return br(wt(i,1),t,r)}function Ar(n,t,r){
for(var e=-1,u=n.length,i=t.length,o={};++e<u;)r(o,n[e],e<i?t[e]:T);return o}function kr(n){return hu(n)?n:[]}function Er(n){return typeof n=="function"?n:$u}function Sr(n,t){return ff(n)?n:Ie(n,t)?[n]:jo(Iu(n))}function Or(n,t,r){var e=n.length;return r=r===T?e:r,!t&&r>=e?n:hr(n,t,r)}function Ir(n,t){if(t)return n.slice();var r=n.length,r=gi?gi(r):new n.constructor(r);return n.copy(r),r}function Rr(n){var t=new n.constructor(n.byteLength);return new vi(t).set(new vi(n)),t}function zr(n,t){return new n.constructor(t?Rr(n.buffer):n.buffer,n.byteOffset,n.length);
}function Wr(n,t){if(n!==t){var r=n!==T,e=null===n,u=n===n,i=wu(n),o=t!==T,f=null===t,c=t===t,a=wu(t);if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Ur(n,t,r,e){var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Li(i-o,0),l=Ku(c+a);for(e=!e;++f<c;)l[f]=t[f];for(;++u<o;)(e||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];return l}function Br(n,t,r,e){var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Li(i-f,0),s=Ku(l+a);
for(e=!e;++u<l;)s[u]=n[u];for(l=u;++c<a;)s[l+c]=t[c];for(;++o<f;)(e||u<i)&&(s[l+r[o]]=n[u++]);return s}function Lr(n,t){var r=-1,e=n.length;for(t||(t=Ku(e));++r<e;)t[r]=n[r];return t}function Cr(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):T;c===T&&(c=n[f]),u?st(r,f,c):ot(r,f,c)}return r}function Dr(n,t){return Cr(n,po(n),t)}function Mr(n,t){return Cr(n,_o(n),t)}function Tr(n,r){return function(e,u){var i=ff(e)?t:ct,o=r?r():{};return i(e,n,ye(u,2),o);
}}function $r(n){return fr(function(t,r){var e=-1,u=r.length,i=1<u?r[u-1]:T,o=2<u?r[2]:T,i=3<n.length&&typeof i=="function"?(u--,i):T;for(o&&Oe(r[0],r[1],o)&&(i=3>u?T:i,u=1),t=Qu(t);++e<u;)(o=r[e])&&n(t,o,e,i);return t})}function Fr(n,t){return function(r,e){if(null==r)return r;if(!su(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=Qu(r);(t?i--:++i<u)&&false!==e(o[i],i,o););return r}}function Nr(n){return function(t,r,e){var u=-1,i=Qu(t);e=e(t);for(var o=e.length;o--;){var f=e[n?o:++u];if(false===r(i[f],f,i))break;
}return t}}function Pr(n,t,r){function e(){return(this&&this!==$n&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=1&t,i=Vr(n);return e}function Zr(n){return function(t){t=Iu(t);var r=Rn.test(t)?M(t):T,e=r?r[0]:t.charAt(0);return t=r?Or(r,1).join(""):t.slice(1),e[n]()+t}}function qr(n){return function(t){return l(Mu(Du(t).replace(En,"")),n,"")}}function Vr(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:
return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=eo(n.prototype),t=n.apply(r,t);return du(t)?t:r}}function Kr(t,r,e){function u(){for(var o=arguments.length,f=Ku(o),c=o,a=de(u);c--;)f[c]=arguments[c];return c=3>o&&f[0]!==a&&f[o-1]!==a?[]:B(f,a),o-=c.length,o<e?ue(t,r,Jr,u.placeholder,T,f,c,T,T,e-o):n(this&&this!==$n&&this instanceof u?i:t,this,f);
}var i=Vr(t);return u}function Gr(n){return function(t,r,e){var u=Qu(t);if(!su(t)){var i=ye(r,3);t=Wu(t),r=function(n){return i(u[n],n,u)}}return r=n(t,r,e),-1<r?u[i?t[r]:r]:T}}function Hr(n){return pe(function(t){var r=t.length,e=r,u=On.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if(typeof i!="function")throw new ti("Expected a function");if(u&&!o&&"wrapper"==ge(i))var o=new On([],true)}for(e=o?e:r;++e<r;)var i=t[e],u=ge(i),f="wrapper"==u?ho(i):T,o=f&&Re(f[0])&&424==f[1]&&!f[4].length&&1==f[9]?o[ge(f[0])].apply(o,f[3]):1==i.length&&Re(i)?o[u]():o.thru(i);
return function(){var n=arguments,e=n[0];if(o&&1==n.length&&ff(e))return o.plant(e).value();for(var u=0,n=r?t[u].apply(this,n):e;++u<r;)n=t[u].call(this,n);return n}})}function Jr(n,t,r,e,u,i,o,f,c,a){function l(){for(var d=arguments.length,y=Ku(d),b=d;b--;)y[b]=arguments[b];if(_){var x,j=de(l),b=y.length;for(x=0;b--;)y[b]===j&&++x}if(e&&(y=Ur(y,e,u,_)),i&&(y=Br(y,i,o,_)),d-=x,_&&d<a)return j=B(y,j),ue(n,t,Jr,l.placeholder,r,y,j,f,c,a-d);if(j=h?r:this,b=p?j[n]:n,d=y.length,f){x=y.length;for(var w=Ci(f.length,x),m=Lr(y);w--;){
var A=f[w];y[w]=Se(A,x)?m[A]:T}}else v&&1<d&&y.reverse();return s&&c<d&&(y.length=c),this&&this!==$n&&this instanceof l&&(b=g||Vr(b)),b.apply(j,y)}var s=128&t,h=1&t,p=2&t,_=24&t,v=512&t,g=p?T:Vr(n);return l}function Yr(n,t){return function(r,e){return Ut(r,n,t(e),{})}}function Qr(n,t){return function(r,e){var u;if(r===T&&e===T)return t;if(r!==T&&(u=r),e!==T){if(u===T)return e;typeof r=="string"||typeof e=="string"?(r=yr(r),e=yr(e)):(r=dr(r),e=dr(e)),u=n(r,e)}return u}}function Xr(t){return pe(function(r){
return r=c(r,E(ye())),fr(function(e){var u=this;return t(r,function(t){return n(t,u,e)})})})}function ne(n,t){t=t===T?" ":yr(t);var r=t.length;return 2>r?r?or(t,n):t:(r=or(t,Oi(n/D(t))),Rn.test(t)?Or(M(r),0,n).join(""):r.slice(0,n))}function te(t,r,e,u){function i(){for(var r=-1,c=arguments.length,a=-1,l=u.length,s=Ku(l+c),h=this&&this!==$n&&this instanceof i?f:t;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++r];return n(h,o?e:this,s)}var o=1&r,f=Vr(t);return i}function re(n){return function(t,r,e){
e&&typeof e!="number"&&Oe(t,r,e)&&(r=e=T),t=Au(t),r===T?(r=t,t=0):r=Au(r),e=e===T?t<r?1:-1:Au(e);var u=-1;r=Li(Oi((r-t)/(e||1)),0);for(var i=Ku(r);r--;)i[n?r:++u]=t,t+=e;return i}}function ee(n){return function(t,r){return typeof t=="string"&&typeof r=="string"||(t=Su(t),r=Su(r)),n(t,r)}}function ue(n,t,r,e,u,i,o,f,c,a){var l=8&t,s=l?o:T;o=l?T:o;var h=l?i:T;return i=l?T:i,t=(t|(l?32:64))&~(l?64:32),4&t||(t&=-4),u=[n,t,u,h,s,i,o,f,c,a],r=r.apply(T,u),Re(n)&&yo(r,u),r.placeholder=e,Le(r,n,t)}function ie(n){
var t=Yu[n];return function(n,r){if(n=Su(n),r=null==r?0:Ci(ku(r),292)){var e=(Iu(n)+"e").split("e"),e=t(e[0]+"e"+(+e[1]+r)),e=(Iu(e)+"e").split("e");return+(e[0]+"e"+(+e[1]-r))}return t(n)}}function oe(n){return function(t){var r=vo(t);return"[object Map]"==r?W(t):"[object Set]"==r?C(t):k(t,n(t))}}function fe(n,t,r,e,u,i,o,f){var c=2&t;if(!c&&typeof n!="function")throw new ti("Expected a function");var a=e?e.length:0;if(a||(t&=-97,e=u=T),o=o===T?o:Li(ku(o),0),f=f===T?f:ku(f),a-=u?u.length:0,64&t){
var l=e,s=u;e=u=T}var h=c?T:ho(n);return i=[n,t,r,e,u,l,s,i,o,f],h&&(r=i[1],n=h[1],t=r|n,e=128==n&&8==r||128==n&&256==r&&i[7].length<=h[8]||384==n&&h[7].length<=h[8]&&8==r,131>t||e)&&(1&n&&(i[2]=h[2],t|=1&r?0:4),(r=h[3])&&(e=i[3],i[3]=e?Ur(e,r,h[4]):r,i[4]=e?B(i[3],"__lodash_placeholder__"):h[4]),(r=h[5])&&(e=i[5],i[5]=e?Br(e,r,h[6]):r,i[6]=e?B(i[5],"__lodash_placeholder__"):h[6]),(r=h[7])&&(i[7]=r),128&n&&(i[8]=null==i[8]?h[8]:Ci(i[8],h[8])),null==i[9]&&(i[9]=h[9]),i[0]=h[0],i[1]=t),n=i[0],t=i[1],
r=i[2],e=i[3],u=i[4],f=i[9]=i[9]===T?c?0:n.length:Li(i[9]-a,0),!f&&24&t&&(t&=-25),c=t&&1!=t?8==t||16==t?Kr(n,t,f):32!=t&&33!=t||u.length?Jr.apply(T,i):te(n,t,r,e):Pr(n,t,r),Le((h?co:yo)(c,i),n,t)}function ce(n,t,r,e){return n===T||lu(n,ei[r])&&!oi.call(e,r)?t:n}function ae(n,t,r,e,u,i){return du(n)&&du(t)&&(i.set(t,n),Yt(n,t,T,ae,i),i.delete(t)),n}function le(n){return xu(n)?T:n}function se(n,t,r,e,u,i){var o=1&r,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return false;if((c=i.get(n))&&i.get(t))return c==t;
var c=-1,a=true,l=2&r?new Nn:T;for(i.set(n,t),i.set(t,n);++c<f;){var s=n[c],p=t[c];if(e)var _=o?e(p,s,c,t,n,i):e(s,p,c,n,t,i);if(_!==T){if(_)continue;a=false;break}if(l){if(!h(t,function(n,t){if(!O(l,t)&&(s===n||u(s,n,r,e,i)))return l.push(t)})){a=false;break}}else if(s!==p&&!u(s,p,r,e,i)){a=false;break}}return i.delete(n),i.delete(t),a}function he(n,t,r,e,u,i,o){switch(r){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)break;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":
if(n.byteLength!=t.byteLength||!i(new vi(n),new vi(t)))break;return true;case"[object Boolean]":case"[object Date]":case"[object Number]":return lu(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=W;case"[object Set]":if(f||(f=L),n.size!=t.size&&!(1&e))break;return(r=o.get(n))?r==t:(e|=2,o.set(n,t),t=se(f(n),f(t),e,u,i,o),o.delete(n),t);case"[object Symbol]":if(to)return to.call(n)==to.call(t)}
return false}function pe(n){return xo(Ue(n,T,Ze),n+"")}function _e(n){return St(n,Wu,po)}function ve(n){return St(n,Uu,_o)}function ge(n){for(var t=n.name+"",r=Gi[t],e=oi.call(Gi,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function de(n){return(oi.call(An,"placeholder")?An:n).placeholder}function ye(){var n=An.iteratee||Fu,n=n===Fu?qt:n;return arguments.length?n(arguments[0],arguments[1]):n}function be(n,t){var r=n.__data__,e=typeof t;return("string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t)?r[typeof t=="string"?"string":"hash"]:r.map;
}function xe(n){for(var t=Wu(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,u===u&&!du(u)]}return t}function je(n,t){var r=null==n?T:n[t];return Ft(r)?r:T}function we(n,t,r){t=Sr(t,n);for(var e=-1,u=t.length,i=false;++e<u;){var o=Me(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&gu(u)&&Se(o,u)&&(ff(n)||of(n)))}function me(n){var t=n.length,r=new n.constructor(t);return t&&"string"==typeof n[0]&&oi.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Ae(n){
return typeof n.constructor!="function"||ze(n)?{}:eo(di(n))}function ke(n,t,r){var e=n.constructor;switch(t){case"[object ArrayBuffer]":return Rr(n);case"[object Boolean]":case"[object Date]":return new e(+n);case"[object DataView]":return t=r?Rr(n.buffer):n.buffer,new n.constructor(t,n.byteOffset,n.byteLength);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":
case"[object Uint16Array]":case"[object Uint32Array]":return zr(n,r);case"[object Map]":return new e;case"[object Number]":case"[object String]":return new e(n);case"[object RegExp]":return t=new n.constructor(n.source,_n.exec(n)),t.lastIndex=n.lastIndex,t;case"[object Set]":return new e;case"[object Symbol]":return to?Qu(to.call(n)):{}}}function Ee(n){return ff(n)||of(n)||!!(ji&&n&&n[ji])}function Se(n,t){var r=typeof n;return t=null==t?9007199254740991:t,!!t&&("number"==r||"symbol"!=r&&bn.test(n))&&-1<n&&0==n%1&&n<t;
}function Oe(n,t,r){if(!du(r))return false;var e=typeof t;return!!("number"==e?su(r)&&Se(t,r.length):"string"==e&&t in r)&&lu(r[t],n)}function Ie(n,t){if(ff(n))return false;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!wu(n))||(nn.test(n)||!X.test(n)||null!=t&&n in Qu(t))}function Re(n){var t=ge(n),r=An[t];return typeof r=="function"&&t in Ln.prototype&&(n===r||(t=ho(r),!!t&&n===t[0]))}function ze(n){var t=n&&n.constructor;return n===(typeof t=="function"&&t.prototype||ei)}function We(n,t){
return function(r){return null!=r&&(r[n]===t&&(t!==T||n in Qu(r)))}}function Ue(t,r,e){return r=Li(r===T?t.length-1:r,0),function(){for(var u=arguments,i=-1,o=Li(u.length-r,0),f=Ku(o);++i<o;)f[i]=u[r+i];for(i=-1,o=Ku(r+1);++i<r;)o[i]=u[i];return o[r]=e(f),n(t,this,o)}}function Be(n,t){if("__proto__"!=t)return n[t]}function Le(n,t,r){var e=t+"";t=xo;var u,i=$e;return u=(u=e.match(an))?u[1].split(ln):[],r=i(u,r),(i=r.length)&&(u=i-1,r[u]=(1<i?"& ":"")+r[u],r=r.join(2<i?", ":" "),e=e.replace(cn,"{\n/* [wrapped with "+r+"] */\n")),
t(n,e)}function Ce(n){var t=0,r=0;return function(){var e=Di(),u=16-(e-r);if(r=e,0<u){if(800<=++t)return arguments[0]}else t=0;return n.apply(T,arguments)}}function De(n,t){var r=-1,e=n.length,u=e-1;for(t=t===T?e:t;++r<t;){var e=ir(r,u),i=n[e];n[e]=n[r],n[r]=i}return n.length=t,n}function Me(n){if(typeof n=="string"||wu(n))return n;var t=n+"";return"0"==t&&1/n==-$?"-0":t}function Te(n){if(null!=n){try{return ii.call(n)}catch(n){}return n+""}return""}function $e(n,t){return r(N,function(r){var e="_."+r[0];
t&r[1]&&!o(n,e)&&n.push(e)}),n.sort()}function Fe(n){if(n instanceof Ln)return n.clone();var t=new On(n.__wrapped__,n.__chain__);return t.__actions__=Lr(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function Ne(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:ku(r),0>r&&(r=Li(e+r,0)),_(n,ye(t,3),r)):-1}function Pe(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==T&&(u=ku(r),u=0>r?Li(e+u,0):Ci(u,e-1)),_(n,ye(t,3),u,true)}function Ze(n){return(null==n?0:n.length)?wt(n,1):[];
}function qe(n){return n&&n.length?n[0]:T}function Ve(n){var t=null==n?0:n.length;return t?n[t-1]:T}function Ke(n,t){return n&&n.length&&t&&t.length?er(n,t):n}function Ge(n){return null==n?n:$i.call(n)}function He(n){if(!n||!n.length)return[];var t=0;return n=i(n,function(n){if(hu(n))return t=Li(n.length,t),true}),A(t,function(t){return c(n,b(t))})}function Je(t,r){if(!t||!t.length)return[];var e=He(t);return null==r?e:c(e,function(t){return n(r,T,t)})}function Ye(n){return n=An(n),n.__chain__=true,n;
}function Qe(n,t){return t(n)}function Xe(){return this}function nu(n,t){return(ff(n)?r:uo)(n,ye(t,3))}function tu(n,t){return(ff(n)?e:io)(n,ye(t,3))}function ru(n,t){return(ff(n)?c:Gt)(n,ye(t,3))}function eu(n,t,r){return t=r?T:t,t=n&&null==t?n.length:t,fe(n,128,T,T,T,T,t)}function uu(n,t){var r;if(typeof t!="function")throw new ti("Expected a function");return n=ku(n),function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=T),r}}function iu(n,t,r){return t=r?T:t,n=fe(n,8,T,T,T,T,T,t),n.placeholder=iu.placeholder,
n}function ou(n,t,r){return t=r?T:t,n=fe(n,16,T,T,T,T,T,t),n.placeholder=ou.placeholder,n}function fu(n,t,r){function e(t){var r=c,e=a;return c=a=T,_=t,s=n.apply(e,r)}function u(n){var r=n-p;return n-=_,p===T||r>=t||0>r||g&&n>=l}function i(){var n=Go();if(u(n))return o(n);var r,e=bo;r=n-_,n=t-(n-p),r=g?Ci(n,l-r):n,h=e(i,r)}function o(n){return h=T,d&&c?e(n):(c=a=T,s)}function f(){var n=Go(),r=u(n);if(c=arguments,a=this,p=n,r){if(h===T)return _=n=p,h=bo(i,t),v?e(n):s;if(g)return h=bo(i,t),e(p)}return h===T&&(h=bo(i,t)),
s}var c,a,l,s,h,p,_=0,v=false,g=false,d=true;if(typeof n!="function")throw new ti("Expected a function");return t=Su(t)||0,du(r)&&(v=!!r.leading,l=(g="maxWait"in r)?Li(Su(r.maxWait)||0,t):l,d="trailing"in r?!!r.trailing:d),f.cancel=function(){h!==T&&lo(h),_=0,c=p=a=h=T},f.flush=function(){return h===T?s:o(Go())},f}function cu(n,t){if(typeof n!="function"||null!=t&&typeof t!="function")throw new ti("Expected a function");var r=function(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;return i.has(u)?i.get(u):(e=n.apply(this,e),
r.cache=i.set(u,e)||i,e)};return r.cache=new(cu.Cache||Fn),r}function au(n){if(typeof n!="function")throw new ti("Expected a function");return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function lu(n,t){return n===t||n!==n&&t!==t}function su(n){return null!=n&&gu(n.length)&&!_u(n)}function hu(n){return yu(n)&&su(n)}function pu(n){if(!yu(n))return false;
var t=Ot(n);return"[object Error]"==t||"[object DOMException]"==t||typeof n.message=="string"&&typeof n.name=="string"&&!xu(n)}function _u(n){return!!du(n)&&(n=Ot(n),"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n)}function vu(n){return typeof n=="number"&&n==ku(n)}function gu(n){return typeof n=="number"&&-1<n&&0==n%1&&9007199254740991>=n}function du(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}function yu(n){return null!=n&&typeof n=="object";
}function bu(n){return typeof n=="number"||yu(n)&&"[object Number]"==Ot(n)}function xu(n){return!(!yu(n)||"[object Object]"!=Ot(n))&&(n=di(n),null===n||(n=oi.call(n,"constructor")&&n.constructor,typeof n=="function"&&n instanceof n&&ii.call(n)==li))}function ju(n){return typeof n=="string"||!ff(n)&&yu(n)&&"[object String]"==Ot(n)}function wu(n){return typeof n=="symbol"||yu(n)&&"[object Symbol]"==Ot(n)}function mu(n){if(!n)return[];if(su(n))return ju(n)?M(n):Lr(n);if(wi&&n[wi]){n=n[wi]();for(var t,r=[];!(t=n.next()).done;)r.push(t.value);
return r}return t=vo(n),("[object Map]"==t?W:"[object Set]"==t?L:Lu)(n)}function Au(n){return n?(n=Su(n),n===$||n===-$?1.7976931348623157e308*(0>n?-1:1):n===n?n:0):0===n?n:0}function ku(n){n=Au(n);var t=n%1;return n===n?t?n-t:n:0}function Eu(n){return n?pt(ku(n),0,4294967295):0}function Su(n){if(typeof n=="number")return n;if(wu(n))return F;if(du(n)&&(n=typeof n.valueOf=="function"?n.valueOf():n,n=du(n)?n+"":n),typeof n!="string")return 0===n?n:+n;n=n.replace(un,"");var t=gn.test(n);return t||yn.test(n)?Dn(n.slice(2),t?2:8):vn.test(n)?F:+n;
}function Ou(n){return Cr(n,Uu(n))}function Iu(n){return null==n?"":yr(n)}function Ru(n,t,r){return n=null==n?T:Et(n,t),n===T?r:n}function zu(n,t){return null!=n&&we(n,t,zt)}function Wu(n){return su(n)?qn(n):Vt(n)}function Uu(n){if(su(n))n=qn(n,true);else if(du(n)){var t,r=ze(n),e=[];for(t in n)("constructor"!=t||!r&&oi.call(n,t))&&e.push(t);n=e}else{if(t=[],null!=n)for(r in Qu(n))t.push(r);n=t}return n}function Bu(n,t){if(null==n)return{};var r=c(ve(n),function(n){return[n]});return t=ye(t),tr(n,r,function(n,r){
return t(n,r[0])})}function Lu(n){return null==n?[]:S(n,Wu(n))}function Cu(n){return $f(Iu(n).toLowerCase())}function Du(n){return(n=Iu(n))&&n.replace(xn,Xn).replace(Sn,"")}function Mu(n,t,r){return n=Iu(n),t=r?T:t,t===T?zn.test(n)?n.match(In)||[]:n.match(sn)||[]:n.match(t)||[]}function Tu(n){return function(){return n}}function $u(n){return n}function Fu(n){return qt(typeof n=="function"?n:_t(n,1))}function Nu(n,t,e){var u=Wu(t),i=kt(t,u);null!=e||du(t)&&(i.length||!u.length)||(e=t,t=n,n=this,i=kt(t,Wu(t)));
var o=!(du(e)&&"chain"in e&&!e.chain),f=_u(n);return r(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Lr(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,a([this.value()],arguments))})}),n}function Pu(){}function Zu(n){return Ie(n)?b(Me(n)):rr(n)}function qu(){return[]}function Vu(){return false}mn=null==mn?$n:rt.defaults($n.Object(),mn,rt.pick($n,Wn));var Ku=mn.Array,Gu=mn.Date,Hu=mn.Error,Ju=mn.Function,Yu=mn.Math,Qu=mn.Object,Xu=mn.RegExp,ni=mn.String,ti=mn.TypeError,ri=Ku.prototype,ei=Qu.prototype,ui=mn["__core-js_shared__"],ii=Ju.prototype.toString,oi=ei.hasOwnProperty,fi=0,ci=function(){
var n=/[^.]+$/.exec(ui&&ui.keys&&ui.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),ai=ei.toString,li=ii.call(Qu),si=$n._,hi=Xu("^"+ii.call(oi).replace(rn,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),pi=Pn?mn.Buffer:T,_i=mn.Symbol,vi=mn.Uint8Array,gi=pi?pi.allocUnsafe:T,di=U(Qu.getPrototypeOf,Qu),yi=Qu.create,bi=ei.propertyIsEnumerable,xi=ri.splice,ji=_i?_i.isConcatSpreadable:T,wi=_i?_i.iterator:T,mi=_i?_i.toStringTag:T,Ai=function(){try{var n=je(Qu,"defineProperty");
return n({},"",{}),n}catch(n){}}(),ki=mn.clearTimeout!==$n.clearTimeout&&mn.clearTimeout,Ei=Gu&&Gu.now!==$n.Date.now&&Gu.now,Si=mn.setTimeout!==$n.setTimeout&&mn.setTimeout,Oi=Yu.ceil,Ii=Yu.floor,Ri=Qu.getOwnPropertySymbols,zi=pi?pi.isBuffer:T,Wi=mn.isFinite,Ui=ri.join,Bi=U(Qu.keys,Qu),Li=Yu.max,Ci=Yu.min,Di=Gu.now,Mi=mn.parseInt,Ti=Yu.random,$i=ri.reverse,Fi=je(mn,"DataView"),Ni=je(mn,"Map"),Pi=je(mn,"Promise"),Zi=je(mn,"Set"),qi=je(mn,"WeakMap"),Vi=je(Qu,"create"),Ki=qi&&new qi,Gi={},Hi=Te(Fi),Ji=Te(Ni),Yi=Te(Pi),Qi=Te(Zi),Xi=Te(qi),no=_i?_i.prototype:T,to=no?no.valueOf:T,ro=no?no.toString:T,eo=function(){
function n(){}return function(t){return du(t)?yi?yi(t):(n.prototype=t,t=new n,n.prototype=T,t):{}}}();An.templateSettings={escape:J,evaluate:Y,interpolate:Q,variable:"",imports:{_:An}},An.prototype=kn.prototype,An.prototype.constructor=An,On.prototype=eo(kn.prototype),On.prototype.constructor=On,Ln.prototype=eo(kn.prototype),Ln.prototype.constructor=Ln,Mn.prototype.clear=function(){this.__data__=Vi?Vi(null):{},this.size=0},Mn.prototype.delete=function(n){return n=this.has(n)&&delete this.__data__[n],
this.size-=n?1:0,n},Mn.prototype.get=function(n){var t=this.__data__;return Vi?(n=t[n],"__lodash_hash_undefined__"===n?T:n):oi.call(t,n)?t[n]:T},Mn.prototype.has=function(n){var t=this.__data__;return Vi?t[n]!==T:oi.call(t,n)},Mn.prototype.set=function(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=Vi&&t===T?"__lodash_hash_undefined__":t,this},Tn.prototype.clear=function(){this.__data__=[],this.size=0},Tn.prototype.delete=function(n){var t=this.__data__;return n=ft(t,n),!(0>n)&&(n==t.length-1?t.pop():xi.call(t,n,1),
--this.size,true)},Tn.prototype.get=function(n){var t=this.__data__;return n=ft(t,n),0>n?T:t[n][1]},Tn.prototype.has=function(n){return-1<ft(this.__data__,n)},Tn.prototype.set=function(n,t){var r=this.__data__,e=ft(r,n);return 0>e?(++this.size,r.push([n,t])):r[e][1]=t,this},Fn.prototype.clear=function(){this.size=0,this.__data__={hash:new Mn,map:new(Ni||Tn),string:new Mn}},Fn.prototype.delete=function(n){return n=be(this,n).delete(n),this.size-=n?1:0,n},Fn.prototype.get=function(n){return be(this,n).get(n);
},Fn.prototype.has=function(n){return be(this,n).has(n)},Fn.prototype.set=function(n,t){var r=be(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this},Nn.prototype.add=Nn.prototype.push=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this},Nn.prototype.has=function(n){return this.__data__.has(n)},Zn.prototype.clear=function(){this.__data__=new Tn,this.size=0},Zn.prototype.delete=function(n){var t=this.__data__;return n=t.delete(n),this.size=t.size,n},Zn.prototype.get=function(n){
return this.__data__.get(n)},Zn.prototype.has=function(n){return this.__data__.has(n)},Zn.prototype.set=function(n,t){var r=this.__data__;if(r instanceof Tn){var e=r.__data__;if(!Ni||199>e.length)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new Fn(e)}return r.set(n,t),this.size=r.size,this};var uo=Fr(mt),io=Fr(At,true),oo=Nr(),fo=Nr(true),co=Ki?function(n,t){return Ki.set(n,t),n}:$u,ao=Ai?function(n,t){return Ai(n,"toString",{configurable:true,enumerable:false,value:Tu(t),writable:true})}:$u,lo=ki||function(n){
return $n.clearTimeout(n)},so=Zi&&1/L(new Zi([,-0]))[1]==$?function(n){return new Zi(n)}:Pu,ho=Ki?function(n){return Ki.get(n)}:Pu,po=Ri?function(n){return null==n?[]:(n=Qu(n),i(Ri(n),function(t){return bi.call(n,t)}))}:qu,_o=Ri?function(n){for(var t=[];n;)a(t,po(n)),n=di(n);return t}:qu,vo=Ot;(Fi&&"[object DataView]"!=vo(new Fi(new ArrayBuffer(1)))||Ni&&"[object Map]"!=vo(new Ni)||Pi&&"[object Promise]"!=vo(Pi.resolve())||Zi&&"[object Set]"!=vo(new Zi)||qi&&"[object WeakMap]"!=vo(new qi))&&(vo=function(n){
var t=Ot(n);if(n=(n="[object Object]"==t?n.constructor:T)?Te(n):"")switch(n){case Hi:return"[object DataView]";case Ji:return"[object Map]";case Yi:return"[object Promise]";case Qi:return"[object Set]";case Xi:return"[object WeakMap]"}return t});var go=ui?_u:Vu,yo=Ce(co),bo=Si||function(n,t){return $n.setTimeout(n,t)},xo=Ce(ao),jo=function(n){n=cu(n,function(n){return 500===t.size&&t.clear(),n});var t=n.cache;return n}(function(n){var t=[];return 46===n.charCodeAt(0)&&t.push(""),n.replace(tn,function(n,r,e,u){
t.push(e?u.replace(hn,"$1"):r||n)}),t}),wo=fr(function(n,t){return hu(n)?yt(n,wt(t,1,hu,true)):[]}),mo=fr(function(n,t){var r=Ve(t);return hu(r)&&(r=T),hu(n)?yt(n,wt(t,1,hu,true),ye(r,2)):[]}),Ao=fr(function(n,t){var r=Ve(t);return hu(r)&&(r=T),hu(n)?yt(n,wt(t,1,hu,true),T,r):[]}),ko=fr(function(n){var t=c(n,kr);return t.length&&t[0]===n[0]?Wt(t):[]}),Eo=fr(function(n){var t=Ve(n),r=c(n,kr);return t===Ve(r)?t=T:r.pop(),r.length&&r[0]===n[0]?Wt(r,ye(t,2)):[]}),So=fr(function(n){var t=Ve(n),r=c(n,kr);return(t=typeof t=="function"?t:T)&&r.pop(),
r.length&&r[0]===n[0]?Wt(r,T,t):[]}),Oo=fr(Ke),Io=pe(function(n,t){var r=null==n?0:n.length,e=ht(n,t);return ur(n,c(t,function(n){return Se(n,r)?+n:n}).sort(Wr)),e}),Ro=fr(function(n){return br(wt(n,1,hu,true))}),zo=fr(function(n){var t=Ve(n);return hu(t)&&(t=T),br(wt(n,1,hu,true),ye(t,2))}),Wo=fr(function(n){var t=Ve(n),t=typeof t=="function"?t:T;return br(wt(n,1,hu,true),T,t)}),Uo=fr(function(n,t){return hu(n)?yt(n,t):[]}),Bo=fr(function(n){return mr(i(n,hu))}),Lo=fr(function(n){var t=Ve(n);return hu(t)&&(t=T),
mr(i(n,hu),ye(t,2))}),Co=fr(function(n){var t=Ve(n),t=typeof t=="function"?t:T;return mr(i(n,hu),T,t)}),Do=fr(He),Mo=fr(function(n){var t=n.length,t=1<t?n[t-1]:T,t=typeof t=="function"?(n.pop(),t):T;return Je(n,t)}),To=pe(function(n){var t=n.length,r=t?n[0]:0,e=this.__wrapped__,u=function(t){return ht(t,n)};return!(1<t||this.__actions__.length)&&e instanceof Ln&&Se(r)?(e=e.slice(r,+r+(t?1:0)),e.__actions__.push({func:Qe,args:[u],thisArg:T}),new On(e,this.__chain__).thru(function(n){return t&&!n.length&&n.push(T),
n})):this.thru(u)}),$o=Tr(function(n,t,r){oi.call(n,r)?++n[r]:st(n,r,1)}),Fo=Gr(Ne),No=Gr(Pe),Po=Tr(function(n,t,r){oi.call(n,r)?n[r].push(t):st(n,r,[t])}),Zo=fr(function(t,r,e){var u=-1,i=typeof r=="function",o=su(t)?Ku(t.length):[];return uo(t,function(t){o[++u]=i?n(r,t,e):Bt(t,r,e)}),o}),qo=Tr(function(n,t,r){st(n,r,t)}),Vo=Tr(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),Ko=fr(function(n,t){if(null==n)return[];var r=t.length;return 1<r&&Oe(n,t[0],t[1])?t=[]:2<r&&Oe(t[0],t[1],t[2])&&(t=[t[0]]),
Xt(n,wt(t,1),[])}),Go=Ei||function(){return $n.Date.now()},Ho=fr(function(n,t,r){var e=1;if(r.length)var u=B(r,de(Ho)),e=32|e;return fe(n,e,t,r,u)}),Jo=fr(function(n,t,r){var e=3;if(r.length)var u=B(r,de(Jo)),e=32|e;return fe(t,e,n,r,u)}),Yo=fr(function(n,t){return dt(n,1,t)}),Qo=fr(function(n,t,r){return dt(n,Su(t)||0,r)});cu.Cache=Fn;var Xo=fr(function(t,r){r=1==r.length&&ff(r[0])?c(r[0],E(ye())):c(wt(r,1),E(ye()));var e=r.length;return fr(function(u){for(var i=-1,o=Ci(u.length,e);++i<o;)u[i]=r[i].call(this,u[i]);
return n(t,this,u)})}),nf=fr(function(n,t){return fe(n,32,T,t,B(t,de(nf)))}),tf=fr(function(n,t){return fe(n,64,T,t,B(t,de(tf)))}),rf=pe(function(n,t){return fe(n,256,T,T,T,t)}),ef=ee(It),uf=ee(function(n,t){return n>=t}),of=Lt(function(){return arguments}())?Lt:function(n){return yu(n)&&oi.call(n,"callee")&&!bi.call(n,"callee")},ff=Ku.isArray,cf=Vn?E(Vn):Ct,af=zi||Vu,lf=Kn?E(Kn):Dt,sf=Gn?E(Gn):Tt,hf=Hn?E(Hn):Nt,pf=Jn?E(Jn):Pt,_f=Yn?E(Yn):Zt,vf=ee(Kt),gf=ee(function(n,t){return n<=t}),df=$r(function(n,t){
if(ze(t)||su(t))Cr(t,Wu(t),n);else for(var r in t)oi.call(t,r)&&ot(n,r,t[r])}),yf=$r(function(n,t){Cr(t,Uu(t),n)}),bf=$r(function(n,t,r,e){Cr(t,Uu(t),n,e)}),xf=$r(function(n,t,r,e){Cr(t,Wu(t),n,e)}),jf=pe(ht),wf=fr(function(n,t){n=Qu(n);var r=-1,e=t.length,u=2<e?t[2]:T;for(u&&Oe(t[0],t[1],u)&&(e=1);++r<e;)for(var u=t[r],i=Uu(u),o=-1,f=i.length;++o<f;){var c=i[o],a=n[c];(a===T||lu(a,ei[c])&&!oi.call(n,c))&&(n[c]=u[c])}return n}),mf=fr(function(t){return t.push(T,ae),n(Of,T,t)}),Af=Yr(function(n,t,r){
null!=t&&typeof t.toString!="function"&&(t=ai.call(t)),n[t]=r},Tu($u)),kf=Yr(function(n,t,r){null!=t&&typeof t.toString!="function"&&(t=ai.call(t)),oi.call(n,t)?n[t].push(r):n[t]=[r]},ye),Ef=fr(Bt),Sf=$r(function(n,t,r){Yt(n,t,r)}),Of=$r(function(n,t,r,e){Yt(n,t,r,e)}),If=pe(function(n,t){var r={};if(null==n)return r;var e=false;t=c(t,function(t){return t=Sr(t,n),e||(e=1<t.length),t}),Cr(n,ve(n),r),e&&(r=_t(r,7,le));for(var u=t.length;u--;)xr(r,t[u]);return r}),Rf=pe(function(n,t){return null==n?{}:nr(n,t);
}),zf=oe(Wu),Wf=oe(Uu),Uf=qr(function(n,t,r){return t=t.toLowerCase(),n+(r?Cu(t):t)}),Bf=qr(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Lf=qr(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Cf=Zr("toLowerCase"),Df=qr(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),Mf=qr(function(n,t,r){return n+(r?" ":"")+$f(t)}),Tf=qr(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),$f=Zr("toUpperCase"),Ff=fr(function(t,r){try{return n(t,T,r)}catch(n){return pu(n)?n:new Hu(n)}}),Nf=pe(function(n,t){
return r(t,function(t){t=Me(t),st(n,t,Ho(n[t],n))}),n}),Pf=Hr(),Zf=Hr(true),qf=fr(function(n,t){return function(r){return Bt(r,n,t)}}),Vf=fr(function(n,t){return function(r){return Bt(n,r,t)}}),Kf=Xr(c),Gf=Xr(u),Hf=Xr(h),Jf=re(),Yf=re(true),Qf=Qr(function(n,t){return n+t},0),Xf=ie("ceil"),nc=Qr(function(n,t){return n/t},1),tc=ie("floor"),rc=Qr(function(n,t){return n*t},1),ec=ie("round"),uc=Qr(function(n,t){return n-t},0);return An.after=function(n,t){if(typeof t!="function")throw new ti("Expected a function");
return n=ku(n),function(){if(1>--n)return t.apply(this,arguments)}},An.ary=eu,An.assign=df,An.assignIn=yf,An.assignInWith=bf,An.assignWith=xf,An.at=jf,An.before=uu,An.bind=Ho,An.bindAll=Nf,An.bindKey=Jo,An.castArray=function(){if(!arguments.length)return[];var n=arguments[0];return ff(n)?n:[n]},An.chain=Ye,An.chunk=function(n,t,r){if(t=(r?Oe(n,t,r):t===T)?1:Li(ku(t),0),r=null==n?0:n.length,!r||1>t)return[];for(var e=0,u=0,i=Ku(Oi(r/t));e<r;)i[u++]=hr(n,e,e+=t);return i},An.compact=function(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){
var i=n[t];i&&(u[e++]=i)}return u},An.concat=function(){var n=arguments.length;if(!n)return[];for(var t=Ku(n-1),r=arguments[0];n--;)t[n-1]=arguments[n];return a(ff(r)?Lr(r):[r],wt(t,1))},An.cond=function(t){var r=null==t?0:t.length,e=ye();return t=r?c(t,function(n){if("function"!=typeof n[1])throw new ti("Expected a function");return[e(n[0]),n[1]]}):[],fr(function(e){for(var u=-1;++u<r;){var i=t[u];if(n(i[0],this,e))return n(i[1],this,e)}})},An.conforms=function(n){return vt(_t(n,1))},An.constant=Tu,
An.countBy=$o,An.create=function(n,t){var r=eo(n);return null==t?r:at(r,t)},An.curry=iu,An.curryRight=ou,An.debounce=fu,An.defaults=wf,An.defaultsDeep=mf,An.defer=Yo,An.delay=Qo,An.difference=wo,An.differenceBy=mo,An.differenceWith=Ao,An.drop=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===T?1:ku(t),hr(n,0>t?0:t,e)):[]},An.dropRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===T?1:ku(t),t=e-t,hr(n,0,0>t?0:t)):[]},An.dropRightWhile=function(n,t){return n&&n.length?jr(n,ye(t,3),true,true):[];
},An.dropWhile=function(n,t){return n&&n.length?jr(n,ye(t,3),true):[]},An.fill=function(n,t,r,e){var u=null==n?0:n.length;if(!u)return[];for(r&&typeof r!="number"&&Oe(n,t,r)&&(r=0,e=u),u=n.length,r=ku(r),0>r&&(r=-r>u?0:u+r),e=e===T||e>u?u:ku(e),0>e&&(e+=u),e=r>e?0:Eu(e);r<e;)n[r++]=t;return n},An.filter=function(n,t){return(ff(n)?i:jt)(n,ye(t,3))},An.flatMap=function(n,t){return wt(ru(n,t),1)},An.flatMapDeep=function(n,t){return wt(ru(n,t),$)},An.flatMapDepth=function(n,t,r){return r=r===T?1:ku(r),
wt(ru(n,t),r)},An.flatten=Ze,An.flattenDeep=function(n){return(null==n?0:n.length)?wt(n,$):[]},An.flattenDepth=function(n,t){return null!=n&&n.length?(t=t===T?1:ku(t),wt(n,t)):[]},An.flip=function(n){return fe(n,512)},An.flow=Pf,An.flowRight=Zf,An.fromPairs=function(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){var u=n[t];e[u[0]]=u[1]}return e},An.functions=function(n){return null==n?[]:kt(n,Wu(n))},An.functionsIn=function(n){return null==n?[]:kt(n,Uu(n))},An.groupBy=Po,An.initial=function(n){
return(null==n?0:n.length)?hr(n,0,-1):[]},An.intersection=ko,An.intersectionBy=Eo,An.intersectionWith=So,An.invert=Af,An.invertBy=kf,An.invokeMap=Zo,An.iteratee=Fu,An.keyBy=qo,An.keys=Wu,An.keysIn=Uu,An.map=ru,An.mapKeys=function(n,t){var r={};return t=ye(t,3),mt(n,function(n,e,u){st(r,t(n,e,u),n)}),r},An.mapValues=function(n,t){var r={};return t=ye(t,3),mt(n,function(n,e,u){st(r,e,t(n,e,u))}),r},An.matches=function(n){return Ht(_t(n,1))},An.matchesProperty=function(n,t){return Jt(n,_t(t,1))},An.memoize=cu,
An.merge=Sf,An.mergeWith=Of,An.method=qf,An.methodOf=Vf,An.mixin=Nu,An.negate=au,An.nthArg=function(n){return n=ku(n),fr(function(t){return Qt(t,n)})},An.omit=If,An.omitBy=function(n,t){return Bu(n,au(ye(t)))},An.once=function(n){return uu(2,n)},An.orderBy=function(n,t,r,e){return null==n?[]:(ff(t)||(t=null==t?[]:[t]),r=e?T:r,ff(r)||(r=null==r?[]:[r]),Xt(n,t,r))},An.over=Kf,An.overArgs=Xo,An.overEvery=Gf,An.overSome=Hf,An.partial=nf,An.partialRight=tf,An.partition=Vo,An.pick=Rf,An.pickBy=Bu,An.property=Zu,
An.propertyOf=function(n){return function(t){return null==n?T:Et(n,t)}},An.pull=Oo,An.pullAll=Ke,An.pullAllBy=function(n,t,r){return n&&n.length&&t&&t.length?er(n,t,ye(r,2)):n},An.pullAllWith=function(n,t,r){return n&&n.length&&t&&t.length?er(n,t,T,r):n},An.pullAt=Io,An.range=Jf,An.rangeRight=Yf,An.rearg=rf,An.reject=function(n,t){return(ff(n)?i:jt)(n,au(ye(t,3)))},An.remove=function(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=ye(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),
u.push(e))}return ur(n,u),r},An.rest=function(n,t){if(typeof n!="function")throw new ti("Expected a function");return t=t===T?t:ku(t),fr(n,t)},An.reverse=Ge,An.sampleSize=function(n,t,r){return t=(r?Oe(n,t,r):t===T)?1:ku(t),(ff(n)?et:ar)(n,t)},An.set=function(n,t,r){return null==n?n:lr(n,t,r)},An.setWith=function(n,t,r,e){return e=typeof e=="function"?e:T,null==n?n:lr(n,t,r,e)},An.shuffle=function(n){return(ff(n)?ut:sr)(n)},An.slice=function(n,t,r){var e=null==n?0:n.length;return e?(r&&typeof r!="number"&&Oe(n,t,r)?(t=0,
r=e):(t=null==t?0:ku(t),r=r===T?e:ku(r)),hr(n,t,r)):[]},An.sortBy=Ko,An.sortedUniq=function(n){return n&&n.length?gr(n):[]},An.sortedUniqBy=function(n,t){return n&&n.length?gr(n,ye(t,2)):[]},An.split=function(n,t,r){return r&&typeof r!="number"&&Oe(n,t,r)&&(t=r=T),r=r===T?4294967295:r>>>0,r?(n=Iu(n))&&(typeof t=="string"||null!=t&&!hf(t))&&(t=yr(t),!t&&Rn.test(n))?Or(M(n),0,r):n.split(t,r):[]},An.spread=function(t,r){if(typeof t!="function")throw new ti("Expected a function");return r=null==r?0:Li(ku(r),0),
fr(function(e){var u=e[r];return e=Or(e,0,r),u&&a(e,u),n(t,this,e)})},An.tail=function(n){var t=null==n?0:n.length;return t?hr(n,1,t):[]},An.take=function(n,t,r){return n&&n.length?(t=r||t===T?1:ku(t),hr(n,0,0>t?0:t)):[]},An.takeRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===T?1:ku(t),t=e-t,hr(n,0>t?0:t,e)):[]},An.takeRightWhile=function(n,t){return n&&n.length?jr(n,ye(t,3),false,true):[]},An.takeWhile=function(n,t){return n&&n.length?jr(n,ye(t,3)):[]},An.tap=function(n,t){return t(n),
n},An.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new ti("Expected a function");return du(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),fu(n,t,{leading:e,maxWait:t,trailing:u})},An.thru=Qe,An.toArray=mu,An.toPairs=zf,An.toPairsIn=Wf,An.toPath=function(n){return ff(n)?c(n,Me):wu(n)?[n]:Lr(jo(Iu(n)))},An.toPlainObject=Ou,An.transform=function(n,t,e){var u=ff(n),i=u||af(n)||_f(n);if(t=ye(t,4),null==e){var o=n&&n.constructor;e=i?u?new o:[]:du(n)&&_u(o)?eo(di(n)):{};
}return(i?r:mt)(n,function(n,r,u){return t(e,n,r,u)}),e},An.unary=function(n){return eu(n,1)},An.union=Ro,An.unionBy=zo,An.unionWith=Wo,An.uniq=function(n){return n&&n.length?br(n):[]},An.uniqBy=function(n,t){return n&&n.length?br(n,ye(t,2)):[]},An.uniqWith=function(n,t){return t=typeof t=="function"?t:T,n&&n.length?br(n,T,t):[]},An.unset=function(n,t){return null==n||xr(n,t)},An.unzip=He,An.unzipWith=Je,An.update=function(n,t,r){return null!=n&&(r=Er(r),n=lr(n,t,r(Et(n,t)),void 0)),n},An.updateWith=function(n,t,r,e){
return e=typeof e=="function"?e:T,null!=n&&(r=Er(r),n=lr(n,t,r(Et(n,t)),e)),n},An.values=Lu,An.valuesIn=function(n){return null==n?[]:S(n,Uu(n))},An.without=Uo,An.words=Mu,An.wrap=function(n,t){return nf(Er(t),n)},An.xor=Bo,An.xorBy=Lo,An.xorWith=Co,An.zip=Do,An.zipObject=function(n,t){return Ar(n||[],t||[],ot)},An.zipObjectDeep=function(n,t){return Ar(n||[],t||[],lr)},An.zipWith=Mo,An.entries=zf,An.entriesIn=Wf,An.extend=yf,An.extendWith=bf,Nu(An,An),An.add=Qf,An.attempt=Ff,An.camelCase=Uf,An.capitalize=Cu,
An.ceil=Xf,An.clamp=function(n,t,r){return r===T&&(r=t,t=T),r!==T&&(r=Su(r),r=r===r?r:0),t!==T&&(t=Su(t),t=t===t?t:0),pt(Su(n),t,r)},An.clone=function(n){return _t(n,4)},An.cloneDeep=function(n){return _t(n,5)},An.cloneDeepWith=function(n,t){return t=typeof t=="function"?t:T,_t(n,5,t)},An.cloneWith=function(n,t){return t=typeof t=="function"?t:T,_t(n,4,t)},An.conformsTo=function(n,t){return null==t||gt(n,t,Wu(t))},An.deburr=Du,An.defaultTo=function(n,t){return null==n||n!==n?t:n},An.divide=nc,An.endsWith=function(n,t,r){
n=Iu(n),t=yr(t);var e=n.length,e=r=r===T?e:pt(ku(r),0,e);return r-=t.length,0<=r&&n.slice(r,e)==t},An.eq=lu,An.escape=function(n){return(n=Iu(n))&&H.test(n)?n.replace(K,nt):n},An.escapeRegExp=function(n){return(n=Iu(n))&&en.test(n)?n.replace(rn,"\\$&"):n},An.every=function(n,t,r){var e=ff(n)?u:bt;return r&&Oe(n,t,r)&&(t=T),e(n,ye(t,3))},An.find=Fo,An.findIndex=Ne,An.findKey=function(n,t){return p(n,ye(t,3),mt)},An.findLast=No,An.findLastIndex=Pe,An.findLastKey=function(n,t){return p(n,ye(t,3),At);
},An.floor=tc,An.forEach=nu,An.forEachRight=tu,An.forIn=function(n,t){return null==n?n:oo(n,ye(t,3),Uu)},An.forInRight=function(n,t){return null==n?n:fo(n,ye(t,3),Uu)},An.forOwn=function(n,t){return n&&mt(n,ye(t,3))},An.forOwnRight=function(n,t){return n&&At(n,ye(t,3))},An.get=Ru,An.gt=ef,An.gte=uf,An.has=function(n,t){return null!=n&&we(n,t,Rt)},An.hasIn=zu,An.head=qe,An.identity=$u,An.includes=function(n,t,r,e){return n=su(n)?n:Lu(n),r=r&&!e?ku(r):0,e=n.length,0>r&&(r=Li(e+r,0)),ju(n)?r<=e&&-1<n.indexOf(t,r):!!e&&-1<v(n,t,r);
},An.indexOf=function(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:ku(r),0>r&&(r=Li(e+r,0)),v(n,t,r)):-1},An.inRange=function(n,t,r){return t=Au(t),r===T?(r=t,t=0):r=Au(r),n=Su(n),n>=Ci(t,r)&&n<Li(t,r)},An.invoke=Ef,An.isArguments=of,An.isArray=ff,An.isArrayBuffer=cf,An.isArrayLike=su,An.isArrayLikeObject=hu,An.isBoolean=function(n){return true===n||false===n||yu(n)&&"[object Boolean]"==Ot(n)},An.isBuffer=af,An.isDate=lf,An.isElement=function(n){return yu(n)&&1===n.nodeType&&!xu(n)},An.isEmpty=function(n){
if(null==n)return true;if(su(n)&&(ff(n)||typeof n=="string"||typeof n.splice=="function"||af(n)||_f(n)||of(n)))return!n.length;var t=vo(n);if("[object Map]"==t||"[object Set]"==t)return!n.size;if(ze(n))return!Vt(n).length;for(var r in n)if(oi.call(n,r))return false;return true},An.isEqual=function(n,t){return Mt(n,t)},An.isEqualWith=function(n,t,r){var e=(r=typeof r=="function"?r:T)?r(n,t):T;return e===T?Mt(n,t,T,r):!!e},An.isError=pu,An.isFinite=function(n){return typeof n=="number"&&Wi(n)},An.isFunction=_u,
An.isInteger=vu,An.isLength=gu,An.isMap=sf,An.isMatch=function(n,t){return n===t||$t(n,t,xe(t))},An.isMatchWith=function(n,t,r){return r=typeof r=="function"?r:T,$t(n,t,xe(t),r)},An.isNaN=function(n){return bu(n)&&n!=+n},An.isNative=function(n){if(go(n))throw new Hu("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");return Ft(n)},An.isNil=function(n){return null==n},An.isNull=function(n){return null===n},An.isNumber=bu,An.isObject=du,An.isObjectLike=yu,An.isPlainObject=xu,An.isRegExp=hf,
An.isSafeInteger=function(n){return vu(n)&&-9007199254740991<=n&&9007199254740991>=n},An.isSet=pf,An.isString=ju,An.isSymbol=wu,An.isTypedArray=_f,An.isUndefined=function(n){return n===T},An.isWeakMap=function(n){return yu(n)&&"[object WeakMap]"==vo(n)},An.isWeakSet=function(n){return yu(n)&&"[object WeakSet]"==Ot(n)},An.join=function(n,t){return null==n?"":Ui.call(n,t)},An.kebabCase=Bf,An.last=Ve,An.lastIndexOf=function(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;if(r!==T&&(u=ku(r),u=0>u?Li(e+u,0):Ci(u,e-1)),
t===t)n:{for(r=u+1;r--;)if(n[r]===t){n=r;break n}n=r}else n=_(n,d,u,true);return n},An.lowerCase=Lf,An.lowerFirst=Cf,An.lt=vf,An.lte=gf,An.max=function(n){return n&&n.length?xt(n,$u,It):T},An.maxBy=function(n,t){return n&&n.length?xt(n,ye(t,2),It):T},An.mean=function(n){return y(n,$u)},An.meanBy=function(n,t){return y(n,ye(t,2))},An.min=function(n){return n&&n.length?xt(n,$u,Kt):T},An.minBy=function(n,t){return n&&n.length?xt(n,ye(t,2),Kt):T},An.stubArray=qu,An.stubFalse=Vu,An.stubObject=function(){
return{}},An.stubString=function(){return""},An.stubTrue=function(){return true},An.multiply=rc,An.nth=function(n,t){return n&&n.length?Qt(n,ku(t)):T},An.noConflict=function(){return $n._===this&&($n._=si),this},An.noop=Pu,An.now=Go,An.pad=function(n,t,r){n=Iu(n);var e=(t=ku(t))?D(n):0;return!t||e>=t?n:(t=(t-e)/2,ne(Ii(t),r)+n+ne(Oi(t),r))},An.padEnd=function(n,t,r){n=Iu(n);var e=(t=ku(t))?D(n):0;return t&&e<t?n+ne(t-e,r):n},An.padStart=function(n,t,r){n=Iu(n);var e=(t=ku(t))?D(n):0;return t&&e<t?ne(t-e,r)+n:n;
},An.parseInt=function(n,t,r){return r||null==t?t=0:t&&(t=+t),Mi(Iu(n).replace(on,""),t||0)},An.random=function(n,t,r){if(r&&typeof r!="boolean"&&Oe(n,t,r)&&(t=r=T),r===T&&(typeof t=="boolean"?(r=t,t=T):typeof n=="boolean"&&(r=n,n=T)),n===T&&t===T?(n=0,t=1):(n=Au(n),t===T?(t=n,n=0):t=Au(t)),n>t){var e=n;n=t,t=e}return r||n%1||t%1?(r=Ti(),Ci(n+r*(t-n+Cn("1e-"+((r+"").length-1))),t)):ir(n,t)},An.reduce=function(n,t,r){var e=ff(n)?l:j,u=3>arguments.length;return e(n,ye(t,4),r,u,uo)},An.reduceRight=function(n,t,r){
var e=ff(n)?s:j,u=3>arguments.length;return e(n,ye(t,4),r,u,io)},An.repeat=function(n,t,r){return t=(r?Oe(n,t,r):t===T)?1:ku(t),or(Iu(n),t)},An.replace=function(){var n=arguments,t=Iu(n[0]);return 3>n.length?t:t.replace(n[1],n[2])},An.result=function(n,t,r){t=Sr(t,n);var e=-1,u=t.length;for(u||(u=1,n=T);++e<u;){var i=null==n?T:n[Me(t[e])];i===T&&(e=u,i=r),n=_u(i)?i.call(n):i}return n},An.round=ec,An.runInContext=x,An.sample=function(n){return(ff(n)?Qn:cr)(n)},An.size=function(n){if(null==n)return 0;
if(su(n))return ju(n)?D(n):n.length;var t=vo(n);return"[object Map]"==t||"[object Set]"==t?n.size:Vt(n).length},An.snakeCase=Df,An.some=function(n,t,r){var e=ff(n)?h:pr;return r&&Oe(n,t,r)&&(t=T),e(n,ye(t,3))},An.sortedIndex=function(n,t){return _r(n,t)},An.sortedIndexBy=function(n,t,r){return vr(n,t,ye(r,2))},An.sortedIndexOf=function(n,t){var r=null==n?0:n.length;if(r){var e=_r(n,t);if(e<r&&lu(n[e],t))return e}return-1},An.sortedLastIndex=function(n,t){return _r(n,t,true)},An.sortedLastIndexBy=function(n,t,r){
return vr(n,t,ye(r,2),true)},An.sortedLastIndexOf=function(n,t){if(null==n?0:n.length){var r=_r(n,t,true)-1;if(lu(n[r],t))return r}return-1},An.startCase=Mf,An.startsWith=function(n,t,r){return n=Iu(n),r=null==r?0:pt(ku(r),0,n.length),t=yr(t),n.slice(r,r+t.length)==t},An.subtract=uc,An.sum=function(n){return n&&n.length?m(n,$u):0},An.sumBy=function(n,t){return n&&n.length?m(n,ye(t,2)):0},An.template=function(n,t,r){var e=An.templateSettings;r&&Oe(n,t,r)&&(t=T),n=Iu(n),t=bf({},t,e,ce),r=bf({},t.imports,e.imports,ce);
var u,i,o=Wu(r),f=S(r,o),c=0;r=t.interpolate||jn;var a="__p+='";r=Xu((t.escape||jn).source+"|"+r.source+"|"+(r===Q?pn:jn).source+"|"+(t.evaluate||jn).source+"|$","g");var l="sourceURL"in t?"//# sourceURL="+t.sourceURL+"\n":"";if(n.replace(r,function(t,r,e,o,f,l){return e||(e=o),a+=n.slice(c,l).replace(wn,z),r&&(u=true,a+="'+__e("+r+")+'"),f&&(i=true,a+="';"+f+";\n__p+='"),e&&(a+="'+((__t=("+e+"))==null?'':__t)+'"),c=l+t.length,t}),a+="';",(t=t.variable)||(a="with(obj){"+a+"}"),a=(i?a.replace(P,""):a).replace(Z,"$1").replace(q,"$1;"),
a="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(u?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+a+"return __p}",t=Ff(function(){return Ju(o,l+"return "+a).apply(T,f)}),t.source=a,pu(t))throw t;return t},An.times=function(n,t){if(n=ku(n),1>n||9007199254740991<n)return[];var r=4294967295,e=Ci(n,4294967295);for(t=ye(t),n-=4294967295,e=A(e,t);++r<n;)t(r);return e},An.toFinite=Au,An.toInteger=ku,An.toLength=Eu,An.toLower=function(n){
return Iu(n).toLowerCase()},An.toNumber=Su,An.toSafeInteger=function(n){return n?pt(ku(n),-9007199254740991,9007199254740991):0===n?n:0},An.toString=Iu,An.toUpper=function(n){return Iu(n).toUpperCase()},An.trim=function(n,t,r){return(n=Iu(n))&&(r||t===T)?n.replace(un,""):n&&(t=yr(t))?(n=M(n),r=M(t),t=I(n,r),r=R(n,r)+1,Or(n,t,r).join("")):n},An.trimEnd=function(n,t,r){return(n=Iu(n))&&(r||t===T)?n.replace(fn,""):n&&(t=yr(t))?(n=M(n),t=R(n,M(t))+1,Or(n,0,t).join("")):n},An.trimStart=function(n,t,r){
return(n=Iu(n))&&(r||t===T)?n.replace(on,""):n&&(t=yr(t))?(n=M(n),t=I(n,M(t)),Or(n,t).join("")):n},An.truncate=function(n,t){var r=30,e="...";if(du(t))var u="separator"in t?t.separator:u,r="length"in t?ku(t.length):r,e="omission"in t?yr(t.omission):e;n=Iu(n);var i=n.length;if(Rn.test(n))var o=M(n),i=o.length;if(r>=i)return n;if(i=r-D(e),1>i)return e;if(r=o?Or(o,0,i).join(""):n.slice(0,i),u===T)return r+e;if(o&&(i+=r.length-i),hf(u)){if(n.slice(i).search(u)){var f=r;for(u.global||(u=Xu(u.source,Iu(_n.exec(u))+"g")),
u.lastIndex=0;o=u.exec(f);)var c=o.index;r=r.slice(0,c===T?i:c)}}else n.indexOf(yr(u),i)!=i&&(u=r.lastIndexOf(u),-1<u&&(r=r.slice(0,u)));return r+e},An.unescape=function(n){return(n=Iu(n))&&G.test(n)?n.replace(V,tt):n},An.uniqueId=function(n){var t=++fi;return Iu(n)+t},An.upperCase=Tf,An.upperFirst=$f,An.each=nu,An.eachRight=tu,An.first=qe,Nu(An,function(){var n={};return mt(An,function(t,r){oi.call(An.prototype,r)||(n[r]=t)}),n}(),{chain:false}),An.VERSION="4.17.11",r("bind bindKey curry curryRight partial partialRight".split(" "),function(n){
An[n].placeholder=An}),r(["drop","take"],function(n,t){Ln.prototype[n]=function(r){r=r===T?1:Li(ku(r),0);var e=this.__filtered__&&!t?new Ln(this):this.clone();return e.__filtered__?e.__takeCount__=Ci(r,e.__takeCount__):e.__views__.push({size:Ci(r,4294967295),type:n+(0>e.__dir__?"Right":"")}),e},Ln.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()}}),r(["filter","map","takeWhile"],function(n,t){var r=t+1,e=1==r||3==r;Ln.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({
iteratee:ye(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),r(["head","last"],function(n,t){var r="take"+(t?"Right":"");Ln.prototype[n]=function(){return this[r](1).value()[0]}}),r(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Ln.prototype[n]=function(){return this.__filtered__?new Ln(this):this[r](1)}}),Ln.prototype.compact=function(){return this.filter($u)},Ln.prototype.find=function(n){return this.filter(n).head()},Ln.prototype.findLast=function(n){return this.reverse().find(n);
},Ln.prototype.invokeMap=fr(function(n,t){return typeof n=="function"?new Ln(this):this.map(function(r){return Bt(r,n,t)})}),Ln.prototype.reject=function(n){return this.filter(au(ye(n)))},Ln.prototype.slice=function(n,t){n=ku(n);var r=this;return r.__filtered__&&(0<n||0>t)?new Ln(r):(0>n?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==T&&(t=ku(t),r=0>t?r.dropRight(-t):r.take(t-n)),r)},Ln.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Ln.prototype.toArray=function(){return this.take(4294967295);
},mt(Ln.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=An[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);u&&(An.prototype[t]=function(){var t=this.__wrapped__,o=e?[1]:arguments,f=t instanceof Ln,c=o[0],l=f||ff(t),s=function(n){return n=u.apply(An,a([n],o)),e&&h?n[0]:n};l&&r&&typeof c=="function"&&1!=c.length&&(f=l=false);var h=this.__chain__,p=!!this.__actions__.length,c=i&&!h,f=f&&!p;return!i&&l?(t=f?t:new Ln(this),t=n.apply(t,o),t.__actions__.push({
func:Qe,args:[s],thisArg:T}),new On(t,h)):c&&f?n.apply(this,o):(t=this.thru(s),c?e?t.value()[0]:t.value():t)})}),r("pop push shift sort splice unshift".split(" "),function(n){var t=ri[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);An.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){var u=this.value();return t.apply(ff(u)?u:[],n)}return this[r](function(r){return t.apply(ff(r)?r:[],n)})}}),mt(Ln.prototype,function(n,t){var r=An[t];if(r){var e=r.name+"";
(Gi[e]||(Gi[e]=[])).push({name:t,func:r})}}),Gi[Jr(T,2).name]=[{name:"wrapper",func:T}],Ln.prototype.clone=function(){var n=new Ln(this.__wrapped__);return n.__actions__=Lr(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Lr(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Lr(this.__views__),n},Ln.prototype.reverse=function(){if(this.__filtered__){var n=new Ln(this);n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n;
},Ln.prototype.value=function(){var n,t=this.__wrapped__.value(),r=this.__dir__,e=ff(t),u=0>r,i=e?t.length:0;n=0;for(var o=i,f=this.__views__,c=-1,a=f.length;++c<a;){var l=f[c],s=l.size;switch(l.type){case"drop":n+=s;break;case"dropRight":o-=s;break;case"take":o=Ci(o,n+s);break;case"takeRight":n=Li(n,o-s)}}if(n={start:n,end:o},o=n.start,f=n.end,n=f-o,o=u?f:o-1,f=this.__iteratees__,c=f.length,a=0,l=Ci(n,this.__takeCount__),!e||!u&&i==n&&l==n)return wr(t,this.__actions__);e=[];n:for(;n--&&a<l;){for(o+=r,
u=-1,i=t[o];++u<c;){var h=f[u],s=h.type,h=(0,h.iteratee)(i);if(2==s)i=h;else if(!h){if(1==s)continue n;break n}}e[a++]=i}return e},An.prototype.at=To,An.prototype.chain=function(){return Ye(this)},An.prototype.commit=function(){return new On(this.value(),this.__chain__)},An.prototype.next=function(){this.__values__===T&&(this.__values__=mu(this.value()));var n=this.__index__>=this.__values__.length;return{done:n,value:n?T:this.__values__[this.__index__++]}},An.prototype.plant=function(n){for(var t,r=this;r instanceof kn;){
var e=Fe(r);e.__index__=0,e.__values__=T,t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},An.prototype.reverse=function(){var n=this.__wrapped__;return n instanceof Ln?(this.__actions__.length&&(n=new Ln(this)),n=n.reverse(),n.__actions__.push({func:Qe,args:[Ge],thisArg:T}),new On(n,this.__chain__)):this.thru(Ge)},An.prototype.toJSON=An.prototype.valueOf=An.prototype.value=function(){return wr(this.__wrapped__,this.__actions__)},An.prototype.first=An.prototype.head,wi&&(An.prototype[wi]=Xe),
An}(); true?($n._=rt, !(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return rt}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))):undefined}).call(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lunr/lunr.js":
/*!***********************************!*\
  !*** ./node_modules/lunr/lunr.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.6
 * Copyright (C) 2019 Oliver Nightingale
 * @license MIT
 */

;(function(){

/**
 * A convenience function for configuring and constructing
 * a new lunr Index.
 *
 * A lunr.Builder instance is created and the pipeline setup
 * with a trimmer, stop word filter and stemmer.
 *
 * This builder object is yielded to the configuration function
 * that is passed as a parameter, allowing the list of fields
 * and other builder parameters to be customised.
 *
 * All documents _must_ be added within the passed config function.
 *
 * @example
 * var idx = lunr(function () {
 *   this.field('title')
 *   this.field('body')
 *   this.ref('id')
 *
 *   documents.forEach(function (doc) {
 *     this.add(doc)
 *   }, this)
 * })
 *
 * @see {@link lunr.Builder}
 * @see {@link lunr.Pipeline}
 * @see {@link lunr.trimmer}
 * @see {@link lunr.stopWordFilter}
 * @see {@link lunr.stemmer}
 * @namespace {function} lunr
 */
var lunr = function (config) {
  var builder = new lunr.Builder

  builder.pipeline.add(
    lunr.trimmer,
    lunr.stopWordFilter,
    lunr.stemmer
  )

  builder.searchPipeline.add(
    lunr.stemmer
  )

  config.call(builder, builder)
  return builder.build()
}

lunr.version = "2.3.6"
/*!
 * lunr.utils
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * A namespace containing utils for the rest of the lunr library
 * @namespace lunr.utils
 */
lunr.utils = {}

/**
 * Print a warning message to the console.
 *
 * @param {String} message The message to be printed.
 * @memberOf lunr.utils
 * @function
 */
lunr.utils.warn = (function (global) {
  /* eslint-disable no-console */
  return function (message) {
    if (global.console && console.warn) {
      console.warn(message)
    }
  }
  /* eslint-enable no-console */
})(this)

/**
 * Convert an object to a string.
 *
 * In the case of `null` and `undefined` the function returns
 * the empty string, in all other cases the result of calling
 * `toString` on the passed object is returned.
 *
 * @param {Any} obj The object to convert to a string.
 * @return {String} string representation of the passed object.
 * @memberOf lunr.utils
 */
lunr.utils.asString = function (obj) {
  if (obj === void 0 || obj === null) {
    return ""
  } else {
    return obj.toString()
  }
}

/**
 * Clones an object.
 *
 * Will create a copy of an existing object such that any mutations
 * on the copy cannot affect the original.
 *
 * Only shallow objects are supported, passing a nested object to this
 * function will cause a TypeError.
 *
 * Objects with primitives, and arrays of primitives are supported.
 *
 * @param {Object} obj The object to clone.
 * @return {Object} a clone of the passed object.
 * @throws {TypeError} when a nested object is passed.
 * @memberOf Utils
 */
lunr.utils.clone = function (obj) {
  if (obj === null || obj === undefined) {
    return obj
  }

  var clone = Object.create(null),
      keys = Object.keys(obj)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i],
        val = obj[key]

    if (Array.isArray(val)) {
      clone[key] = val.slice()
      continue
    }

    if (typeof val === 'string' ||
        typeof val === 'number' ||
        typeof val === 'boolean') {
      clone[key] = val
      continue
    }

    throw new TypeError("clone is not deep and does not support nested objects")
  }

  return clone
}
lunr.FieldRef = function (docRef, fieldName, stringValue) {
  this.docRef = docRef
  this.fieldName = fieldName
  this._stringValue = stringValue
}

lunr.FieldRef.joiner = "/"

lunr.FieldRef.fromString = function (s) {
  var n = s.indexOf(lunr.FieldRef.joiner)

  if (n === -1) {
    throw "malformed field ref string"
  }

  var fieldRef = s.slice(0, n),
      docRef = s.slice(n + 1)

  return new lunr.FieldRef (docRef, fieldRef, s)
}

lunr.FieldRef.prototype.toString = function () {
  if (this._stringValue == undefined) {
    this._stringValue = this.fieldName + lunr.FieldRef.joiner + this.docRef
  }

  return this._stringValue
}
/*!
 * lunr.Set
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * A lunr set.
 *
 * @constructor
 */
lunr.Set = function (elements) {
  this.elements = Object.create(null)

  if (elements) {
    this.length = elements.length

    for (var i = 0; i < this.length; i++) {
      this.elements[elements[i]] = true
    }
  } else {
    this.length = 0
  }
}

/**
 * A complete set that contains all elements.
 *
 * @static
 * @readonly
 * @type {lunr.Set}
 */
lunr.Set.complete = {
  intersect: function (other) {
    return other
  },

  union: function (other) {
    return other
  },

  contains: function () {
    return true
  }
}

/**
 * An empty set that contains no elements.
 *
 * @static
 * @readonly
 * @type {lunr.Set}
 */
lunr.Set.empty = {
  intersect: function () {
    return this
  },

  union: function (other) {
    return other
  },

  contains: function () {
    return false
  }
}

/**
 * Returns true if this set contains the specified object.
 *
 * @param {object} object - Object whose presence in this set is to be tested.
 * @returns {boolean} - True if this set contains the specified object.
 */
lunr.Set.prototype.contains = function (object) {
  return !!this.elements[object]
}

/**
 * Returns a new set containing only the elements that are present in both
 * this set and the specified set.
 *
 * @param {lunr.Set} other - set to intersect with this set.
 * @returns {lunr.Set} a new set that is the intersection of this and the specified set.
 */

lunr.Set.prototype.intersect = function (other) {
  var a, b, elements, intersection = []

  if (other === lunr.Set.complete) {
    return this
  }

  if (other === lunr.Set.empty) {
    return other
  }

  if (this.length < other.length) {
    a = this
    b = other
  } else {
    a = other
    b = this
  }

  elements = Object.keys(a.elements)

  for (var i = 0; i < elements.length; i++) {
    var element = elements[i]
    if (element in b.elements) {
      intersection.push(element)
    }
  }

  return new lunr.Set (intersection)
}

/**
 * Returns a new set combining the elements of this and the specified set.
 *
 * @param {lunr.Set} other - set to union with this set.
 * @return {lunr.Set} a new set that is the union of this and the specified set.
 */

lunr.Set.prototype.union = function (other) {
  if (other === lunr.Set.complete) {
    return lunr.Set.complete
  }

  if (other === lunr.Set.empty) {
    return this
  }

  return new lunr.Set(Object.keys(this.elements).concat(Object.keys(other.elements)))
}
/**
 * A function to calculate the inverse document frequency for
 * a posting. This is shared between the builder and the index
 *
 * @private
 * @param {object} posting - The posting for a given term
 * @param {number} documentCount - The total number of documents.
 */
lunr.idf = function (posting, documentCount) {
  var documentsWithTerm = 0

  for (var fieldName in posting) {
    if (fieldName == '_index') continue // Ignore the term index, its not a field
    documentsWithTerm += Object.keys(posting[fieldName]).length
  }

  var x = (documentCount - documentsWithTerm + 0.5) / (documentsWithTerm + 0.5)

  return Math.log(1 + Math.abs(x))
}

/**
 * A token wraps a string representation of a token
 * as it is passed through the text processing pipeline.
 *
 * @constructor
 * @param {string} [str=''] - The string token being wrapped.
 * @param {object} [metadata={}] - Metadata associated with this token.
 */
lunr.Token = function (str, metadata) {
  this.str = str || ""
  this.metadata = metadata || {}
}

/**
 * Returns the token string that is being wrapped by this object.
 *
 * @returns {string}
 */
lunr.Token.prototype.toString = function () {
  return this.str
}

/**
 * A token update function is used when updating or optionally
 * when cloning a token.
 *
 * @callback lunr.Token~updateFunction
 * @param {string} str - The string representation of the token.
 * @param {Object} metadata - All metadata associated with this token.
 */

/**
 * Applies the given function to the wrapped string token.
 *
 * @example
 * token.update(function (str, metadata) {
 *   return str.toUpperCase()
 * })
 *
 * @param {lunr.Token~updateFunction} fn - A function to apply to the token string.
 * @returns {lunr.Token}
 */
lunr.Token.prototype.update = function (fn) {
  this.str = fn(this.str, this.metadata)
  return this
}

/**
 * Creates a clone of this token. Optionally a function can be
 * applied to the cloned token.
 *
 * @param {lunr.Token~updateFunction} [fn] - An optional function to apply to the cloned token.
 * @returns {lunr.Token}
 */
lunr.Token.prototype.clone = function (fn) {
  fn = fn || function (s) { return s }
  return new lunr.Token (fn(this.str, this.metadata), this.metadata)
}
/*!
 * lunr.tokenizer
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * A function for splitting a string into tokens ready to be inserted into
 * the search index. Uses `lunr.tokenizer.separator` to split strings, change
 * the value of this property to change how strings are split into tokens.
 *
 * This tokenizer will convert its parameter to a string by calling `toString` and
 * then will split this string on the character in `lunr.tokenizer.separator`.
 * Arrays will have their elements converted to strings and wrapped in a lunr.Token.
 *
 * Optional metadata can be passed to the tokenizer, this metadata will be cloned and
 * added as metadata to every token that is created from the object to be tokenized.
 *
 * @static
 * @param {?(string|object|object[])} obj - The object to convert into tokens
 * @param {?object} metadata - Optional metadata to associate with every token
 * @returns {lunr.Token[]}
 * @see {@link lunr.Pipeline}
 */
lunr.tokenizer = function (obj, metadata) {
  if (obj == null || obj == undefined) {
    return []
  }

  if (Array.isArray(obj)) {
    return obj.map(function (t) {
      return new lunr.Token(
        lunr.utils.asString(t).toLowerCase(),
        lunr.utils.clone(metadata)
      )
    })
  }

  var str = obj.toString().trim().toLowerCase(),
      len = str.length,
      tokens = []

  for (var sliceEnd = 0, sliceStart = 0; sliceEnd <= len; sliceEnd++) {
    var char = str.charAt(sliceEnd),
        sliceLength = sliceEnd - sliceStart

    if ((char.match(lunr.tokenizer.separator) || sliceEnd == len)) {

      if (sliceLength > 0) {
        var tokenMetadata = lunr.utils.clone(metadata) || {}
        tokenMetadata["position"] = [sliceStart, sliceLength]
        tokenMetadata["index"] = tokens.length

        tokens.push(
          new lunr.Token (
            str.slice(sliceStart, sliceEnd),
            tokenMetadata
          )
        )
      }

      sliceStart = sliceEnd + 1
    }

  }

  return tokens
}

/**
 * The separator used to split a string into tokens. Override this property to change the behaviour of
 * `lunr.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens.
 *
 * @static
 * @see lunr.tokenizer
 */
lunr.tokenizer.separator = /[\s\-]+/
/*!
 * lunr.Pipeline
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * lunr.Pipelines maintain an ordered list of functions to be applied to all
 * tokens in documents entering the search index and queries being ran against
 * the index.
 *
 * An instance of lunr.Index created with the lunr shortcut will contain a
 * pipeline with a stop word filter and an English language stemmer. Extra
 * functions can be added before or after either of these functions or these
 * default functions can be removed.
 *
 * When run the pipeline will call each function in turn, passing a token, the
 * index of that token in the original list of all tokens and finally a list of
 * all the original tokens.
 *
 * The output of functions in the pipeline will be passed to the next function
 * in the pipeline. To exclude a token from entering the index the function
 * should return undefined, the rest of the pipeline will not be called with
 * this token.
 *
 * For serialisation of pipelines to work, all functions used in an instance of
 * a pipeline should be registered with lunr.Pipeline. Registered functions can
 * then be loaded. If trying to load a serialised pipeline that uses functions
 * that are not registered an error will be thrown.
 *
 * If not planning on serialising the pipeline then registering pipeline functions
 * is not necessary.
 *
 * @constructor
 */
lunr.Pipeline = function () {
  this._stack = []
}

lunr.Pipeline.registeredFunctions = Object.create(null)

/**
 * A pipeline function maps lunr.Token to lunr.Token. A lunr.Token contains the token
 * string as well as all known metadata. A pipeline function can mutate the token string
 * or mutate (or add) metadata for a given token.
 *
 * A pipeline function can indicate that the passed token should be discarded by returning
 * null. This token will not be passed to any downstream pipeline functions and will not be
 * added to the index.
 *
 * Multiple tokens can be returned by returning an array of tokens. Each token will be passed
 * to any downstream pipeline functions and all will returned tokens will be added to the index.
 *
 * Any number of pipeline functions may be chained together using a lunr.Pipeline.
 *
 * @interface lunr.PipelineFunction
 * @param {lunr.Token} token - A token from the document being processed.
 * @param {number} i - The index of this token in the complete list of tokens for this document/field.
 * @param {lunr.Token[]} tokens - All tokens for this document/field.
 * @returns {(?lunr.Token|lunr.Token[])}
 */

/**
 * Register a function with the pipeline.
 *
 * Functions that are used in the pipeline should be registered if the pipeline
 * needs to be serialised, or a serialised pipeline needs to be loaded.
 *
 * Registering a function does not add it to a pipeline, functions must still be
 * added to instances of the pipeline for them to be used when running a pipeline.
 *
 * @param {lunr.PipelineFunction} fn - The function to check for.
 * @param {String} label - The label to register this function with
 */
lunr.Pipeline.registerFunction = function (fn, label) {
  if (label in this.registeredFunctions) {
    lunr.utils.warn('Overwriting existing registered function: ' + label)
  }

  fn.label = label
  lunr.Pipeline.registeredFunctions[fn.label] = fn
}

/**
 * Warns if the function is not registered as a Pipeline function.
 *
 * @param {lunr.PipelineFunction} fn - The function to check for.
 * @private
 */
lunr.Pipeline.warnIfFunctionNotRegistered = function (fn) {
  var isRegistered = fn.label && (fn.label in this.registeredFunctions)

  if (!isRegistered) {
    lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\n', fn)
  }
}

/**
 * Loads a previously serialised pipeline.
 *
 * All functions to be loaded must already be registered with lunr.Pipeline.
 * If any function from the serialised data has not been registered then an
 * error will be thrown.
 *
 * @param {Object} serialised - The serialised pipeline to load.
 * @returns {lunr.Pipeline}
 */
lunr.Pipeline.load = function (serialised) {
  var pipeline = new lunr.Pipeline

  serialised.forEach(function (fnName) {
    var fn = lunr.Pipeline.registeredFunctions[fnName]

    if (fn) {
      pipeline.add(fn)
    } else {
      throw new Error('Cannot load unregistered function: ' + fnName)
    }
  })

  return pipeline
}

/**
 * Adds new functions to the end of the pipeline.
 *
 * Logs a warning if the function has not been registered.
 *
 * @param {lunr.PipelineFunction[]} functions - Any number of functions to add to the pipeline.
 */
lunr.Pipeline.prototype.add = function () {
  var fns = Array.prototype.slice.call(arguments)

  fns.forEach(function (fn) {
    lunr.Pipeline.warnIfFunctionNotRegistered(fn)
    this._stack.push(fn)
  }, this)
}

/**
 * Adds a single function after a function that already exists in the
 * pipeline.
 *
 * Logs a warning if the function has not been registered.
 *
 * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline.
 * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline.
 */
lunr.Pipeline.prototype.after = function (existingFn, newFn) {
  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)

  var pos = this._stack.indexOf(existingFn)
  if (pos == -1) {
    throw new Error('Cannot find existingFn')
  }

  pos = pos + 1
  this._stack.splice(pos, 0, newFn)
}

/**
 * Adds a single function before a function that already exists in the
 * pipeline.
 *
 * Logs a warning if the function has not been registered.
 *
 * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline.
 * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline.
 */
lunr.Pipeline.prototype.before = function (existingFn, newFn) {
  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)

  var pos = this._stack.indexOf(existingFn)
  if (pos == -1) {
    throw new Error('Cannot find existingFn')
  }

  this._stack.splice(pos, 0, newFn)
}

/**
 * Removes a function from the pipeline.
 *
 * @param {lunr.PipelineFunction} fn The function to remove from the pipeline.
 */
lunr.Pipeline.prototype.remove = function (fn) {
  var pos = this._stack.indexOf(fn)
  if (pos == -1) {
    return
  }

  this._stack.splice(pos, 1)
}

/**
 * Runs the current list of functions that make up the pipeline against the
 * passed tokens.
 *
 * @param {Array} tokens The tokens to run through the pipeline.
 * @returns {Array}
 */
lunr.Pipeline.prototype.run = function (tokens) {
  var stackLength = this._stack.length

  for (var i = 0; i < stackLength; i++) {
    var fn = this._stack[i]
    var memo = []

    for (var j = 0; j < tokens.length; j++) {
      var result = fn(tokens[j], j, tokens)

      if (result === void 0 || result === '') continue

      if (Array.isArray(result)) {
        for (var k = 0; k < result.length; k++) {
          memo.push(result[k])
        }
      } else {
        memo.push(result)
      }
    }

    tokens = memo
  }

  return tokens
}

/**
 * Convenience method for passing a string through a pipeline and getting
 * strings out. This method takes care of wrapping the passed string in a
 * token and mapping the resulting tokens back to strings.
 *
 * @param {string} str - The string to pass through the pipeline.
 * @param {?object} metadata - Optional metadata to associate with the token
 * passed to the pipeline.
 * @returns {string[]}
 */
lunr.Pipeline.prototype.runString = function (str, metadata) {
  var token = new lunr.Token (str, metadata)

  return this.run([token]).map(function (t) {
    return t.toString()
  })
}

/**
 * Resets the pipeline by removing any existing processors.
 *
 */
lunr.Pipeline.prototype.reset = function () {
  this._stack = []
}

/**
 * Returns a representation of the pipeline ready for serialisation.
 *
 * Logs a warning if the function has not been registered.
 *
 * @returns {Array}
 */
lunr.Pipeline.prototype.toJSON = function () {
  return this._stack.map(function (fn) {
    lunr.Pipeline.warnIfFunctionNotRegistered(fn)

    return fn.label
  })
}
/*!
 * lunr.Vector
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * A vector is used to construct the vector space of documents and queries. These
 * vectors support operations to determine the similarity between two documents or
 * a document and a query.
 *
 * Normally no parameters are required for initializing a vector, but in the case of
 * loading a previously dumped vector the raw elements can be provided to the constructor.
 *
 * For performance reasons vectors are implemented with a flat array, where an elements
 * index is immediately followed by its value. E.g. [index, value, index, value]. This
 * allows the underlying array to be as sparse as possible and still offer decent
 * performance when being used for vector calculations.
 *
 * @constructor
 * @param {Number[]} [elements] - The flat list of element index and element value pairs.
 */
lunr.Vector = function (elements) {
  this._magnitude = 0
  this.elements = elements || []
}


/**
 * Calculates the position within the vector to insert a given index.
 *
 * This is used internally by insert and upsert. If there are duplicate indexes then
 * the position is returned as if the value for that index were to be updated, but it
 * is the callers responsibility to check whether there is a duplicate at that index
 *
 * @param {Number} insertIdx - The index at which the element should be inserted.
 * @returns {Number}
 */
lunr.Vector.prototype.positionForIndex = function (index) {
  // For an empty vector the tuple can be inserted at the beginning
  if (this.elements.length == 0) {
    return 0
  }

  var start = 0,
      end = this.elements.length / 2,
      sliceLength = end - start,
      pivotPoint = Math.floor(sliceLength / 2),
      pivotIndex = this.elements[pivotPoint * 2]

  while (sliceLength > 1) {
    if (pivotIndex < index) {
      start = pivotPoint
    }

    if (pivotIndex > index) {
      end = pivotPoint
    }

    if (pivotIndex == index) {
      break
    }

    sliceLength = end - start
    pivotPoint = start + Math.floor(sliceLength / 2)
    pivotIndex = this.elements[pivotPoint * 2]
  }

  if (pivotIndex == index) {
    return pivotPoint * 2
  }

  if (pivotIndex > index) {
    return pivotPoint * 2
  }

  if (pivotIndex < index) {
    return (pivotPoint + 1) * 2
  }
}

/**
 * Inserts an element at an index within the vector.
 *
 * Does not allow duplicates, will throw an error if there is already an entry
 * for this index.
 *
 * @param {Number} insertIdx - The index at which the element should be inserted.
 * @param {Number} val - The value to be inserted into the vector.
 */
lunr.Vector.prototype.insert = function (insertIdx, val) {
  this.upsert(insertIdx, val, function () {
    throw "duplicate index"
  })
}

/**
 * Inserts or updates an existing index within the vector.
 *
 * @param {Number} insertIdx - The index at which the element should be inserted.
 * @param {Number} val - The value to be inserted into the vector.
 * @param {function} fn - A function that is called for updates, the existing value and the
 * requested value are passed as arguments
 */
lunr.Vector.prototype.upsert = function (insertIdx, val, fn) {
  this._magnitude = 0
  var position = this.positionForIndex(insertIdx)

  if (this.elements[position] == insertIdx) {
    this.elements[position + 1] = fn(this.elements[position + 1], val)
  } else {
    this.elements.splice(position, 0, insertIdx, val)
  }
}

/**
 * Calculates the magnitude of this vector.
 *
 * @returns {Number}
 */
lunr.Vector.prototype.magnitude = function () {
  if (this._magnitude) return this._magnitude

  var sumOfSquares = 0,
      elementsLength = this.elements.length

  for (var i = 1; i < elementsLength; i += 2) {
    var val = this.elements[i]
    sumOfSquares += val * val
  }

  return this._magnitude = Math.sqrt(sumOfSquares)
}

/**
 * Calculates the dot product of this vector and another vector.
 *
 * @param {lunr.Vector} otherVector - The vector to compute the dot product with.
 * @returns {Number}
 */
lunr.Vector.prototype.dot = function (otherVector) {
  var dotProduct = 0,
      a = this.elements, b = otherVector.elements,
      aLen = a.length, bLen = b.length,
      aVal = 0, bVal = 0,
      i = 0, j = 0

  while (i < aLen && j < bLen) {
    aVal = a[i], bVal = b[j]
    if (aVal < bVal) {
      i += 2
    } else if (aVal > bVal) {
      j += 2
    } else if (aVal == bVal) {
      dotProduct += a[i + 1] * b[j + 1]
      i += 2
      j += 2
    }
  }

  return dotProduct
}

/**
 * Calculates the similarity between this vector and another vector.
 *
 * @param {lunr.Vector} otherVector - The other vector to calculate the
 * similarity with.
 * @returns {Number}
 */
lunr.Vector.prototype.similarity = function (otherVector) {
  return this.dot(otherVector) / this.magnitude() || 0
}

/**
 * Converts the vector to an array of the elements within the vector.
 *
 * @returns {Number[]}
 */
lunr.Vector.prototype.toArray = function () {
  var output = new Array (this.elements.length / 2)

  for (var i = 1, j = 0; i < this.elements.length; i += 2, j++) {
    output[j] = this.elements[i]
  }

  return output
}

/**
 * A JSON serializable representation of the vector.
 *
 * @returns {Number[]}
 */
lunr.Vector.prototype.toJSON = function () {
  return this.elements
}
/* eslint-disable */
/*!
 * lunr.stemmer
 * Copyright (C) 2019 Oliver Nightingale
 * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
 */

/**
 * lunr.stemmer is an english language stemmer, this is a JavaScript
 * implementation of the PorterStemmer taken from http://tartarus.org/~martin
 *
 * @static
 * @implements {lunr.PipelineFunction}
 * @param {lunr.Token} token - The string to stem
 * @returns {lunr.Token}
 * @see {@link lunr.Pipeline}
 * @function
 */
lunr.stemmer = (function(){
  var step2list = {
      "ational" : "ate",
      "tional" : "tion",
      "enci" : "ence",
      "anci" : "ance",
      "izer" : "ize",
      "bli" : "ble",
      "alli" : "al",
      "entli" : "ent",
      "eli" : "e",
      "ousli" : "ous",
      "ization" : "ize",
      "ation" : "ate",
      "ator" : "ate",
      "alism" : "al",
      "iveness" : "ive",
      "fulness" : "ful",
      "ousness" : "ous",
      "aliti" : "al",
      "iviti" : "ive",
      "biliti" : "ble",
      "logi" : "log"
    },

    step3list = {
      "icate" : "ic",
      "ative" : "",
      "alize" : "al",
      "iciti" : "ic",
      "ical" : "ic",
      "ful" : "",
      "ness" : ""
    },

    c = "[^aeiou]",          // consonant
    v = "[aeiouy]",          // vowel
    C = c + "[^aeiouy]*",    // consonant sequence
    V = v + "[aeiou]*",      // vowel sequence

    mgr0 = "^(" + C + ")?" + V + C,               // [C]VC... is m>0
    meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",  // [C]VC[V] is m=1
    mgr1 = "^(" + C + ")?" + V + C + V + C,       // [C]VCVC... is m>1
    s_v = "^(" + C + ")?" + v;                   // vowel in stem

  var re_mgr0 = new RegExp(mgr0);
  var re_mgr1 = new RegExp(mgr1);
  var re_meq1 = new RegExp(meq1);
  var re_s_v = new RegExp(s_v);

  var re_1a = /^(.+?)(ss|i)es$/;
  var re2_1a = /^(.+?)([^s])s$/;
  var re_1b = /^(.+?)eed$/;
  var re2_1b = /^(.+?)(ed|ing)$/;
  var re_1b_2 = /.$/;
  var re2_1b_2 = /(at|bl|iz)$/;
  var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
  var re4_1b_2 = new RegExp("^" + C + v + "[^aeiouwxy]$");

  var re_1c = /^(.+?[^aeiou])y$/;
  var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;

  var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;

  var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
  var re2_4 = /^(.+?)(s|t)(ion)$/;

  var re_5 = /^(.+?)e$/;
  var re_5_1 = /ll$/;
  var re3_5 = new RegExp("^" + C + v + "[^aeiouwxy]$");

  var porterStemmer = function porterStemmer(w) {
    var stem,
      suffix,
      firstch,
      re,
      re2,
      re3,
      re4;

    if (w.length < 3) { return w; }

    firstch = w.substr(0,1);
    if (firstch == "y") {
      w = firstch.toUpperCase() + w.substr(1);
    }

    // Step 1a
    re = re_1a
    re2 = re2_1a;

    if (re.test(w)) { w = w.replace(re,"$1$2"); }
    else if (re2.test(w)) { w = w.replace(re2,"$1$2"); }

    // Step 1b
    re = re_1b;
    re2 = re2_1b;
    if (re.test(w)) {
      var fp = re.exec(w);
      re = re_mgr0;
      if (re.test(fp[1])) {
        re = re_1b_2;
        w = w.replace(re,"");
      }
    } else if (re2.test(w)) {
      var fp = re2.exec(w);
      stem = fp[1];
      re2 = re_s_v;
      if (re2.test(stem)) {
        w = stem;
        re2 = re2_1b_2;
        re3 = re3_1b_2;
        re4 = re4_1b_2;
        if (re2.test(w)) { w = w + "e"; }
        else if (re3.test(w)) { re = re_1b_2; w = w.replace(re,""); }
        else if (re4.test(w)) { w = w + "e"; }
      }
    }

    // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)
    re = re_1c;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      w = stem + "i";
    }

    // Step 2
    re = re_2;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      suffix = fp[2];
      re = re_mgr0;
      if (re.test(stem)) {
        w = stem + step2list[suffix];
      }
    }

    // Step 3
    re = re_3;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      suffix = fp[2];
      re = re_mgr0;
      if (re.test(stem)) {
        w = stem + step3list[suffix];
      }
    }

    // Step 4
    re = re_4;
    re2 = re2_4;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      re = re_mgr1;
      if (re.test(stem)) {
        w = stem;
      }
    } else if (re2.test(w)) {
      var fp = re2.exec(w);
      stem = fp[1] + fp[2];
      re2 = re_mgr1;
      if (re2.test(stem)) {
        w = stem;
      }
    }

    // Step 5
    re = re_5;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      re = re_mgr1;
      re2 = re_meq1;
      re3 = re3_5;
      if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
        w = stem;
      }
    }

    re = re_5_1;
    re2 = re_mgr1;
    if (re.test(w) && re2.test(w)) {
      re = re_1b_2;
      w = w.replace(re,"");
    }

    // and turn initial Y back to y

    if (firstch == "y") {
      w = firstch.toLowerCase() + w.substr(1);
    }

    return w;
  };

  return function (token) {
    return token.update(porterStemmer);
  }
})();

lunr.Pipeline.registerFunction(lunr.stemmer, 'stemmer')
/*!
 * lunr.stopWordFilter
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * lunr.generateStopWordFilter builds a stopWordFilter function from the provided
 * list of stop words.
 *
 * The built in lunr.stopWordFilter is built using this generator and can be used
 * to generate custom stopWordFilters for applications or non English languages.
 *
 * @function
 * @param {Array} token The token to pass through the filter
 * @returns {lunr.PipelineFunction}
 * @see lunr.Pipeline
 * @see lunr.stopWordFilter
 */
lunr.generateStopWordFilter = function (stopWords) {
  var words = stopWords.reduce(function (memo, stopWord) {
    memo[stopWord] = stopWord
    return memo
  }, {})

  return function (token) {
    if (token && words[token.toString()] !== token.toString()) return token
  }
}

/**
 * lunr.stopWordFilter is an English language stop word list filter, any words
 * contained in the list will not be passed through the filter.
 *
 * This is intended to be used in the Pipeline. If the token does not pass the
 * filter then undefined will be returned.
 *
 * @function
 * @implements {lunr.PipelineFunction}
 * @params {lunr.Token} token - A token to check for being a stop word.
 * @returns {lunr.Token}
 * @see {@link lunr.Pipeline}
 */
lunr.stopWordFilter = lunr.generateStopWordFilter([
  'a',
  'able',
  'about',
  'across',
  'after',
  'all',
  'almost',
  'also',
  'am',
  'among',
  'an',
  'and',
  'any',
  'are',
  'as',
  'at',
  'be',
  'because',
  'been',
  'but',
  'by',
  'can',
  'cannot',
  'could',
  'dear',
  'did',
  'do',
  'does',
  'either',
  'else',
  'ever',
  'every',
  'for',
  'from',
  'get',
  'got',
  'had',
  'has',
  'have',
  'he',
  'her',
  'hers',
  'him',
  'his',
  'how',
  'however',
  'i',
  'if',
  'in',
  'into',
  'is',
  'it',
  'its',
  'just',
  'least',
  'let',
  'like',
  'likely',
  'may',
  'me',
  'might',
  'most',
  'must',
  'my',
  'neither',
  'no',
  'nor',
  'not',
  'of',
  'off',
  'often',
  'on',
  'only',
  'or',
  'other',
  'our',
  'own',
  'rather',
  'said',
  'say',
  'says',
  'she',
  'should',
  'since',
  'so',
  'some',
  'than',
  'that',
  'the',
  'their',
  'them',
  'then',
  'there',
  'these',
  'they',
  'this',
  'tis',
  'to',
  'too',
  'twas',
  'us',
  'wants',
  'was',
  'we',
  'were',
  'what',
  'when',
  'where',
  'which',
  'while',
  'who',
  'whom',
  'why',
  'will',
  'with',
  'would',
  'yet',
  'you',
  'your'
])

lunr.Pipeline.registerFunction(lunr.stopWordFilter, 'stopWordFilter')
/*!
 * lunr.trimmer
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * lunr.trimmer is a pipeline function for trimming non word
 * characters from the beginning and end of tokens before they
 * enter the index.
 *
 * This implementation may not work correctly for non latin
 * characters and should either be removed or adapted for use
 * with languages with non-latin characters.
 *
 * @static
 * @implements {lunr.PipelineFunction}
 * @param {lunr.Token} token The token to pass through the filter
 * @returns {lunr.Token}
 * @see lunr.Pipeline
 */
lunr.trimmer = function (token) {
  return token.update(function (s) {
    return s.replace(/^\W+/, '').replace(/\W+$/, '')
  })
}

lunr.Pipeline.registerFunction(lunr.trimmer, 'trimmer')
/*!
 * lunr.TokenSet
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * A token set is used to store the unique list of all tokens
 * within an index. Token sets are also used to represent an
 * incoming query to the index, this query token set and index
 * token set are then intersected to find which tokens to look
 * up in the inverted index.
 *
 * A token set can hold multiple tokens, as in the case of the
 * index token set, or it can hold a single token as in the
 * case of a simple query token set.
 *
 * Additionally token sets are used to perform wildcard matching.
 * Leading, contained and trailing wildcards are supported, and
 * from this edit distance matching can also be provided.
 *
 * Token sets are implemented as a minimal finite state automata,
 * where both common prefixes and suffixes are shared between tokens.
 * This helps to reduce the space used for storing the token set.
 *
 * @constructor
 */
lunr.TokenSet = function () {
  this.final = false
  this.edges = {}
  this.id = lunr.TokenSet._nextId
  lunr.TokenSet._nextId += 1
}

/**
 * Keeps track of the next, auto increment, identifier to assign
 * to a new tokenSet.
 *
 * TokenSets require a unique identifier to be correctly minimised.
 *
 * @private
 */
lunr.TokenSet._nextId = 1

/**
 * Creates a TokenSet instance from the given sorted array of words.
 *
 * @param {String[]} arr - A sorted array of strings to create the set from.
 * @returns {lunr.TokenSet}
 * @throws Will throw an error if the input array is not sorted.
 */
lunr.TokenSet.fromArray = function (arr) {
  var builder = new lunr.TokenSet.Builder

  for (var i = 0, len = arr.length; i < len; i++) {
    builder.insert(arr[i])
  }

  builder.finish()
  return builder.root
}

/**
 * Creates a token set from a query clause.
 *
 * @private
 * @param {Object} clause - A single clause from lunr.Query.
 * @param {string} clause.term - The query clause term.
 * @param {number} [clause.editDistance] - The optional edit distance for the term.
 * @returns {lunr.TokenSet}
 */
lunr.TokenSet.fromClause = function (clause) {
  if ('editDistance' in clause) {
    return lunr.TokenSet.fromFuzzyString(clause.term, clause.editDistance)
  } else {
    return lunr.TokenSet.fromString(clause.term)
  }
}

/**
 * Creates a token set representing a single string with a specified
 * edit distance.
 *
 * Insertions, deletions, substitutions and transpositions are each
 * treated as an edit distance of 1.
 *
 * Increasing the allowed edit distance will have a dramatic impact
 * on the performance of both creating and intersecting these TokenSets.
 * It is advised to keep the edit distance less than 3.
 *
 * @param {string} str - The string to create the token set from.
 * @param {number} editDistance - The allowed edit distance to match.
 * @returns {lunr.Vector}
 */
lunr.TokenSet.fromFuzzyString = function (str, editDistance) {
  var root = new lunr.TokenSet

  var stack = [{
    node: root,
    editsRemaining: editDistance,
    str: str
  }]

  while (stack.length) {
    var frame = stack.pop()

    // no edit
    if (frame.str.length > 0) {
      var char = frame.str.charAt(0),
          noEditNode

      if (char in frame.node.edges) {
        noEditNode = frame.node.edges[char]
      } else {
        noEditNode = new lunr.TokenSet
        frame.node.edges[char] = noEditNode
      }

      if (frame.str.length == 1) {
        noEditNode.final = true
      }

      stack.push({
        node: noEditNode,
        editsRemaining: frame.editsRemaining,
        str: frame.str.slice(1)
      })
    }

    if (frame.editsRemaining == 0) {
      continue
    }

    // insertion
    if ("*" in frame.node.edges) {
      var insertionNode = frame.node.edges["*"]
    } else {
      var insertionNode = new lunr.TokenSet
      frame.node.edges["*"] = insertionNode
    }

    if (frame.str.length == 0) {
      insertionNode.final = true
    }

    stack.push({
      node: insertionNode,
      editsRemaining: frame.editsRemaining - 1,
      str: frame.str
    })

    // deletion
    // can only do a deletion if we have enough edits remaining
    // and if there are characters left to delete in the string
    if (frame.str.length > 1) {
      stack.push({
        node: frame.node,
        editsRemaining: frame.editsRemaining - 1,
        str: frame.str.slice(1)
      })
    }

    // deletion
    // just removing the last character from the str
    if (frame.str.length == 1) {
      frame.node.final = true
    }

    // substitution
    // can only do a substitution if we have enough edits remaining
    // and if there are characters left to substitute
    if (frame.str.length >= 1) {
      if ("*" in frame.node.edges) {
        var substitutionNode = frame.node.edges["*"]
      } else {
        var substitutionNode = new lunr.TokenSet
        frame.node.edges["*"] = substitutionNode
      }

      if (frame.str.length == 1) {
        substitutionNode.final = true
      }

      stack.push({
        node: substitutionNode,
        editsRemaining: frame.editsRemaining - 1,
        str: frame.str.slice(1)
      })
    }

    // transposition
    // can only do a transposition if there are edits remaining
    // and there are enough characters to transpose
    if (frame.str.length > 1) {
      var charA = frame.str.charAt(0),
          charB = frame.str.charAt(1),
          transposeNode

      if (charB in frame.node.edges) {
        transposeNode = frame.node.edges[charB]
      } else {
        transposeNode = new lunr.TokenSet
        frame.node.edges[charB] = transposeNode
      }

      if (frame.str.length == 1) {
        transposeNode.final = true
      }

      stack.push({
        node: transposeNode,
        editsRemaining: frame.editsRemaining - 1,
        str: charA + frame.str.slice(2)
      })
    }
  }

  return root
}

/**
 * Creates a TokenSet from a string.
 *
 * The string may contain one or more wildcard characters (*)
 * that will allow wildcard matching when intersecting with
 * another TokenSet.
 *
 * @param {string} str - The string to create a TokenSet from.
 * @returns {lunr.TokenSet}
 */
lunr.TokenSet.fromString = function (str) {
  var node = new lunr.TokenSet,
      root = node

  /*
   * Iterates through all characters within the passed string
   * appending a node for each character.
   *
   * When a wildcard character is found then a self
   * referencing edge is introduced to continually match
   * any number of any characters.
   */
  for (var i = 0, len = str.length; i < len; i++) {
    var char = str[i],
        final = (i == len - 1)

    if (char == "*") {
      node.edges[char] = node
      node.final = final

    } else {
      var next = new lunr.TokenSet
      next.final = final

      node.edges[char] = next
      node = next
    }
  }

  return root
}

/**
 * Converts this TokenSet into an array of strings
 * contained within the TokenSet.
 *
 * @returns {string[]}
 */
lunr.TokenSet.prototype.toArray = function () {
  var words = []

  var stack = [{
    prefix: "",
    node: this
  }]

  while (stack.length) {
    var frame = stack.pop(),
        edges = Object.keys(frame.node.edges),
        len = edges.length

    if (frame.node.final) {
      /* In Safari, at this point the prefix is sometimes corrupted, see:
       * https://github.com/olivernn/lunr.js/issues/279 Calling any
       * String.prototype method forces Safari to "cast" this string to what
       * it's supposed to be, fixing the bug. */
      frame.prefix.charAt(0)
      words.push(frame.prefix)
    }

    for (var i = 0; i < len; i++) {
      var edge = edges[i]

      stack.push({
        prefix: frame.prefix.concat(edge),
        node: frame.node.edges[edge]
      })
    }
  }

  return words
}

/**
 * Generates a string representation of a TokenSet.
 *
 * This is intended to allow TokenSets to be used as keys
 * in objects, largely to aid the construction and minimisation
 * of a TokenSet. As such it is not designed to be a human
 * friendly representation of the TokenSet.
 *
 * @returns {string}
 */
lunr.TokenSet.prototype.toString = function () {
  // NOTE: Using Object.keys here as this.edges is very likely
  // to enter 'hash-mode' with many keys being added
  //
  // avoiding a for-in loop here as it leads to the function
  // being de-optimised (at least in V8). From some simple
  // benchmarks the performance is comparable, but allowing
  // V8 to optimize may mean easy performance wins in the future.

  if (this._str) {
    return this._str
  }

  var str = this.final ? '1' : '0',
      labels = Object.keys(this.edges).sort(),
      len = labels.length

  for (var i = 0; i < len; i++) {
    var label = labels[i],
        node = this.edges[label]

    str = str + label + node.id
  }

  return str
}

/**
 * Returns a new TokenSet that is the intersection of
 * this TokenSet and the passed TokenSet.
 *
 * This intersection will take into account any wildcards
 * contained within the TokenSet.
 *
 * @param {lunr.TokenSet} b - An other TokenSet to intersect with.
 * @returns {lunr.TokenSet}
 */
lunr.TokenSet.prototype.intersect = function (b) {
  var output = new lunr.TokenSet,
      frame = undefined

  var stack = [{
    qNode: b,
    output: output,
    node: this
  }]

  while (stack.length) {
    frame = stack.pop()

    // NOTE: As with the #toString method, we are using
    // Object.keys and a for loop instead of a for-in loop
    // as both of these objects enter 'hash' mode, causing
    // the function to be de-optimised in V8
    var qEdges = Object.keys(frame.qNode.edges),
        qLen = qEdges.length,
        nEdges = Object.keys(frame.node.edges),
        nLen = nEdges.length

    for (var q = 0; q < qLen; q++) {
      var qEdge = qEdges[q]

      for (var n = 0; n < nLen; n++) {
        var nEdge = nEdges[n]

        if (nEdge == qEdge || qEdge == '*') {
          var node = frame.node.edges[nEdge],
              qNode = frame.qNode.edges[qEdge],
              final = node.final && qNode.final,
              next = undefined

          if (nEdge in frame.output.edges) {
            // an edge already exists for this character
            // no need to create a new node, just set the finality
            // bit unless this node is already final
            next = frame.output.edges[nEdge]
            next.final = next.final || final

          } else {
            // no edge exists yet, must create one
            // set the finality bit and insert it
            // into the output
            next = new lunr.TokenSet
            next.final = final
            frame.output.edges[nEdge] = next
          }

          stack.push({
            qNode: qNode,
            output: next,
            node: node
          })
        }
      }
    }
  }

  return output
}
lunr.TokenSet.Builder = function () {
  this.previousWord = ""
  this.root = new lunr.TokenSet
  this.uncheckedNodes = []
  this.minimizedNodes = {}
}

lunr.TokenSet.Builder.prototype.insert = function (word) {
  var node,
      commonPrefix = 0

  if (word < this.previousWord) {
    throw new Error ("Out of order word insertion")
  }

  for (var i = 0; i < word.length && i < this.previousWord.length; i++) {
    if (word[i] != this.previousWord[i]) break
    commonPrefix++
  }

  this.minimize(commonPrefix)

  if (this.uncheckedNodes.length == 0) {
    node = this.root
  } else {
    node = this.uncheckedNodes[this.uncheckedNodes.length - 1].child
  }

  for (var i = commonPrefix; i < word.length; i++) {
    var nextNode = new lunr.TokenSet,
        char = word[i]

    node.edges[char] = nextNode

    this.uncheckedNodes.push({
      parent: node,
      char: char,
      child: nextNode
    })

    node = nextNode
  }

  node.final = true
  this.previousWord = word
}

lunr.TokenSet.Builder.prototype.finish = function () {
  this.minimize(0)
}

lunr.TokenSet.Builder.prototype.minimize = function (downTo) {
  for (var i = this.uncheckedNodes.length - 1; i >= downTo; i--) {
    var node = this.uncheckedNodes[i],
        childKey = node.child.toString()

    if (childKey in this.minimizedNodes) {
      node.parent.edges[node.char] = this.minimizedNodes[childKey]
    } else {
      // Cache the key for this node since
      // we know it can't change anymore
      node.child._str = childKey

      this.minimizedNodes[childKey] = node.child
    }

    this.uncheckedNodes.pop()
  }
}
/*!
 * lunr.Index
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * An index contains the built index of all documents and provides a query interface
 * to the index.
 *
 * Usually instances of lunr.Index will not be created using this constructor, instead
 * lunr.Builder should be used to construct new indexes, or lunr.Index.load should be
 * used to load previously built and serialized indexes.
 *
 * @constructor
 * @param {Object} attrs - The attributes of the built search index.
 * @param {Object} attrs.invertedIndex - An index of term/field to document reference.
 * @param {Object<string, lunr.Vector>} attrs.fieldVectors - Field vectors
 * @param {lunr.TokenSet} attrs.tokenSet - An set of all corpus tokens.
 * @param {string[]} attrs.fields - The names of indexed document fields.
 * @param {lunr.Pipeline} attrs.pipeline - The pipeline to use for search terms.
 */
lunr.Index = function (attrs) {
  this.invertedIndex = attrs.invertedIndex
  this.fieldVectors = attrs.fieldVectors
  this.tokenSet = attrs.tokenSet
  this.fields = attrs.fields
  this.pipeline = attrs.pipeline
}

/**
 * A result contains details of a document matching a search query.
 * @typedef {Object} lunr.Index~Result
 * @property {string} ref - The reference of the document this result represents.
 * @property {number} score - A number between 0 and 1 representing how similar this document is to the query.
 * @property {lunr.MatchData} matchData - Contains metadata about this match including which term(s) caused the match.
 */

/**
 * Although lunr provides the ability to create queries using lunr.Query, it also provides a simple
 * query language which itself is parsed into an instance of lunr.Query.
 *
 * For programmatically building queries it is advised to directly use lunr.Query, the query language
 * is best used for human entered text rather than program generated text.
 *
 * At its simplest queries can just be a single term, e.g. `hello`, multiple terms are also supported
 * and will be combined with OR, e.g `hello world` will match documents that contain either 'hello'
 * or 'world', though those that contain both will rank higher in the results.
 *
 * Wildcards can be included in terms to match one or more unspecified characters, these wildcards can
 * be inserted anywhere within the term, and more than one wildcard can exist in a single term. Adding
 * wildcards will increase the number of documents that will be found but can also have a negative
 * impact on query performance, especially with wildcards at the beginning of a term.
 *
 * Terms can be restricted to specific fields, e.g. `title:hello`, only documents with the term
 * hello in the title field will match this query. Using a field not present in the index will lead
 * to an error being thrown.
 *
 * Modifiers can also be added to terms, lunr supports edit distance and boost modifiers on terms. A term
 * boost will make documents matching that term score higher, e.g. `foo^5`. Edit distance is also supported
 * to provide fuzzy matching, e.g. 'hello~2' will match documents with hello with an edit distance of 2.
 * Avoid large values for edit distance to improve query performance.
 *
 * Each term also supports a presence modifier. By default a term's presence in document is optional, however
 * this can be changed to either required or prohibited. For a term's presence to be required in a document the
 * term should be prefixed with a '+', e.g. `+foo bar` is a search for documents that must contain 'foo' and
 * optionally contain 'bar'. Conversely a leading '-' sets the terms presence to prohibited, i.e. it must not
 * appear in a document, e.g. `-foo bar` is a search for documents that do not contain 'foo' but may contain 'bar'.
 *
 * To escape special characters the backslash character '\' can be used, this allows searches to include
 * characters that would normally be considered modifiers, e.g. `foo\~2` will search for a term "foo~2" instead
 * of attempting to apply a boost of 2 to the search term "foo".
 *
 * @typedef {string} lunr.Index~QueryString
 * @example <caption>Simple single term query</caption>
 * hello
 * @example <caption>Multiple term query</caption>
 * hello world
 * @example <caption>term scoped to a field</caption>
 * title:hello
 * @example <caption>term with a boost of 10</caption>
 * hello^10
 * @example <caption>term with an edit distance of 2</caption>
 * hello~2
 * @example <caption>terms with presence modifiers</caption>
 * -foo +bar baz
 */

/**
 * Performs a search against the index using lunr query syntax.
 *
 * Results will be returned sorted by their score, the most relevant results
 * will be returned first.  For details on how the score is calculated, please see
 * the {@link https://lunrjs.com/guides/searching.html#scoring|guide}.
 *
 * For more programmatic querying use lunr.Index#query.
 *
 * @param {lunr.Index~QueryString} queryString - A string containing a lunr query.
 * @throws {lunr.QueryParseError} If the passed query string cannot be parsed.
 * @returns {lunr.Index~Result[]}
 */
lunr.Index.prototype.search = function (queryString) {
  return this.query(function (query) {
    var parser = new lunr.QueryParser(queryString, query)
    parser.parse()
  })
}

/**
 * A query builder callback provides a query object to be used to express
 * the query to perform on the index.
 *
 * @callback lunr.Index~queryBuilder
 * @param {lunr.Query} query - The query object to build up.
 * @this lunr.Query
 */

/**
 * Performs a query against the index using the yielded lunr.Query object.
 *
 * If performing programmatic queries against the index, this method is preferred
 * over lunr.Index#search so as to avoid the additional query parsing overhead.
 *
 * A query object is yielded to the supplied function which should be used to
 * express the query to be run against the index.
 *
 * Note that although this function takes a callback parameter it is _not_ an
 * asynchronous operation, the callback is just yielded a query object to be
 * customized.
 *
 * @param {lunr.Index~queryBuilder} fn - A function that is used to build the query.
 * @returns {lunr.Index~Result[]}
 */
lunr.Index.prototype.query = function (fn) {
  // for each query clause
  // * process terms
  // * expand terms from token set
  // * find matching documents and metadata
  // * get document vectors
  // * score documents

  var query = new lunr.Query(this.fields),
      matchingFields = Object.create(null),
      queryVectors = Object.create(null),
      termFieldCache = Object.create(null),
      requiredMatches = Object.create(null),
      prohibitedMatches = Object.create(null)

  /*
   * To support field level boosts a query vector is created per
   * field. An empty vector is eagerly created to support negated
   * queries.
   */
  for (var i = 0; i < this.fields.length; i++) {
    queryVectors[this.fields[i]] = new lunr.Vector
  }

  fn.call(query, query)

  for (var i = 0; i < query.clauses.length; i++) {
    /*
     * Unless the pipeline has been disabled for this term, which is
     * the case for terms with wildcards, we need to pass the clause
     * term through the search pipeline. A pipeline returns an array
     * of processed terms. Pipeline functions may expand the passed
     * term, which means we may end up performing multiple index lookups
     * for a single query term.
     */
    var clause = query.clauses[i],
        terms = null,
        clauseMatches = lunr.Set.complete

    if (clause.usePipeline) {
      terms = this.pipeline.runString(clause.term, {
        fields: clause.fields
      })
    } else {
      terms = [clause.term]
    }

    for (var m = 0; m < terms.length; m++) {
      var term = terms[m]

      /*
       * Each term returned from the pipeline needs to use the same query
       * clause object, e.g. the same boost and or edit distance. The
       * simplest way to do this is to re-use the clause object but mutate
       * its term property.
       */
      clause.term = term

      /*
       * From the term in the clause we create a token set which will then
       * be used to intersect the indexes token set to get a list of terms
       * to lookup in the inverted index
       */
      var termTokenSet = lunr.TokenSet.fromClause(clause),
          expandedTerms = this.tokenSet.intersect(termTokenSet).toArray()

      /*
       * If a term marked as required does not exist in the tokenSet it is
       * impossible for the search to return any matches. We set all the field
       * scoped required matches set to empty and stop examining any further
       * clauses.
       */
      if (expandedTerms.length === 0 && clause.presence === lunr.Query.presence.REQUIRED) {
        for (var k = 0; k < clause.fields.length; k++) {
          var field = clause.fields[k]
          requiredMatches[field] = lunr.Set.empty
        }

        break
      }

      for (var j = 0; j < expandedTerms.length; j++) {
        /*
         * For each term get the posting and termIndex, this is required for
         * building the query vector.
         */
        var expandedTerm = expandedTerms[j],
            posting = this.invertedIndex[expandedTerm],
            termIndex = posting._index

        for (var k = 0; k < clause.fields.length; k++) {
          /*
           * For each field that this query term is scoped by (by default
           * all fields are in scope) we need to get all the document refs
           * that have this term in that field.
           *
           * The posting is the entry in the invertedIndex for the matching
           * term from above.
           */
          var field = clause.fields[k],
              fieldPosting = posting[field],
              matchingDocumentRefs = Object.keys(fieldPosting),
              termField = expandedTerm + "/" + field,
              matchingDocumentsSet = new lunr.Set(matchingDocumentRefs)

          /*
           * if the presence of this term is required ensure that the matching
           * documents are added to the set of required matches for this clause.
           *
           */
          if (clause.presence == lunr.Query.presence.REQUIRED) {
            clauseMatches = clauseMatches.union(matchingDocumentsSet)

            if (requiredMatches[field] === undefined) {
              requiredMatches[field] = lunr.Set.complete
            }
          }

          /*
           * if the presence of this term is prohibited ensure that the matching
           * documents are added to the set of prohibited matches for this field,
           * creating that set if it does not yet exist.
           */
          if (clause.presence == lunr.Query.presence.PROHIBITED) {
            if (prohibitedMatches[field] === undefined) {
              prohibitedMatches[field] = lunr.Set.empty
            }

            prohibitedMatches[field] = prohibitedMatches[field].union(matchingDocumentsSet)

            /*
             * Prohibited matches should not be part of the query vector used for
             * similarity scoring and no metadata should be extracted so we continue
             * to the next field
             */
            continue
          }

          /*
           * The query field vector is populated using the termIndex found for
           * the term and a unit value with the appropriate boost applied.
           * Using upsert because there could already be an entry in the vector
           * for the term we are working with. In that case we just add the scores
           * together.
           */
          queryVectors[field].upsert(termIndex, clause.boost, function (a, b) { return a + b })

          /**
           * If we've already seen this term, field combo then we've already collected
           * the matching documents and metadata, no need to go through all that again
           */
          if (termFieldCache[termField]) {
            continue
          }

          for (var l = 0; l < matchingDocumentRefs.length; l++) {
            /*
             * All metadata for this term/field/document triple
             * are then extracted and collected into an instance
             * of lunr.MatchData ready to be returned in the query
             * results
             */
            var matchingDocumentRef = matchingDocumentRefs[l],
                matchingFieldRef = new lunr.FieldRef (matchingDocumentRef, field),
                metadata = fieldPosting[matchingDocumentRef],
                fieldMatch

            if ((fieldMatch = matchingFields[matchingFieldRef]) === undefined) {
              matchingFields[matchingFieldRef] = new lunr.MatchData (expandedTerm, field, metadata)
            } else {
              fieldMatch.add(expandedTerm, field, metadata)
            }

          }

          termFieldCache[termField] = true
        }
      }
    }

    /**
     * If the presence was required we need to update the requiredMatches field sets.
     * We do this after all fields for the term have collected their matches because
     * the clause terms presence is required in _any_ of the fields not _all_ of the
     * fields.
     */
    if (clause.presence === lunr.Query.presence.REQUIRED) {
      for (var k = 0; k < clause.fields.length; k++) {
        var field = clause.fields[k]
        requiredMatches[field] = requiredMatches[field].intersect(clauseMatches)
      }
    }
  }

  /**
   * Need to combine the field scoped required and prohibited
   * matching documents into a global set of required and prohibited
   * matches
   */
  var allRequiredMatches = lunr.Set.complete,
      allProhibitedMatches = lunr.Set.empty

  for (var i = 0; i < this.fields.length; i++) {
    var field = this.fields[i]

    if (requiredMatches[field]) {
      allRequiredMatches = allRequiredMatches.intersect(requiredMatches[field])
    }

    if (prohibitedMatches[field]) {
      allProhibitedMatches = allProhibitedMatches.union(prohibitedMatches[field])
    }
  }

  var matchingFieldRefs = Object.keys(matchingFields),
      results = [],
      matches = Object.create(null)

  /*
   * If the query is negated (contains only prohibited terms)
   * we need to get _all_ fieldRefs currently existing in the
   * index. This is only done when we know that the query is
   * entirely prohibited terms to avoid any cost of getting all
   * fieldRefs unnecessarily.
   *
   * Additionally, blank MatchData must be created to correctly
   * populate the results.
   */
  if (query.isNegated()) {
    matchingFieldRefs = Object.keys(this.fieldVectors)

    for (var i = 0; i < matchingFieldRefs.length; i++) {
      var matchingFieldRef = matchingFieldRefs[i]
      var fieldRef = lunr.FieldRef.fromString(matchingFieldRef)
      matchingFields[matchingFieldRef] = new lunr.MatchData
    }
  }

  for (var i = 0; i < matchingFieldRefs.length; i++) {
    /*
     * Currently we have document fields that match the query, but we
     * need to return documents. The matchData and scores are combined
     * from multiple fields belonging to the same document.
     *
     * Scores are calculated by field, using the query vectors created
     * above, and combined into a final document score using addition.
     */
    var fieldRef = lunr.FieldRef.fromString(matchingFieldRefs[i]),
        docRef = fieldRef.docRef

    if (!allRequiredMatches.contains(docRef)) {
      continue
    }

    if (allProhibitedMatches.contains(docRef)) {
      continue
    }

    var fieldVector = this.fieldVectors[fieldRef],
        score = queryVectors[fieldRef.fieldName].similarity(fieldVector),
        docMatch

    if ((docMatch = matches[docRef]) !== undefined) {
      docMatch.score += score
      docMatch.matchData.combine(matchingFields[fieldRef])
    } else {
      var match = {
        ref: docRef,
        score: score,
        matchData: matchingFields[fieldRef]
      }
      matches[docRef] = match
      results.push(match)
    }
  }

  /*
   * Sort the results objects by score, highest first.
   */
  return results.sort(function (a, b) {
    return b.score - a.score
  })
}

/**
 * Prepares the index for JSON serialization.
 *
 * The schema for this JSON blob will be described in a
 * separate JSON schema file.
 *
 * @returns {Object}
 */
lunr.Index.prototype.toJSON = function () {
  var invertedIndex = Object.keys(this.invertedIndex)
    .sort()
    .map(function (term) {
      return [term, this.invertedIndex[term]]
    }, this)

  var fieldVectors = Object.keys(this.fieldVectors)
    .map(function (ref) {
      return [ref, this.fieldVectors[ref].toJSON()]
    }, this)

  return {
    version: lunr.version,
    fields: this.fields,
    fieldVectors: fieldVectors,
    invertedIndex: invertedIndex,
    pipeline: this.pipeline.toJSON()
  }
}

/**
 * Loads a previously serialized lunr.Index
 *
 * @param {Object} serializedIndex - A previously serialized lunr.Index
 * @returns {lunr.Index}
 */
lunr.Index.load = function (serializedIndex) {
  var attrs = {},
      fieldVectors = {},
      serializedVectors = serializedIndex.fieldVectors,
      invertedIndex = Object.create(null),
      serializedInvertedIndex = serializedIndex.invertedIndex,
      tokenSetBuilder = new lunr.TokenSet.Builder,
      pipeline = lunr.Pipeline.load(serializedIndex.pipeline)

  if (serializedIndex.version != lunr.version) {
    lunr.utils.warn("Version mismatch when loading serialised index. Current version of lunr '" + lunr.version + "' does not match serialized index '" + serializedIndex.version + "'")
  }

  for (var i = 0; i < serializedVectors.length; i++) {
    var tuple = serializedVectors[i],
        ref = tuple[0],
        elements = tuple[1]

    fieldVectors[ref] = new lunr.Vector(elements)
  }

  for (var i = 0; i < serializedInvertedIndex.length; i++) {
    var tuple = serializedInvertedIndex[i],
        term = tuple[0],
        posting = tuple[1]

    tokenSetBuilder.insert(term)
    invertedIndex[term] = posting
  }

  tokenSetBuilder.finish()

  attrs.fields = serializedIndex.fields

  attrs.fieldVectors = fieldVectors
  attrs.invertedIndex = invertedIndex
  attrs.tokenSet = tokenSetBuilder.root
  attrs.pipeline = pipeline

  return new lunr.Index(attrs)
}
/*!
 * lunr.Builder
 * Copyright (C) 2019 Oliver Nightingale
 */

/**
 * lunr.Builder performs indexing on a set of documents and
 * returns instances of lunr.Index ready for querying.
 *
 * All configuration of the index is done via the builder, the
 * fields to index, the document reference, the text processing
 * pipeline and document scoring parameters are all set on the
 * builder before indexing.
 *
 * @constructor
 * @property {string} _ref - Internal reference to the document reference field.
 * @property {string[]} _fields - Internal reference to the document fields to index.
 * @property {object} invertedIndex - The inverted index maps terms to document fields.
 * @property {object} documentTermFrequencies - Keeps track of document term frequencies.
 * @property {object} documentLengths - Keeps track of the length of documents added to the index.
 * @property {lunr.tokenizer} tokenizer - Function for splitting strings into tokens for indexing.
 * @property {lunr.Pipeline} pipeline - The pipeline performs text processing on tokens before indexing.
 * @property {lunr.Pipeline} searchPipeline - A pipeline for processing search terms before querying the index.
 * @property {number} documentCount - Keeps track of the total number of documents indexed.
 * @property {number} _b - A parameter to control field length normalization, setting this to 0 disabled normalization, 1 fully normalizes field lengths, the default value is 0.75.
 * @property {number} _k1 - A parameter to control how quickly an increase in term frequency results in term frequency saturation, the default value is 1.2.
 * @property {number} termIndex - A counter incremented for each unique term, used to identify a terms position in the vector space.
 * @property {array} metadataWhitelist - A list of metadata keys that have been whitelisted for entry in the index.
 */
lunr.Builder = function () {
  this._ref = "id"
  this._fields = Object.create(null)
  this._documents = Object.create(null)
  this.invertedIndex = Object.create(null)
  this.fieldTermFrequencies = {}
  this.fieldLengths = {}
  this.tokenizer = lunr.tokenizer
  this.pipeline = new lunr.Pipeline
  this.searchPipeline = new lunr.Pipeline
  this.documentCount = 0
  this._b = 0.75
  this._k1 = 1.2
  this.termIndex = 0
  this.metadataWhitelist = []
}

/**
 * Sets the document field used as the document reference. Every document must have this field.
 * The type of this field in the document should be a string, if it is not a string it will be
 * coerced into a string by calling toString.
 *
 * The default ref is 'id'.
 *
 * The ref should _not_ be changed during indexing, it should be set before any documents are
 * added to the index. Changing it during indexing can lead to inconsistent results.
 *
 * @param {string} ref - The name of the reference field in the document.
 */
lunr.Builder.prototype.ref = function (ref) {
  this._ref = ref
}

/**
 * A function that is used to extract a field from a document.
 *
 * Lunr expects a field to be at the top level of a document, if however the field
 * is deeply nested within a document an extractor function can be used to extract
 * the right field for indexing.
 *
 * @callback fieldExtractor
 * @param {object} doc - The document being added to the index.
 * @returns {?(string|object|object[])} obj - The object that will be indexed for this field.
 * @example <caption>Extracting a nested field</caption>
 * function (doc) { return doc.nested.field }
 */

/**
 * Adds a field to the list of document fields that will be indexed. Every document being
 * indexed should have this field. Null values for this field in indexed documents will
 * not cause errors but will limit the chance of that document being retrieved by searches.
 *
 * All fields should be added before adding documents to the index. Adding fields after
 * a document has been indexed will have no effect on already indexed documents.
 *
 * Fields can be boosted at build time. This allows terms within that field to have more
 * importance when ranking search results. Use a field boost to specify that matches within
 * one field are more important than other fields.
 *
 * @param {string} fieldName - The name of a field to index in all documents.
 * @param {object} attributes - Optional attributes associated with this field.
 * @param {number} [attributes.boost=1] - Boost applied to all terms within this field.
 * @param {fieldExtractor} [attributes.extractor] - Function to extract a field from a document.
 * @throws {RangeError} fieldName cannot contain unsupported characters '/'
 */
lunr.Builder.prototype.field = function (fieldName, attributes) {
  if (/\//.test(fieldName)) {
    throw new RangeError ("Field '" + fieldName + "' contains illegal character '/'")
  }

  this._fields[fieldName] = attributes || {}
}

/**
 * A parameter to tune the amount of field length normalisation that is applied when
 * calculating relevance scores. A value of 0 will completely disable any normalisation
 * and a value of 1 will fully normalise field lengths. The default is 0.75. Values of b
 * will be clamped to the range 0 - 1.
 *
 * @param {number} number - The value to set for this tuning parameter.
 */
lunr.Builder.prototype.b = function (number) {
  if (number < 0) {
    this._b = 0
  } else if (number > 1) {
    this._b = 1
  } else {
    this._b = number
  }
}

/**
 * A parameter that controls the speed at which a rise in term frequency results in term
 * frequency saturation. The default value is 1.2. Setting this to a higher value will give
 * slower saturation levels, a lower value will result in quicker saturation.
 *
 * @param {number} number - The value to set for this tuning parameter.
 */
lunr.Builder.prototype.k1 = function (number) {
  this._k1 = number
}

/**
 * Adds a document to the index.
 *
 * Before adding fields to the index the index should have been fully setup, with the document
 * ref and all fields to index already having been specified.
 *
 * The document must have a field name as specified by the ref (by default this is 'id') and
 * it should have all fields defined for indexing, though null or undefined values will not
 * cause errors.
 *
 * Entire documents can be boosted at build time. Applying a boost to a document indicates that
 * this document should rank higher in search results than other documents.
 *
 * @param {object} doc - The document to add to the index.
 * @param {object} attributes - Optional attributes associated with this document.
 * @param {number} [attributes.boost=1] - Boost applied to all terms within this document.
 */
lunr.Builder.prototype.add = function (doc, attributes) {
  var docRef = doc[this._ref],
      fields = Object.keys(this._fields)

  this._documents[docRef] = attributes || {}
  this.documentCount += 1

  for (var i = 0; i < fields.length; i++) {
    var fieldName = fields[i],
        extractor = this._fields[fieldName].extractor,
        field = extractor ? extractor(doc) : doc[fieldName],
        tokens = this.tokenizer(field, {
          fields: [fieldName]
        }),
        terms = this.pipeline.run(tokens),
        fieldRef = new lunr.FieldRef (docRef, fieldName),
        fieldTerms = Object.create(null)

    this.fieldTermFrequencies[fieldRef] = fieldTerms
    this.fieldLengths[fieldRef] = 0

    // store the length of this field for this document
    this.fieldLengths[fieldRef] += terms.length

    // calculate term frequencies for this field
    for (var j = 0; j < terms.length; j++) {
      var term = terms[j]

      if (fieldTerms[term] == undefined) {
        fieldTerms[term] = 0
      }

      fieldTerms[term] += 1

      // add to inverted index
      // create an initial posting if one doesn't exist
      if (this.invertedIndex[term] == undefined) {
        var posting = Object.create(null)
        posting["_index"] = this.termIndex
        this.termIndex += 1

        for (var k = 0; k < fields.length; k++) {
          posting[fields[k]] = Object.create(null)
        }

        this.invertedIndex[term] = posting
      }

      // add an entry for this term/fieldName/docRef to the invertedIndex
      if (this.invertedIndex[term][fieldName][docRef] == undefined) {
        this.invertedIndex[term][fieldName][docRef] = Object.create(null)
      }

      // store all whitelisted metadata about this token in the
      // inverted index
      for (var l = 0; l < this.metadataWhitelist.length; l++) {
        var metadataKey = this.metadataWhitelist[l],
            metadata = term.metadata[metadataKey]

        if (this.invertedIndex[term][fieldName][docRef][metadataKey] == undefined) {
          this.invertedIndex[term][fieldName][docRef][metadataKey] = []
        }

        this.invertedIndex[term][fieldName][docRef][metadataKey].push(metadata)
      }
    }

  }
}

/**
 * Calculates the average document length for this index
 *
 * @private
 */
lunr.Builder.prototype.calculateAverageFieldLengths = function () {

  var fieldRefs = Object.keys(this.fieldLengths),
      numberOfFields = fieldRefs.length,
      accumulator = {},
      documentsWithField = {}

  for (var i = 0; i < numberOfFields; i++) {
    var fieldRef = lunr.FieldRef.fromString(fieldRefs[i]),
        field = fieldRef.fieldName

    documentsWithField[field] || (documentsWithField[field] = 0)
    documentsWithField[field] += 1

    accumulator[field] || (accumulator[field] = 0)
    accumulator[field] += this.fieldLengths[fieldRef]
  }

  var fields = Object.keys(this._fields)

  for (var i = 0; i < fields.length; i++) {
    var fieldName = fields[i]
    accumulator[fieldName] = accumulator[fieldName] / documentsWithField[fieldName]
  }

  this.averageFieldLength = accumulator
}

/**
 * Builds a vector space model of every document using lunr.Vector
 *
 * @private
 */
lunr.Builder.prototype.createFieldVectors = function () {
  var fieldVectors = {},
      fieldRefs = Object.keys(this.fieldTermFrequencies),
      fieldRefsLength = fieldRefs.length,
      termIdfCache = Object.create(null)

  for (var i = 0; i < fieldRefsLength; i++) {
    var fieldRef = lunr.FieldRef.fromString(fieldRefs[i]),
        fieldName = fieldRef.fieldName,
        fieldLength = this.fieldLengths[fieldRef],
        fieldVector = new lunr.Vector,
        termFrequencies = this.fieldTermFrequencies[fieldRef],
        terms = Object.keys(termFrequencies),
        termsLength = terms.length


    var fieldBoost = this._fields[fieldName].boost || 1,
        docBoost = this._documents[fieldRef.docRef].boost || 1

    for (var j = 0; j < termsLength; j++) {
      var term = terms[j],
          tf = termFrequencies[term],
          termIndex = this.invertedIndex[term]._index,
          idf, score, scoreWithPrecision

      if (termIdfCache[term] === undefined) {
        idf = lunr.idf(this.invertedIndex[term], this.documentCount)
        termIdfCache[term] = idf
      } else {
        idf = termIdfCache[term]
      }

      score = idf * ((this._k1 + 1) * tf) / (this._k1 * (1 - this._b + this._b * (fieldLength / this.averageFieldLength[fieldName])) + tf)
      score *= fieldBoost
      score *= docBoost
      scoreWithPrecision = Math.round(score * 1000) / 1000
      // Converts 1.23456789 to 1.234.
      // Reducing the precision so that the vectors take up less
      // space when serialised. Doing it now so that they behave
      // the same before and after serialisation. Also, this is
      // the fastest approach to reducing a number's precision in
      // JavaScript.

      fieldVector.insert(termIndex, scoreWithPrecision)
    }

    fieldVectors[fieldRef] = fieldVector
  }

  this.fieldVectors = fieldVectors
}

/**
 * Creates a token set of all tokens in the index using lunr.TokenSet
 *
 * @private
 */
lunr.Builder.prototype.createTokenSet = function () {
  this.tokenSet = lunr.TokenSet.fromArray(
    Object.keys(this.invertedIndex).sort()
  )
}

/**
 * Builds the index, creating an instance of lunr.Index.
 *
 * This completes the indexing process and should only be called
 * once all documents have been added to the index.
 *
 * @returns {lunr.Index}
 */
lunr.Builder.prototype.build = function () {
  this.calculateAverageFieldLengths()
  this.createFieldVectors()
  this.createTokenSet()

  return new lunr.Index({
    invertedIndex: this.invertedIndex,
    fieldVectors: this.fieldVectors,
    tokenSet: this.tokenSet,
    fields: Object.keys(this._fields),
    pipeline: this.searchPipeline
  })
}

/**
 * Applies a plugin to the index builder.
 *
 * A plugin is a function that is called with the index builder as its context.
 * Plugins can be used to customise or extend the behaviour of the index
 * in some way. A plugin is just a function, that encapsulated the custom
 * behaviour that should be applied when building the index.
 *
 * The plugin function will be called with the index builder as its argument, additional
 * arguments can also be passed when calling use. The function will be called
 * with the index builder as its context.
 *
 * @param {Function} plugin The plugin to apply.
 */
lunr.Builder.prototype.use = function (fn) {
  var args = Array.prototype.slice.call(arguments, 1)
  args.unshift(this)
  fn.apply(this, args)
}
/**
 * Contains and collects metadata about a matching document.
 * A single instance of lunr.MatchData is returned as part of every
 * lunr.Index~Result.
 *
 * @constructor
 * @param {string} term - The term this match data is associated with
 * @param {string} field - The field in which the term was found
 * @param {object} metadata - The metadata recorded about this term in this field
 * @property {object} metadata - A cloned collection of metadata associated with this document.
 * @see {@link lunr.Index~Result}
 */
lunr.MatchData = function (term, field, metadata) {
  var clonedMetadata = Object.create(null),
      metadataKeys = Object.keys(metadata || {})

  // Cloning the metadata to prevent the original
  // being mutated during match data combination.
  // Metadata is kept in an array within the inverted
  // index so cloning the data can be done with
  // Array#slice
  for (var i = 0; i < metadataKeys.length; i++) {
    var key = metadataKeys[i]
    clonedMetadata[key] = metadata[key].slice()
  }

  this.metadata = Object.create(null)

  if (term !== undefined) {
    this.metadata[term] = Object.create(null)
    this.metadata[term][field] = clonedMetadata
  }
}

/**
 * An instance of lunr.MatchData will be created for every term that matches a
 * document. However only one instance is required in a lunr.Index~Result. This
 * method combines metadata from another instance of lunr.MatchData with this
 * objects metadata.
 *
 * @param {lunr.MatchData} otherMatchData - Another instance of match data to merge with this one.
 * @see {@link lunr.Index~Result}
 */
lunr.MatchData.prototype.combine = function (otherMatchData) {
  var terms = Object.keys(otherMatchData.metadata)

  for (var i = 0; i < terms.length; i++) {
    var term = terms[i],
        fields = Object.keys(otherMatchData.metadata[term])

    if (this.metadata[term] == undefined) {
      this.metadata[term] = Object.create(null)
    }

    for (var j = 0; j < fields.length; j++) {
      var field = fields[j],
          keys = Object.keys(otherMatchData.metadata[term][field])

      if (this.metadata[term][field] == undefined) {
        this.metadata[term][field] = Object.create(null)
      }

      for (var k = 0; k < keys.length; k++) {
        var key = keys[k]

        if (this.metadata[term][field][key] == undefined) {
          this.metadata[term][field][key] = otherMatchData.metadata[term][field][key]
        } else {
          this.metadata[term][field][key] = this.metadata[term][field][key].concat(otherMatchData.metadata[term][field][key])
        }

      }
    }
  }
}

/**
 * Add metadata for a term/field pair to this instance of match data.
 *
 * @param {string} term - The term this match data is associated with
 * @param {string} field - The field in which the term was found
 * @param {object} metadata - The metadata recorded about this term in this field
 */
lunr.MatchData.prototype.add = function (term, field, metadata) {
  if (!(term in this.metadata)) {
    this.metadata[term] = Object.create(null)
    this.metadata[term][field] = metadata
    return
  }

  if (!(field in this.metadata[term])) {
    this.metadata[term][field] = metadata
    return
  }

  var metadataKeys = Object.keys(metadata)

  for (var i = 0; i < metadataKeys.length; i++) {
    var key = metadataKeys[i]

    if (key in this.metadata[term][field]) {
      this.metadata[term][field][key] = this.metadata[term][field][key].concat(metadata[key])
    } else {
      this.metadata[term][field][key] = metadata[key]
    }
  }
}
/**
 * A lunr.Query provides a programmatic way of defining queries to be performed
 * against a {@link lunr.Index}.
 *
 * Prefer constructing a lunr.Query using the {@link lunr.Index#query} method
 * so the query object is pre-initialized with the right index fields.
 *
 * @constructor
 * @property {lunr.Query~Clause[]} clauses - An array of query clauses.
 * @property {string[]} allFields - An array of all available fields in a lunr.Index.
 */
lunr.Query = function (allFields) {
  this.clauses = []
  this.allFields = allFields
}

/**
 * Constants for indicating what kind of automatic wildcard insertion will be used when constructing a query clause.
 *
 * This allows wildcards to be added to the beginning and end of a term without having to manually do any string
 * concatenation.
 *
 * The wildcard constants can be bitwise combined to select both leading and trailing wildcards.
 *
 * @constant
 * @default
 * @property {number} wildcard.NONE - The term will have no wildcards inserted, this is the default behaviour
 * @property {number} wildcard.LEADING - Prepend the term with a wildcard, unless a leading wildcard already exists
 * @property {number} wildcard.TRAILING - Append a wildcard to the term, unless a trailing wildcard already exists
 * @see lunr.Query~Clause
 * @see lunr.Query#clause
 * @see lunr.Query#term
 * @example <caption>query term with trailing wildcard</caption>
 * query.term('foo', { wildcard: lunr.Query.wildcard.TRAILING })
 * @example <caption>query term with leading and trailing wildcard</caption>
 * query.term('foo', {
 *   wildcard: lunr.Query.wildcard.LEADING | lunr.Query.wildcard.TRAILING
 * })
 */

lunr.Query.wildcard = new String ("*")
lunr.Query.wildcard.NONE = 0
lunr.Query.wildcard.LEADING = 1
lunr.Query.wildcard.TRAILING = 2

/**
 * Constants for indicating what kind of presence a term must have in matching documents.
 *
 * @constant
 * @enum {number}
 * @see lunr.Query~Clause
 * @see lunr.Query#clause
 * @see lunr.Query#term
 * @example <caption>query term with required presence</caption>
 * query.term('foo', { presence: lunr.Query.presence.REQUIRED })
 */
lunr.Query.presence = {
  /**
   * Term's presence in a document is optional, this is the default value.
   */
  OPTIONAL: 1,

  /**
   * Term's presence in a document is required, documents that do not contain
   * this term will not be returned.
   */
  REQUIRED: 2,

  /**
   * Term's presence in a document is prohibited, documents that do contain
   * this term will not be returned.
   */
  PROHIBITED: 3
}

/**
 * A single clause in a {@link lunr.Query} contains a term and details on how to
 * match that term against a {@link lunr.Index}.
 *
 * @typedef {Object} lunr.Query~Clause
 * @property {string[]} fields - The fields in an index this clause should be matched against.
 * @property {number} [boost=1] - Any boost that should be applied when matching this clause.
 * @property {number} [editDistance] - Whether the term should have fuzzy matching applied, and how fuzzy the match should be.
 * @property {boolean} [usePipeline] - Whether the term should be passed through the search pipeline.
 * @property {number} [wildcard=lunr.Query.wildcard.NONE] - Whether the term should have wildcards appended or prepended.
 * @property {number} [presence=lunr.Query.presence.OPTIONAL] - The terms presence in any matching documents.
 */

/**
 * Adds a {@link lunr.Query~Clause} to this query.
 *
 * Unless the clause contains the fields to be matched all fields will be matched. In addition
 * a default boost of 1 is applied to the clause.
 *
 * @param {lunr.Query~Clause} clause - The clause to add to this query.
 * @see lunr.Query~Clause
 * @returns {lunr.Query}
 */
lunr.Query.prototype.clause = function (clause) {
  if (!('fields' in clause)) {
    clause.fields = this.allFields
  }

  if (!('boost' in clause)) {
    clause.boost = 1
  }

  if (!('usePipeline' in clause)) {
    clause.usePipeline = true
  }

  if (!('wildcard' in clause)) {
    clause.wildcard = lunr.Query.wildcard.NONE
  }

  if ((clause.wildcard & lunr.Query.wildcard.LEADING) && (clause.term.charAt(0) != lunr.Query.wildcard)) {
    clause.term = "*" + clause.term
  }

  if ((clause.wildcard & lunr.Query.wildcard.TRAILING) && (clause.term.slice(-1) != lunr.Query.wildcard)) {
    clause.term = "" + clause.term + "*"
  }

  if (!('presence' in clause)) {
    clause.presence = lunr.Query.presence.OPTIONAL
  }

  this.clauses.push(clause)

  return this
}

/**
 * A negated query is one in which every clause has a presence of
 * prohibited. These queries require some special processing to return
 * the expected results.
 *
 * @returns boolean
 */
lunr.Query.prototype.isNegated = function () {
  for (var i = 0; i < this.clauses.length; i++) {
    if (this.clauses[i].presence != lunr.Query.presence.PROHIBITED) {
      return false
    }
  }

  return true
}

/**
 * Adds a term to the current query, under the covers this will create a {@link lunr.Query~Clause}
 * to the list of clauses that make up this query.
 *
 * The term is used as is, i.e. no tokenization will be performed by this method. Instead conversion
 * to a token or token-like string should be done before calling this method.
 *
 * The term will be converted to a string by calling `toString`. Multiple terms can be passed as an
 * array, each term in the array will share the same options.
 *
 * @param {object|object[]} term - The term(s) to add to the query.
 * @param {object} [options] - Any additional properties to add to the query clause.
 * @returns {lunr.Query}
 * @see lunr.Query#clause
 * @see lunr.Query~Clause
 * @example <caption>adding a single term to a query</caption>
 * query.term("foo")
 * @example <caption>adding a single term to a query and specifying search fields, term boost and automatic trailing wildcard</caption>
 * query.term("foo", {
 *   fields: ["title"],
 *   boost: 10,
 *   wildcard: lunr.Query.wildcard.TRAILING
 * })
 * @example <caption>using lunr.tokenizer to convert a string to tokens before using them as terms</caption>
 * query.term(lunr.tokenizer("foo bar"))
 */
lunr.Query.prototype.term = function (term, options) {
  if (Array.isArray(term)) {
    term.forEach(function (t) { this.term(t, lunr.utils.clone(options)) }, this)
    return this
  }

  var clause = options || {}
  clause.term = term.toString()

  this.clause(clause)

  return this
}
lunr.QueryParseError = function (message, start, end) {
  this.name = "QueryParseError"
  this.message = message
  this.start = start
  this.end = end
}

lunr.QueryParseError.prototype = new Error
lunr.QueryLexer = function (str) {
  this.lexemes = []
  this.str = str
  this.length = str.length
  this.pos = 0
  this.start = 0
  this.escapeCharPositions = []
}

lunr.QueryLexer.prototype.run = function () {
  var state = lunr.QueryLexer.lexText

  while (state) {
    state = state(this)
  }
}

lunr.QueryLexer.prototype.sliceString = function () {
  var subSlices = [],
      sliceStart = this.start,
      sliceEnd = this.pos

  for (var i = 0; i < this.escapeCharPositions.length; i++) {
    sliceEnd = this.escapeCharPositions[i]
    subSlices.push(this.str.slice(sliceStart, sliceEnd))
    sliceStart = sliceEnd + 1
  }

  subSlices.push(this.str.slice(sliceStart, this.pos))
  this.escapeCharPositions.length = 0

  return subSlices.join('')
}

lunr.QueryLexer.prototype.emit = function (type) {
  this.lexemes.push({
    type: type,
    str: this.sliceString(),
    start: this.start,
    end: this.pos
  })

  this.start = this.pos
}

lunr.QueryLexer.prototype.escapeCharacter = function () {
  this.escapeCharPositions.push(this.pos - 1)
  this.pos += 1
}

lunr.QueryLexer.prototype.next = function () {
  if (this.pos >= this.length) {
    return lunr.QueryLexer.EOS
  }

  var char = this.str.charAt(this.pos)
  this.pos += 1
  return char
}

lunr.QueryLexer.prototype.width = function () {
  return this.pos - this.start
}

lunr.QueryLexer.prototype.ignore = function () {
  if (this.start == this.pos) {
    this.pos += 1
  }

  this.start = this.pos
}

lunr.QueryLexer.prototype.backup = function () {
  this.pos -= 1
}

lunr.QueryLexer.prototype.acceptDigitRun = function () {
  var char, charCode

  do {
    char = this.next()
    charCode = char.charCodeAt(0)
  } while (charCode > 47 && charCode < 58)

  if (char != lunr.QueryLexer.EOS) {
    this.backup()
  }
}

lunr.QueryLexer.prototype.more = function () {
  return this.pos < this.length
}

lunr.QueryLexer.EOS = 'EOS'
lunr.QueryLexer.FIELD = 'FIELD'
lunr.QueryLexer.TERM = 'TERM'
lunr.QueryLexer.EDIT_DISTANCE = 'EDIT_DISTANCE'
lunr.QueryLexer.BOOST = 'BOOST'
lunr.QueryLexer.PRESENCE = 'PRESENCE'

lunr.QueryLexer.lexField = function (lexer) {
  lexer.backup()
  lexer.emit(lunr.QueryLexer.FIELD)
  lexer.ignore()
  return lunr.QueryLexer.lexText
}

lunr.QueryLexer.lexTerm = function (lexer) {
  if (lexer.width() > 1) {
    lexer.backup()
    lexer.emit(lunr.QueryLexer.TERM)
  }

  lexer.ignore()

  if (lexer.more()) {
    return lunr.QueryLexer.lexText
  }
}

lunr.QueryLexer.lexEditDistance = function (lexer) {
  lexer.ignore()
  lexer.acceptDigitRun()
  lexer.emit(lunr.QueryLexer.EDIT_DISTANCE)
  return lunr.QueryLexer.lexText
}

lunr.QueryLexer.lexBoost = function (lexer) {
  lexer.ignore()
  lexer.acceptDigitRun()
  lexer.emit(lunr.QueryLexer.BOOST)
  return lunr.QueryLexer.lexText
}

lunr.QueryLexer.lexEOS = function (lexer) {
  if (lexer.width() > 0) {
    lexer.emit(lunr.QueryLexer.TERM)
  }
}

// This matches the separator used when tokenising fields
// within a document. These should match otherwise it is
// not possible to search for some tokens within a document.
//
// It is possible for the user to change the separator on the
// tokenizer so it _might_ clash with any other of the special
// characters already used within the search string, e.g. :.
//
// This means that it is possible to change the separator in
// such a way that makes some words unsearchable using a search
// string.
lunr.QueryLexer.termSeparator = lunr.tokenizer.separator

lunr.QueryLexer.lexText = function (lexer) {
  while (true) {
    var char = lexer.next()

    if (char == lunr.QueryLexer.EOS) {
      return lunr.QueryLexer.lexEOS
    }

    // Escape character is '\'
    if (char.charCodeAt(0) == 92) {
      lexer.escapeCharacter()
      continue
    }

    if (char == ":") {
      return lunr.QueryLexer.lexField
    }

    if (char == "~") {
      lexer.backup()
      if (lexer.width() > 0) {
        lexer.emit(lunr.QueryLexer.TERM)
      }
      return lunr.QueryLexer.lexEditDistance
    }

    if (char == "^") {
      lexer.backup()
      if (lexer.width() > 0) {
        lexer.emit(lunr.QueryLexer.TERM)
      }
      return lunr.QueryLexer.lexBoost
    }

    // "+" indicates term presence is required
    // checking for length to ensure that only
    // leading "+" are considered
    if (char == "+" && lexer.width() === 1) {
      lexer.emit(lunr.QueryLexer.PRESENCE)
      return lunr.QueryLexer.lexText
    }

    // "-" indicates term presence is prohibited
    // checking for length to ensure that only
    // leading "-" are considered
    if (char == "-" && lexer.width() === 1) {
      lexer.emit(lunr.QueryLexer.PRESENCE)
      return lunr.QueryLexer.lexText
    }

    if (char.match(lunr.QueryLexer.termSeparator)) {
      return lunr.QueryLexer.lexTerm
    }
  }
}

lunr.QueryParser = function (str, query) {
  this.lexer = new lunr.QueryLexer (str)
  this.query = query
  this.currentClause = {}
  this.lexemeIdx = 0
}

lunr.QueryParser.prototype.parse = function () {
  this.lexer.run()
  this.lexemes = this.lexer.lexemes

  var state = lunr.QueryParser.parseClause

  while (state) {
    state = state(this)
  }

  return this.query
}

lunr.QueryParser.prototype.peekLexeme = function () {
  return this.lexemes[this.lexemeIdx]
}

lunr.QueryParser.prototype.consumeLexeme = function () {
  var lexeme = this.peekLexeme()
  this.lexemeIdx += 1
  return lexeme
}

lunr.QueryParser.prototype.nextClause = function () {
  var completedClause = this.currentClause
  this.query.clause(completedClause)
  this.currentClause = {}
}

lunr.QueryParser.parseClause = function (parser) {
  var lexeme = parser.peekLexeme()

  if (lexeme == undefined) {
    return
  }

  switch (lexeme.type) {
    case lunr.QueryLexer.PRESENCE:
      return lunr.QueryParser.parsePresence
    case lunr.QueryLexer.FIELD:
      return lunr.QueryParser.parseField
    case lunr.QueryLexer.TERM:
      return lunr.QueryParser.parseTerm
    default:
      var errorMessage = "expected either a field or a term, found " + lexeme.type

      if (lexeme.str.length >= 1) {
        errorMessage += " with value '" + lexeme.str + "'"
      }

      throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }
}

lunr.QueryParser.parsePresence = function (parser) {
  var lexeme = parser.consumeLexeme()

  if (lexeme == undefined) {
    return
  }

  switch (lexeme.str) {
    case "-":
      parser.currentClause.presence = lunr.Query.presence.PROHIBITED
      break
    case "+":
      parser.currentClause.presence = lunr.Query.presence.REQUIRED
      break
    default:
      var errorMessage = "unrecognised presence operator'" + lexeme.str + "'"
      throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  var nextLexeme = parser.peekLexeme()

  if (nextLexeme == undefined) {
    var errorMessage = "expecting term or field, found nothing"
    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  switch (nextLexeme.type) {
    case lunr.QueryLexer.FIELD:
      return lunr.QueryParser.parseField
    case lunr.QueryLexer.TERM:
      return lunr.QueryParser.parseTerm
    default:
      var errorMessage = "expecting term or field, found '" + nextLexeme.type + "'"
      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
  }
}

lunr.QueryParser.parseField = function (parser) {
  var lexeme = parser.consumeLexeme()

  if (lexeme == undefined) {
    return
  }

  if (parser.query.allFields.indexOf(lexeme.str) == -1) {
    var possibleFields = parser.query.allFields.map(function (f) { return "'" + f + "'" }).join(', '),
        errorMessage = "unrecognised field '" + lexeme.str + "', possible fields: " + possibleFields

    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  parser.currentClause.fields = [lexeme.str]

  var nextLexeme = parser.peekLexeme()

  if (nextLexeme == undefined) {
    var errorMessage = "expecting term, found nothing"
    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  switch (nextLexeme.type) {
    case lunr.QueryLexer.TERM:
      return lunr.QueryParser.parseTerm
    default:
      var errorMessage = "expecting term, found '" + nextLexeme.type + "'"
      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
  }
}

lunr.QueryParser.parseTerm = function (parser) {
  var lexeme = parser.consumeLexeme()

  if (lexeme == undefined) {
    return
  }

  parser.currentClause.term = lexeme.str.toLowerCase()

  if (lexeme.str.indexOf("*") != -1) {
    parser.currentClause.usePipeline = false
  }

  var nextLexeme = parser.peekLexeme()

  if (nextLexeme == undefined) {
    parser.nextClause()
    return
  }

  switch (nextLexeme.type) {
    case lunr.QueryLexer.TERM:
      parser.nextClause()
      return lunr.QueryParser.parseTerm
    case lunr.QueryLexer.FIELD:
      parser.nextClause()
      return lunr.QueryParser.parseField
    case lunr.QueryLexer.EDIT_DISTANCE:
      return lunr.QueryParser.parseEditDistance
    case lunr.QueryLexer.BOOST:
      return lunr.QueryParser.parseBoost
    case lunr.QueryLexer.PRESENCE:
      parser.nextClause()
      return lunr.QueryParser.parsePresence
    default:
      var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
  }
}

lunr.QueryParser.parseEditDistance = function (parser) {
  var lexeme = parser.consumeLexeme()

  if (lexeme == undefined) {
    return
  }

  var editDistance = parseInt(lexeme.str, 10)

  if (isNaN(editDistance)) {
    var errorMessage = "edit distance must be numeric"
    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  parser.currentClause.editDistance = editDistance

  var nextLexeme = parser.peekLexeme()

  if (nextLexeme == undefined) {
    parser.nextClause()
    return
  }

  switch (nextLexeme.type) {
    case lunr.QueryLexer.TERM:
      parser.nextClause()
      return lunr.QueryParser.parseTerm
    case lunr.QueryLexer.FIELD:
      parser.nextClause()
      return lunr.QueryParser.parseField
    case lunr.QueryLexer.EDIT_DISTANCE:
      return lunr.QueryParser.parseEditDistance
    case lunr.QueryLexer.BOOST:
      return lunr.QueryParser.parseBoost
    case lunr.QueryLexer.PRESENCE:
      parser.nextClause()
      return lunr.QueryParser.parsePresence
    default:
      var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
  }
}

lunr.QueryParser.parseBoost = function (parser) {
  var lexeme = parser.consumeLexeme()

  if (lexeme == undefined) {
    return
  }

  var boost = parseInt(lexeme.str, 10)

  if (isNaN(boost)) {
    var errorMessage = "boost must be numeric"
    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
  }

  parser.currentClause.boost = boost

  var nextLexeme = parser.peekLexeme()

  if (nextLexeme == undefined) {
    parser.nextClause()
    return
  }

  switch (nextLexeme.type) {
    case lunr.QueryLexer.TERM:
      parser.nextClause()
      return lunr.QueryParser.parseTerm
    case lunr.QueryLexer.FIELD:
      parser.nextClause()
      return lunr.QueryParser.parseField
    case lunr.QueryLexer.EDIT_DISTANCE:
      return lunr.QueryParser.parseEditDistance
    case lunr.QueryLexer.BOOST:
      return lunr.QueryParser.parseBoost
    case lunr.QueryLexer.PRESENCE:
      parser.nextClause()
      return lunr.QueryParser.parsePresence
    default:
      var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
  }
}

  /**
   * export the module via AMD, CommonJS or as a browser global
   * Export code from https://github.com/umdjs/umd/blob/master/returnExports.js
   */
  ;(function (root, factory) {
    if (true) {
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    } else {}
  }(this, function () {
    /**
     * Just return a value to define the module export.
     * This example returns an object, but the module
     * can return a function as the exported value.
     */
    return lunr
  }))
})();


/***/ }),

/***/ "./node_modules/nanoid/format.js":
/*!***************************************!*\
  !*** ./node_modules/nanoid/format.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Secure random string generator with custom alphabet.
 *
 * Alphabet must contain 256 symbols or less. Otherwise, the generator
 * will not be secure.
 *
 * @param {generator} random The random bytes generator.
 * @param {string} alphabet Symbols to be used in new random string.
 * @param {size} size The number of symbols in new random string.
 *
 * @return {string} Random string.
 *
 * @example
 * const format = require('nanoid/format')
 *
 * function random (size) {
 *   const result = []
 *   for (let i = 0; i < size; i++) {
 *     result.push(randomByte())
 *   }
 *   return result
 * }
 *
 * format(random, "abcdef", 5) //=> "fbaef"
 *
 * @name format
 * @function
 */
module.exports = function (random, alphabet, size) {
  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1
  var step = Math.ceil(1.6 * mask * size / alphabet.length)

  var id = ''
  while (true) {
    var bytes = random(step)
    for (var i = 0; i < step; i++) {
      var byte = bytes[i] & mask
      if (alphabet[byte]) {
        id += alphabet[byte]
        if (id.length === size) return id
      }
    }
  }
}

/**
 * @callback generator
 * @param {number} bytes The number of bytes to generate.
 * @return {number[]} Random bytes.
 */


/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/shortid/index.js":
/*!***************************************!*\
  !*** ./node_modules/shortid/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = __webpack_require__(/*! ./lib/index */ "./node_modules/shortid/lib/index.js");


/***/ }),

/***/ "./node_modules/shortid/lib/alphabet.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/alphabet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var randomFromSeed = __webpack_require__(/*! ./random/random-from-seed */ "./node_modules/shortid/lib/random/random-from-seed.js");

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

function get () {
  return alphabet || ORIGINAL;
}

module.exports = {
    get: get,
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};


/***/ }),

/***/ "./node_modules/shortid/lib/build.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/build.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var generate = __webpack_require__(/*! ./generate */ "./node_modules/shortid/lib/generate.js");
var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1459707606518;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 6;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function build(clusterWorkerId) {
    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + generate(version);
    str = str + generate(clusterWorkerId);
    if (counter > 0) {
        str = str + generate(counter);
    }
    str = str + generate(seconds);
    return str;
}

module.exports = build;


/***/ }),

/***/ "./node_modules/shortid/lib/generate.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/generate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
var random = __webpack_require__(/*! ./random/random-byte */ "./node_modules/shortid/lib/random/random-byte-browser.js");
var format = __webpack_require__(/*! nanoid/format */ "./node_modules/nanoid/format.js");

function generate(number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + format(random, alphabet.get(), 1);
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

module.exports = generate;


/***/ }),

/***/ "./node_modules/shortid/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/shortid/lib/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");
var build = __webpack_require__(/*! ./build */ "./node_modules/shortid/lib/build.js");
var isValid = __webpack_require__(/*! ./is-valid */ "./node_modules/shortid/lib/is-valid.js");

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
var clusterWorkerId = __webpack_require__(/*! ./util/cluster-worker-id */ "./node_modules/shortid/lib/util/cluster-worker-id-browser.js") || 0;

/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}

/**
 * Generate unique id
 * Returns string id
 */
function generate() {
  return build(clusterWorkerId);
}

// Export all other functions as properties of the generate function
module.exports = generate;
module.exports.generate = generate;
module.exports.seed = seed;
module.exports.worker = worker;
module.exports.characters = characters;
module.exports.isValid = isValid;


/***/ }),

/***/ "./node_modules/shortid/lib/is-valid.js":
/*!**********************************************!*\
  !*** ./node_modules/shortid/lib/is-valid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var alphabet = __webpack_require__(/*! ./alphabet */ "./node_modules/shortid/lib/alphabet.js");

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var nonAlphabetic = new RegExp('[^' +
      alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') +
    ']');
    return !nonAlphabetic.test(id);
}

module.exports = isShortId;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-byte-browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-byte-browser.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

var randomByte;

if (!crypto || !crypto.getRandomValues) {
    randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
            bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
    };
} else {
    randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
    };
}

module.exports = randomByte;


/***/ }),

/***/ "./node_modules/shortid/lib/random/random-from-seed.js":
/*!*************************************************************!*\
  !*** ./node_modules/shortid/lib/random/random-from-seed.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed(_seed_) {
    seed = _seed_;
}

module.exports = {
    nextValue: getNextValue,
    seed: setSeed
};


/***/ }),

/***/ "./node_modules/shortid/lib/util/cluster-worker-id-browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/shortid/lib/util/cluster-worker-id-browser.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = 0;


/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/svelte/index.mjs":
/*!***************************************!*\
  !*** ./node_modules/svelte/index.mjs ***!
  \***************************************/
/*! exports provided: onMount, onDestroy, beforeUpdate, afterUpdate, setContext, getContext, tick, createEventDispatcher */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "./node_modules/svelte/internal.mjs");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onMount", function() { return _internal__WEBPACK_IMPORTED_MODULE_0__["onMount"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onDestroy", function() { return _internal__WEBPACK_IMPORTED_MODULE_0__["onDestroy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "beforeUpdate", function() { return _internal__WEBPACK_IMPORTED_MODULE_0__["beforeUpdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "afterUpdate", function() { return _internal__WEBPACK_IMPORTED_MODULE_0__["afterUpdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setContext", function() { return _internal__WEBPACK_IMPORTED_MODULE_0__["setContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContext", function() { return _internal__WEBPACK_IMPORTED_MODULE_0__["getContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tick", function() { return _internal__WEBPACK_IMPORTED_MODULE_0__["tick"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createEventDispatcher", function() { return _internal__WEBPACK_IMPORTED_MODULE_0__["createEventDispatcher"]; });




/***/ }),

/***/ "./node_modules/svelte/internal.mjs":
/*!******************************************!*\
  !*** ./node_modules/svelte/internal.mjs ***!
  \******************************************/
/*! exports provided: create_animation, fix_position, handle_promise, append, insert, detach, detach_between, detach_before, detach_after, destroy_each, element, object_without_properties, svg_element, text, space, empty, listen, prevent_default, stop_propagation, attr, set_attributes, set_custom_element_data, xlink_attr, get_binding_group_value, to_number, time_ranges_to_array, children, claim_element, claim_text, set_data, set_input_type, set_style, select_option, select_options, select_value, select_multiple_value, add_resize_listener, toggle_class, custom_event, destroy_block, outro_and_destroy_block, fix_and_outro_and_destroy_block, update_keyed_each, measure, current_component, set_current_component, beforeUpdate, onMount, afterUpdate, onDestroy, createEventDispatcher, setContext, getContext, bubble, clear_loops, loop, dirty_components, intros, schedule_update, tick, add_binding_callback, add_render_callback, add_flush_callback, flush, get_spread_update, invalid_attribute_name_character, spread, escaped, escape, each, missing_component, validate_component, debug, create_ssr_component, get_store_value, group_outros, check_outros, on_outro, create_in_transition, create_out_transition, create_bidirectional_transition, noop, identity, assign, is_promise, add_location, run, blank_object, run_all, is_function, safe_not_equal, not_equal, validate_store, subscribe, create_slot, get_slot_context, get_slot_changes, exclude_internal_props, bind, mount_component, init, SvelteElement, SvelteComponent, SvelteComponentDev */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create_animation", function() { return create_animation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fix_position", function() { return fix_position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handle_promise", function() { return handle_promise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "append", function() { return append; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insert", function() { return insert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detach", function() { return detach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detach_between", function() { return detach_between; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detach_before", function() { return detach_before; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detach_after", function() { return detach_after; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "destroy_each", function() { return destroy_each; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "element", function() { return element; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "object_without_properties", function() { return object_without_properties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "svg_element", function() { return svg_element; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "text", function() { return text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "space", function() { return space; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return empty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listen", function() { return listen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prevent_default", function() { return prevent_default; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stop_propagation", function() { return stop_propagation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attr", function() { return attr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set_attributes", function() { return set_attributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set_custom_element_data", function() { return set_custom_element_data; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xlink_attr", function() { return xlink_attr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get_binding_group_value", function() { return get_binding_group_value; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "to_number", function() { return to_number; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "time_ranges_to_array", function() { return time_ranges_to_array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "children", function() { return children; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "claim_element", function() { return claim_element; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "claim_text", function() { return claim_text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set_data", function() { return set_data; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set_input_type", function() { return set_input_type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set_style", function() { return set_style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "select_option", function() { return select_option; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "select_options", function() { return select_options; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "select_value", function() { return select_value; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "select_multiple_value", function() { return select_multiple_value; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add_resize_listener", function() { return add_resize_listener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggle_class", function() { return toggle_class; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "custom_event", function() { return custom_event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "destroy_block", function() { return destroy_block; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outro_and_destroy_block", function() { return outro_and_destroy_block; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fix_and_outro_and_destroy_block", function() { return fix_and_outro_and_destroy_block; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "update_keyed_each", function() { return update_keyed_each; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measure", function() { return measure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "current_component", function() { return current_component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set_current_component", function() { return set_current_component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beforeUpdate", function() { return beforeUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onMount", function() { return onMount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterUpdate", function() { return afterUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onDestroy", function() { return onDestroy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEventDispatcher", function() { return createEventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setContext", function() { return setContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContext", function() { return getContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bubble", function() { return bubble; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear_loops", function() { return clear_loops; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loop", function() { return loop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dirty_components", function() { return dirty_components; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intros", function() { return intros; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "schedule_update", function() { return schedule_update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tick", function() { return tick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add_binding_callback", function() { return add_binding_callback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add_render_callback", function() { return add_render_callback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add_flush_callback", function() { return add_flush_callback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flush", function() { return flush; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get_spread_update", function() { return get_spread_update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invalid_attribute_name_character", function() { return invalid_attribute_name_character; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spread", function() { return spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escaped", function() { return escaped; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escape", function() { return escape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "each", function() { return each; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "missing_component", function() { return missing_component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validate_component", function() { return validate_component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debug", function() { return debug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create_ssr_component", function() { return create_ssr_component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get_store_value", function() { return get_store_value; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "group_outros", function() { return group_outros; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "check_outros", function() { return check_outros; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on_outro", function() { return on_outro; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create_in_transition", function() { return create_in_transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create_out_transition", function() { return create_out_transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create_bidirectional_transition", function() { return create_bidirectional_transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return noop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "is_promise", function() { return is_promise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add_location", function() { return add_location; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "run", function() { return run; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blank_object", function() { return blank_object; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "run_all", function() { return run_all; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "is_function", function() { return is_function; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "safe_not_equal", function() { return safe_not_equal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "not_equal", function() { return not_equal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validate_store", function() { return validate_store; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subscribe", function() { return subscribe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create_slot", function() { return create_slot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get_slot_context", function() { return get_slot_context; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get_slot_changes", function() { return get_slot_changes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exclude_internal_props", function() { return exclude_internal_props; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bind", function() { return bind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mount_component", function() { return mount_component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SvelteElement", function() { return SvelteElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SvelteComponent", function() { return SvelteComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SvelteComponentDev", function() { return SvelteComponentDev; });
function noop() {}

const identity = x => x;

function assign(tar, src) {
	for (const k in src) tar[k] = src[k];
	return tar;
}

function is_promise(value) {
	return value && typeof value.then === 'function';
}

function add_location(element, file, line, column, char) {
	element.__svelte_meta = {
		loc: { file, line, column, char }
	};
}

function run(fn) {
	return fn();
}

function blank_object() {
	return Object.create(null);
}

function run_all(fns) {
	fns.forEach(run);
}

function is_function(thing) {
	return typeof thing === 'function';
}

function safe_not_equal(a, b) {
	return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}

function not_equal(a, b) {
	return a != a ? b == b : a !== b;
}

function validate_store(store, name) {
	if (!store || typeof store.subscribe !== 'function') {
		throw new Error(`'${name}' is not a store with a 'subscribe' method`);
	}
}

function subscribe(component, store, callback) {
	const unsub = store.subscribe(callback);

	component.$$.on_destroy.push(unsub.unsubscribe
		? () => unsub.unsubscribe()
		: unsub);
}

function create_slot(definition, ctx, fn) {
	if (definition) {
		const slot_ctx = get_slot_context(definition, ctx, fn);
		return definition[0](slot_ctx);
	}
}

function get_slot_context(definition, ctx, fn) {
	return definition[1]
		? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
		: ctx.$$scope.ctx;
}

function get_slot_changes(definition, ctx, changed, fn) {
	return definition[1]
		? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
		: ctx.$$scope.changed || {};
}

function exclude_internal_props(props) {
	const result = {};
	for (const k in props) if (k[0] !== '$') result[k] = props[k];
	return result;
}

const tasks = new Set();
let running = false;

function run_tasks() {
	tasks.forEach(task => {
		if (!task[0](window.performance.now())) {
			tasks.delete(task);
			task[1]();
		}
	});

	running = tasks.size > 0;
	if (running) requestAnimationFrame(run_tasks);
}

function clear_loops() {
	// for testing...
	tasks.forEach(task => tasks.delete(task));
	running = false;
}

function loop(fn) {
	let task;

	if (!running) {
		running = true;
		requestAnimationFrame(run_tasks);
	}

	return {
		promise: new Promise(fulfil => {
			tasks.add(task = [fn, fulfil]);
		}),
		abort() {
			tasks.delete(task);
		}
	};
}

function append(target, node) {
	target.appendChild(node);
}

function insert(target, node, anchor) {
	target.insertBefore(node, anchor || null);
}

function detach(node) {
	node.parentNode.removeChild(node);
}

function detach_between(before, after) {
	while (before.nextSibling && before.nextSibling !== after) {
		before.parentNode.removeChild(before.nextSibling);
	}
}

function detach_before(after) {
	while (after.previousSibling) {
		after.parentNode.removeChild(after.previousSibling);
	}
}

function detach_after(before) {
	while (before.nextSibling) {
		before.parentNode.removeChild(before.nextSibling);
	}
}

function destroy_each(iterations, detaching) {
	for (let i = 0; i < iterations.length; i += 1) {
		if (iterations[i]) iterations[i].d(detaching);
	}
}

function element(name) {
	return document.createElement(name);
}

function object_without_properties(obj, exclude) {
	const target = {};
	for (const k in obj) {
		if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) {
			target[k] = obj[k];
		}
	}
	return target;
}

function svg_element(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

function text(data) {
	return document.createTextNode(data);
}

function space() {
	return text(' ');
}

function empty() {
	return text('');
}

function listen(node, event, handler, options) {
	node.addEventListener(event, handler, options);
	return () => node.removeEventListener(event, handler, options);
}

function prevent_default(fn) {
	return function(event) {
		event.preventDefault();
		return fn.call(this, event);
	};
}

function stop_propagation(fn) {
	return function(event) {
		event.stopPropagation();
		return fn.call(this, event);
	};
}

function attr(node, attribute, value) {
	if (value == null) node.removeAttribute(attribute);
	else node.setAttribute(attribute, value);
}

function set_attributes(node, attributes) {
	for (const key in attributes) {
		if (key === 'style') {
			node.style.cssText = attributes[key];
		} else if (key in node) {
			node[key] = attributes[key];
		} else {
			attr(node, key, attributes[key]);
		}
	}
}

function set_custom_element_data(node, prop, value) {
	if (prop in node) {
		node[prop] = value;
	} else {
		attr(node, prop, value);
	}
}

function xlink_attr(node, attribute, value) {
	node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}

function get_binding_group_value(group) {
	const value = [];
	for (let i = 0; i < group.length; i += 1) {
		if (group[i].checked) value.push(group[i].__value);
	}
	return value;
}

function to_number(value) {
	return value === '' ? undefined : +value;
}

function time_ranges_to_array(ranges) {
	const array = [];
	for (let i = 0; i < ranges.length; i += 1) {
		array.push({ start: ranges.start(i), end: ranges.end(i) });
	}
	return array;
}

function children(element) {
	return Array.from(element.childNodes);
}

function claim_element(nodes, name, attributes, svg) {
	for (let i = 0; i < nodes.length; i += 1) {
		const node = nodes[i];
		if (node.nodeName === name) {
			for (let j = 0; j < node.attributes.length; j += 1) {
				const attribute = node.attributes[j];
				if (!attributes[attribute.name]) node.removeAttribute(attribute.name);
			}
			return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes
		}
	}

	return svg ? svg_element(name) : element(name);
}

function claim_text(nodes, data) {
	for (let i = 0; i < nodes.length; i += 1) {
		const node = nodes[i];
		if (node.nodeType === 3) {
			node.data = data;
			return nodes.splice(i, 1)[0];
		}
	}

	return text(data);
}

function set_data(text, data) {
	data = '' + data;
	if (text.data !== data) text.data = data;
}

function set_input_type(input, type) {
	try {
		input.type = type;
	} catch (e) {
		// do nothing
	}
}

function set_style(node, key, value) {
	node.style.setProperty(key, value);
}

function select_option(select, value) {
	for (let i = 0; i < select.options.length; i += 1) {
		const option = select.options[i];

		if (option.__value === value) {
			option.selected = true;
			return;
		}
	}
}

function select_options(select, value) {
	for (let i = 0; i < select.options.length; i += 1) {
		const option = select.options[i];
		option.selected = ~value.indexOf(option.__value);
	}
}

function select_value(select) {
	const selected_option = select.querySelector(':checked') || select.options[0];
	return selected_option && selected_option.__value;
}

function select_multiple_value(select) {
	return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
}

function add_resize_listener(element, fn) {
	if (getComputedStyle(element).position === 'static') {
		element.style.position = 'relative';
	}

	const object = document.createElement('object');
	object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');
	object.type = 'text/html';

	let win;

	object.onload = () => {
		win = object.contentDocument.defaultView;
		win.addEventListener('resize', fn);
	};

	if (/Trident/.test(navigator.userAgent)) {
		element.appendChild(object);
		object.data = 'about:blank';
	} else {
		object.data = 'about:blank';
		element.appendChild(object);
	}

	return {
		cancel: () => {
			win && win.removeEventListener && win.removeEventListener('resize', fn);
			element.removeChild(object);
		}
	};
}

function toggle_class(element, name, toggle) {
	element.classList[toggle ? 'add' : 'remove'](name);
}

function custom_event(type, detail) {
	const e = document.createEvent('CustomEvent');
	e.initCustomEvent(type, false, false, detail);
	return e;
}

let stylesheet;
let active = 0;
let current_rules = {};

// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
	let hash = 5381;
	let i = str.length;

	while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
	return hash >>> 0;
}

function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
	const step = 16.666 / duration;
	let keyframes = '{\n';

	for (let p = 0; p <= 1; p += step) {
		const t = a + (b - a) * ease(p);
		keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
	}

	const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
	const name = `__svelte_${hash(rule)}_${uid}`;

	if (!current_rules[name]) {
		if (!stylesheet) {
			const style = element('style');
			document.head.appendChild(style);
			stylesheet = style.sheet;
		}

		current_rules[name] = true;
		stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
	}

	const animation = node.style.animation || '';
	node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;

	active += 1;
	return name;
}

function delete_rule(node, name) {
	node.style.animation = (node.style.animation || '')
		.split(', ')
		.filter(name
			? anim => anim.indexOf(name) < 0 // remove specific animation
			: anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
		)
		.join(', ');

	if (name && !--active) clear_rules();
}

function clear_rules() {
	requestAnimationFrame(() => {
		if (active) return;
		let i = stylesheet.cssRules.length;
		while (i--) stylesheet.deleteRule(i);
		current_rules = {};
	});
}

function create_animation(node, from, fn, params) {
	if (!from) return noop;

	const to = node.getBoundingClientRect();
	if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;

	const {
		delay = 0,
		duration = 300,
		easing = identity,
		start: start_time = window.performance.now() + delay,
		end = start_time + duration,
		tick = noop,
		css
	} = fn(node, { from, to }, params);

	let running = true;
	let started = false;
	let name;

	const css_text = node.style.cssText;

	function start() {
		if (css) {
			if (delay) node.style.cssText = css_text; // TODO create delayed animation instead?
			name = create_rule(node, 0, 1, duration, 0, easing, css);
		}

		started = true;
	}

	function stop() {
		if (css) delete_rule(node, name);
		running = false;
	}

	loop(now => {
		if (!started && now >= start_time) {
			start();
		}

		if (started && now >= end) {
			tick(1, 0);
			stop();
		}

		if (!running) {
			return false;
		}

		if (started) {
			const p = now - start_time;
			const t = 0 + 1 * easing(p / duration);
			tick(t, 1 - t);
		}

		return true;
	});

	if (delay) {
		if (css) node.style.cssText += css(0, 1);
	} else {
		start();
	}

	tick(0, 1);

	return stop;
}

function fix_position(node) {
	const style = getComputedStyle(node);

	if (style.position !== 'absolute' && style.position !== 'fixed') {
		const { width, height } = style;
		const a = node.getBoundingClientRect();
		node.style.position = 'absolute';
		node.style.width = width;
		node.style.height = height;
		const b = node.getBoundingClientRect();

		if (a.left !== b.left || a.top !== b.top) {
			const style = getComputedStyle(node);
			const transform = style.transform === 'none' ? '' : style.transform;

			node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
		}
	}
}

let current_component;

function set_current_component(component) {
	current_component = component;
}

function get_current_component() {
	if (!current_component) throw new Error(`Function called outside component initialization`);
	return current_component;
}

function beforeUpdate(fn) {
	get_current_component().$$.before_render.push(fn);
}

function onMount(fn) {
	get_current_component().$$.on_mount.push(fn);
}

function afterUpdate(fn) {
	get_current_component().$$.after_render.push(fn);
}

function onDestroy(fn) {
	get_current_component().$$.on_destroy.push(fn);
}

function createEventDispatcher() {
	const component = current_component;

	return (type, detail) => {
		const callbacks = component.$$.callbacks[type];

		if (callbacks) {
			// TODO are there situations where events could be dispatched
			// in a server (non-DOM) environment?
			const event = custom_event(type, detail);
			callbacks.slice().forEach(fn => {
				fn.call(component, event);
			});
		}
	};
}

function setContext(key, context) {
	get_current_component().$$.context.set(key, context);
}

function getContext(key) {
	return get_current_component().$$.context.get(key);
}

// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
	const callbacks = component.$$.callbacks[event.type];

	if (callbacks) {
		callbacks.slice().forEach(fn => fn(event));
	}
}

const dirty_components = [];
const intros = { enabled: false };

const resolved_promise = Promise.resolve();
let update_scheduled = false;
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];

function schedule_update() {
	if (!update_scheduled) {
		update_scheduled = true;
		resolved_promise.then(flush);
	}
}

function tick() {
	schedule_update();
	return resolved_promise;
}

function add_binding_callback(fn) {
	binding_callbacks.push(fn);
}

function add_render_callback(fn) {
	render_callbacks.push(fn);
}

function add_flush_callback(fn) {
	flush_callbacks.push(fn);
}

function flush() {
	const seen_callbacks = new Set();

	do {
		// first, call beforeUpdate functions
		// and update components
		while (dirty_components.length) {
			const component = dirty_components.shift();
			set_current_component(component);
			update(component.$$);
		}

		while (binding_callbacks.length) binding_callbacks.shift()();

		// then, once components are updated, call
		// afterUpdate functions. This may cause
		// subsequent updates...
		while (render_callbacks.length) {
			const callback = render_callbacks.pop();
			if (!seen_callbacks.has(callback)) {
				callback();

				// ...so guard against infinite loops
				seen_callbacks.add(callback);
			}
		}
	} while (dirty_components.length);

	while (flush_callbacks.length) {
		flush_callbacks.pop()();
	}

	update_scheduled = false;
}

function update($$) {
	if ($$.fragment) {
		$$.update($$.dirty);
		run_all($$.before_render);
		$$.fragment.p($$.dirty, $$.ctx);
		$$.dirty = null;

		$$.after_render.forEach(add_render_callback);
	}
}

let promise;

function wait() {
	if (!promise) {
		promise = Promise.resolve();
		promise.then(() => {
			promise = null;
		});
	}

	return promise;
}

function dispatch(node, direction, kind) {
	node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}

let outros;

function group_outros() {
	outros = {
		remaining: 0,
		callbacks: []
	};
}

function check_outros() {
	if (!outros.remaining) {
		run_all(outros.callbacks);
	}
}

function on_outro(callback) {
	outros.callbacks.push(callback);
}

function create_in_transition(node, fn, params) {
	let config = fn(node, params);
	let running = false;
	let animation_name;
	let task;
	let uid = 0;

	function cleanup() {
		if (animation_name) delete_rule(node, animation_name);
	}

	function go() {
		const {
			delay = 0,
			duration = 300,
			easing = identity,
			tick: tick$$1 = noop,
			css
		} = config;

		if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
		tick$$1(0, 1);

		const start_time = window.performance.now() + delay;
		const end_time = start_time + duration;

		if (task) task.abort();
		running = true;

		task = loop(now => {
			if (running) {
				if (now >= end_time) {
					tick$$1(1, 0);
					cleanup();
					return running = false;
				}

				if (now >= start_time) {
					const t = easing((now - start_time) / duration);
					tick$$1(t, 1 - t);
				}
			}

			return running;
		});
	}

	let started = false;

	return {
		start() {
			if (started) return;

			delete_rule(node);

			if (typeof config === 'function') {
				config = config();
				wait().then(go);
			} else {
				go();
			}
		},

		invalidate() {
			started = false;
		},

		end() {
			if (running) {
				cleanup();
				running = false;
			}
		}
	};
}

function create_out_transition(node, fn, params) {
	let config = fn(node, params);
	let running = true;
	let animation_name;

	const group = outros;

	group.remaining += 1;

	function go() {
		const {
			delay = 0,
			duration = 300,
			easing = identity,
			tick: tick$$1 = noop,
			css
		} = config;

		if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);

		const start_time = window.performance.now() + delay;
		const end_time = start_time + duration;

		loop(now => {
			if (running) {
				if (now >= end_time) {
					tick$$1(0, 1);

					if (!--group.remaining) {
						// this will result in `end()` being called,
						// so we don't need to clean up here
						run_all(group.callbacks);
					}

					return false;
				}

				if (now >= start_time) {
					const t = easing((now - start_time) / duration);
					tick$$1(1 - t, t);
				}
			}

			return running;
		});
	}

	if (typeof config === 'function') {
		wait().then(() => {
			config = config();
			go();
		});
	} else {
		go();
	}

	return {
		end(reset) {
			if (reset && config.tick) {
				config.tick(1, 0);
			}

			if (running) {
				if (animation_name) delete_rule(node, animation_name);
				running = false;
			}
		}
	};
}

function create_bidirectional_transition(node, fn, params, intro) {
	let config = fn(node, params);

	let t = intro ? 0 : 1;

	let running_program = null;
	let pending_program = null;
	let animation_name = null;

	function clear_animation() {
		if (animation_name) delete_rule(node, animation_name);
	}

	function init(program, duration) {
		const d = program.b - t;
		duration *= Math.abs(d);

		return {
			a: t,
			b: program.b,
			d,
			duration,
			start: program.start,
			end: program.start + duration,
			group: program.group
		};
	}

	function go(b) {
		const {
			delay = 0,
			duration = 300,
			easing = identity,
			tick: tick$$1 = noop,
			css
		} = config;

		const program = {
			start: window.performance.now() + delay,
			b
		};

		if (!b) {
			program.group = outros;
			outros.remaining += 1;
		}

		if (running_program) {
			pending_program = program;
		} else {
			// if this is an intro, and there's a delay, we need to do
			// an initial tick and/or apply CSS animation immediately
			if (css) {
				clear_animation();
				animation_name = create_rule(node, t, b, duration, delay, easing, css);
			}

			if (b) tick$$1(0, 1);

			running_program = init(program, duration);
			add_render_callback(() => dispatch(node, b, 'start'));

			loop(now => {
				if (pending_program && now > pending_program.start) {
					running_program = init(pending_program, duration);
					pending_program = null;

					dispatch(node, running_program.b, 'start');

					if (css) {
						clear_animation();
						animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
					}
				}

				if (running_program) {
					if (now >= running_program.end) {
						tick$$1(t = running_program.b, 1 - t);
						dispatch(node, running_program.b, 'end');

						if (!pending_program) {
							// we're done
							if (running_program.b) {
								// intro  we can tidy up immediately
								clear_animation();
							} else {
								// outro  needs to be coordinated
								if (!--running_program.group.remaining) run_all(running_program.group.callbacks);
							}
						}

						running_program = null;
					}

					else if (now >= running_program.start) {
						const p = now - running_program.start;
						t = running_program.a + running_program.d * easing(p / running_program.duration);
						tick$$1(t, 1 - t);
					}
				}

				return !!(running_program || pending_program);
			});
		}
	}

	return {
		run(b) {
			if (typeof config === 'function') {
				wait().then(() => {
					config = config();
					go(b);
				});
			} else {
				go(b);
			}
		},

		end() {
			clear_animation();
			running_program = pending_program = null;
		}
	};
}

function handle_promise(promise, info) {
	const token = info.token = {};

	function update(type, index, key, value) {
		if (info.token !== token) return;

		info.resolved = key && { [key]: value };

		const child_ctx = assign(assign({}, info.ctx), info.resolved);
		const block = type && (info.current = type)(child_ctx);

		if (info.block) {
			if (info.blocks) {
				info.blocks.forEach((block, i) => {
					if (i !== index && block) {
						group_outros();
						on_outro(() => {
							block.d(1);
							info.blocks[i] = null;
						});
						block.o(1);
						check_outros();
					}
				});
			} else {
				info.block.d(1);
			}

			block.c();
			if (block.i) block.i(1);
			block.m(info.mount(), info.anchor);

			flush();
		}

		info.block = block;
		if (info.blocks) info.blocks[index] = block;
	}

	if (is_promise(promise)) {
		promise.then(value => {
			update(info.then, 1, info.value, value);
		}, error => {
			update(info.catch, 2, info.error, error);
		});

		// if we previously had a then/catch block, destroy it
		if (info.current !== info.pending) {
			update(info.pending, 0);
			return true;
		}
	} else {
		if (info.current !== info.then) {
			update(info.then, 1, info.value, promise);
			return true;
		}

		info.resolved = { [info.value]: promise };
	}
}

function destroy_block(block, lookup) {
	block.d(1);
	lookup.delete(block.key);
}

function outro_and_destroy_block(block, lookup) {
	on_outro(() => {
		destroy_block(block, lookup);
	});

	block.o(1);
}

function fix_and_outro_and_destroy_block(block, lookup) {
	block.f();
	outro_and_destroy_block(block, lookup);
}

function update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
	let o = old_blocks.length;
	let n = list.length;

	let i = o;
	const old_indexes = {};
	while (i--) old_indexes[old_blocks[i].key] = i;

	const new_blocks = [];
	const new_lookup = new Map();
	const deltas = new Map();

	i = n;
	while (i--) {
		const child_ctx = get_context(ctx, list, i);
		const key = get_key(child_ctx);
		let block = lookup.get(key);

		if (!block) {
			block = create_each_block(key, child_ctx);
			block.c();
		} else if (dynamic) {
			block.p(changed, child_ctx);
		}

		new_lookup.set(key, new_blocks[i] = block);

		if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
	}

	const will_move = new Set();
	const did_move = new Set();

	function insert(block) {
		if (block.i) block.i(1);
		block.m(node, next);
		lookup.set(block.key, block);
		next = block.first;
		n--;
	}

	while (o && n) {
		const new_block = new_blocks[n - 1];
		const old_block = old_blocks[o - 1];
		const new_key = new_block.key;
		const old_key = old_block.key;

		if (new_block === old_block) {
			// do nothing
			next = new_block.first;
			o--;
			n--;
		}

		else if (!new_lookup.has(old_key)) {
			// remove old block
			destroy(old_block, lookup);
			o--;
		}

		else if (!lookup.has(new_key) || will_move.has(new_key)) {
			insert(new_block);
		}

		else if (did_move.has(old_key)) {
			o--;

		} else if (deltas.get(new_key) > deltas.get(old_key)) {
			did_move.add(new_key);
			insert(new_block);

		} else {
			will_move.add(old_key);
			o--;
		}
	}

	while (o--) {
		const old_block = old_blocks[o];
		if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
	}

	while (n) insert(new_blocks[n - 1]);

	return new_blocks;
}

function measure(blocks) {
	const rects = {};
	let i = blocks.length;
	while (i--) rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();
	return rects;
}

function get_spread_update(levels, updates) {
	const update = {};

	const to_null_out = {};
	const accounted_for = { $$scope: 1 };

	let i = levels.length;
	while (i--) {
		const o = levels[i];
		const n = updates[i];

		if (n) {
			for (const key in o) {
				if (!(key in n)) to_null_out[key] = 1;
			}

			for (const key in n) {
				if (!accounted_for[key]) {
					update[key] = n[key];
					accounted_for[key] = 1;
				}
			}

			levels[i] = n;
		} else {
			for (const key in o) {
				accounted_for[key] = 1;
			}
		}
	}

	for (const key in to_null_out) {
		if (!(key in update)) update[key] = undefined;
	}

	return update;
}

const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter

function spread(args) {
	const attributes = Object.assign({}, ...args);
	let str = '';

	Object.keys(attributes).forEach(name => {
		if (invalid_attribute_name_character.test(name)) return;

		const value = attributes[name];
		if (value === undefined) return;
		if (value === true) str += " " + name;

		const escaped = String(value)
			.replace(/"/g, '&#34;')
			.replace(/'/g, '&#39;');

		str += " " + name + "=" + JSON.stringify(escaped);
	});

	return str;
}

const escaped = {
	'"': '&quot;',
	"'": '&#39;',
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;'
};

function escape(html) {
	return String(html).replace(/["'&<>]/g, match => escaped[match]);
}

function each(items, fn) {
	let str = '';
	for (let i = 0; i < items.length; i += 1) {
		str += fn(items[i], i);
	}
	return str;
}

const missing_component = {
	$$render: () => ''
};

function validate_component(component, name) {
	if (!component || !component.$$render) {
		if (name === 'svelte:component') name += ' this={...}';
		throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
	}

	return component;
}

function debug(file, line, column, values) {
	console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
	console.log(values); // eslint-disable-line no-console
	return '';
}

let on_destroy;

function create_ssr_component(fn) {
	function $$render(result, props, bindings, slots) {
		const parent_component = current_component;

		const $$ = {
			on_destroy,
			context: new Map(parent_component ? parent_component.$$.context : []),

			// these will be immediately discarded
			on_mount: [],
			before_render: [],
			after_render: [],
			callbacks: blank_object()
		};

		set_current_component({ $$ });

		const html = fn(result, props, bindings, slots);

		set_current_component(parent_component);
		return html;
	}

	return {
		render: (props = {}, options = {}) => {
			on_destroy = [];

			const result = { head: '', css: new Set() };
			const html = $$render(result, props, {}, options);

			run_all(on_destroy);

			return {
				html,
				css: {
					code: Array.from(result.css).map(css => css.code).join('\n'),
					map: null // TODO
				},
				head: result.head
			};
		},

		$$render
	};
}

function get_store_value(store) {
	let value;
	store.subscribe(_ => value = _)();
	return value;
}

function bind(component, name, callback) {
	if (component.$$.props.indexOf(name) === -1) return;
	component.$$.bound[name] = callback;
	callback(component.$$.ctx[name]);
}

function mount_component(component, target, anchor) {
	const { fragment, on_mount, on_destroy, after_render } = component.$$;

	fragment.m(target, anchor);

	// onMount happens after the initial afterUpdate. Because
	// afterUpdate callbacks happen in reverse order (inner first)
	// we schedule onMount callbacks before afterUpdate callbacks
	add_render_callback(() => {
		const new_on_destroy = on_mount.map(run).filter(is_function);
		if (on_destroy) {
			on_destroy.push(...new_on_destroy);
		} else {
			// Edge case - component was destroyed immediately,
			// most likely as a result of a binding initialising
			run_all(new_on_destroy);
		}
		component.$$.on_mount = [];
	});

	after_render.forEach(add_render_callback);
}

function destroy(component, detaching) {
	if (component.$$) {
		run_all(component.$$.on_destroy);
		component.$$.fragment.d(detaching);

		// TODO null out other refs, including component.$$ (but need to
		// preserve final state?)
		component.$$.on_destroy = component.$$.fragment = null;
		component.$$.ctx = {};
	}
}

function make_dirty(component, key) {
	if (!component.$$.dirty) {
		dirty_components.push(component);
		schedule_update();
		component.$$.dirty = blank_object();
	}
	component.$$.dirty[key] = true;
}

function init(component, options, instance, create_fragment, not_equal$$1, prop_names) {
	const parent_component = current_component;
	set_current_component(component);

	const props = options.props || {};

	const $$ = component.$$ = {
		fragment: null,
		ctx: null,

		// state
		props: prop_names,
		update: noop,
		not_equal: not_equal$$1,
		bound: blank_object(),

		// lifecycle
		on_mount: [],
		on_destroy: [],
		before_render: [],
		after_render: [],
		context: new Map(parent_component ? parent_component.$$.context : []),

		// everything else
		callbacks: blank_object(),
		dirty: null
	};

	let ready = false;

	$$.ctx = instance
		? instance(component, props, (key, value) => {
			if ($$.ctx && not_equal$$1($$.ctx[key], $$.ctx[key] = value)) {
				if ($$.bound[key]) $$.bound[key](value);
				if (ready) make_dirty(component, key);
			}
		})
		: props;

	$$.update();
	ready = true;
	run_all($$.before_render);
	$$.fragment = create_fragment($$.ctx);

	if (options.target) {
		if (options.hydrate) {
			$$.fragment.l(children(options.target));
		} else {
			$$.fragment.c();
		}

		if (options.intro && component.$$.fragment.i) component.$$.fragment.i();
		mount_component(component, options.target, options.anchor);
		flush();
	}

	set_current_component(parent_component);
}

let SvelteElement;
if (typeof HTMLElement !== 'undefined') {
	SvelteElement = class extends HTMLElement {
		constructor() {
			super();
			this.attachShadow({ mode: 'open' });
		}

		connectedCallback() {
			for (const key in this.$$.slotted) {
				this.appendChild(this.$$.slotted[key]);
			}
		}

		attributeChangedCallback(attr$$1, oldValue, newValue) {
			this[attr$$1] = newValue;
		}

		$destroy() {
			destroy(this, true);
			this.$destroy = noop;
		}

		$on(type, callback) {
			// TODO should this delegate to addEventListener?
			const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
			callbacks.push(callback);

			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		$set() {
			// overridden by instance, if it has props
		}
	};
}

class SvelteComponent {
	$destroy() {
		destroy(this, true);
		this.$destroy = noop;
	}

	$on(type, callback) {
		const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
		callbacks.push(callback);

		return () => {
			const index = callbacks.indexOf(callback);
			if (index !== -1) callbacks.splice(index, 1);
		};
	}

	$set() {
		// overridden by instance, if it has props
	}
}

class SvelteComponentDev extends SvelteComponent {
	constructor(options) {
		if (!options || (!options.target && !options.$$inline)) {
			throw new Error(`'target' is a required option`);
		}

		super();
	}

	$destroy() {
		super.$destroy();
		this.$destroy = () => {
			console.warn(`Component was already destroyed`); // eslint-disable-line no-console
		};
	}
}




/***/ }),

/***/ "./node_modules/svelte/store.mjs":
/*!***************************************!*\
  !*** ./node_modules/svelte/store.mjs ***!
  \***************************************/
/*! exports provided: readable, writable, derived, get */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readable", function() { return readable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writable", function() { return writable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "derived", function() { return derived; });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "./node_modules/svelte/internal.mjs");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "get", function() { return _internal__WEBPACK_IMPORTED_MODULE_0__["get_store_value"]; });



function readable(value, start) {
	return {
		subscribe: writable(value, start).subscribe
	};
}

function writable(value, start = _internal__WEBPACK_IMPORTED_MODULE_0__["noop"]) {
	let stop;
	const subscribers = [];

	function set(new_value) {
		if (Object(_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"])(value, new_value)) {
			value = new_value;
			if (!stop) return; // not ready
			subscribers.forEach(s => s[1]());
			subscribers.forEach(s => s[0](value));
		}
	}

	function update(fn) {
		set(fn(value));
	}

	function subscribe(run, invalidate = _internal__WEBPACK_IMPORTED_MODULE_0__["noop"]) {
		const subscriber = [run, invalidate];
		subscribers.push(subscriber);
		if (subscribers.length === 1) stop = start(set) || _internal__WEBPACK_IMPORTED_MODULE_0__["noop"];
		run(value);

		return () => {
			const index = subscribers.indexOf(subscriber);
			if (index !== -1) subscribers.splice(index, 1);
			if (subscribers.length === 0) stop();
		};
	}

	return { set, update, subscribe };
}

function derived(stores, fn, initial_value) {
	const single = !Array.isArray(stores);
	if (single) stores = [stores];

	const auto = fn.length < 2;
	let value = {};

	return readable(initial_value, set => {
		let inited = false;
		const values = [];

		let pending = 0;

		const sync = () => {
			if (pending) return;
			const result = fn(single ? values[0] : values, set);
			if (auto) set(result);
		};

		const unsubscribers = stores.map((store, i) => store.subscribe(
			value => {
				values[i] = value;
				pending &= ~(1 << i);
				if (inited) sync();
			},
			() => {
				pending |= (1 << i);
			})
		);

		inited = true;
		sync();

		return function stop() {
			Object(_internal__WEBPACK_IMPORTED_MODULE_0__["run_all"])(unsubscribers);
		};
	});
}




/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/App.html":
/*!**********************!*\
  !*** ./src/App.html ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _NoPackage_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NoPackage.html */ "./src/NoPackage.html");
/* harmony import */ var _PackageRoot_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PackageRoot.html */ "./src/PackageRoot.html");
/* harmony import */ var _builderStore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./builderStore */ "./src/builderStore/index.js");
/* harmony import */ var C_code_budibase_builder_src_App_svelte_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/App.svelte.css */ "./src/App.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_App_svelte_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_App_svelte_css__WEBPACK_IMPORTED_MODULE_4__);
/* src\App.html generated by Svelte v3.2.2 */





// (1:0) <script>    import NoPackage from "./NoPackage.html";  import PackageRoot from "./PackageRoot.html";  import {hasAppPackage, initialise}
function create_catch_block(ctx) {
	return {
		c: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		m: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		d: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"]
	};
}

// (14:1) {:then result}
function create_then_block(ctx) {
	var t, if_block1_anchor, current;

	var if_block0 = (ctx.$hasAppPackage) && create_if_block_1(ctx);

	var if_block1 = (!ctx.$hasAppPackage) && create_if_block(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			if (if_block1) if_block1.c();
			if_block1_anchor = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["empty"])();
		},

		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, if_block1_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			if (ctx.$hasAppPackage) {
				if (!if_block0) {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.i(1);
					if_block0.m(t.parentNode, t);
				} else {
									if_block0.i(1);
				}
			} else if (if_block0) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					if_block0.d(1);
					if_block0 = null;
				});

				if_block0.o(1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
			}

			if (!ctx.$hasAppPackage) {
				if (!if_block1) {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.i(1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				} else {
									if_block1.i(1);
				}
			} else if (if_block1) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					if_block1.d(1);
					if_block1 = null;
				});

				if_block1.o(1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
			}
		},

		i(local) {
			if (current) return;
			if (if_block0) if_block0.i();
			if (if_block1) if_block1.i();
			current = true;
		},

		o(local) {
			if (if_block0) if_block0.o();
			if (if_block1) if_block1.o();
			current = false;
		},

		d(detaching) {
			if (if_block0) if_block0.d(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}

			if (if_block1) if_block1.d(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(if_block1_anchor);
			}
		}
	};
}

// (15:2) {#if $hasAppPackage}
function create_if_block_1(ctx) {
	var current;

	var packageroot = new _PackageRoot_html__WEBPACK_IMPORTED_MODULE_2__["default"]({});

	return {
		c() {
			packageroot.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(packageroot, target, anchor);
			current = true;
		},

		i(local) {
			if (current) return;
			packageroot.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			packageroot.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			packageroot.$destroy(detaching);
		}
	};
}

// (19:2) {#if !$hasAppPackage}
function create_if_block(ctx) {
	var current;

	var nopackage = new _NoPackage_html__WEBPACK_IMPORTED_MODULE_1__["default"]({});

	return {
		c() {
			nopackage.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(nopackage, target, anchor);
			current = true;
		},

		i(local) {
			if (current) return;
			nopackage.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			nopackage.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			nopackage.$destroy(detaching);
		}
	};
}

// (10:22)      <h1>loading</h1>   {:then result}
function create_pending_block(ctx) {
	var h1;

	return {
		c() {
			h1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("h1");
			h1.textContent = "loading";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, h1, anchor);
		},

		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(h1);
			}
		}
	};
}

function create_fragment(ctx) {
	var div, promise, current;

	let info = {
		ctx,
		current: null,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 'result',
		error: 'null',
		blocks: Array(3)
	};

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["handle_promise"])(promise = Object(_builderStore__WEBPACK_IMPORTED_MODULE_3__["initialise"])(), info);

	return {
		c() {
			div = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");

			info.block.c();
			div.className = "app-root svelte-rqgp85";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);

			info.block.m(div, info.anchor = null);
			info.mount = () => div;
			info.anchor = null;

			current = true;
		},

		p(changed, new_ctx) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (promise !== (promise = Object(_builderStore__WEBPACK_IMPORTED_MODULE_3__["initialise"])()) && Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["handle_promise"])(promise, info)) {
				// nothing
			} else {
				info.block.p(changed, Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["assign"])(Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["assign"])({}, ctx), info.resolved));
			}
		},

		i(local) {
			if (current) return;
			info.block.i();
			current = true;
		},

		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				if (block) block.o();
			}

			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div);
			}

			info.block.d();
			info = null;
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $hasAppPackage;

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["subscribe"])($$self, _builderStore__WEBPACK_IMPORTED_MODULE_3__["hasAppPackage"], $$value => { $hasAppPackage = $$value; $$invalidate('$hasAppPackage', $hasAppPackage); });

	return { $hasAppPackage };
}

class App extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], []);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (App);




/***/ }),

/***/ "./src/App.svelte.css":
/*!****************************!*\
  !*** ./src/App.svelte.css ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../node_modules/css-loader!./App.svelte.css */ "./node_modules/css-loader/index.js!./src/App.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/NoPackage.html":
/*!****************************!*\
  !*** ./src/NoPackage.html ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _common_Button_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common/Button.html */ "./src/common/Button.html");
/* harmony import */ var _builderStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./builderStore */ "./src/builderStore/index.js");
/* harmony import */ var C_code_budibase_builder_src_NoPackage_svelte_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/NoPackage.svelte.css */ "./src/NoPackage.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_NoPackage_svelte_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_NoPackage_svelte_css__WEBPACK_IMPORTED_MODULE_3__);
/* src\NoPackage.html generated by Svelte v3.2.2 */




// (16:16) <Button color="primary"                          on:click={createNewPackage}                          class="option">
function create_default_slot_1(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Create a New Package");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

// (21:16) <Button color="primary-outline"                          class="option">
function create_default_slot(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Import a Package");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

function create_fragment(ctx) {
	var div3, div2, img, t0, div1, div0, h4, t2, t3, current;

	var button0 = new _common_Button_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		color: "primary",
		class: "option",
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	}
	});
	button0.$on("click", _builderStore__WEBPACK_IMPORTED_MODULE_2__["createNewPackage"]);

	var button1 = new _common_Button_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		color: "primary-outline",
		class: "option",
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	}
	});

	return {
		c() {
			div3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			img = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("img");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			h4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("h4");
			h4.textContent = "What would you like to do?";
			t2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			button0.$$.fragment.c();
			t3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			button1.$$.fragment.c();
			img.src = "./assets/budibase-logo.png";
			img.className = "logo svelte-siv2n6";
			img.alt = "budibase logo";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(h4, "margin-bottom", "20px");
			div2.className = "inner svelte-siv2n6";
			div3.className = "root svelte-siv2n6";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div3, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, div2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, img);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, div1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, h4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(button0, div0, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t3);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(button1, div0, null);
			current = true;
		},

		p(changed, ctx) {
			var button0_changes = {};
			if (changed.$$scope) button0_changes.$$scope = { changed, ctx };
			button0.$set(button0_changes);

			var button1_changes = {};
			if (changed.$$scope) button1_changes.$$scope = { changed, ctx };
			button1.$set(button1_changes);
		},

		i(local) {
			if (current) return;
			button0.$$.fragment.i(local);

			button1.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			button0.$$.fragment.o(local);
			button1.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div3);
			}

			button0.$destroy();

			button1.$destroy();
		}
	};
}

class NoPackage extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, null, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], []);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (NoPackage);




/***/ }),

/***/ "./src/NoPackage.svelte.css":
/*!**********************************!*\
  !*** ./src/NoPackage.svelte.css ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../node_modules/css-loader!./NoPackage.svelte.css */ "./node_modules/css-loader/index.js!./src/NoPackage.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/PackageRoot.html":
/*!******************************!*\
  !*** ./src/PackageRoot.html ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _nav_Nav_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nav/Nav.html */ "./src/nav/Nav.html");
/* harmony import */ var _database_DatabaseRoot_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./database/DatabaseRoot.html */ "./src/database/DatabaseRoot.html");
/* harmony import */ var _userInterface_UserInterfaceRoot_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./userInterface/UserInterfaceRoot.html */ "./src/userInterface/UserInterfaceRoot.html");
/* harmony import */ var _actionsAndTriggers_ActionsAndTriggersRoot_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actionsAndTriggers/ActionsAndTriggersRoot.html */ "./src/actionsAndTriggers/ActionsAndTriggersRoot.html");
/* harmony import */ var _common_ComingSoon_html__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common/ComingSoon.html */ "./src/common/ComingSoon.html");
/* harmony import */ var _builderStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./builderStore */ "./src/builderStore/index.js");
/* harmony import */ var C_code_budibase_builder_src_PackageRoot_svelte_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/PackageRoot.svelte.css */ "./src/PackageRoot.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_PackageRoot_svelte_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_PackageRoot_svelte_css__WEBPACK_IMPORTED_MODULE_7__);
/* src\PackageRoot.html generated by Svelte v3.2.2 */








// (28:46) 
function create_if_block_4(ctx) {
	var current;

	var userinterface = new _userInterface_UserInterfaceRoot_html__WEBPACK_IMPORTED_MODULE_3__["default"]({});

	return {
		c() {
			userinterface.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(userinterface, target, anchor);
			current = true;
		},

		i(local) {
			if (current) return;
			userinterface.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			userinterface.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			userinterface.$destroy(detaching);
		}
	};
}

// (26:45) 
function create_if_block_3(ctx) {
	var current;

	var comingsoon = new _common_ComingSoon_html__WEBPACK_IMPORTED_MODULE_5__["default"]({ props: { name: "Access Levels" } });

	return {
		c() {
			comingsoon.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(comingsoon, target, anchor);
			current = true;
		},

		i(local) {
			if (current) return;
			comingsoon.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			comingsoon.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			comingsoon.$destroy(detaching);
		}
	};
}

// (24:40) 
function create_if_block_2(ctx) {
	var current;

	var comingsoon = new _common_ComingSoon_html__WEBPACK_IMPORTED_MODULE_5__["default"]({ props: { name: "Triggers" } });

	return {
		c() {
			comingsoon.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(comingsoon, target, anchor);
			current = true;
		},

		i(local) {
			if (current) return;
			comingsoon.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			comingsoon.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			comingsoon.$destroy(detaching);
		}
	};
}

// (22:39) 
function create_if_block_1(ctx) {
	var current;

	var actionsandtriggers = new _actionsAndTriggers_ActionsAndTriggersRoot_html__WEBPACK_IMPORTED_MODULE_4__["default"]({});

	return {
		c() {
			actionsandtriggers.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(actionsandtriggers, target, anchor);
			current = true;
		},

		i(local) {
			if (current) return;
			actionsandtriggers.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			actionsandtriggers.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			actionsandtriggers.$destroy(detaching);
		}
	};
}

// (20:4) {#if $activeNav === "database"}
function create_if_block(ctx) {
	var current;

	var database = new _database_DatabaseRoot_html__WEBPACK_IMPORTED_MODULE_2__["default"]({});

	return {
		c() {
			database.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(database, target, anchor);
			current = true;
		},

		i(local) {
			if (current) return;
			database.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			database.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			database.$destroy(detaching);
		}
	};
}

function create_fragment(ctx) {
	var div1, t, div0, current_block_type_index, if_block, current;

	var nav = new _nav_Nav_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: { width: ctx.navWidth } });

	var if_block_creators = [
		create_if_block,
		create_if_block_1,
		create_if_block_2,
		create_if_block_3,
		create_if_block_4
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (ctx.$activeNav === "database") return 0;
		if (ctx.$activeNav === "actions") return 1;
		if (ctx.$activeNav === "triggers") return 2;
		if (ctx.$activeNav === "access levels") return 3;
		if (ctx.$activeNav === "user interface") return 4;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			nav.$$.fragment.c();
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			if (if_block) if_block.c();
			div0.className = "content svelte-1rxbdcd";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div0, "width", "calc(100% - " + ctx.navWidth + ")");
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div0, "left", ctx.navWidth);
			div1.className = "root svelte-1rxbdcd";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(nav, div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			if (~current_block_type_index) if_blocks[current_block_type_index].m(div0, null);
			current = true;
		},

		p(changed, ctx) {
			var nav_changes = {};
			if (changed.navWidth) nav_changes.width = ctx.navWidth;
			nav.$set(nav_changes);

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
					Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});
					if_block.o(1);
					Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}
					if_block.i(1);
					if_block.m(div0, null);
				} else {
					if_block = null;
				}
			}

			if (!current || changed.navWidth) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div0, "width", "calc(100% - " + ctx.navWidth + ")");
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div0, "left", ctx.navWidth);
			}
		},

		i(local) {
			if (current) return;
			nav.$$.fragment.i(local);

			if (if_block) if_block.i();
			current = true;
		},

		o(local) {
			nav.$$.fragment.o(local);
			if (if_block) if_block.o();
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			nav.$destroy();

			if (~current_block_type_index) if_blocks[current_block_type_index].d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $activeNav;

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["subscribe"])($$self, _builderStore__WEBPACK_IMPORTED_MODULE_6__["activeNav"], $$value => { $activeNav = $$value; $$invalidate('$activeNav', $activeNav); });

	

let { navWidth = "50px" } = $$props;

	$$self.$set = $$props => {
		if ('navWidth' in $$props) $$invalidate('navWidth', navWidth = $$props.navWidth);
	};

	return { navWidth, $activeNav };
}

class PackageRoot extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["navWidth"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (PackageRoot);




/***/ }),

/***/ "./src/PackageRoot.svelte.css":
/*!************************************!*\
  !*** ./src/PackageRoot.svelte.css ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../node_modules/css-loader!./PackageRoot.svelte.css */ "./node_modules/css-loader/index.js!./src/PackageRoot.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/actionsAndTriggers/ActionsAndTriggersRoot.html":
/*!************************************************************!*\
  !*** ./src/actionsAndTriggers/ActionsAndTriggersRoot.html ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _common_ComingSoon_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/ComingSoon.html */ "./src/common/ComingSoon.html");
/* src\actionsAndTriggers\ActionsAndTriggersRoot.html generated by Svelte v3.2.2 */



function create_fragment(ctx) {
	var current;

	var comingsoon = new _common_ComingSoon_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: { name: "Actions and Triggers" } });

	return {
		c() {
			comingsoon.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(comingsoon, target, anchor);
			current = true;
		},

		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		i(local) {
			if (current) return;
			comingsoon.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			comingsoon.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			comingsoon.$destroy(detaching);
		}
	};
}

class ActionsAndTriggersRoot extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, null, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], []);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (ActionsAndTriggersRoot);


/***/ }),

/***/ "./src/assets/budibase-logo-only.png":
/*!*******************************************!*\
  !*** ./src/assets/budibase-logo-only.png ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "src/assets/budibase-logo-only.png";

/***/ }),

/***/ "./src/assets/budibase-logo-white.png":
/*!********************************************!*\
  !*** ./src/assets/budibase-logo-white.png ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "src/assets/budibase-logo-white.png";

/***/ }),

/***/ "./src/assets/lato-latin-ext.woff2":
/*!*****************************************!*\
  !*** ./src/assets/lato-latin-ext.woff2 ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "src/assets/lato-latin-ext.woff2";

/***/ }),

/***/ "./src/assets/lato-latin.woff2":
/*!*************************************!*\
  !*** ./src/assets/lato-latin.woff2 ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "src/assets/lato-latin.woff2";

/***/ }),

/***/ "./src/builderStore/createPackage.js":
/*!*******************************************!*\
  !*** ./src/builderStore/createPackage.js ***!
  \*******************************************/
/*! exports provided: createPackage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPackage", function() { return createPackage; });
/* harmony import */ var _common_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/core */ "./src/common/core.js");


const createPackage = (hasAppPackage, database) => {
    hasAppPackage.set(true);
    const root = Object(_common_core__WEBPACK_IMPORTED_MODULE_0__["constructHierarchy"])(testroot);
    database.importHierarchy(root);
};

const testroot = {
  "name": "root",
  "type": "root",
  "children": [
    {
      "name": "settings",
      "type": "record",
      "fields": [
        {
          "name": "appName",
          "type": "string",
          "typeOptions": {
            "maxLength": null,
            "values": null,
            "allowDeclaredValuesOnly": false
          },
          "label": "appName",
          "getInitialValue": "default",
          "getUndefinedValue": "default"
        }
      ],
      "children": [],
      "validationRules": [],
      "nodeId": 1,
      "indexes": [],
      "allidsShardFactor": 64,
      "collectionName": "",
      "isSingle": true
    },
    {
      "name": "customer",
      "type": "record",
      "fields": [
        {
          "name": "surname",
          "type": "string",
          "typeOptions": {
            "maxLength": null,
            "values": null,
            "allowDeclaredValuesOnly": false
          },
          "label": "surname",
          "getInitialValue": "default",
          "getUndefinedValue": "default"
        },
        {
          "name": "isalive",
          "type": "bool",
          "typeOptions": {
            "allowNulls": true
          },
          "label": "isalive",
          "getInitialValue": "true",
          "getUndefinedValue": "default"
        },
        {
          "name": "createddate",
          "type": "datetime",
          "typeOptions": {
            "maxValue": "+275760-09-13T00:00:00.000Z",
            "minValue": "-271821-04-20T00:00:00.000Z"
          },
          "label": "createddate",
          "getInitialValue": "default",
          "getUndefinedValue": "default"
        },
        {
          "name": "age",
          "type": "number",
          "typeOptions": {
            "maxValue": 9007199254740991,
            "minValue": -9007199254740991,
            "decimalPlaces": 0
          },
          "label": "age",
          "getInitialValue": "default",
          "getUndefinedValue": "default"
        },
        {
          "name": "profilepic",
          "type": "file",
          "typeOptions": {},
          "label": "profilepic",
          "getInitialValue": "default",
          "getUndefinedValue": "default"
        },
        {
          "name": "partner",
          "type": "reference",
          "typeOptions": {
            "indexNodeKey": "/partnersReference",
            "displayValue": "name",
            "reverseIndexNodeKeys": [
              "/partners/4-{id}/partnerCustomers"
            ]
          },
          "label": "partner",
          "getInitialValue": "default",
          "getUndefinedValue": "default"
        },
        {
          "name": "referredBy",
          "type": "reference",
          "typeOptions": {
            "indexNodeKey": "/customer_index",
            "displayValue": "surname",
            "reverseIndexNodeKeys": [
              "/customers/2-{id}/referredToCustomers"
            ]
          },
          "label": "referredBy",
          "getInitialValue": "default",
          "getUndefinedValue": "default"
        }
      ],
      "children": [
        {
          "name": "invoice",
          "type": "record",
          "fields": [
            {
              "name": "totalIncVat",
              "type": "number",
              "typeOptions": {
                "maxValue": 9007199254740991,
                "minValue": -9007199254740991,
                "decimalPlaces": 2
              },
              "label": "totalIncVat",
              "getInitialValue": "default",
              "getUndefinedValue": "default"
            },
            {
              "name": "createdDate",
              "type": "datetime",
              "typeOptions": {
                "maxValue": "+275760-09-13T00:00:00.000Z",
                "minValue": "-271821-04-20T00:00:00.000Z"
              },
              "label": "createdDate",
              "getInitialValue": "default",
              "getUndefinedValue": "default"
            },
            {
              "name": "paidAmount",
              "type": "number",
              "typeOptions": {
                "maxValue": 9007199254740991,
                "minValue": -9007199254740991,
                "decimalPlaces": 0
              },
              "label": "paidAmount",
              "getInitialValue": "default",
              "getUndefinedValue": "default"
            },
            {
              "name": "invoiceType",
              "type": "string",
              "typeOptions": {
                "maxLength": null,
                "values": null,
                "allowDeclaredValuesOnly": false
              },
              "label": "invoiceType",
              "getInitialValue": "default",
              "getUndefinedValue": "default"
            },
            {
              "name": "isWrittenOff",
              "type": "bool",
              "typeOptions": {
                "allowNulls": true
              },
              "label": "isWrittenOff",
              "getInitialValue": "default",
              "getUndefinedValue": "default"
            },
            {
              "name": "customer",
              "type": "reference",
              "typeOptions": {
                "indexNodeKey": "/customersReference",
                "reverseIndexNodeKeys": [
                  "/customers/2-{id}/invoice_index"
                ],
                "displayValue": "name"
              },
              "label": "customer",
              "getInitialValue": "default",
              "getUndefinedValue": "default"
            }
          ],
          "children": [
            {
              "name": "charge",
              "type": "record",
              "fields": [
                {
                  "name": "amount",
                  "type": "number",
                  "typeOptions": {
                    "maxValue": 9007199254740991,
                    "minValue": -9007199254740991,
                    "decimalPlaces": 0
                  },
                  "label": "amount",
                  "getInitialValue": "default",
                  "getUndefinedValue": "default"
                },
                {
                  "name": "partnerInvoice",
                  "type": "reference",
                  "typeOptions": {
                    "reverseIndexNodeKeys": [
                      "/partners/4-{id}/invoices/6-{id}/partnerCharges"
                    ],
                    "displayValue": "createdDate",
                    "indexNodeKey": "/partners/4-{id}/partnerInvoices_index"
                  },
                  "label": "partnerInvoice",
                  "getInitialValue": "default",
                  "getUndefinedValue": "default"
                }
              ],
              "children": [],
              "validationRules": [],
              "nodeId": 10,
              "indexes": [],
              "allidsShardFactor": 1,
              "collectionName": "charges",
              "isSingle": false
            }
          ],
          "validationRules": [],
          "nodeId": 8,
          "indexes": [
            {
              "name": "charge_index",
              "type": "index",
              "map": "return {...record};",
              "filter": "",
              "indexType": "ancestor",
              "getShardName": "",
              "getSortKey": "record.id",
              "aggregateGroups": [],
              "allowedRecordNodeIds": [
                10
              ],
              "nodeId": 11
            }
          ],
          "allidsShardFactor": 1,
          "collectionName": "invoices",
          "isSingle": false
        }
      ],
      "validationRules": [],
      "nodeId": 2,
      "indexes": [
        {
          "name": "invoice_index",
          "type": "index",
          "map": "return {createdDate: record.createdDate, totalIncVat: record.totalIncVat};",
          "filter": "",
          "indexType": "ancestor",
          "getShardName": "",
          "getSortKey": "record.id",
          "aggregateGroups": [],
          "allowedRecordNodeIds": [
            8
          ],
          "nodeId": 9
        },
        {
          "name": "referredToCustomers",
          "type": "index",
          "map": "return {...record};",
          "filter": "",
          "indexType": "reference",
          "getShardName": "return !record.surname ? 'null' : record.surname.substring(0,1);",
          "getSortKey": "record.id",
          "aggregateGroups": [],
          "allowedRecordNodeIds": [
            2
          ],
          "nodeId": 14
        },
        {
          "name": "invoicesByOutstanding",
          "type": "index",
          "map": "return {...record};",
          "filter": "",
          "indexType": "ancestor",
          "getShardName": "return (record.totalIncVat > record.paidAmount ? 'outstanding' : 'paid');",
          "getSortKey": "record.id",
          "aggregateGroups": [
            {
              "name": "all_invoices_by_type",
              "type": "aggregateGroup",
              "groupBy": "return record.invoiceType",
              "aggregates": [
                {
                  "name": "totalIncVat",
                  "aggregatedValue": "return record.totalIncVat"
                }
              ],
              "condition": "",
              "nodeId": 26
            }
          ],
          "allowedRecordNodeIds": [
            6,
            8
          ],
          "nodeId": 25
        }
      ],
      "allidsShardFactor": 64,
      "collectionName": "customers",
      "isSingle": false
    },
    {
      "name": "partner",
      "type": "record",
      "fields": [
        {
          "name": "businessName",
          "type": "string",
          "typeOptions": {
            "maxLength": null,
            "values": null,
            "allowDeclaredValuesOnly": false
          },
          "label": "businessName",
          "getInitialValue": "default",
          "getUndefinedValue": "default"
        }
      ],
      "children": [
        {
          "name": "invoice",
          "type": "record",
          "fields": [
            {
              "name": "totalIncVat",
              "type": "number",
              "typeOptions": {
                "maxValue": 9007199254740991,
                "minValue": -9007199254740991,
                "decimalPlaces": 2
              },
              "label": "totalIncVat",
              "getInitialValue": "default",
              "getUndefinedValue": "default"
            },
            {
              "name": "createdDate",
              "type": "datetime",
              "typeOptions": {
                "maxValue": "+275760-09-13T00:00:00.000Z",
                "minValue": "-271821-04-20T00:00:00.000Z"
              },
              "label": "createdDate",
              "getInitialValue": "default",
              "getUndefinedValue": "default"
            },
            {
              "name": "paidAmount",
              "type": "number",
              "typeOptions": {
                "maxValue": 9007199254740991,
                "minValue": -9007199254740991,
                "decimalPlaces": 0
              },
              "label": "paidAmount",
              "getInitialValue": "default",
              "getUndefinedValue": "default"
            }
          ],
          "children": [],
          "validationRules": [],
          "nodeId": 6,
          "indexes": [
            {
              "name": "partnerCharges",
              "type": "index",
              "map": "return {...record};",
              "filter": "",
              "indexType": "reference",
              "getShardName": "",
              "getSortKey": "record.id",
              "aggregateGroups": [],
              "allowedRecordNodeIds": [
                {
                  "name": "charge",
                  "type": "record",
                  "fields": [
                    {
                      "name": "amount",
                      "type": "number",
                      "typeOptions": {
                        "maxValue": 9007199254740991,
                        "minValue": -9007199254740991,
                        "decimalPlaces": 0
                      },
                      "label": "amount",
                      "getInitialValue": "default",
                      "getUndefinedValue": "default"
                    },
                    {
                      "name": "partnerInvoice",
                      "type": "reference",
                      "typeOptions": {
                        "reverseIndexNodeKeys": [
                          "/partners/4-{id}/invoices/6-{id}/partnerCharges"
                        ],
                        "displayValue": "createdDate",
                        "indexNodeKey": "/partners/4-{id}/partnerInvoices_index"
                      },
                      "label": "partnerInvoice",
                      "getInitialValue": "default",
                      "getUndefinedValue": "default"
                    }
                  ],
                  "children": [],
                  "validationRules": [],
                  "nodeId": 10,
                  "indexes": [],
                  "allidsShardFactor": 1,
                  "collectionName": "charges",
                  "isSingle": false
                }
              ],
              "nodeId": 15
            }
          ],
          "allidsShardFactor": 1,
          "collectionName": "invoices",
          "isSingle": false
        }
      ],
      "validationRules": [],
      "nodeId": 4,
      "indexes": [
        {
          "name": "partnerInvoices_index",
          "type": "index",
          "map": "return {...record};",
          "filter": "",
          "indexType": "ancestor",
          "getShardName": "",
          "getSortKey": "record.id",
          "aggregateGroups": [],
          "allowedRecordNodeIds": [
            6
          ],
          "nodeId": 7
        },
        {
          "name": "partnerCustomers",
          "type": "index",
          "map": "return {...record};",
          "filter": "record.isalive === true",
          "indexType": "reference",
          "getShardName": "",
          "getSortKey": "record.id",
          "aggregateGroups": [],
          "allowedRecordNodeIds": [
            2
          ],
          "nodeId": 13
        }
      ],
      "allidsShardFactor": 64,
      "collectionName": "partners",
      "isSingle": false
    }
  ],
  "pathMaps": [],
  "indexes": [
    {
      "name": "customer_index",
      "type": "index",
      "map": "return record;",
      "filter": "",
      "indexType": "ancestor",
      "getShardName": "",
      "getSortKey": "record.id",
      "aggregateGroups": [
        {
          "name": "Customers Summary",
          "type": "aggregateGroup",
          "groupBy": "",
          "aggregates": [
            {
              "name": "all customers - age breakdown",
              "aggregatedValue": "return record.age"
            }
          ],
          "condition": "",
          "nodeId": 24
        }
      ],
      "allowedRecordNodeIds": [
        2
      ],
      "nodeId": 3
    },
    {
      "name": "partner_index",
      "type": "index",
      "map": "return {...record};",
      "filter": "",
      "indexType": "ancestor",
      "getShardName": "",
      "getSortKey": "record.id",
      "aggregateGroups": [],
      "allowedRecordNodeIds": [
        4
      ],
      "nodeId": 5
    },
    {
      "name": "partnersReference",
      "type": "index",
      "map": "return {name:record.businessName};",
      "filter": "",
      "indexType": "ancestor",
      "getShardName": "",
      "getSortKey": "record.id",
      "aggregateGroups": [],
      "allowedRecordNodeIds": [
        4
      ],
      "nodeId": 12
    },
    {
      "name": "customersReference",
      "type": "index",
      "map": "return {name:record.surname}",
      "filter": "record.isalive === true",
      "indexType": "ancestor",
      "getShardName": "",
      "getSortKey": "record.id",
      "aggregateGroups": [],
      "allowedRecordNodeIds": [
        2
      ],
      "nodeId": 16
    },
    {
      "name": "deceased",
      "type": "index",
      "map": "return {surname: record.surname, age:record.age};",
      "filter": "record.isalive === false",
      "indexType": "ancestor",
      "getShardName": "",
      "getSortKey": "record.id",
      "aggregateGroups": [],
      "allowedRecordNodeIds": [
        2
      ],
      "nodeId": 17
    },
    {
      "name": "customer_invoices",
      "type": "index",
      "map": "return record;",
      "filter": "record.type === 'invoice'",
      "indexType": "ancestor",
      "getShardName": "",
      "getSortKey": "record.id",
      "aggregateGroups": [],
      "allowedRecordNodeIds": [
        8
      ],
      "nodeId": 18
    },
    {
      "name": "Outstanding Invoices",
      "type": "index",
      "map": "return {...record};",
      "filter": "record.type === 'invoice' && record.paidAmount < record.totalIncVat",
      "indexType": "ancestor",
      "getShardName": "",
      "getSortKey": "record.id",
      "aggregateGroups": [
        {
          "name": "all_invoices",
          "type": "aggregateGroup",
          "groupBy": "",
          "aggregates": [],
          "condition": "",
          "nodeId": 20
        },
        {
          "name": "all_invoices_by_type",
          "type": "aggregateGroup",
          "groupBy": "return record.invoiceType",
          "aggregates": [
            {
              "name": "totalIncVat",
              "aggregatedValue": "return record.totalIncVat"
            },
            {
              "name": "paidAmount",
              "aggregatedValue": "return record.paidAmount"
            }
          ],
          "condition": "",
          "nodeId": 21
        },
        {
          "name": "written_off",
          "type": "aggregateGroup",
          "groupBy": "return record.invoiceType",
          "aggregates": [
            {
              "name": "totalIncVat",
              "aggregatedValue": "return record.totalIncVat"
            }
          ],
          "condition": "record.isWrittenOff === true",
          "nodeId": 22
        }
      ],
      "allowedRecordNodeIds": [
        8,
        6
      ],
      "nodeId": 19
    },
    {
      "name": "customersBySurname",
      "type": "index",
      "map": "return {...record};",
      "filter": "",
      "indexType": "ancestor",
      "getShardName": "return !record.surname ? 'null' : record.surname.substring(0,1);",
      "getSortKey": "record.id",
      "aggregateGroups": [],
      "allowedRecordNodeIds": [
        2
      ],
      "nodeId": 23
    }
  ],
  "nodeId": 0
}

/***/ }),

/***/ "./src/builderStore/database.js":
/*!**************************************!*\
  !*** ./src/builderStore/database.js ***!
  \**************************************/
/*! exports provided: getDatabaseStore, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDatabaseStore", function() { return getDatabaseStore; });
/* harmony import */ var _useLocalStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useLocalStorage */ "./src/builderStore/useLocalStorage.js");
/* harmony import */ var budibase_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! budibase-core */ "./node_modules/budibase-core/budibase-core.umd.js");
/* harmony import */ var budibase_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(budibase_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/fp */ "./node_modules/lodash/fp.js");
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_fp__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/core */ "./src/common/core.js");

 



const getDatabaseStore = () => {
    const writable = Object(_useLocalStorage__WEBPACK_IMPORTED_MODULE_0__["bbWritable"])(
        "database", {
        hierarchy: {},
        currentNodeIsNew: false,
        errors: [],
        currentNode: null}, 
        db => {
            if(!!db.hierarchy && !Object(lodash_fp__WEBPACK_IMPORTED_MODULE_2__["isEmpty"])(db.hierarchy)) {
                db.hierarchy = Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["constructHierarchy"])(db.hierarchy);
                const shadowHierarchy = createShadowHierarchy(db.hierarchy);
                db.currentNode = Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["getNode"])(
                    shadowHierarchy, db.currentNode.nodeId
                );
            }
            return db;
        });

    writable.newChildRecord = newRecord(writable, false);
    writable.newRootRecord = newRecord(writable, true);
    writable.selectExistingNode = selectExistingNode(writable);
    writable.newChildIndex = newIndex(writable, false);
    writable.newRootIndex = newIndex(writable, true);
    writable.saveCurrentNode = saveCurrentNode(writable);
    writable.importHierarchy = importHierarchy(writable);
    writable.deleteCurrentNode = deleteCurrentNode(writable);
    writable.saveField = saveField(writable);
    writable.deleteField = deleteField(writable);
    return writable;
} 

/* harmony default export */ __webpack_exports__["default"] = (getDatabaseStore);

const newRecord = (databaseStore, useRoot) => () => {
    databaseStore.update(db => {
        db.currentNodeIsNew = true;
        const shadowHierarchy = createShadowHierarchy(db.hierarchy);
        parent = useRoot ? shadowHierarchy
                 : Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["getNode"])(
                    shadowHierarchy, 
                    db.currentNode.nodeId);
        db.errors = [];
        db.currentNode = Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["templateApi"])(shadowHierarchy)
                         .getNewRecordTemplate(parent, "", true);
        return db;
    });
}


const selectExistingNode = (databaseStore) => (nodeId) => {
    databaseStore.update(db => {
        const shadowHierarchy = createShadowHierarchy(db.hierarchy);
        db.currentNode = Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["getNode"])(
            shadowHierarchy, nodeId
        );
        db.currentNodeIsNew = false;
        db.errors = [];
        return db;
    })
}

const newIndex = (databaseStore, useRoot) => () => {
    databaseStore.update(db => {
        db.currentNodeIsNew = true;
        db.errors = [];
        const shadowHierarchy = createShadowHierarchy(db.hierarchy);
        parent = !useRoot ? shadowHierarchy
                 : Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["getNode"])(
                    shadowHierarchy, 
                    db.currentNode.nodeId);

        db.currentNode = Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["templateApi"])(shadowHierarchy)
                         .getNewIndexTemplate(parent);
        return db;
    });
}

const saveCurrentNode = (databaseStore) => () => {
    databaseStore.update(db => {

        const errors = _common_core__WEBPACK_IMPORTED_MODULE_3__["validate"].node(db.currentNode);
        db.errors = errors;
        if(errors.length > 0) {
            return db;
        }

        const parentNode = Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["getNode"])(
            db.hierarchy, db.currentNode.parent().nodeId);

        const existingNode = Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["getNode"])(
            db.hierarchy, db.currentNode.nodeId);

        let index = parentNode.children.length;
        if(!!existingNode) {
            // remove existing
            index = existingNode.parent().children.indexOf(existingNode);
            existingNode.parent().children = Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["chain"])(existingNode.parent().children, [
                Object(lodash_fp__WEBPACK_IMPORTED_MODULE_2__["filter"])(c => c.nodeId !== existingNode.nodeId)
            ]);
        }

        // should add node into existing hierarchy
        const cloned = Object(lodash_fp__WEBPACK_IMPORTED_MODULE_2__["cloneDeep"])(db.currentNode);
        Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["templateApi"])(db.hierarchy).constructNode(
            parentNode, 
            cloned
        );

        const newIndexOfchild = child => {
            if(child === cloned) return index;
            const currentIndex = parentNode.children.indexOf(child);
            return currentIndex >= index ? currentIndex + 1 : currentIndex;
        }

        parentNode.children = Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["chain"])(parentNode.children, [
            Object(lodash_fp__WEBPACK_IMPORTED_MODULE_2__["sortBy"])(newIndexOfchild)
        ]);

        return db;
    });
}

const importHierarchy = databaseStore => hierarchy => {
    databaseStore.update(db => {
        db.hierarchy = hierarchy;
        db.currentNode = hierarchy.children.length > 0
                         ? hierarchy.children[0] 
                         : null;
        db.currentNodeIsNew = false; 
        return db;
    })
} 

const deleteCurrentNode = databaseStore => () => {
    databaseStore.update(db => {
        const nodeToDelete = Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["getNode"])(db.hierarchy, db.currentNode.nodeId);
        db.currentNode = budibase_core__WEBPACK_IMPORTED_MODULE_1__["hierarchy"].isRoot(nodeToDelete.parent())
                         ? Object(lodash_fp__WEBPACK_IMPORTED_MODULE_2__["find"])(n => n != db.currentNode)
                               (db.hierarchy.children)
                         : nodeToDelete.parent();
        if(budibase_core__WEBPACK_IMPORTED_MODULE_1__["hierarchy"].isRecord(nodeToDelete)) {
            nodeToDelete.parent().children = Object(lodash_fp__WEBPACK_IMPORTED_MODULE_2__["filter"])(c => c.nodeId !== nodeToDelete.nodeId)
                                                   (nodeToDelete.parent().children);
        } else {
            nodeToDelete.parent().indexes = Object(lodash_fp__WEBPACK_IMPORTED_MODULE_2__["filter"])(c => c.nodeId !== nodeToDelete.nodeId)
                                                   (nodeToDelete.parent().indexes);
        }
        db.errors = [];
        return db;
    });
}

const saveField = databaseStore => (field) => {
    databaseStore.update(db => {
        db.currentNode.fields = Object(lodash_fp__WEBPACK_IMPORTED_MODULE_2__["filter"])(f => f.name !== field.name)
                                      (db.currentNode.fields);
            
        Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["templateApi"])(db.hierarchy).addField(db.currentNode, field);
        return db;
    });
}


const deleteField = databaseStore => field => {
    databaseStore.update(db => {
        db.currentNode.fields = Object(lodash_fp__WEBPACK_IMPORTED_MODULE_2__["filter"])(f => f.name !== field.name)
                                      (db.currentNode.fields);

        return db;
    });
}

const createShadowHierarchy = hierarchy => 
    Object(_common_core__WEBPACK_IMPORTED_MODULE_3__["constructHierarchy"])(JSON.parse(JSON.stringify(hierarchy)));



/***/ }),

/***/ "./src/builderStore/index.js":
/*!***********************************!*\
  !*** ./src/builderStore/index.js ***!
  \***********************************/
/*! exports provided: hasAppPackage, database, createNewPackage, activeNav, initialise */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasAppPackage", function() { return hasAppPackage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "database", function() { return database; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNewPackage", function() { return createNewPackage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activeNav", function() { return activeNav; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initialise", function() { return initialise; });
/* harmony import */ var _useLocalStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useLocalStorage */ "./src/builderStore/useLocalStorage.js");
/* harmony import */ var _createPackage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createPackage */ "./src/builderStore/createPackage.js");
/* harmony import */ var _database__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./database */ "./src/builderStore/database.js");




const hasAppPackage = Object(_useLocalStorage__WEBPACK_IMPORTED_MODULE_0__["bbWritable"])("hasAppPackage", false);

const database = Object(_database__WEBPACK_IMPORTED_MODULE_2__["default"])();
const createNewPackage = () =>
    Object(_createPackage__WEBPACK_IMPORTED_MODULE_1__["createPackage"])(hasAppPackage, database);

const activeNav = Object(_useLocalStorage__WEBPACK_IMPORTED_MODULE_0__["bbWritable"])("activeNav", "database");

const initialise = async () => {
    await Object(_useLocalStorage__WEBPACK_IMPORTED_MODULE_0__["initialiseLocalFolder"])();

    await hasAppPackage.initialise();
    await database.initialise();
    await activeNav.initialise();
}


 


/***/ }),

/***/ "./src/builderStore/useLocalStorage.js":
/*!*********************************************!*\
  !*** ./src/builderStore/useLocalStorage.js ***!
  \*********************************************/
/*! exports provided: bbWritable, initialiseLocalFolder, getOrCreateFile, writeFileFireAndForget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bbWritable", function() { return bbWritable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initialiseLocalFolder", function() { return initialiseLocalFolder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrCreateFile", function() { return getOrCreateFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFileFireAndForget", function() { return writeFileFireAndForget; });
/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store.mjs");
!(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ "./node_modules/util/util.js");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);
// useLocalStorage.js






const access = Object(util__WEBPACK_IMPORTED_MODULE_3__["promisify"])(!(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).access);
const readFile = Object(util__WEBPACK_IMPORTED_MODULE_3__["promisify"])(!(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).readFile);
const writeFile = Object(util__WEBPACK_IMPORTED_MODULE_3__["promisify"])(!(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).writeFile);
const mkdir = Object(util__WEBPACK_IMPORTED_MODULE_3__["promisify"])(!(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).mkdir);
const budibaseFolder = Object(path__WEBPACK_IMPORTED_MODULE_2__["join"])(!(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).homedir(), "budibase");

const budibaseFile = filename => Object(path__WEBPACK_IMPORTED_MODULE_2__["join"])(budibaseFolder, filename);

const bbWritable = (name, initial, modifyStored) => {

    if(!modifyStored)
        modifyStored = s => s;

    const wr = Object(svelte_store__WEBPACK_IMPORTED_MODULE_0__["writable"])(initial);

    const initialise = async () => {
        const localStorageKey = budibaseFile(`store_${name}.json`);
        const jsonFromStore = await getOrCreateFile(localStorageKey, initial);
        const val = modifyStored(JSON.parse(jsonFromStore));    
        wr.set(val);
    }

    wr.subscribe(v => 
        writeFileFireAndForget(
            localStorageKey, 
            JSON.stringify(v))
    );

    wr.initialise = initialise;

    return wr;
}

const initialiseLocalFolder = async () => {
    try {
        await access(budibaseFolder);
    } catch(_) {
        await mkdir(budibaseFolder);
    }
}

const getOrCreateFile = async (path, defaultContent) => {
    try {
        return await readFile(path);
    } catch(_) {
        await writeFile(path, defaultContent, "utf8");
        return defaultContent;
    }
}

const writeFileFireAndForget = (path, content) => {
    !(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).writeFile(path, content, "utf8", () => {});
} 

/***/ }),

/***/ "./src/common/Button.html":
/*!********************************!*\
  !*** ./src/common/Button.html ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var C_code_budibase_builder_src_common_Button_svelte_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/Button.svelte.css */ "./src/common/Button.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_Button_svelte_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_Button_svelte_css__WEBPACK_IMPORTED_MODULE_2__);
/* src\common\Button.html generated by Svelte v3.2.2 */



function create_fragment(ctx) {
	var button, button_class_value, current, dispose;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["create_slot"])(default_slot_1, ctx, null);

	return {
		c() {
			button = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("button");

			if (default_slot) default_slot.c();

			button.className = button_class_value = "" + ctx.color + " " + ctx.className + " svelte-2mdb6s";
			button.style.cssText = ctx.style;
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(button, "click", ctx.onclick);
		},

		l(nodes) {
			if (default_slot) default_slot.l(button_nodes);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["get_slot_changes"])(default_slot_1, ctx, changed, null), Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["get_slot_context"])(default_slot_1, ctx, null));
			}

			if ((!current || changed.color || changed.className) && button_class_value !== (button_class_value = "" + ctx.color + " " + ctx.className + " svelte-2mdb6s")) {
				button.className = button_class_value;
			}

			if (!current || changed.style) {
				button.style.cssText = ctx.style;
			}
		},

		i(local) {
			if (current) return;
			if (default_slot && default_slot.i) default_slot.i(local);
			current = true;
		},

		o(local) {
			if (default_slot && default_slot.o) default_slot.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(button);
			}

			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { color = "primary", className = "", style = "" } = $$props;

const dispatch = Object(svelte__WEBPACK_IMPORTED_MODULE_1__["createEventDispatcher"])();
const onclick = (e) => dispatch('click', e);

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('color' in $$props) $$invalidate('color', color = $$props.color);
		if ('className' in $$props) $$invalidate('className', className = $$props.className);
		if ('style' in $$props) $$invalidate('style', style = $$props.style);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return {
		color,
		className,
		style,
		onclick,
		$$slots,
		$$scope
	};
}

class Button extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["color", "className", "style"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (Button);




/***/ }),

/***/ "./src/common/Button.svelte.css":
/*!**************************************!*\
  !*** ./src/common/Button.svelte.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./Button.svelte.css */ "./node_modules/css-loader/index.js!./src/common/Button.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/Checkbox.html":
/*!**********************************!*\
  !*** ./src/common/Checkbox.html ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* src\common\Checkbox.html generated by Svelte v3.2.2 */


function create_fragment(ctx) {
	var input, t, dispose;

	return {
		c() {
			input = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("input");
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(ctx.label);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["attr"])(input, "type", "checkbox");
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(input, "change", ctx.input_change_handler);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, input, anchor);

			input.checked = ctx.checked;

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		p(changed, ctx) {
			if (changed.checked) input.checked = ctx.checked;

			if (changed.label) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t, ctx.label);
			}
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(input);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { checked=false, label="" } = $$props;

	function input_change_handler() {
		checked = this.checked;
		$$invalidate('checked', checked);
	}

	$$self.$set = $$props => {
		if ('checked' in $$props) $$invalidate('checked', checked = $$props.checked);
		if ('label' in $$props) $$invalidate('label', label = $$props.label);
	};

	return { checked, label, input_change_handler };
}

class Checkbox extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["checked", "label"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (Checkbox);


/***/ }),

/***/ "./src/common/CodeArea.html":
/*!**********************************!*\
  !*** ./src/common/CodeArea.html ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var C_code_budibase_builder_src_common_CodeArea_svelte_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/CodeArea.svelte.css */ "./src/common/CodeArea.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_CodeArea_svelte_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_CodeArea_svelte_css__WEBPACK_IMPORTED_MODULE_1__);
/* src\common\CodeArea.html generated by Svelte v3.2.2 */


function create_fragment(ctx) {
	var div, t0, t1, textarea, dispose;

	return {
		c() {
			div = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(ctx.label);
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			textarea = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("textarea");
			textarea.className = "svelte-1ooq0hh";
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(textarea, "input", ctx.textarea_input_handler);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, textarea, anchor);

			textarea.value = ctx.text;
		},

		p(changed, ctx) {
			if (changed.label) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t0, ctx.label);
			}

			if (changed.text) textarea.value = ctx.text;
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(textarea);
			}

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	// todo: use https://ace.c9.io
let { text = "", label = "" } = $$props;

	function textarea_input_handler() {
		text = this.value;
		$$invalidate('text', text);
	}

	$$self.$set = $$props => {
		if ('text' in $$props) $$invalidate('text', text = $$props.text);
		if ('label' in $$props) $$invalidate('label', label = $$props.label);
	};

	return { text, label, textarea_input_handler };
}

class CodeArea extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["text", "label"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (CodeArea);




/***/ }),

/***/ "./src/common/CodeArea.svelte.css":
/*!****************************************!*\
  !*** ./src/common/CodeArea.svelte.css ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./CodeArea.svelte.css */ "./node_modules/css-loader/index.js!./src/common/CodeArea.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/ComingSoon.html":
/*!************************************!*\
  !*** ./src/common/ComingSoon.html ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var C_code_budibase_builder_src_common_ComingSoon_svelte_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/ComingSoon.svelte.css */ "./src/common/ComingSoon.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_ComingSoon_svelte_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_ComingSoon_svelte_css__WEBPACK_IMPORTED_MODULE_1__);
/* src\common\ComingSoon.html generated by Svelte v3.2.2 */


function create_fragment(ctx) {
	var div, h4, t0, t1;

	return {
		c() {
			div = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			h4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("h4");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Coming Sometime: ");
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(ctx.name);
			h4.className = "svelte-o0id5a";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, h4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(h4, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(h4, t1);
		},

		p(changed, ctx) {
			if (changed.name) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t1, ctx.name);
			}
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div);
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { name = "" } = $$props;

	$$self.$set = $$props => {
		if ('name' in $$props) $$invalidate('name', name = $$props.name);
	};

	return { name };
}

class ComingSoon extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["name"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (ComingSoon);




/***/ }),

/***/ "./src/common/ComingSoon.svelte.css":
/*!******************************************!*\
  !*** ./src/common/ComingSoon.svelte.css ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./ComingSoon.svelte.css */ "./node_modules/css-loader/index.js!./src/common/ComingSoon.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/DatePicker.html":
/*!************************************!*\
  !*** ./src/common/DatePicker.html ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var flatpickr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! flatpickr */ "./node_modules/flatpickr/dist/flatpickr.js");
/* harmony import */ var flatpickr__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(flatpickr__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var flatpickr_dist_flatpickr_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! flatpickr/dist/flatpickr.css */ "./node_modules/flatpickr/dist/flatpickr.css");
/* harmony import */ var flatpickr_dist_flatpickr_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(flatpickr_dist_flatpickr_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var C_code_budibase_builder_src_common_DatePicker_svelte_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/common/DatePicker.svelte.css */ "./src/common/DatePicker.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_DatePicker_svelte_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_DatePicker_svelte_css__WEBPACK_IMPORTED_MODULE_4__);
/* src\common\DatePicker.html generated by Svelte v3.2.2 */





function create_fragment(ctx) {
	var div1, div0, t0, t1, input_1;

	return {
		c() {
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(ctx.label);
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			input_1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("input");
			div0.className = "label svelte-1pf9x5k";
			input_1.className = "control svelte-1pf9x5k";
			div1.className = "container svelte-1pf9x5k";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, input_1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => ctx.input_1_binding(input_1, null));
		},

		p(changed, ctx) {
			if (changed.label) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t0, ctx.label);
			}

			if (changed.items) {
				ctx.input_1_binding(null, input_1);
				;
				ctx.input_1_binding(input_1, null);
			}
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			ctx.input_1_binding(null, input_1);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	

let { value, label } = $$props;
let input;
let fpInstance;

Object(svelte__WEBPACK_IMPORTED_MODULE_3__["onMount"])(() => {
    $$invalidate('fpInstance', fpInstance =  flatpickr__WEBPACK_IMPORTED_MODULE_1___default()(input, {}));

    fpInstance.config.onChange.push(selectedDates => {
        if(selectedDates.length > 0)
            $$invalidate('value', value = new Date(selectedDates[0]));
    });

    return fpInstance;
})

	function input_1_binding($$node, check) {
		input = $$node;
		$$invalidate('input', input);
	}

	$$self.$set = $$props => {
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('label' in $$props) $$invalidate('label', label = $$props.label);
	};

	$$self.$$.update = ($$dirty = { fpInstance: 1, value: 1 }) => {
		if ($$dirty.fpInstance || $$dirty.value) { if (fpInstance) fpInstance.setDate(value); }
	};

	return { value, label, input, input_1_binding };
}

class DatePicker extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["value", "label"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (DatePicker);




/***/ }),

/***/ "./src/common/DatePicker.svelte.css":
/*!******************************************!*\
  !*** ./src/common/DatePicker.svelte.css ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./DatePicker.svelte.css */ "./node_modules/css-loader/index.js!./src/common/DatePicker.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/Dropdown.html":
/*!**********************************!*\
  !*** ./src/common/Dropdown.html ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var C_code_budibase_builder_src_common_Dropdown_svelte_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/Dropdown.svelte.css */ "./src/common/Dropdown.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_Dropdown_svelte_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_Dropdown_svelte_css__WEBPACK_IMPORTED_MODULE_2__);
/* src\common\Dropdown.html generated by Svelte v3.2.2 */



function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.option = list[i];
	return child_ctx;
}

// (23:8) {#each options as option}
function create_each_block(ctx) {
	var option, t_value = !ctx.textMember ? ctx.option : ctx.textMember(ctx.option), t, option_value_value;

	return {
		c() {
			option = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("option");
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t_value);
			option.__value = option_value_value = !ctx.valueMember ? ctx.option : ctx.valueMember(ctx.option);
			option.value = option.__value;
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, option, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(option, t);
		},

		p(changed, ctx) {
			if ((changed.textMember || changed.options) && t_value !== (t_value = !ctx.textMember ? ctx.option : ctx.textMember(ctx.option))) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t, t_value);
			}

			if ((changed.valueMember || changed.options) && option_value_value !== (option_value_value = !ctx.valueMember ? ctx.option : ctx.valueMember(ctx.option))) {
				option.__value = option_value_value;
			}

			option.value = option.__value;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(option);
			}
		}
	};
}

function create_fragment(ctx) {
	var div1, div0, t0, t1, select, select_value_value, dispose;

	var each_value = ctx.options;

	var each_blocks = [];

	for (var i_1 = 0; i_1 < each_value.length; i_1 += 1) {
		each_blocks[i_1] = create_each_block(get_each_context(ctx, each_value, i_1));
	}

	return {
		c() {
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(ctx.label);
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			select = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("select");

			for (var i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].c();
			}
			div0.className = "label svelte-bm0783";
			select.className = "control svelte-bm0783";
			select.multiple = ctx.multiple;
			div1.className = "container svelte-bm0783";
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(select, "change", ctx.valueChanged);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, select);

			for (var i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].m(select, null);
			}

			select_value_value = ctx.selected;
			for (var i = 0; i < select.options.length; i += 1) {
				var option = select.options[i];

				if (option.__value === select_value_value) {
					option.selected = true;
					break;
				}
			}
		},

		p(changed, ctx) {
			if (changed.label) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t0, ctx.label);
			}

			if (changed.valueMember || changed.options || changed.textMember) {
				each_value = ctx.options;

				for (var i_1 = 0; i_1 < each_value.length; i_1 += 1) {
					const child_ctx = get_each_context(ctx, each_value, i_1);

					if (each_blocks[i_1]) {
						each_blocks[i_1].p(changed, child_ctx);
					} else {
						each_blocks[i_1] = create_each_block(child_ctx);
						each_blocks[i_1].c();
						each_blocks[i_1].m(select, null);
					}
				}

				for (; i_1 < each_blocks.length; i_1 += 1) {
					each_blocks[i_1].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if (changed.multiple) {
				select.multiple = ctx.multiple;
			}

			if ((changed.selected) && select_value_value !== (select_value_value = ctx.selected)) {
				for (var i = 0; i < select.options.length; i += 1) {
					var option = select.options[i];

					if (option.__value === select_value_value) {
						option.selected = true;
						break;
					}
				}
			}
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["destroy_each"])(each_blocks, detaching);

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { selected, label, options, valueMember, textMember, multiple=false } = $$props;

const dispatch =Object(svelte__WEBPACK_IMPORTED_MODULE_1__["createEventDispatcher"])();
const valueChanged = (event) => {
    $$invalidate('selected', selected = event.target.value);
    dispatch("change", selected);
}

	$$self.$set = $$props => {
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
		if ('label' in $$props) $$invalidate('label', label = $$props.label);
		if ('options' in $$props) $$invalidate('options', options = $$props.options);
		if ('valueMember' in $$props) $$invalidate('valueMember', valueMember = $$props.valueMember);
		if ('textMember' in $$props) $$invalidate('textMember', textMember = $$props.textMember);
		if ('multiple' in $$props) $$invalidate('multiple', multiple = $$props.multiple);
	};

	return {
		selected,
		label,
		options,
		valueMember,
		textMember,
		multiple,
		valueChanged
	};
}

class Dropdown extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["selected", "label", "options", "valueMember", "textMember", "multiple"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (Dropdown);




/***/ }),

/***/ "./src/common/Dropdown.svelte.css":
/*!****************************************!*\
  !*** ./src/common/Dropdown.svelte.css ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./Dropdown.svelte.css */ "./node_modules/css-loader/index.js!./src/common/Dropdown.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/DropdownButton.html":
/*!****************************************!*\
  !*** ./src/common/DropdownButton.html ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon */ "./src/common/icon.js");
/* harmony import */ var C_code_budibase_builder_src_common_DropdownButton_svelte_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/DropdownButton.svelte.css */ "./src/common/DropdownButton.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_DropdownButton_svelte_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_DropdownButton_svelte_css__WEBPACK_IMPORTED_MODULE_2__);
/* src\common\DropdownButton.html generated by Svelte v3.2.2 */



function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.action = list[i];
	return child_ctx;
}

// (17:8) {#each actions as action}
function create_each_block(ctx) {
	var div, t0_value = ctx.action.label, t0, t1, dispose;

	return {
		c() {
			div = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t0_value);
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div.className = "action-row svelte-179p8ge";
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(div, "click", ctx.action.onclick);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, t1);
		},

		p(changed, new_ctx) {
			ctx = new_ctx;
			if ((changed.actions) && t0_value !== (t0_value = ctx.action.label)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t0, t0_value);
			}
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div);
			}

			dispose();
		}
	};
}

function create_fragment(ctx) {
	var div2, raw_value = Object(_icon__WEBPACK_IMPORTED_MODULE_1__["default"])(ctx.iconName), raw_after, t0, div0, t1, div1, dispose;

	var each_value = ctx.actions;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			raw_after = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])('noscript');
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			div0.className = "dropdown-background svelte-179p8ge";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div0, "display", (ctx.isDroppedDown ? 'block' : 'none'));
			div1.className = "dropdown-content svelte-179p8ge";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div1, "display", (ctx.isDroppedDown ? 'inline-block' : 'none'));
			div2.className = "root svelte-179p8ge";

			dispose = [
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(div0, "click", Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["stop_propagation"])(ctx.click_handler)),
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(div2, "click", ctx.click_handler_1)
			];
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div2, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, raw_after);
			raw_after.insertAdjacentHTML("beforebegin", raw_value);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, div1);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}
		},

		p(changed, ctx) {
			if ((changed.iconName) && raw_value !== (raw_value = Object(_icon__WEBPACK_IMPORTED_MODULE_1__["default"])(ctx.iconName))) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach_before"])(raw_after);
				raw_after.insertAdjacentHTML("beforebegin", raw_value);
			}

			if (changed.isDroppedDown) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div0, "display", (ctx.isDroppedDown ? 'block' : 'none'));
			}

			if (changed.actions) {
				each_value = ctx.actions;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if (changed.isDroppedDown) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div1, "display", (ctx.isDroppedDown ? 'inline-block' : 'none'));
			}
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div2);
			}

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["destroy_each"])(each_blocks, detaching);

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["run_all"])(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { iconName, actions = [] } = $$props; // [ {label: "Action Name", onclick: () => {...} } ]
let isDroppedDown = false;

	function click_handler() {
		const $$result = isDroppedDown = false;
		$$invalidate('isDroppedDown', isDroppedDown);
		return $$result;
	}

	function click_handler_1() {
		const $$result = isDroppedDown = !isDroppedDown;
		$$invalidate('isDroppedDown', isDroppedDown);
		return $$result;
	}

	$$self.$set = $$props => {
		if ('iconName' in $$props) $$invalidate('iconName', iconName = $$props.iconName);
		if ('actions' in $$props) $$invalidate('actions', actions = $$props.actions);
	};

	return {
		iconName,
		actions,
		isDroppedDown,
		click_handler,
		click_handler_1
	};
}

class DropdownButton extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["iconName", "actions"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (DropdownButton);




/***/ }),

/***/ "./src/common/DropdownButton.svelte.css":
/*!**********************************************!*\
  !*** ./src/common/DropdownButton.svelte.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./DropdownButton.svelte.css */ "./node_modules/css-loader/index.js!./src/common/DropdownButton.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/ErrorsBox.html":
/*!***********************************!*\
  !*** ./src/common/ErrorsBox.html ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var C_code_budibase_builder_src_common_ErrorsBox_svelte_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/ErrorsBox.svelte.css */ "./src/common/ErrorsBox.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_ErrorsBox_svelte_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_ErrorsBox_svelte_css__WEBPACK_IMPORTED_MODULE_1__);
/* src\common\ErrorsBox.html generated by Svelte v3.2.2 */


function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.error = list[i];
	return child_ctx;
}

// (7:0) {#if hasErrors}
function create_if_block(ctx) {
	var div;

	var each_value = ctx.errors;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			div.className = "error-container svelte-6bvkk9";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},

		p(changed, ctx) {
			if (changed.errors) {
				each_value = ctx.errors;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div);
			}

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["destroy_each"])(each_blocks, detaching);
		}
	};
}

// (9:4) {#each errors as error}
function create_each_block(ctx) {
	var div, t_value = ctx.error.error, t;

	return {
		c() {
			div = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t_value);
			div.className = "error-row svelte-6bvkk9";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, t);
		},

		p(changed, ctx) {
			if ((changed.errors) && t_value !== (t_value = ctx.error.error)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t, t_value);
			}
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div);
			}
		}
	};
}

function create_fragment(ctx) {
	var if_block_anchor;

	var if_block = (ctx.hasErrors) && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["empty"])();
		},

		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, if_block_anchor, anchor);
		},

		p(changed, ctx) {
			if (ctx.hasErrors) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(if_block_anchor);
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { errors = [] } = $$props;

	$$self.$set = $$props => {
		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
	};

	let hasErrors;

	$$self.$$.update = ($$dirty = { errors: 1 }) => {
		if ($$dirty.errors) { $$invalidate('hasErrors', hasErrors = errors.length > 0); }
	};

	return { errors, hasErrors };
}

class ErrorsBox extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["errors"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (ErrorsBox);




/***/ }),

/***/ "./src/common/ErrorsBox.svelte.css":
/*!*****************************************!*\
  !*** ./src/common/ErrorsBox.svelte.css ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./ErrorsBox.svelte.css */ "./node_modules/css-loader/index.js!./src/common/ErrorsBox.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/Modal.html":
/*!*******************************!*\
  !*** ./src/common/Modal.html ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var C_code_budibase_builder_src_common_Modal_svelte_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/Modal.svelte.css */ "./src/common/Modal.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_Modal_svelte_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_Modal_svelte_css__WEBPACK_IMPORTED_MODULE_1__);
/* src\common\Modal.html generated by Svelte v3.2.2 */


function create_fragment(ctx) {
	var div1, div0, current, dispose;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["create_slot"])(default_slot_1, ctx, null);

	return {
		c() {
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");

			if (default_slot) default_slot.c();

			div0.className = "content svelte-n9lkn5";
			div1.className = "root svelte-n9lkn5";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div1, "display", (ctx.isOpen ? 'grid' : 'none'));

			dispose = [
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(div0, "click", Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["stop_propagation"])(click_handler)),
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(div1, "click", ctx.click_handler_1)
			];
		},

		l(nodes) {
			if (default_slot) default_slot.l(div0_nodes);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["get_slot_changes"])(default_slot_1, ctx, changed, null), Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["get_slot_context"])(default_slot_1, ctx, null));
			}

			if (!current || changed.isOpen) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div1, "display", (ctx.isOpen ? 'grid' : 'none'));
			}
		},

		i(local) {
			if (current) return;
			if (default_slot && default_slot.i) default_slot.i(local);
			current = true;
		},

		o(local) {
			if (default_slot && default_slot.o) default_slot.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			if (default_slot) default_slot.d(detaching);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["run_all"])(dispose);
		}
	};
}

function click_handler() {}

function instance($$self, $$props, $$invalidate) {
	let { isOpen = false } = $$props;

	let { $$slots = {}, $$scope } = $$props;

	function click_handler_1() {
		const $$result = isOpen=false;
		$$invalidate('isOpen', isOpen);
		return $$result;
	}

	$$self.$set = $$props => {
		if ('isOpen' in $$props) $$invalidate('isOpen', isOpen = $$props.isOpen);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return {
		isOpen,
		click_handler_1,
		$$slots,
		$$scope
	};
}

class Modal extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["isOpen"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (Modal);




/***/ }),

/***/ "./src/common/Modal.svelte.css":
/*!*************************************!*\
  !*** ./src/common/Modal.svelte.css ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./Modal.svelte.css */ "./node_modules/css-loader/index.js!./src/common/Modal.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/NumberBox.html":
/*!***********************************!*\
  !*** ./src/common/NumberBox.html ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var C_code_budibase_builder_src_common_NumberBox_svelte_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/NumberBox.svelte.css */ "./src/common/NumberBox.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_NumberBox_svelte_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_NumberBox_svelte_css__WEBPACK_IMPORTED_MODULE_1__);
/* src\common\NumberBox.html generated by Svelte v3.2.2 */


function create_fragment(ctx) {
	var div1, div0, t0, t1, input, dispose;

	return {
		c() {
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(ctx.label);
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			input = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("input");
			div0.className = "label svelte-umifqh";
			input.className = "control svelte-umifqh";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["attr"])(input, "type", "text");
			input.value = ctx.value;
			div1.className = "container svelte-umifqh";
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(input, "change", ctx.inputChanged);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, input);
		},

		p(changed, ctx) {
			if (changed.label) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t0, ctx.label);
			}

			if (changed.value) {
				input.value = ctx.value;
			}
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { value, label } = $$props;

const inputChanged = ev => {
    try {
        $$invalidate('value', value = Number(ev.target.value));
    } catch(_) {
        $$invalidate('value', value = null);
    }
}

let numberText = value === null || value === undefined
                 ? "" : value.toString();

	$$self.$set = $$props => {
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('label' in $$props) $$invalidate('label', label = $$props.label);
	};

	return { value, label, inputChanged };
}

class NumberBox extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["value", "label"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (NumberBox);




/***/ }),

/***/ "./src/common/NumberBox.svelte.css":
/*!*****************************************!*\
  !*** ./src/common/NumberBox.svelte.css ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./NumberBox.svelte.css */ "./node_modules/css-loader/index.js!./src/common/NumberBox.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/Textbox.html":
/*!*********************************!*\
  !*** ./src/common/Textbox.html ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var C_code_budibase_builder_src_common_Textbox_svelte_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/common/Textbox.svelte.css */ "./src/common/Textbox.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_Textbox_svelte_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_Textbox_svelte_css__WEBPACK_IMPORTED_MODULE_1__);
/* src\common\Textbox.html generated by Svelte v3.2.2 */


function create_fragment(ctx) {
	var div1, div0, t0, t1, input, dispose;

	return {
		c() {
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(ctx.label);
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			input = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("input");
			div0.className = "label svelte-umifqh";
			input.className = "control svelte-umifqh";
			div1.className = "container svelte-umifqh";
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(input, "input", ctx.input_input_handler);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, input);

			input.value = ctx.text;
		},

		p(changed, ctx) {
			if (changed.label) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t0, ctx.label);
			}

			if (changed.text && (input.value !== ctx.text)) input.value = ctx.text;
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { text = "", label = "" } = $$props;

	function input_input_handler() {
		text = this.value;
		$$invalidate('text', text);
	}

	$$self.$set = $$props => {
		if ('text' in $$props) $$invalidate('text', text = $$props.text);
		if ('label' in $$props) $$invalidate('label', label = $$props.label);
	};

	return { text, label, input_input_handler };
}

class Textbox extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["text", "label"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (Textbox);




/***/ }),

/***/ "./src/common/Textbox.svelte.css":
/*!***************************************!*\
  !*** ./src/common/Textbox.svelte.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./Textbox.svelte.css */ "./node_modules/css-loader/index.js!./src/common/Textbox.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/ValuesList.html":
/*!************************************!*\
  !*** ./src/common/ValuesList.html ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/fp */ "./node_modules/lodash/fp.js");
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_fp__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var C_code_budibase_builder_src_common_ValuesList_svelte_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/common/ValuesList.svelte.css */ "./src/common/ValuesList.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_common_ValuesList_svelte_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_common_ValuesList_svelte_css__WEBPACK_IMPORTED_MODULE_2__);
/* src\common\ValuesList.html generated by Svelte v3.2.2 */



function create_fragment(ctx) {
	var div1, div0, t0, t1, textarea, dispose;

	return {
		c() {
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(ctx.label);
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			textarea = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("textarea");
			div0.className = "label svelte-1guzwer";
			textarea.className = "control svelte-1guzwer";
			textarea.value = ctx.valuesText;
			div1.className = "container svelte-1guzwer";
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(textarea, "change", ctx.inputChanged);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, textarea);
		},

		p(changed, ctx) {
			if (changed.label) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t0, ctx.label);
			}

			if (changed.valuesText) {
				textarea.value = ctx.valuesText;
			}
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { values, label } = $$props;

const inputChanged = ev => {
    try {
        $$invalidate('values', values = ev.target.value.split("\n"));
    } catch(_) {
        $$invalidate('values', values = []);
    }
}

	$$self.$set = $$props => {
		if ('values' in $$props) $$invalidate('values', values = $$props.values);
		if ('label' in $$props) $$invalidate('label', label = $$props.label);
	};

	let valuesText;

	$$self.$$.update = ($$dirty = { values: 1 }) => {
		if ($$dirty.values) { $$invalidate('valuesText', valuesText = Object(lodash_fp__WEBPACK_IMPORTED_MODULE_1__["join"])("\n")(values)); }
	};

	return { values, label, inputChanged, valuesText };
}

class ValuesList extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["values", "label"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (ValuesList);




/***/ }),

/***/ "./src/common/ValuesList.svelte.css":
/*!******************************************!*\
  !*** ./src/common/ValuesList.svelte.css ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./ValuesList.svelte.css */ "./node_modules/css-loader/index.js!./src/common/ValuesList.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/common/core.js":
/*!****************************!*\
  !*** ./src/common/core.js ***!
  \****************************/
/*! exports provided: chain, getNode, constructHierarchy, templateApi, allTypes, validate, getPotentialReverseReferenceIndexes, getPotentialReferenceIndexes, getDefaultTypeOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return chain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNode", function() { return getNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constructHierarchy", function() { return constructHierarchy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "templateApi", function() { return templateApi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allTypes", function() { return allTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validate", function() { return validate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPotentialReverseReferenceIndexes", function() { return getPotentialReverseReferenceIndexes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPotentialReferenceIndexes", function() { return getPotentialReferenceIndexes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultTypeOptions", function() { return getDefaultTypeOptions; });
/* harmony import */ var budibase_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! budibase-core */ "./node_modules/budibase-core/budibase-core.umd.js");
/* harmony import */ var budibase_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(budibase_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/fp */ "./node_modules/lodash/fp.js");
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_fp__WEBPACK_IMPORTED_MODULE_1__);
 


const chain = budibase_core__WEBPACK_IMPORTED_MODULE_0__["common"].$;

const getNode = (hierarchy, nodeId) => 
    chain(hierarchy, [
        budibase_core__WEBPACK_IMPORTED_MODULE_0__["hierarchy"].getFlattenedHierarchy,
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_1__["find"])(n => n.nodeId === nodeId || n.nodeKey() === nodeId)
    ]);

const constructHierarchy = node => {
    if(!node) return node;
    return templateApi(node).constructHeirarchy(node);
}

const templateApi = hierarchy => Object(budibase_core__WEBPACK_IMPORTED_MODULE_0__["getTemplateApi"])({heirarchy:hierarchy})

const allTypes = templateApi({}).allTypes;

const validate = {
    all: templateApi({}).validateAll,
    node: templateApi({}).validateNode,
    field: templateApi({}).validateField
};

const getPotentialReverseReferenceIndexes = (hierarchy, refIndex) => 
    chain(hierarchy, [
        budibase_core__WEBPACK_IMPORTED_MODULE_0__["hierarchy"].getFlattenedHierarchy,
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_1__["filter"])(n => Object(lodash_fp__WEBPACK_IMPORTED_MODULE_1__["includes"])(n.nodeId)(refIndex.allowedRecordNodeIds)),
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_1__["map"])(n => n.indexes),
        lodash_fp__WEBPACK_IMPORTED_MODULE_1__["flatten"],
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_1__["filter"])(budibase_core__WEBPACK_IMPORTED_MODULE_0__["hierarchy"].isReferenceIndex)
    ]);

const getPotentialReferenceIndexes = (hierarchy, record) =>
    chain(hierarchy, [
        budibase_core__WEBPACK_IMPORTED_MODULE_0__["hierarchy"].getFlattenedHierarchy,
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_1__["filter"])(budibase_core__WEBPACK_IMPORTED_MODULE_0__["hierarchy"].isAncestorIndex),
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_1__["filter"])(i => budibase_core__WEBPACK_IMPORTED_MODULE_0__["hierarchy"].isAncestor(record)(i)
                    || i.parent().nodeId === record.parent().nodeId
                    || budibase_core__WEBPACK_IMPORTED_MODULE_0__["hierarchy"].isRoot(i.parent()))
    ]);

const getDefaultTypeOptions = type => 
    !type ? {} : allTypes[type].getDefaultOptions();

/***/ }),

/***/ "./src/common/icon.js":
/*!****************************!*\
  !*** ./src/common/icon.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var feather_icons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! feather-icons */ "./node_modules/feather-icons/dist/feather.js");
/* harmony import */ var feather_icons__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(feather_icons__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ __webpack_exports__["default"] = (icon => feather_icons__WEBPACK_IMPORTED_MODULE_0___default.a.toSvg(icon));

/***/ }),

/***/ "./src/database/ActionsHeader.html":
/*!*****************************************!*\
  !*** ./src/database/ActionsHeader.html ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _common_Button_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Button.html */ "./src/common/Button.html");
/* harmony import */ var _builderStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../builderStore */ "./src/builderStore/index.js");
/* harmony import */ var _common_Modal_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/Modal.html */ "./src/common/Modal.html");
/* harmony import */ var _common_ErrorsBox_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/ErrorsBox.html */ "./src/common/ErrorsBox.html");
/* harmony import */ var C_code_budibase_builder_src_database_ActionsHeader_svelte_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/database/ActionsHeader.svelte.css */ "./src/database/ActionsHeader.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_database_ActionsHeader_svelte_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_database_ActionsHeader_svelte_css__WEBPACK_IMPORTED_MODULE_5__);
/* src\database\ActionsHeader.html generated by Svelte v3.2.2 */






// (25:8) {:else}
function create_else_block(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Update");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

// (23:8) {#if $database.currentNodeIsNew}
function create_if_block_2(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Create");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

// (22:4) <Button color="primary" on:click={database.saveCurrentNode}>
function create_default_slot_4(ctx) {
	var if_block_anchor;

	function select_block_type(ctx) {
		if (ctx.$database.currentNodeIsNew) return create_if_block_2;
		return create_else_block;
	}

	var current_block_type = select_block_type(ctx);
	var if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["empty"])();
		},

		m(target, anchor) {
			if_block.m(target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, if_block_anchor, anchor);
		},

		p(changed, ctx) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);
				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},

		d(detaching) {
			if_block.d(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(if_block_anchor);
			}
		}
	};
}

// (30:4) {#if !$database.currentNodeIsNew}
function create_if_block_1(ctx) {
	var current;

	var button = new _common_Button_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		color: "deletion",
		$$slots: { default: [create_default_slot_3] },
		$$scope: { ctx }
	}
	});
	button.$on("click", ctx.openConfirmDelete);

	return {
		c() {
			button.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(button, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var button_changes = {};
			if (changed.$$scope) button_changes.$$scope = { changed, ctx };
			button.$set(button_changes);
		},

		i(local) {
			if (current) return;
			button.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			button.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			button.$destroy(detaching);
		}
	};
}

// (31:4) <Button color="deletion" on:click={openConfirmDelete}>
function create_default_slot_3(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Delete");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

// (36:4) {#if !!$database.errors && $database.errors.length > 0}
function create_if_block(ctx) {
	var div, current;

	var errorsbox = new _common_ErrorsBox_html__WEBPACK_IMPORTED_MODULE_4__["default"]({ props: { errors: ctx.$database.errors } });

	return {
		c() {
			div = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			errorsbox.$$.fragment.c();
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div, "width", "500px");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(errorsbox, div, null);
			current = true;
		},

		p(changed, ctx) {
			var errorsbox_changes = {};
			if (changed.$database) errorsbox_changes.errors = ctx.$database.errors;
			errorsbox.$set(errorsbox_changes);
		},

		i(local) {
			if (current) return;
			errorsbox.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			errorsbox.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div);
			}

			errorsbox.$destroy();
		}
	};
}

// (45:12) <Button color="primary"  on:click={deleteCurrentNode}>
function create_default_slot_2(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Yes");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

// (46:12) <Button color="secondary" on:click={() => confirmDelete = false}>
function create_default_slot_1(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("No");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

// (42:4) <Modal bind:isOpen={confirmDelete}>
function create_default_slot(ctx) {
	var div0, t0, t1_value = ctx.$database.currentNode.name, t1, t2, t3, div1, t4, current;

	var button0 = new _common_Button_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		color: "primary",
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	}
	});
	button0.$on("click", ctx.deleteCurrentNode);

	var button1 = new _common_Button_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		color: "secondary",
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	}
	});
	button1.$on("click", ctx.click_handler);

	return {
		c() {
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Are you sure you want to delete ");
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t1_value);
			t2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(" ?");
			t3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			button0.$$.fragment.c();
			t4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			button1.$$.fragment.c();
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div0, "margin", "10px 0px 20px 0px");
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div1, "float", "right");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div0, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t3, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(button0, div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(button1, div1, null);
			current = true;
		},

		p(changed, ctx) {
			if ((!current || changed.$database) && t1_value !== (t1_value = ctx.$database.currentNode.name)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t1, t1_value);
			}

			var button0_changes = {};
			if (changed.$$scope) button0_changes.$$scope = { changed, ctx };
			button0.$set(button0_changes);

			var button1_changes = {};
			if (changed.$$scope) button1_changes.$$scope = { changed, ctx };
			button1.$set(button1_changes);
		},

		i(local) {
			if (current) return;
			button0.$$.fragment.i(local);

			button1.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			button0.$$.fragment.o(local);
			button1.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div0);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t3);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			button0.$destroy();

			button1.$destroy();
		}
	};
}

function create_fragment(ctx) {
	var div, t0, t1, t2, updating_isOpen, current;

	var button = new _common_Button_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		color: "primary",
		$$slots: { default: [create_default_slot_4] },
		$$scope: { ctx }
	}
	});
	button.$on("click", _builderStore__WEBPACK_IMPORTED_MODULE_2__["database"].saveCurrentNode);

	var if_block0 = (!ctx.$database.currentNodeIsNew) && create_if_block_1(ctx);

	var if_block1 = (!!ctx.$database.errors && ctx.$database.errors.length > 0) && create_if_block(ctx);

	function modal_isOpen_binding(value) {
		ctx.modal_isOpen_binding.call(null, value);
		updating_isOpen = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_isOpen = false);
	}

	let modal_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};
	if (ctx.confirmDelete !== void 0) {
		modal_props.isOpen = ctx.confirmDelete;
	}
	var modal = new _common_Modal_html__WEBPACK_IMPORTED_MODULE_3__["default"]({ props: modal_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(modal, 'isOpen', modal_isOpen_binding));

	return {
		c() {
			div = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			button.$$.fragment.c();
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			if (if_block0) if_block0.c();
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			if (if_block1) if_block1.c();
			t2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			modal.$$.fragment.c();
			div.className = "root svelte-160njkp";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div, "left", ctx.left);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(button, div, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, t0);
			if (if_block0) if_block0.m(div, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, t1);
			if (if_block1) if_block1.m(div, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, t2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(modal, div, null);
			current = true;
		},

		p(changed, ctx) {
			var button_changes = {};
			if (changed.$$scope || changed.$database) button_changes.$$scope = { changed, ctx };
			button.$set(button_changes);

			if (!ctx.$database.currentNodeIsNew) {
				if (if_block0) {
					if_block0.p(changed, ctx);
					if_block0.i(1);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.i(1);
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					if_block0.d(1);
					if_block0 = null;
				});

				if_block0.o(1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
			}

			if (!!ctx.$database.errors && ctx.$database.errors.length > 0) {
				if (if_block1) {
					if_block1.p(changed, ctx);
					if_block1.i(1);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.i(1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					if_block1.d(1);
					if_block1 = null;
				});

				if_block1.o(1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
			}

			var modal_changes = {};
			if (changed.$$scope || changed.$database) modal_changes.$$scope = { changed, ctx };
			if (!updating_isOpen && changed.confirmDelete) {
				modal_changes.isOpen = ctx.confirmDelete;
			}
			modal.$set(modal_changes);

			if (!current || changed.left) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div, "left", ctx.left);
			}
		},

		i(local) {
			if (current) return;
			button.$$.fragment.i(local);

			if (if_block0) if_block0.i();
			if (if_block1) if_block1.i();

			modal.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			button.$$.fragment.o(local);
			if (if_block0) if_block0.o();
			if (if_block1) if_block1.o();
			modal.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div);
			}

			button.$destroy();

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();

			modal.$destroy();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $database;

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["subscribe"])($$self, _builderStore__WEBPACK_IMPORTED_MODULE_2__["database"], $$value => { $database = $$value; $$invalidate('$database', $database); });

	

let { left } = $$props;
let confirmDelete = false;
const openConfirmDelete = () => {
    $$invalidate('confirmDelete', confirmDelete = true);
}

const deleteCurrentNode = () => {
    $$invalidate('confirmDelete', confirmDelete = false);
    _builderStore__WEBPACK_IMPORTED_MODULE_2__["database"].deleteCurrentNode();
}

	function click_handler() {
		const $$result = confirmDelete = false;
		$$invalidate('confirmDelete', confirmDelete);
		return $$result;
	}

	function modal_isOpen_binding(value) {
		confirmDelete = value;
		$$invalidate('confirmDelete', confirmDelete);
	}

	$$self.$set = $$props => {
		if ('left' in $$props) $$invalidate('left', left = $$props.left);
	};

	return {
		left,
		confirmDelete,
		openConfirmDelete,
		deleteCurrentNode,
		$database,
		click_handler,
		modal_isOpen_binding
	};
}

class ActionsHeader extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["left"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (ActionsHeader);




/***/ }),

/***/ "./src/database/ActionsHeader.svelte.css":
/*!***********************************************!*\
  !*** ./src/database/ActionsHeader.svelte.css ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./ActionsHeader.svelte.css */ "./node_modules/css-loader/index.js!./src/database/ActionsHeader.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/database/DatabaseRoot.html":
/*!****************************************!*\
  !*** ./src/database/DatabaseRoot.html ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _HierarchyRow_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HierarchyRow.html */ "./src/database/HierarchyRow.html");
/* harmony import */ var _RecordView_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RecordView.html */ "./src/database/RecordView.html");
/* harmony import */ var _IndexView_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./IndexView.html */ "./src/database/IndexView.html");
/* harmony import */ var _ActionsHeader_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ActionsHeader.html */ "./src/database/ActionsHeader.html");
/* harmony import */ var _builderStore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../builderStore */ "./src/builderStore/index.js");
/* harmony import */ var _common_icon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/icon */ "./src/common/icon.js");
/* harmony import */ var _common_DropdownButton_html__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/DropdownButton.html */ "./src/common/DropdownButton.html");
/* harmony import */ var budibase_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! budibase-core */ "./node_modules/budibase-core/budibase-core.umd.js");
/* harmony import */ var budibase_core__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(budibase_core__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var C_code_budibase_builder_src_database_DatabaseRoot_svelte_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/database/DatabaseRoot.svelte.css */ "./src/database/DatabaseRoot.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_database_DatabaseRoot_svelte_css__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_database_DatabaseRoot_svelte_css__WEBPACK_IMPORTED_MODULE_9__);
/* src\database\DatabaseRoot.html generated by Svelte v3.2.2 */










function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.index = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.record = list[i];
	return child_ctx;
}

// (58:8) {#each $database.hierarchy.children as record}
function create_each_block_1(ctx) {
	var current;

	var hierarchyrow = new _HierarchyRow_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: { node: ctx.record } });

	return {
		c() {
			hierarchyrow.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(hierarchyrow, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var hierarchyrow_changes = {};
			if (changed.$database) hierarchyrow_changes.node = ctx.record;
			hierarchyrow.$set(hierarchyrow_changes);
		},

		i(local) {
			if (current) return;
			hierarchyrow.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			hierarchyrow.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			hierarchyrow.$destroy(detaching);
		}
	};
}

// (66:8) {#each $database.hierarchy.indexes as index}
function create_each_block(ctx) {
	var current;

	var hierarchyrow = new _HierarchyRow_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: { node: ctx.index } });

	return {
		c() {
			hierarchyrow.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(hierarchyrow, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var hierarchyrow_changes = {};
			if (changed.$database) hierarchyrow_changes.node = ctx.index;
			hierarchyrow.$set(hierarchyrow_changes);
		},

		i(local) {
			if (current) return;
			hierarchyrow.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			hierarchyrow.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			hierarchyrow.$destroy(detaching);
		}
	};
}

// (79:12) {:else}
function create_else_block(ctx) {
	var current;

	var indexview = new _IndexView_html__WEBPACK_IMPORTED_MODULE_3__["default"]({});

	return {
		c() {
			indexview.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(indexview, target, anchor);
			current = true;
		},

		i(local) {
			if (current) return;
			indexview.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			indexview.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			indexview.$destroy(detaching);
		}
	};
}

// (77:62) 
function create_if_block_1(ctx) {
	var current;

	var recordview = new _RecordView_html__WEBPACK_IMPORTED_MODULE_2__["default"]({});

	return {
		c() {
			recordview.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(recordview, target, anchor);
			current = true;
		},

		i(local) {
			if (current) return;
			recordview.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			recordview.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			recordview.$destroy(detaching);
		}
	};
}

// (75:12) {#if !$database.currentNode}
function create_if_block(ctx) {
	var h1;

	return {
		c() {
			h1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("h1");
			h1.textContent = "nothing selected";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, h1, anchor);
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(h1);
			}
		}
	};
}

function create_fragment(ctx) {
	var div8, div4, div1, div0, t1, t2, t3, div3, div2, t5, t6, t7, div7, div5, t8, div6, current_block_type_index, if_block, current;

	var dropdownbutton0 = new _common_DropdownButton_html__WEBPACK_IMPORTED_MODULE_7__["default"]({
		props: { iconName: "plus", actions: ctx.newRecordActions }
	});

	var each_value_1 = ctx.$database.hierarchy.children;

	var each_blocks_1 = [];

	for (var i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	function outro_block(i, detaching, local) {
		if (each_blocks_1[i]) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					each_blocks_1[i].d(detaching);
					each_blocks_1[i] = null;
				});
			}

			each_blocks_1[i].o(local);
		}
	}

	var dropdownbutton1 = new _common_DropdownButton_html__WEBPACK_IMPORTED_MODULE_7__["default"]({
		props: { iconName: "plus", actions: ctx.newIndexActions }
	});

	var each_value = ctx.$database.hierarchy.indexes;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function outro_block_1(i, detaching, local) {
		if (each_blocks[i]) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					each_blocks[i].d(detaching);
					each_blocks[i] = null;
				});
			}

			each_blocks[i].o(local);
		}
	}

	var actionsheader = new _ActionsHeader_html__WEBPACK_IMPORTED_MODULE_4__["default"]({ props: { left: hierarchyWidth } });

	var if_block_creators = [
		create_if_block,
		create_if_block_1,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (!ctx.$database.currentNode) return 0;
		if (ctx.$database.currentNode.type === "record") return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div8 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0.textContent = "Records";
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			dropdownbutton0.$$.fragment.c();
			t2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();

			for (var i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div2.textContent = "Indexes";
			t5 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			dropdownbutton1.$$.fragment.c();
			t6 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t7 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div7 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div5 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			actionsheader.$$.fragment.c();
			t8 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div6 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			if_block.c();
			div0.className = "hierarchy-title svelte-z7gm0t";
			div1.className = "hierarchy-title-row svelte-z7gm0t";
			div2.className = "hierarchy-title svelte-z7gm0t";
			div3.className = "hierarchy-title-row svelte-z7gm0t";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div3, "margin-top", "20px");
			div4.className = "hierarchy svelte-z7gm0t";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div4, "width", hierarchyWidth);
			div5.className = "actions-header svelte-z7gm0t";
			div6.className = "node-view svelte-z7gm0t";
			div7.className = "node-container svelte-z7gm0t";
			div8.className = "root svelte-z7gm0t";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div8, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div8, div4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div4, div1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(dropdownbutton0, div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div4, t2);

			for (var i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div4, null);
			}

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div4, t3);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div4, div3);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, div2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, t5);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(dropdownbutton1, div3, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div4, t6);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div4, null);
			}

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div8, t7);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div8, div7);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div7, div5);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(actionsheader, div5, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div7, t8);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div7, div6);
			if_blocks[current_block_type_index].m(div6, null);
			current = true;
		},

		p(changed, ctx) {
			var dropdownbutton0_changes = {};
			if (changed.newRecordActions) dropdownbutton0_changes.actions = ctx.newRecordActions;
			dropdownbutton0.$set(dropdownbutton0_changes);

			if (changed.$database) {
				each_value_1 = ctx.$database.hierarchy.children;

				for (var i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(changed, child_ctx);
						each_blocks_1[i].i(1);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].i(1);
						each_blocks_1[i].m(div4, t3);
					}
				}

				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				for (; i < each_blocks_1.length; i += 1) outro_block(i, 1, 1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
			}

			var dropdownbutton1_changes = {};
			if (changed.newIndexActions) dropdownbutton1_changes.actions = ctx.newIndexActions;
			dropdownbutton1.$set(dropdownbutton1_changes);

			if (changed.$database) {
				each_value = ctx.$database.hierarchy.indexes;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						each_blocks[i].i(1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].i(1);
						each_blocks[i].m(div4, null);
					}
				}

				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				for (; i < each_blocks.length; i += 1) outro_block_1(i, 1, 1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
			}

			if (!current || changed.hierarchyWidth) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div4, "width", hierarchyWidth);
			}

			var actionsheader_changes = {};
			if (changed.hierarchyWidth) actionsheader_changes.left = hierarchyWidth;
			actionsheader.$set(actionsheader_changes);

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index !== previous_block_index) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					if_blocks[previous_block_index].d(1);
					if_blocks[previous_block_index] = null;
				});
				if_block.o(1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				if_block.i(1);
				if_block.m(div6, null);
			}
		},

		i(local) {
			if (current) return;
			dropdownbutton0.$$.fragment.i(local);

			for (var i = 0; i < each_value_1.length; i += 1) each_blocks_1[i].i();

			dropdownbutton1.$$.fragment.i(local);

			for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

			actionsheader.$$.fragment.i(local);

			if (if_block) if_block.i();
			current = true;
		},

		o(local) {
			dropdownbutton0.$$.fragment.o(local);

			each_blocks_1 = each_blocks_1.filter(Boolean);
			for (let i = 0; i < each_blocks_1.length; i += 1) outro_block(i, 0);

			dropdownbutton1.$$.fragment.o(local);

			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) outro_block_1(i, 0);

			actionsheader.$$.fragment.o(local);
			if (if_block) if_block.o();
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div8);
			}

			dropdownbutton0.$destroy();

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["destroy_each"])(each_blocks_1, detaching);

			dropdownbutton1.$destroy();

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["destroy_each"])(each_blocks, detaching);

			actionsheader.$destroy();

			if_blocks[current_block_type_index].d();
		}
	};
}

const hierarchyWidth = "200px";

function instance($$self, $$props, $$invalidate) {
	let $database;

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["subscribe"])($$self, _builderStore__WEBPACK_IMPORTED_MODULE_5__["database"], $$value => { $database = $$value; $$invalidate('$database', $database); });

	

const defaultNewIndexActions =  [{
    label:"New Root Index", 
    onclick: _builderStore__WEBPACK_IMPORTED_MODULE_5__["database"].newRootIndex
}];

const defaultNewRecordActions = [{
    label:"New Root Record", 
    onclick: _builderStore__WEBPACK_IMPORTED_MODULE_5__["database"].newRootRecord
}];

let newIndexActions = defaultNewIndexActions;
let newRecordActions = defaultNewRecordActions;

_builderStore__WEBPACK_IMPORTED_MODULE_5__["database"].subscribe(db => {
    if(budibase_core__WEBPACK_IMPORTED_MODULE_8__["hierarchy"].isIndex(db.currentNode)) {
        

        $$invalidate('newRecordActions', newRecordActions = defaultNewRecordActions);
        $$invalidate('newIndexActions', newIndexActions = defaultNewIndexActions);

    } else {
        $$invalidate('newRecordActions', newRecordActions = [
            ...defaultNewRecordActions,
            {label: `New Child Record of ${db.currentNode.name}`, 
            onclick: _builderStore__WEBPACK_IMPORTED_MODULE_5__["database"].newChildRecord}
        ]);

        $$invalidate('newIndexActions', newIndexActions = [
            ...defaultNewIndexActions,
            {label: `New Index on ${db.currentNode.name}`, 
            onclick: _builderStore__WEBPACK_IMPORTED_MODULE_5__["database"].newChildIndex}
        ]);
    }
});

	return {
		newIndexActions,
		newRecordActions,
		$database
	};
}

class DatabaseRoot extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], []);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (DatabaseRoot);




/***/ }),

/***/ "./src/database/DatabaseRoot.svelte.css":
/*!**********************************************!*\
  !*** ./src/database/DatabaseRoot.svelte.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./DatabaseRoot.svelte.css */ "./node_modules/css-loader/index.js!./src/database/DatabaseRoot.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/database/FieldView.html":
/*!*************************************!*\
  !*** ./src/database/FieldView.html ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _common_Dropdown_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Dropdown.html */ "./src/common/Dropdown.html");
/* harmony import */ var _common_Textbox_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Textbox.html */ "./src/common/Textbox.html");
/* harmony import */ var _common_Button_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/Button.html */ "./src/common/Button.html");
/* harmony import */ var _common_NumberBox_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/NumberBox.html */ "./src/common/NumberBox.html");
/* harmony import */ var _common_ValuesList_html__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/ValuesList.html */ "./src/common/ValuesList.html");
/* harmony import */ var _common_ErrorsBox_html__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/ErrorsBox.html */ "./src/common/ErrorsBox.html");
/* harmony import */ var _common_Checkbox_html__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/Checkbox.html */ "./src/common/Checkbox.html");
/* harmony import */ var _common_DatePicker_html__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/DatePicker.html */ "./src/common/DatePicker.html");
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/fp */ "./node_modules/lodash/fp.js");
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash_fp__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _common_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../common/core */ "./src/common/core.js");
/* harmony import */ var C_code_budibase_builder_src_database_FieldView_svelte_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/database/FieldView.svelte.css */ "./src/database/FieldView.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_database_FieldView_svelte_css__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_database_FieldView_svelte_css__WEBPACK_IMPORTED_MODULE_11__);
/* src\database\FieldView.html generated by Svelte v3.2.2 */












// (64:4) {:else}
function create_else_block(ctx) {
	var div, t_value = ctx.field.name, t;

	return {
		c() {
			div = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t_value);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div, "font-weight", "bold");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, t);
		},

		p(changed, ctx) {
			if ((changed.field) && t_value !== (t_value = ctx.field.name)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t, t_value);
			}
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div);
			}
		}
	};
}

// (62:4) {#if isNew}
function create_if_block_6(ctx) {
	var updating_text, current;

	function textbox_text_binding(value) {
		ctx.textbox_text_binding.call(null, value);
		updating_text = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_text = false);
	}

	let textbox_props = { label: "Field Name" };
	if (ctx.clonedField.name !== void 0) {
		textbox_props.text = ctx.clonedField.name;
	}
	var textbox = new _common_Textbox_html__WEBPACK_IMPORTED_MODULE_2__["default"]({ props: textbox_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(textbox, 'text', textbox_text_binding));

	return {
		c() {
			textbox.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(textbox, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var textbox_changes = {};
			if (!updating_text && changed.clonedField) {
				textbox_changes.text = ctx.clonedField.name;
			}
			textbox.$set(textbox_changes);
		},

		i(local) {
			if (current) return;
			textbox.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			textbox.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			textbox.$destroy(detaching);
		}
	};
}

// (98:51) 
function create_if_block_5(ctx) {
	var updating_value, t, updating_value_1, current;

	function numberbox0_value_binding_1(value) {
		ctx.numberbox0_value_binding_1.call(null, value);
		updating_value = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_value = false);
	}

	let numberbox0_props = { label: "Min Length" };
	if (ctx.clonedField.typeOptions.minLength !== void 0) {
		numberbox0_props.value = ctx.clonedField.typeOptions.minLength;
	}
	var numberbox0 = new _common_NumberBox_html__WEBPACK_IMPORTED_MODULE_4__["default"]({ props: numberbox0_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(numberbox0, 'value', numberbox0_value_binding_1));

	function numberbox1_value_binding_1(value_1) {
		ctx.numberbox1_value_binding_1.call(null, value_1);
		updating_value_1 = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_value_1 = false);
	}

	let numberbox1_props = { label: "Max Length" };
	if (ctx.clonedField.typeOptions.maxLength !== void 0) {
		numberbox1_props.value = ctx.clonedField.typeOptions.maxLength;
	}
	var numberbox1 = new _common_NumberBox_html__WEBPACK_IMPORTED_MODULE_4__["default"]({ props: numberbox1_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(numberbox1, 'value', numberbox1_value_binding_1));

	return {
		c() {
			numberbox0.$$.fragment.c();
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			numberbox1.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(numberbox0, target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(numberbox1, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var numberbox0_changes = {};
			if (!updating_value && changed.clonedField) {
				numberbox0_changes.value = ctx.clonedField.typeOptions.minLength;
			}
			numberbox0.$set(numberbox0_changes);

			var numberbox1_changes = {};
			if (!updating_value_1 && changed.clonedField) {
				numberbox1_changes.value = ctx.clonedField.typeOptions.maxLength;
			}
			numberbox1.$set(numberbox1_changes);
		},

		i(local) {
			if (current) return;
			numberbox0.$$.fragment.i(local);

			numberbox1.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			numberbox0.$$.fragment.o(local);
			numberbox1.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			numberbox0.$destroy(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}

			numberbox1.$destroy(detaching);
		}
	};
}

// (84:47) 
function create_if_block_4(ctx) {
	var updating_selected, t, updating_selected_1, current;

	function dropdown0_selected_binding(value) {
		ctx.dropdown0_selected_binding.call(null, value);
		updating_selected = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_selected = false);
	}

	let dropdown0_props = {
		label: "Lookup Index",
		options: ctx.possibleReferenceIndexes,
		valueMember: func,
		textMember: func_1
	};
	if (ctx.clonedField.typeOptions.indexNodeKey !== void 0) {
		dropdown0_props.selected = ctx.clonedField.typeOptions.indexNodeKey;
	}
	var dropdown0 = new _common_Dropdown_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: dropdown0_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(dropdown0, 'selected', dropdown0_selected_binding));

	function dropdown1_selected_binding(value_1) {
		ctx.dropdown1_selected_binding.call(null, value_1);
		updating_selected_1 = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_selected_1 = false);
	}

	let dropdown1_props = {
		label: "Reverse Reference Index",
		options: ctx.possibleReverseReferenceIndexes,
		multiple: "true",
		valueMember: func_2,
		textMember: func_3
	};
	if (ctx.clonedField.typeOptions.reverseIndexNodeKeys !== void 0) {
		dropdown1_props.selected = ctx.clonedField.typeOptions.reverseIndexNodeKeys;
	}
	var dropdown1 = new _common_Dropdown_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: dropdown1_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(dropdown1, 'selected', dropdown1_selected_binding));

	return {
		c() {
			dropdown0.$$.fragment.c();
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			dropdown1.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(dropdown0, target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(dropdown1, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var dropdown0_changes = {};
			if (changed.possibleReferenceIndexes) dropdown0_changes.options = ctx.possibleReferenceIndexes;
			if (!updating_selected && changed.clonedField) {
				dropdown0_changes.selected = ctx.clonedField.typeOptions.indexNodeKey;
			}
			dropdown0.$set(dropdown0_changes);

			var dropdown1_changes = {};
			if (changed.possibleReverseReferenceIndexes) dropdown1_changes.options = ctx.possibleReverseReferenceIndexes;
			if (!updating_selected_1 && changed.clonedField) {
				dropdown1_changes.selected = ctx.clonedField.typeOptions.reverseIndexNodeKeys;
			}
			dropdown1.$set(dropdown1_changes);
		},

		i(local) {
			if (current) return;
			dropdown0.$$.fragment.i(local);

			dropdown1.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			dropdown0.$$.fragment.o(local);
			dropdown1.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			dropdown0.$destroy(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}

			dropdown1.$destroy(detaching);
		}
	};
}

// (80:44) 
function create_if_block_3(ctx) {
	var updating_value, t0, updating_value_1, t1, updating_value_2, current;

	function numberbox0_value_binding(value) {
		ctx.numberbox0_value_binding.call(null, value);
		updating_value = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_value = false);
	}

	let numberbox0_props = { label: "Min Value" };
	if (ctx.clonedField.typeOptions.minValue !== void 0) {
		numberbox0_props.value = ctx.clonedField.typeOptions.minValue;
	}
	var numberbox0 = new _common_NumberBox_html__WEBPACK_IMPORTED_MODULE_4__["default"]({ props: numberbox0_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(numberbox0, 'value', numberbox0_value_binding));

	function numberbox1_value_binding(value_1) {
		ctx.numberbox1_value_binding.call(null, value_1);
		updating_value_1 = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_value_1 = false);
	}

	let numberbox1_props = { label: "Max Value" };
	if (ctx.clonedField.typeOptions.maxValue !== void 0) {
		numberbox1_props.value = ctx.clonedField.typeOptions.maxValue;
	}
	var numberbox1 = new _common_NumberBox_html__WEBPACK_IMPORTED_MODULE_4__["default"]({ props: numberbox1_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(numberbox1, 'value', numberbox1_value_binding));

	function numberbox2_value_binding(value_2) {
		ctx.numberbox2_value_binding.call(null, value_2);
		updating_value_2 = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_value_2 = false);
	}

	let numberbox2_props = { label: "Decimal Places" };
	if (ctx.clonedField.typeOptions.decimalPlaces !== void 0) {
		numberbox2_props.value = ctx.clonedField.typeOptions.decimalPlaces;
	}
	var numberbox2 = new _common_NumberBox_html__WEBPACK_IMPORTED_MODULE_4__["default"]({ props: numberbox2_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(numberbox2, 'value', numberbox2_value_binding));

	return {
		c() {
			numberbox0.$$.fragment.c();
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			numberbox1.$$.fragment.c();
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			numberbox2.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(numberbox0, target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t0, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(numberbox1, target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(numberbox2, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var numberbox0_changes = {};
			if (!updating_value && changed.clonedField) {
				numberbox0_changes.value = ctx.clonedField.typeOptions.minValue;
			}
			numberbox0.$set(numberbox0_changes);

			var numberbox1_changes = {};
			if (!updating_value_1 && changed.clonedField) {
				numberbox1_changes.value = ctx.clonedField.typeOptions.maxValue;
			}
			numberbox1.$set(numberbox1_changes);

			var numberbox2_changes = {};
			if (!updating_value_2 && changed.clonedField) {
				numberbox2_changes.value = ctx.clonedField.typeOptions.decimalPlaces;
			}
			numberbox2.$set(numberbox2_changes);
		},

		i(local) {
			if (current) return;
			numberbox0.$$.fragment.i(local);

			numberbox1.$$.fragment.i(local);

			numberbox2.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			numberbox0.$$.fragment.o(local);
			numberbox1.$$.fragment.o(local);
			numberbox2.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			numberbox0.$destroy(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t0);
			}

			numberbox1.$destroy(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t1);
			}

			numberbox2.$destroy(detaching);
		}
	};
}

// (77:46) 
function create_if_block_2(ctx) {
	var updating_value, t, updating_value_1, current;

	function datepicker0_value_binding(value) {
		ctx.datepicker0_value_binding.call(null, value);
		updating_value = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_value = false);
	}

	let datepicker0_props = { label: "Min Value" };
	if (ctx.clonedField.typeOptions.minValue !== void 0) {
		datepicker0_props.value = ctx.clonedField.typeOptions.minValue;
	}
	var datepicker0 = new _common_DatePicker_html__WEBPACK_IMPORTED_MODULE_8__["default"]({ props: datepicker0_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(datepicker0, 'value', datepicker0_value_binding));

	function datepicker1_value_binding(value_1) {
		ctx.datepicker1_value_binding.call(null, value_1);
		updating_value_1 = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_value_1 = false);
	}

	let datepicker1_props = { label: "Max Value" };
	if (ctx.clonedField.typeOptions.maxValue !== void 0) {
		datepicker1_props.value = ctx.clonedField.typeOptions.maxValue;
	}
	var datepicker1 = new _common_DatePicker_html__WEBPACK_IMPORTED_MODULE_8__["default"]({ props: datepicker1_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(datepicker1, 'value', datepicker1_value_binding));

	return {
		c() {
			datepicker0.$$.fragment.c();
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			datepicker1.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(datepicker0, target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(datepicker1, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var datepicker0_changes = {};
			if (!updating_value && changed.clonedField) {
				datepicker0_changes.value = ctx.clonedField.typeOptions.minValue;
			}
			datepicker0.$set(datepicker0_changes);

			var datepicker1_changes = {};
			if (!updating_value_1 && changed.clonedField) {
				datepicker1_changes.value = ctx.clonedField.typeOptions.maxValue;
			}
			datepicker1.$set(datepicker1_changes);
		},

		i(local) {
			if (current) return;
			datepicker0.$$.fragment.i(local);

			datepicker1.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			datepicker0.$$.fragment.o(local);
			datepicker1.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			datepicker0.$destroy(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}

			datepicker1.$destroy(detaching);
		}
	};
}

// (75:42) 
function create_if_block_1(ctx) {
	var updating_checked, current;

	function checkbox_checked_binding_1(value) {
		ctx.checkbox_checked_binding_1.call(null, value);
		updating_checked = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_checked = false);
	}

	let checkbox_props = { label: "Allow Null" };
	if (ctx.clonedField.typeOptions.allowNulls !== void 0) {
		checkbox_props.checked = ctx.clonedField.typeOptions.allowNulls;
	}
	var checkbox = new _common_Checkbox_html__WEBPACK_IMPORTED_MODULE_7__["default"]({ props: checkbox_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(checkbox, 'checked', checkbox_checked_binding_1));

	return {
		c() {
			checkbox.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(checkbox, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var checkbox_changes = {};
			if (!updating_checked && changed.clonedField) {
				checkbox_changes.checked = ctx.clonedField.typeOptions.allowNulls;
			}
			checkbox.$set(checkbox_changes);
		},

		i(local) {
			if (current) return;
			checkbox.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			checkbox.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			checkbox.$destroy(detaching);
		}
	};
}

// (71:4) {#if clonedField.type === "string"}
function create_if_block(ctx) {
	var updating_value, t0, updating_values, t1, updating_checked, current;

	function numberbox_value_binding(value) {
		ctx.numberbox_value_binding.call(null, value);
		updating_value = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_value = false);
	}

	let numberbox_props = { label: "Max Length" };
	if (ctx.clonedField.typeOptions.maxLength !== void 0) {
		numberbox_props.value = ctx.clonedField.typeOptions.maxLength;
	}
	var numberbox = new _common_NumberBox_html__WEBPACK_IMPORTED_MODULE_4__["default"]({ props: numberbox_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(numberbox, 'value', numberbox_value_binding));

	function valueslist_values_binding(value_1) {
		ctx.valueslist_values_binding.call(null, value_1);
		updating_values = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_values = false);
	}

	let valueslist_props = { label: "Values (options)" };
	if (ctx.clonedField.typeOptions.values !== void 0) {
		valueslist_props.values = ctx.clonedField.typeOptions.values;
	}
	var valueslist = new _common_ValuesList_html__WEBPACK_IMPORTED_MODULE_5__["default"]({ props: valueslist_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(valueslist, 'values', valueslist_values_binding));

	function checkbox_checked_binding(value_2) {
		ctx.checkbox_checked_binding.call(null, value_2);
		updating_checked = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_checked = false);
	}

	let checkbox_props = { label: "Declared Values Only" };
	if (ctx.clonedField.typeOptions.allowDeclaredValuesOnly !== void 0) {
		checkbox_props.checked = ctx.clonedField.typeOptions.allowDeclaredValuesOnly;
	}
	var checkbox = new _common_Checkbox_html__WEBPACK_IMPORTED_MODULE_7__["default"]({ props: checkbox_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(checkbox, 'checked', checkbox_checked_binding));

	return {
		c() {
			numberbox.$$.fragment.c();
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			valueslist.$$.fragment.c();
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			checkbox.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(numberbox, target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t0, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(valueslist, target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(checkbox, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var numberbox_changes = {};
			if (!updating_value && changed.clonedField) {
				numberbox_changes.value = ctx.clonedField.typeOptions.maxLength;
			}
			numberbox.$set(numberbox_changes);

			var valueslist_changes = {};
			if (!updating_values && changed.clonedField) {
				valueslist_changes.values = ctx.clonedField.typeOptions.values;
			}
			valueslist.$set(valueslist_changes);

			var checkbox_changes = {};
			if (!updating_checked && changed.clonedField) {
				checkbox_changes.checked = ctx.clonedField.typeOptions.allowDeclaredValuesOnly;
			}
			checkbox.$set(checkbox_changes);
		},

		i(local) {
			if (current) return;
			numberbox.$$.fragment.i(local);

			valueslist.$$.fragment.i(local);

			checkbox.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			numberbox.$$.fragment.o(local);
			valueslist.$$.fragment.o(local);
			checkbox.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			numberbox.$destroy(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t0);
			}

			valueslist.$destroy(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t1);
			}

			checkbox.$destroy(detaching);
		}
	};
}

// (104:8) <Button color="primary" on:click={save}>
function create_default_slot_1(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Save");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

// (105:8) <Button color="secondary" on:click={() => onFinished(false)}>
function create_default_slot(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Cancel");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

function create_fragment(ctx) {
	var div1, t0, current_block_type_index, if_block0, t1, updating_text, t2, updating_selected, t3, current_block_type_index_1, if_block1, t4, div0, t5, current;

	var errorsbox = new _common_ErrorsBox_html__WEBPACK_IMPORTED_MODULE_6__["default"]({ props: { errors: ctx.errors } });

	var if_block_creators = [
		create_if_block_6,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (ctx.isNew) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	function textbox_text_binding_1(value) {
		ctx.textbox_text_binding_1.call(null, value);
		updating_text = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_text = false);
	}

	let textbox_props = { label: "Label" };
	if (ctx.clonedField.label !== void 0) {
		textbox_props.text = ctx.clonedField.label;
	}
	var textbox = new _common_Textbox_html__WEBPACK_IMPORTED_MODULE_2__["default"]({ props: textbox_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(textbox, 'text', textbox_text_binding_1));

	function dropdown_selected_binding(value_1) {
		ctx.dropdown_selected_binding.call(null, value_1);
		updating_selected = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_selected = false);
	}

	let dropdown_props = { label: "Type", options: Object(lodash_fp__WEBPACK_IMPORTED_MODULE_9__["keys"])(_common_core__WEBPACK_IMPORTED_MODULE_10__["allTypes"]) };
	if (ctx.clonedField.type !== void 0) {
		dropdown_props.selected = ctx.clonedField.type;
	}
	var dropdown = new _common_Dropdown_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: dropdown_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(dropdown, 'selected', dropdown_selected_binding));
	dropdown.$on("change", ctx.typeChanged);

	var if_block_creators_1 = [
		create_if_block,
		create_if_block_1,
		create_if_block_2,
		create_if_block_3,
		create_if_block_4,
		create_if_block_5
	];

	var if_blocks_1 = [];

	function select_block_type_1(ctx) {
		if (ctx.clonedField.type === "string") return 0;
		if (ctx.clonedField.type === "bool") return 1;
		if (ctx.clonedField.type === "datetime") return 2;
		if (ctx.clonedField.type === "number") return 3;
		if (ctx.clonedField.type === "reference") return 4;
		if (ctx.clonedField.type.startsWith("array")) return 5;
		return -1;
	}

	if (~(current_block_type_index_1 = select_block_type_1(ctx))) {
		if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	}

	var button0 = new _common_Button_html__WEBPACK_IMPORTED_MODULE_3__["default"]({
		props: {
		color: "primary",
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	}
	});
	button0.$on("click", ctx.save);

	var button1 = new _common_Button_html__WEBPACK_IMPORTED_MODULE_3__["default"]({
		props: {
		color: "secondary",
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	}
	});
	button1.$on("click", ctx.click_handler);

	return {
		c() {
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			errorsbox.$$.fragment.c();
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			if_block0.c();
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			textbox.$$.fragment.c();
			t2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			dropdown.$$.fragment.c();
			t3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			if (if_block1) if_block1.c();
			t4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			button0.$$.fragment.c();
			t5 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			button1.$$.fragment.c();
			div0.className = "actions svelte-16y4fgx";
			div1.className = "root";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(errorsbox, div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t0);
			if_blocks[current_block_type_index].m(div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(textbox, div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(dropdown, div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t3);
			if (~current_block_type_index_1) if_blocks_1[current_block_type_index_1].m(div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(button0, div0, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t5);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(button1, div0, null);
			current = true;
		},

		p(changed, ctx) {
			var errorsbox_changes = {};
			if (changed.errors) errorsbox_changes.errors = ctx.errors;
			errorsbox.$set(errorsbox_changes);

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					if_blocks[previous_block_index].d(1);
					if_blocks[previous_block_index] = null;
				});
				if_block0.o(1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();

				if_block0 = if_blocks[current_block_type_index];
				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}
				if_block0.i(1);
				if_block0.m(div1, t1);
			}

			var textbox_changes = {};
			if (!updating_text && changed.clonedField) {
				textbox_changes.text = ctx.clonedField.label;
			}
			textbox.$set(textbox_changes);

			var dropdown_changes = {};
			if (changed.keys || changed.allTypes) dropdown_changes.options = Object(lodash_fp__WEBPACK_IMPORTED_MODULE_9__["keys"])(_common_core__WEBPACK_IMPORTED_MODULE_10__["allTypes"]);
			if (!updating_selected && changed.clonedField) {
				dropdown_changes.selected = ctx.clonedField.type;
			}
			dropdown.$set(dropdown_changes);

			var previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);
			if (current_block_type_index_1 === previous_block_index_1) {
				if (~current_block_type_index_1) if_blocks_1[current_block_type_index_1].p(changed, ctx);
			} else {
				if (if_block1) {
					Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
					Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
						if_blocks_1[previous_block_index_1].d(1);
						if_blocks_1[previous_block_index_1] = null;
					});
					if_block1.o(1);
					Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
				}

				if (~current_block_type_index_1) {
					if_block1 = if_blocks_1[current_block_type_index_1];
					if (!if_block1) {
						if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block1.c();
					}
					if_block1.i(1);
					if_block1.m(div1, t4);
				} else {
					if_block1 = null;
				}
			}

			var button0_changes = {};
			if (changed.$$scope) button0_changes.$$scope = { changed, ctx };
			button0.$set(button0_changes);

			var button1_changes = {};
			if (changed.$$scope) button1_changes.$$scope = { changed, ctx };
			button1.$set(button1_changes);
		},

		i(local) {
			if (current) return;
			errorsbox.$$.fragment.i(local);

			if (if_block0) if_block0.i();

			textbox.$$.fragment.i(local);

			dropdown.$$.fragment.i(local);

			if (if_block1) if_block1.i();

			button0.$$.fragment.i(local);

			button1.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			errorsbox.$$.fragment.o(local);
			if (if_block0) if_block0.o();
			textbox.$$.fragment.o(local);
			dropdown.$$.fragment.o(local);
			if (if_block1) if_block1.o();
			button0.$$.fragment.o(local);
			button1.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			errorsbox.$destroy();

			if_blocks[current_block_type_index].d();

			textbox.$destroy();

			dropdown.$destroy();

			if (~current_block_type_index_1) if_blocks_1[current_block_type_index_1].d();

			button0.$destroy();

			button1.$destroy();
		}
	};
}

function func(n) {
	return n.nodeKey();
}

function func_1(n) {
	return n.name;
}

function func_2(n) {
	return n.nodeKey();
}

function func_3(n) {
	return n.name;
}

function instance($$self, $$props, $$invalidate) {
	

let { field, allFields, onFinished = () => {} } = $$props;
let { database } = $$props;

let errors = [];

const typeChanged = (ev) => 
    { const $$result = clonedField.typeOptions = Object(_common_core__WEBPACK_IMPORTED_MODULE_10__["getDefaultTypeOptions"])(ev.detail); $$invalidate('clonedField', clonedField), $$invalidate('field', field); return $$result; };


const save = () => {

    $$invalidate('errors', errors = _common_core__WEBPACK_IMPORTED_MODULE_10__["validate"].field(allFields)(clonedField));
    if(errors.length > 0) return;
    field.typeOptions = Object(lodash_fp__WEBPACK_IMPORTED_MODULE_9__["cloneDeep"])(clonedField.typeOptions); $$invalidate('field', field);
    onFinished(
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_9__["assign"])(field)(clonedField)
    );
}

	function textbox_text_binding(value) {
		clonedField.name = value;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function textbox_text_binding_1(value) {
		clonedField.label = value;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function dropdown_selected_binding(value_1) {
		clonedField.type = value_1;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function numberbox_value_binding(value) {
		clonedField.typeOptions.maxLength = value;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function valueslist_values_binding(value_1) {
		clonedField.typeOptions.values = value_1;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function checkbox_checked_binding(value_2) {
		clonedField.typeOptions.allowDeclaredValuesOnly = value_2;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function checkbox_checked_binding_1(value) {
		clonedField.typeOptions.allowNulls = value;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function datepicker0_value_binding(value) {
		clonedField.typeOptions.minValue = value;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function datepicker1_value_binding(value_1) {
		clonedField.typeOptions.maxValue = value_1;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function numberbox0_value_binding(value) {
		clonedField.typeOptions.minValue = value;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function numberbox1_value_binding(value_1) {
		clonedField.typeOptions.maxValue = value_1;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function numberbox2_value_binding(value_2) {
		clonedField.typeOptions.decimalPlaces = value_2;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function dropdown0_selected_binding(value) {
		clonedField.typeOptions.indexNodeKey = value;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function dropdown1_selected_binding(value_1) {
		clonedField.typeOptions.reverseIndexNodeKeys = value_1;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function numberbox0_value_binding_1(value) {
		clonedField.typeOptions.minLength = value;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function numberbox1_value_binding_1(value_1) {
		clonedField.typeOptions.maxLength = value_1;
		$$invalidate('clonedField', clonedField), $$invalidate('field', field);
	}

	function click_handler() {
		return onFinished(false);
	}

	$$self.$set = $$props => {
		if ('field' in $$props) $$invalidate('field', field = $$props.field);
		if ('allFields' in $$props) $$invalidate('allFields', allFields = $$props.allFields);
		if ('onFinished' in $$props) $$invalidate('onFinished', onFinished = $$props.onFinished);
		if ('database' in $$props) $$invalidate('database', database = $$props.database);
	};

	let clonedField, isNew, possibleReferenceIndexes, selectedReverseRefIndex, possibleReverseReferenceIndexes;

	$$self.$$.update = ($$dirty = { field: 1, database: 1, clonedField: 1, selectedReverseRefIndex: 1 }) => {
		if ($$dirty.field) { $$invalidate('clonedField', clonedField = Object(lodash_fp__WEBPACK_IMPORTED_MODULE_9__["cloneDeep"])(field)); }
		if ($$dirty.field) { $$invalidate('isNew', isNew = !!field && field.name.length === 0); }
		if ($$dirty.database) { $$invalidate('possibleReferenceIndexes', possibleReferenceIndexes = Object(_common_core__WEBPACK_IMPORTED_MODULE_10__["getPotentialReferenceIndexes"])(
            database.hierarchy, database.currentNode
        )); }
		if ($$dirty.clonedField || $$dirty.database) { $$invalidate('selectedReverseRefIndex', selectedReverseRefIndex = 
            !clonedField.typeOptions.indexNodeKey 
            ? ""
            : Object(_common_core__WEBPACK_IMPORTED_MODULE_10__["getNode"])(database.hierarchy, clonedField.typeOptions.indexNodeKey)); }
		if ($$dirty.selectedReverseRefIndex || $$dirty.database) { $$invalidate('possibleReverseReferenceIndexes', possibleReverseReferenceIndexes = 
            !selectedReverseRefIndex 
            ? []
            : Object(_common_core__WEBPACK_IMPORTED_MODULE_10__["getPotentialReverseReferenceIndexes"])(
                database.hierarchy, selectedReverseRefIndex)); }
	};

	return {
		field,
		allFields,
		onFinished,
		database,
		errors,
		typeChanged,
		save,
		clonedField,
		isNew,
		possibleReferenceIndexes,
		possibleReverseReferenceIndexes,
		textbox_text_binding,
		textbox_text_binding_1,
		dropdown_selected_binding,
		numberbox_value_binding,
		valueslist_values_binding,
		checkbox_checked_binding,
		checkbox_checked_binding_1,
		datepicker0_value_binding,
		datepicker1_value_binding,
		numberbox0_value_binding,
		numberbox1_value_binding,
		numberbox2_value_binding,
		dropdown0_selected_binding,
		dropdown1_selected_binding,
		numberbox0_value_binding_1,
		numberbox1_value_binding_1,
		click_handler
	};
}

class FieldView extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["field", "allFields", "onFinished", "database"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (FieldView);




/***/ }),

/***/ "./src/database/FieldView.svelte.css":
/*!*******************************************!*\
  !*** ./src/database/FieldView.svelte.css ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./FieldView.svelte.css */ "./node_modules/css-loader/index.js!./src/database/FieldView.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/database/HierarchyRow.html":
/*!****************************************!*\
  !*** ./src/database/HierarchyRow.html ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _builderStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../builderStore */ "./src/builderStore/index.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var C_code_budibase_builder_src_database_HierarchyRow_svelte_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/database/HierarchyRow.svelte.css */ "./src/database/HierarchyRow.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_database_HierarchyRow_svelte_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_database_HierarchyRow_svelte_css__WEBPACK_IMPORTED_MODULE_3__);
/* src\database\HierarchyRow.html generated by Svelte v3.2.2 */




function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.child = list[i];
	return child_ctx;
}

// (14:4) {#if node.children}
function create_if_block(ctx) {
	var each_1_anchor, current;

	var each_value = ctx.node.children;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function outro_block(i, detaching, local) {
		if (each_blocks[i]) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					each_blocks[i].d(detaching);
					each_blocks[i] = null;
				});
			}

			each_blocks[i].o(local);
		}
	}

	return {
		c() {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["empty"])();
		},

		m(target, anchor) {
			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, each_1_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			if (changed.node || changed.level) {
				each_value = ctx.node.children;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						each_blocks[i].i(1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].i(1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				for (; i < each_blocks.length; i += 1) outro_block(i, 1, 1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
			}
		},

		i(local) {
			if (current) return;
			for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

			current = true;
		},

		o(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) outro_block(i, 0);

			current = false;
		},

		d(detaching) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["destroy_each"])(each_blocks, detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(each_1_anchor);
			}
		}
	};
}

// (15:4) {#each node.children as child}
function create_each_block(ctx) {
	var current;

	var hierarchyrow = new HierarchyRow({
		props: { node: ctx.child, level: ctx.level+1 }
	});

	return {
		c() {
			hierarchyrow.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(hierarchyrow, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var hierarchyrow_changes = {};
			if (changed.node) hierarchyrow_changes.node = ctx.child;
			if (changed.level) hierarchyrow_changes.level = ctx.level+1;
			hierarchyrow.$set(hierarchyrow_changes);
		},

		i(local) {
			if (current) return;
			hierarchyrow.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			hierarchyrow.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			hierarchyrow.$destroy(detaching);
		}
	};
}

function create_fragment(ctx) {
	var div1, div0, t0_value = ctx.node.name, t0, t1, current, dispose;

	var if_block = (ctx.node.children) && create_if_block(ctx);

	return {
		c() {
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t0_value);
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			if (if_block) if_block.c();
			div0.className = "title svelte-1rctf7f";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div0, "padding-left", "" + (20 + (ctx.level * 20)) + "px");
			div1.className = "root svelte-1rctf7f";
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(div0, "click", ctx.click_handler);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t1);
			if (if_block) if_block.m(div1, null);
			current = true;
		},

		p(changed, ctx) {
			if ((!current || changed.node) && t0_value !== (t0_value = ctx.node.name)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t0, t0_value);
			}

			if (!current || changed.level) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div0, "padding-left", "" + (20 + (ctx.level * 20)) + "px");
			}

			if (ctx.node.children) {
				if (if_block) {
					if_block.p(changed, ctx);
					if_block.i(1);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.i(1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					if_block.d(1);
					if_block = null;
				});

				if_block.o(1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
			}
		},

		i(local) {
			if (current) return;
			if (if_block) if_block.i();
			current = true;
		},

		o(local) {
			if (if_block) if_block.o();
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			if (if_block) if_block.d();
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
let { level = 0, node } = $$props;

	function click_handler() {
		return _builderStore__WEBPACK_IMPORTED_MODULE_1__["database"].selectExistingNode(node.nodeId);
	}

	$$self.$set = $$props => {
		if ('level' in $$props) $$invalidate('level', level = $$props.level);
		if ('node' in $$props) $$invalidate('node', node = $$props.node);
	};

	return { level, node, click_handler };
}

class HierarchyRow extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["level", "node"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (HierarchyRow);




/***/ }),

/***/ "./src/database/HierarchyRow.svelte.css":
/*!**********************************************!*\
  !*** ./src/database/HierarchyRow.svelte.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./HierarchyRow.svelte.css */ "./node_modules/css-loader/index.js!./src/database/HierarchyRow.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/database/IndexView.html":
/*!*************************************!*\
  !*** ./src/database/IndexView.html ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _common_Textbox_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Textbox.html */ "./src/common/Textbox.html");
/* harmony import */ var _common_CodeArea_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/CodeArea.html */ "./src/common/CodeArea.html");
/* harmony import */ var _common_Button_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/Button.html */ "./src/common/Button.html");
/* harmony import */ var _common_Dropdown_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/Dropdown.html */ "./src/common/Dropdown.html");
/* harmony import */ var _builderStore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../builderStore */ "./src/builderStore/index.js");
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/fp */ "./node_modules/lodash/fp.js");
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_fp__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var budibase_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! budibase-core */ "./node_modules/budibase-core/budibase-core.umd.js");
/* harmony import */ var budibase_core__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(budibase_core__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var C_code_budibase_builder_src_database_IndexView_svelte_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/database/IndexView.svelte.css */ "./src/database/IndexView.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_database_IndexView_svelte_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_database_IndexView_svelte_css__WEBPACK_IMPORTED_MODULE_8__);
/* src\database\IndexView.html generated by Svelte v3.2.2 */









function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.rec = list[i];
	return child_ctx;
}

// (45:8) {#each indexableRecords as rec}
function create_each_block(ctx) {
	var input, input_checked_value, t0, span, t1_value = ctx.rec.node.name, t1, dispose;

	function change_handler() {
		return ctx.change_handler(ctx);
	}

	return {
		c() {
			input = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("input");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			span = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("span");
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t1_value);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["attr"])(input, "type", "checkbox");
			input.checked = input_checked_value = ctx.rec.isallowed;
			span.className = "svelte-1fkfoam";
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(input, "change", change_handler);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, input, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t0, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, span, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(span, t1);
		},

		p(changed, new_ctx) {
			ctx = new_ctx;
			if ((changed.indexableRecords) && input_checked_value !== (input_checked_value = ctx.rec.isallowed)) {
				input.checked = input_checked_value;
			}

			if ((changed.indexableRecords) && t1_value !== (t1_value = ctx.rec.node.name)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t1, t1_value);
			}
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(input);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t0);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(span);
			}

			dispose();
		}
	};
}

function create_fragment(ctx) {
	var div2, updating_text, t0, div1, div0, t2, t3, updating_value, t4, updating_text_1, t5, updating_text_2, t6, updating_text_3, current;

	function textbox_text_binding(value) {
		ctx.textbox_text_binding.call(null, value);
		updating_text = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_text = false);
	}

	let textbox_props = { label: "Name" };
	if (ctx.index.name !== void 0) {
		textbox_props.text = ctx.index.name;
	}
	var textbox = new _common_Textbox_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: textbox_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(textbox, 'text', textbox_text_binding));

	var each_value = ctx.indexableRecords;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function dropdown_value_binding(value_1) {
		ctx.dropdown_value_binding.call(null, value_1);
		updating_value = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_value = false);
	}

	let dropdown_props = {
		label: "Index Type",
		options: ["ancestor", "reference"]
	};
	if (ctx.index.indexType !== void 0) {
		dropdown_props.value = ctx.index.indexType;
	}
	var dropdown = new _common_Dropdown_html__WEBPACK_IMPORTED_MODULE_4__["default"]({ props: dropdown_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(dropdown, 'value', dropdown_value_binding));

	function codearea0_text_binding(value_2) {
		ctx.codearea0_text_binding.call(null, value_2);
		updating_text_1 = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_text_1 = false);
	}

	let codearea0_props = { label: "Map (javascript)" };
	if (ctx.index.map !== void 0) {
		codearea0_props.text = ctx.index.map;
	}
	var codearea0 = new _common_CodeArea_html__WEBPACK_IMPORTED_MODULE_2__["default"]({ props: codearea0_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(codearea0, 'text', codearea0_text_binding));

	function codearea1_text_binding(value_3) {
		ctx.codearea1_text_binding.call(null, value_3);
		updating_text_2 = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_text_2 = false);
	}

	let codearea1_props = { label: "Filter (javascript expression)" };
	if (ctx.index.filter !== void 0) {
		codearea1_props.text = ctx.index.filter;
	}
	var codearea1 = new _common_CodeArea_html__WEBPACK_IMPORTED_MODULE_2__["default"]({ props: codearea1_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(codearea1, 'text', codearea1_text_binding));

	function codearea2_text_binding(value_4) {
		ctx.codearea2_text_binding.call(null, value_4);
		updating_text_3 = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_text_3 = false);
	}

	let codearea2_props = {
		label: "Shard Name (javascript expression)"
	};
	if (ctx.index.getShardName !== void 0) {
		codearea2_props.text = ctx.index.getShardName;
	}
	var codearea2 = new _common_CodeArea_html__WEBPACK_IMPORTED_MODULE_2__["default"]({ props: codearea2_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(codearea2, 'text', codearea2_text_binding));

	return {
		c() {
			div2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			textbox.$$.fragment.c();
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0.textContent = "Records to Index";
			t2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			dropdown.$$.fragment.c();
			t4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			codearea0.$$.fragment.c();
			t5 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			codearea1.$$.fragment.c();
			t6 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			codearea2.$$.fragment.c();
			div1.className = "allowed-records svelte-1fkfoam";
			div2.className = "root svelte-1fkfoam";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div2, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(textbox, div2, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, div1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t2);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, t3);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(dropdown, div2, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, t4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(codearea0, div2, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, t5);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(codearea1, div2, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, t6);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(codearea2, div2, null);
			current = true;
		},

		p(changed, ctx) {
			var textbox_changes = {};
			if (!updating_text && changed.index) {
				textbox_changes.text = ctx.index.name;
			}
			textbox.$set(textbox_changes);

			if (changed.indexableRecords) {
				each_value = ctx.indexableRecords;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			var dropdown_changes = {};
			if (!updating_value && changed.index) {
				dropdown_changes.value = ctx.index.indexType;
			}
			dropdown.$set(dropdown_changes);

			var codearea0_changes = {};
			if (!updating_text_1 && changed.index) {
				codearea0_changes.text = ctx.index.map;
			}
			codearea0.$set(codearea0_changes);

			var codearea1_changes = {};
			if (!updating_text_2 && changed.index) {
				codearea1_changes.text = ctx.index.filter;
			}
			codearea1.$set(codearea1_changes);

			var codearea2_changes = {};
			if (!updating_text_3 && changed.index) {
				codearea2_changes.text = ctx.index.getShardName;
			}
			codearea2.$set(codearea2_changes);
		},

		i(local) {
			if (current) return;
			textbox.$$.fragment.i(local);

			dropdown.$$.fragment.i(local);

			codearea0.$$.fragment.i(local);

			codearea1.$$.fragment.i(local);

			codearea2.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			textbox.$$.fragment.o(local);
			dropdown.$$.fragment.o(local);
			codearea0.$$.fragment.o(local);
			codearea1.$$.fragment.o(local);
			codearea2.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div2);
			}

			textbox.$destroy();

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["destroy_each"])(each_blocks, detaching);

			dropdown.$destroy();

			codearea0.$destroy();

			codearea1.$destroy();

			codearea2.$destroy();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	

const chain = budibase_core__WEBPACK_IMPORTED_MODULE_7__["common"].$;

let index;
let indexableRecords = [];

_builderStore__WEBPACK_IMPORTED_MODULE_5__["database"].subscribe($database => {
    $$invalidate('index', index = $database.currentNode);
    $$invalidate('indexableRecords', indexableRecords = chain($database.hierarchy,[
        budibase_core__WEBPACK_IMPORTED_MODULE_7__["hierarchy"].getFlattenedHierarchy,
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["filter"])(budibase_core__WEBPACK_IMPORTED_MODULE_7__["hierarchy"].isDecendant(index.parent())),
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["filter"])(budibase_core__WEBPACK_IMPORTED_MODULE_7__["hierarchy"].isRecord),
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["map"])(n => ({
            node:n,
            isallowed: Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["some"])(id => n.nodeId === id)(index.allowedRecordNodeIds)
        }))
    ]));
});

const toggleAllowedRecord = record => {
    if(record.isallowed) {
        index.allowedRecordNodeIds = Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["filter"])(id => id !== record.nodeId)
                                           (index.allowedRecordNodeIds); $$invalidate('index', index);
    } else {
        index.allowedRecordNodeIds.push(record.nodeId);
    }
};

	function textbox_text_binding(value) {
		index.name = value;
		$$invalidate('index', index);
	}

	function change_handler({ rec }) {
		return toggleAllowedRecord(rec);
	}

	function dropdown_value_binding(value_1) {
		index.indexType = value_1;
		$$invalidate('index', index);
	}

	function codearea0_text_binding(value_2) {
		index.map = value_2;
		$$invalidate('index', index);
	}

	function codearea1_text_binding(value_3) {
		index.filter = value_3;
		$$invalidate('index', index);
	}

	function codearea2_text_binding(value_4) {
		index.getShardName = value_4;
		$$invalidate('index', index);
	}

	return {
		index,
		indexableRecords,
		toggleAllowedRecord,
		textbox_text_binding,
		change_handler,
		dropdown_value_binding,
		codearea0_text_binding,
		codearea1_text_binding,
		codearea2_text_binding
	};
}

class IndexView extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], []);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (IndexView);




/***/ }),

/***/ "./src/database/IndexView.svelte.css":
/*!*******************************************!*\
  !*** ./src/database/IndexView.svelte.css ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./IndexView.svelte.css */ "./node_modules/css-loader/index.js!./src/database/IndexView.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/database/RecordView.html":
/*!**************************************!*\
  !*** ./src/database/RecordView.html ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _common_Textbox_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Textbox.html */ "./src/common/Textbox.html");
/* harmony import */ var _common_Button_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Button.html */ "./src/common/Button.html");
/* harmony import */ var _common_icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/icon */ "./src/common/icon.js");
/* harmony import */ var _FieldView_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FieldView.html */ "./src/database/FieldView.html");
/* harmony import */ var _common_Modal_html__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/Modal.html */ "./src/common/Modal.html");
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/fp */ "./node_modules/lodash/fp.js");
/* harmony import */ var lodash_fp__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_fp__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _builderStore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../builderStore */ "./src/builderStore/index.js");
/* harmony import */ var budibase_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! budibase-core */ "./node_modules/budibase-core/budibase-core.umd.js");
/* harmony import */ var budibase_core__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(budibase_core__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _common_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../common/core */ "./src/common/core.js");
/* harmony import */ var C_code_budibase_builder_src_database_RecordView_svelte_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/database/RecordView.svelte.css */ "./src/database/RecordView.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_database_RecordView_svelte_css__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_database_RecordView_svelte_css__WEBPACK_IMPORTED_MODULE_10__);
/* src\database\RecordView.html generated by Svelte v3.2.2 */











function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.index = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.field = list[i];
	return child_ctx;
}

// (85:4) {#if !record.isSingle}
function create_if_block_3(ctx) {
	var updating_text, t, updating_text_1, current;

	function textbox0_text_binding(value) {
		ctx.textbox0_text_binding.call(null, value);
		updating_text = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_text = false);
	}

	let textbox0_props = { label: "Collection Name" };
	if (ctx.record.collectionName !== void 0) {
		textbox0_props.text = ctx.record.collectionName;
	}
	var textbox0 = new _common_Textbox_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: textbox0_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(textbox0, 'text', textbox0_text_binding));

	function textbox1_text_binding(value_1) {
		ctx.textbox1_text_binding.call(null, value_1);
		updating_text_1 = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_text_1 = false);
	}

	let textbox1_props = { label: "Shard Factor" };
	if (ctx.record.allidsShardFactor !== void 0) {
		textbox1_props.text = ctx.record.allidsShardFactor;
	}
	var textbox1 = new _common_Textbox_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: textbox1_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(textbox1, 'text', textbox1_text_binding));

	return {
		c() {
			textbox0.$$.fragment.c();
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			textbox1.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(textbox0, target, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(textbox1, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var textbox0_changes = {};
			if (!updating_text && changed.record) {
				textbox0_changes.text = ctx.record.collectionName;
			}
			textbox0.$set(textbox0_changes);

			var textbox1_changes = {};
			if (!updating_text_1 && changed.record) {
				textbox1_changes.text = ctx.record.allidsShardFactor;
			}
			textbox1.$set(textbox1_changes);
		},

		i(local) {
			if (current) return;
			textbox0.$$.fragment.i(local);

			textbox1.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			textbox0.$$.fragment.o(local);
			textbox1.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			textbox0.$destroy(detaching);

			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}

			textbox1.$destroy(detaching);
		}
	};
}

// (121:4) {:else}
function create_else_block_1(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("(no fields added)");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

// (94:4) {#if record.fields.length > 0}
function create_if_block_2(ctx) {
	var table, thead, t_6, tbody;

	var each_value_1 = ctx.record.fields;

	var each_blocks = [];

	for (var i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			table = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("table");
			thead = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("thead");
			thead.innerHTML = `<tr class="svelte-gq7l8x"><th class="svelte-gq7l8x">Name</th>
			                <th class="svelte-gq7l8x">Type</th>
			                <th class="svelte-gq7l8x">Options</th>
			                <th class="svelte-gq7l8x"></th></tr>`;
			t_6 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			tbody = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("tbody");

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			thead.className = "svelte-gq7l8x";
			tbody.className = "svelte-gq7l8x";
			table.className = "fields-table svelte-gq7l8x";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, table, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(table, thead);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(table, t_6);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(table, tbody);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}
		},

		p(changed, ctx) {
			if (changed.getIcon || changed.getTypeOptions || changed.record) {
				each_value_1 = ctx.record.fields;

				for (var i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value_1.length;
			}
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(table);
			}

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["destroy_each"])(each_blocks, detaching);
		}
	};
}

// (105:12) {#each record.fields as field}
function create_each_block_1(ctx) {
	var tr, td0, div0, t0_value = ctx.field.label, t0, t1, div1, t2_value = ctx.field.name, t2, t3, td1, t4_value = ctx.field.type, t4, t5, td2, raw0_value = ctx.getTypeOptions(ctx.field.typeOptions), t6, td3, span0, raw1_value = Object(_common_icon__WEBPACK_IMPORTED_MODULE_3__["default"])("edit"), t7, span1, raw2_value = Object(_common_icon__WEBPACK_IMPORTED_MODULE_3__["default"])("trash"), dispose;

	function click_handler() {
		return ctx.click_handler(ctx);
	}

	function click_handler_1() {
		return ctx.click_handler_1(ctx);
	}

	return {
		c() {
			tr = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("tr");
			td0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("td");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t0_value);
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t2_value);
			t3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			td1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("td");
			t4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t4_value);
			t5 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			td2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("td");
			t6 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			td3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("td");
			span0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("span");
			t7 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			span1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("span");
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div1, "font-size", "0.7em");
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(div1, "color", "var(--slate)");
			td0.className = "svelte-gq7l8x";
			td1.className = "svelte-gq7l8x";
			td2.className = "svelte-gq7l8x";
			span0.className = "edit-button svelte-gq7l8x";
			span1.className = "edit-button svelte-gq7l8x";
			td3.className = "svelte-gq7l8x";
			tr.className = "svelte-gq7l8x";

			dispose = [
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(span0, "click", click_handler),
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(span1, "click", click_handler_1)
			];
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, tr, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(tr, td0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(td0, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(td0, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(td0, div1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(tr, t3);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(tr, td1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(td1, t4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(tr, t5);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(tr, td2);
			td2.innerHTML = raw0_value;
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(tr, t6);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(tr, td3);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(td3, span0);
			span0.innerHTML = raw1_value;
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(td3, t7);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(td3, span1);
			span1.innerHTML = raw2_value;
		},

		p(changed, new_ctx) {
			ctx = new_ctx;
			if ((changed.record) && t0_value !== (t0_value = ctx.field.label)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t0, t0_value);
			}

			if ((changed.record) && t2_value !== (t2_value = ctx.field.name)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t2, t2_value);
			}

			if ((changed.record) && t4_value !== (t4_value = ctx.field.type)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t4, t4_value);
			}

			if ((changed.record) && raw0_value !== (raw0_value = ctx.getTypeOptions(ctx.field.typeOptions))) {
				td2.innerHTML = raw0_value;
			}
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(tr);
			}

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["run_all"])(dispose);
		}
	};
}

// (125:4) {#if editingField}
function create_if_block_1(ctx) {
	var updating_isOpen, current;

	function modal_isOpen_binding(value) {
		ctx.modal_isOpen_binding.call(null, value);
		updating_isOpen = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_isOpen = false);
	}

	let modal_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};
	if (ctx.editingField !== void 0) {
		modal_props.isOpen = ctx.editingField;
	}
	var modal = new _common_Modal_html__WEBPACK_IMPORTED_MODULE_5__["default"]({ props: modal_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(modal, 'isOpen', modal_isOpen_binding));

	return {
		c() {
			modal.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(modal, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var modal_changes = {};
			if (changed.$$scope || changed.fieldToEdit || changed.onFinishedFieldEdit || changed.record || changed.$database) modal_changes.$$scope = { changed, ctx };
			if (!updating_isOpen && changed.editingField) {
				modal_changes.isOpen = ctx.editingField;
			}
			modal.$set(modal_changes);
		},

		i(local) {
			if (current) return;
			modal.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			modal.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			modal.$destroy(detaching);
		}
	};
}

// (126:4) <Modal bind:isOpen={editingField}>
function create_default_slot(ctx) {
	var current;

	var fieldview = new _FieldView_html__WEBPACK_IMPORTED_MODULE_4__["default"]({
		props: {
		field: ctx.fieldToEdit,
		onFinished: ctx.onFinishedFieldEdit,
		allFields: ctx.record.fields,
		database: ctx.$database
	}
	});

	return {
		c() {
			fieldview.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(fieldview, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var fieldview_changes = {};
			if (changed.fieldToEdit) fieldview_changes.field = ctx.fieldToEdit;
			if (changed.onFinishedFieldEdit) fieldview_changes.onFinished = ctx.onFinishedFieldEdit;
			if (changed.record) fieldview_changes.allFields = ctx.record.fields;
			if (changed.$database) fieldview_changes.database = ctx.$database;
			fieldview.$set(fieldview_changes);
		},

		i(local) {
			if (current) return;
			fieldview.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			fieldview.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			fieldview.$destroy(detaching);
		}
	};
}

// (158:4) {:else}
function create_else_block(ctx) {
	var t;

	return {
		c() {
			t = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("(no indexes added)");
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, t, anchor);
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(t);
			}
		}
	};
}

// (151:8) {#if index.filter}
function create_if_block(ctx) {
	var div, span, t1, code, t2_value = ctx.index.filter, t2;

	return {
		c() {
			div = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			span = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("span");
			span.textContent = "filter:";
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			code = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("code");
			t2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t2_value);
			span.className = "index-label svelte-gq7l8x";
			code.className = "index-mapfilter svelte-gq7l8x";
			div.className = "index-field-row svelte-gq7l8x";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, span);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div, code);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(code, t2);
		},

		p(changed, ctx) {
			if ((changed.record) && t2_value !== (t2_value = ctx.index.filter)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t2, t2_value);
			}
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div);
			}
		}
	};
}

// (138:4) {#each record.indexes as index}
function create_each_block(ctx) {
	var div3, div0, t0_value = ctx.index.name, t0, t1, div1, span0, t3, span1, t4_value = ctx.getIndexAllowedRecords(ctx.index), t4, t5, span2, t7, span3, t8_value = ctx.index.indexType, t8, t9, div2, span4, t11, code, t12_value = ctx.index.map, t12, t13, t14;

	var if_block = (ctx.index.filter) && create_if_block(ctx);

	return {
		c() {
			div3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t0_value);
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			span0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("span");
			span0.textContent = "records indexed:";
			t3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			span1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("span");
			t4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t4_value);
			t5 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			span2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("span");
			span2.textContent = "type:";
			t7 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			span3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("span");
			t8 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t8_value);
			t9 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			span4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("span");
			span4.textContent = "map:";
			t11 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			code = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("code");
			t12 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t12_value);
			t13 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			if (if_block) if_block.c();
			t14 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div0.className = "index-name svelte-gq7l8x";
			span0.className = "index-label svelte-gq7l8x";
			span2.className = "index-label svelte-gq7l8x";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(span2, "margin-left", "15px");
			div1.className = "index-field-row svelte-gq7l8x";
			span4.className = "index-label svelte-gq7l8x";
			code.className = "index-mapfilter svelte-gq7l8x";
			div2.className = "index-field-row svelte-gq7l8x";
			div3.className = "index-container svelte-gq7l8x";
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div3, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, div1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, span0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t3);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, span1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(span1, t4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t5);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, span2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t7);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, span3);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(span3, t8);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, t9);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, div2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, span4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, t11);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, code);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(code, t12);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, t13);
			if (if_block) if_block.m(div3, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, t14);
		},

		p(changed, ctx) {
			if ((changed.record) && t0_value !== (t0_value = ctx.index.name)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t0, t0_value);
			}

			if ((changed.getIndexAllowedRecords || changed.record) && t4_value !== (t4_value = ctx.getIndexAllowedRecords(ctx.index))) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t4, t4_value);
			}

			if ((changed.record) && t8_value !== (t8_value = ctx.index.indexType)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t8, t8_value);
			}

			if ((changed.record) && t12_value !== (t12_value = ctx.index.map)) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t12, t12_value);
			}

			if (ctx.index.filter) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div3, t14);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div3);
			}

			if (if_block) if_block.d();
		}
	};
}

function create_fragment(ctx) {
	var div1, updating_text, t0, div0, t1_value = ctx.record.nodeKey(), t1, t2, t3, h40, t4, span, raw_value = Object(_common_icon__WEBPACK_IMPORTED_MODULE_3__["default"])("plus"), t5, t6, t7, h41, t9, current, dispose;

	function textbox_text_binding(value) {
		ctx.textbox_text_binding.call(null, value);
		updating_text = true;
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_flush_callback"])(() => updating_text = false);
	}

	let textbox_props = { label: "Name" };
	if (ctx.record.name !== void 0) {
		textbox_props.text = ctx.record.name;
	}
	var textbox = new _common_Textbox_html__WEBPACK_IMPORTED_MODULE_1__["default"]({ props: textbox_props });

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["add_binding_callback"])(() => Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["bind"])(textbox, 'text', textbox_text_binding));

	var if_block0 = (!ctx.record.isSingle) && create_if_block_3(ctx);

	function select_block_type(ctx) {
		if (ctx.record.fields.length > 0) return create_if_block_2;
		return create_else_block_1;
	}

	var current_block_type = select_block_type(ctx);
	var if_block1 = current_block_type(ctx);

	var if_block2 = (ctx.editingField) && create_if_block_1(ctx);

	var each_value = ctx.record.indexes;

	var each_blocks = [];

	for (var i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	var each_1_else = null;

	if (!each_value.length) {
		each_1_else = create_else_block(ctx);
		each_1_else.c();
	}

	return {
		c() {
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			textbox.$$.fragment.c();
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])(t1_value);
			t2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			if (if_block0) if_block0.c();
			t3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			h40 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("h4");
			t4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["text"])("Fields ");
			span = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("span");
			t5 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			if_block1.c();
			t6 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			if (if_block2) if_block2.c();
			t7 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			h41 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("h4");
			h41.textContent = "Indexes";
			t9 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			span.className = "add-field-button svelte-gq7l8x";
			div1.className = "root svelte-gq7l8x";
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(span, "click", ctx.newField);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div1, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(textbox, div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div0, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t2);
			if (if_block0) if_block0.m(div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t3);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, h40);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(h40, t4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(h40, span);
			span.innerHTML = raw_value;
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t5);
			if_block1.m(div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t6);
			if (if_block2) if_block2.m(div1, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t7);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, h41);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, t9);

			for (var i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			if (each_1_else) {
				each_1_else.m(div1, null);
			}

			current = true;
		},

		p(changed, ctx) {
			var textbox_changes = {};
			if (!updating_text && changed.record) {
				textbox_changes.text = ctx.record.name;
			}
			textbox.$set(textbox_changes);

			if ((!current || changed.record) && t1_value !== (t1_value = ctx.record.nodeKey())) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_data"])(t1, t1_value);
			}

			if (!ctx.record.isSingle) {
				if (if_block0) {
					if_block0.p(changed, ctx);
					if_block0.i(1);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.i(1);
					if_block0.m(div1, t3);
				}
			} else if (if_block0) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					if_block0.d(1);
					if_block0 = null;
				});

				if_block0.o(1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
				if_block1.p(changed, ctx);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);
				if (if_block1) {
					if_block1.c();
					if_block1.m(div1, t6);
				}
			}

			if (ctx.editingField) {
				if (if_block2) {
					if_block2.p(changed, ctx);
					if_block2.i(1);
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					if_block2.i(1);
					if_block2.m(div1, t7);
				}
			} else if (if_block2) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["group_outros"])();
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["on_outro"])(() => {
					if_block2.d(1);
					if_block2 = null;
				});

				if_block2.o(1);
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["check_outros"])();
			}

			if (changed.record || changed.getIndexAllowedRecords) {
				each_value = ctx.record.indexes;

				for (var i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if (each_value.length) {
				if (each_1_else) {
					each_1_else.d(1);
					each_1_else = null;
				}
			} else if (!each_1_else) {
				each_1_else = create_else_block(ctx);
				each_1_else.c();
				each_1_else.m(div1, null);
			}
		},

		i(local) {
			if (current) return;
			textbox.$$.fragment.i(local);

			if (if_block0) if_block0.i();
			if (if_block2) if_block2.i();
			current = true;
		},

		o(local) {
			textbox.$$.fragment.o(local);
			if (if_block0) if_block0.o();
			if (if_block2) if_block2.o();
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div1);
			}

			textbox.$destroy();

			if (if_block0) if_block0.d();
			if_block1.d();
			if (if_block2) if_block2.d();

			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["destroy_each"])(each_blocks, detaching);

			if (each_1_else) each_1_else.d();

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $database;

	Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["subscribe"])($$self, _builderStore__WEBPACK_IMPORTED_MODULE_7__["database"], $$value => { $database = $$value; $$invalidate('$database', $database); });

	

let record;
let getIndexAllowedRecords;
let editingField = false;
let fieldToEdit;
let isNewField = false;
let newField;
let editField;
let deleteField;
let onFinishedFieldEdit;


_builderStore__WEBPACK_IMPORTED_MODULE_7__["database"].subscribe($database => {
    $$invalidate('record', record = $database.currentNode);
    const flattened = budibase_core__WEBPACK_IMPORTED_MODULE_8__["hierarchy"].getFlattenedHierarchy($database.hierarchy);
    $$invalidate('getIndexAllowedRecords', getIndexAllowedRecords = index => 
        Object(_common_core__WEBPACK_IMPORTED_MODULE_9__["chain"])(index.allowedRecordNodeIds, [
            Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["filter"])(id => Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["some"])(n => n.nodeId === id)(flattened)),
            Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["map"])(id => Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["find"])(n => n.nodeId === id)
                          (flattened).name),
            Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["join"])(", ")
        ]));

    $$invalidate('newField', newField = () => {
        $$invalidate('isNewField', isNewField = true);
        $$invalidate('fieldToEdit', fieldToEdit = Object(_common_core__WEBPACK_IMPORTED_MODULE_9__["templateApi"])($database.hierarchy).getNewField("string"));
        $$invalidate('editingField', editingField = true);
    })

    $$invalidate('onFinishedFieldEdit', onFinishedFieldEdit = (field) => {
        if(field) {
            _builderStore__WEBPACK_IMPORTED_MODULE_7__["database"].saveField(field);
        }
        $$invalidate('editingField', editingField = false);
    })

    $$invalidate('editField', editField = (field) => {
        $$invalidate('isNewField', isNewField = false);
        $$invalidate('fieldToEdit', fieldToEdit = field);
        $$invalidate('editingField', editingField = true);
    })

    $$invalidate('deleteField', deleteField = (field) => {
        _builderStore__WEBPACK_IMPORTED_MODULE_7__["database"].deleteField(field);
    })

})

let getTypeOptionsValueText = value => {
    if(value === Number.MAX_SAFE_INTEGER
       || value === Number.MIN_SAFE_INTEGER
       || new Date(value).getTime() === new Date(8640000000000000).getTime()
       || new Date(value).getTime() === new Date(-8640000000000000).getTime()) return "(any)";
    
    if(value === null) return "(not set)";
    return value;
}

let getTypeOptions = typeOptions => 
    Object(_common_core__WEBPACK_IMPORTED_MODULE_9__["chain"])(typeOptions, [
        lodash_fp__WEBPACK_IMPORTED_MODULE_6__["keys"],
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["map"])(k => `<span style="color:var(--slate)">${k}: </span>${getTypeOptionsValueText(typeOptions[k])}`),
        Object(lodash_fp__WEBPACK_IMPORTED_MODULE_6__["join"])("<br>")
    ]);

	function textbox_text_binding(value) {
		record.name = value;
		$$invalidate('record', record);
	}

	function textbox0_text_binding(value) {
		record.collectionName = value;
		$$invalidate('record', record);
	}

	function textbox1_text_binding(value_1) {
		record.allidsShardFactor = value_1;
		$$invalidate('record', record);
	}

	function click_handler({ field }) {
		return editField(field);
	}

	function click_handler_1({ field }) {
		return deleteField(field);
	}

	function modal_isOpen_binding(value) {
		editingField = value;
		$$invalidate('editingField', editingField);
	}

	return {
		record,
		getIndexAllowedRecords,
		editingField,
		fieldToEdit,
		newField,
		editField,
		deleteField,
		onFinishedFieldEdit,
		getTypeOptions,
		$database,
		textbox_text_binding,
		textbox0_text_binding,
		textbox1_text_binding,
		click_handler,
		click_handler_1,
		modal_isOpen_binding
	};
}

class RecordView extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], []);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (RecordView);




/***/ }),

/***/ "./src/database/RecordView.svelte.css":
/*!********************************************!*\
  !*** ./src/database/RecordView.svelte.css ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./RecordView.svelte.css */ "./node_modules/css-loader/index.js!./src/database/RecordView.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/fonts.css":
/*!***********************!*\
  !*** ./src/fonts.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../node_modules/css-loader!./fonts.css */ "./node_modules/css-loader/index.js!./src/fonts.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/global.css":
/*!************************!*\
  !*** ./src/global.css ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../node_modules/css-loader!./global.css */ "./node_modules/css-loader/index.js!./src/global.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _App_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.html */ "./src/App.html");
/* harmony import */ var _assets_budibase_logo_only_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets/budibase-logo-only.png */ "./src/assets/budibase-logo-only.png");
/* harmony import */ var _assets_budibase_logo_only_png__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_assets_budibase_logo_only_png__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _assets_budibase_logo_white_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assets/budibase-logo-white.png */ "./src/assets/budibase-logo-white.png");
/* harmony import */ var _assets_budibase_logo_white_png__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_assets_budibase_logo_white_png__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _assets_lato_latin_ext_woff2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assets/lato-latin-ext.woff2 */ "./src/assets/lato-latin-ext.woff2");
/* harmony import */ var _assets_lato_latin_ext_woff2__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_assets_lato_latin_ext_woff2__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _assets_lato_latin_woff2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assets/lato-latin.woff2 */ "./src/assets/lato-latin.woff2");
/* harmony import */ var _assets_lato_latin_woff2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_assets_lato_latin_woff2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _fonts_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fonts.css */ "./src/fonts.css");
/* harmony import */ var _fonts_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fonts_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _global_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./global.css */ "./src/global.css");
/* harmony import */ var _global_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_global_css__WEBPACK_IMPORTED_MODULE_6__);








const app = new _App_html__WEBPACK_IMPORTED_MODULE_0__["default"]({
	target: document.body
});

window.app = app;

/* harmony default export */ __webpack_exports__["default"] = (app);

/***/ }),

/***/ "./src/nav/Nav.html":
/*!**************************!*\
  !*** ./src/nav/Nav.html ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _NavItem_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NavItem.html */ "./src/nav/NavItem.html");
/* harmony import */ var C_code_budibase_builder_src_nav_Nav_svelte_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/nav/Nav.svelte.css */ "./src/nav/Nav.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_nav_Nav_svelte_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_nav_Nav_svelte_css__WEBPACK_IMPORTED_MODULE_2__);
/* src\nav\Nav.html generated by Svelte v3.2.2 */



function create_fragment(ctx) {
	var nav, img, t0, t1, t2, t3, t4, current;

	var navitem0 = new _NavItem_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		name: "database",
		label: "Database",
		icon: "database"
	}
	});

	var navitem1 = new _NavItem_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		name: "actions",
		label: "Actions",
		icon: "codesandbox"
	}
	});

	var navitem2 = new _NavItem_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		name: "triggers",
		label: "Triggers",
		icon: "zap"
	}
	});

	var navitem3 = new _NavItem_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		name: "access levels",
		label: "Access Levels",
		icon: "user"
	}
	});

	var navitem4 = new _NavItem_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: {
		name: "user interface",
		label: "User Interface",
		icon: "monitor"
	}
	});

	return {
		c() {
			nav = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("nav");
			img = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("img");
			t0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			navitem0.$$.fragment.c();
			t1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			navitem1.$$.fragment.c();
			t2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			navitem2.$$.fragment.c();
			t3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			navitem3.$$.fragment.c();
			t4 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["space"])();
			navitem4.$$.fragment.c();
			img.src = "./assets/budibase-logo-only.png";
			img.className = "logo svelte-n1ql72";
			img.alt = "budibase logo";
			nav.className = "nav svelte-n1ql72";
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(nav, "width", ctx.width);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, nav, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(nav, img);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(nav, t0);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(navitem0, nav, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(nav, t1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(navitem1, nav, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(nav, t2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(navitem2, nav, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(nav, t3);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(navitem3, nav, null);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(nav, t4);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(navitem4, nav, null);
			current = true;
		},

		p(changed, ctx) {
			if (!current || changed.width) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["set_style"])(nav, "width", ctx.width);
			}
		},

		i(local) {
			if (current) return;
			navitem0.$$.fragment.i(local);

			navitem1.$$.fragment.i(local);

			navitem2.$$.fragment.i(local);

			navitem3.$$.fragment.i(local);

			navitem4.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			navitem0.$$.fragment.o(local);
			navitem1.$$.fragment.o(local);
			navitem2.$$.fragment.o(local);
			navitem3.$$.fragment.o(local);
			navitem4.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(nav);
			}

			navitem0.$destroy();

			navitem1.$destroy();

			navitem2.$destroy();

			navitem3.$destroy();

			navitem4.$destroy();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { width=50 } = $$props;

	$$self.$set = $$props => {
		if ('width' in $$props) $$invalidate('width', width = $$props.width);
	};

	return { width };
}

class Nav extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["width"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (Nav);




/***/ }),

/***/ "./src/nav/Nav.svelte.css":
/*!********************************!*\
  !*** ./src/nav/Nav.svelte.css ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./Nav.svelte.css */ "./node_modules/css-loader/index.js!./src/nav/Nav.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/nav/NavItem.html":
/*!******************************!*\
  !*** ./src/nav/NavItem.html ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _builderStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../builderStore */ "./src/builderStore/index.js");
/* harmony import */ var _common_icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/icon */ "./src/common/icon.js");
/* harmony import */ var C_code_budibase_builder_src_nav_NavItem_svelte_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/nav/NavItem.svelte.css */ "./src/nav/NavItem.svelte.css");
/* harmony import */ var C_code_budibase_builder_src_nav_NavItem_svelte_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(C_code_budibase_builder_src_nav_NavItem_svelte_css__WEBPACK_IMPORTED_MODULE_3__);
/* src\nav\NavItem.html generated by Svelte v3.2.2 */




function create_fragment(ctx) {
	var div3, div2, div1, div0, raw_value = Object(_common_icon__WEBPACK_IMPORTED_MODULE_2__["default"])(ctx.icon), dispose;

	return {
		c() {
			div3 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div2 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div1 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0 = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["element"])("div");
			div0.className = "icon svelte-1mmcju5";
			div1.className = "inner svelte-1mmcju5";
			div2.className = "nav-item svelte-1mmcju5";
			div3.className = "" + ctx.navActive + " svelte-1mmcju5";
			dispose = Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["listen"])(div2, "click", ctx.setActive);
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["insert"])(target, div3, anchor);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div3, div2);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div2, div1);
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["append"])(div1, div0);
			div0.innerHTML = raw_value;
		},

		p(changed, ctx) {
			if ((changed.icon) && raw_value !== (raw_value = Object(_common_icon__WEBPACK_IMPORTED_MODULE_2__["default"])(ctx.icon))) {
				div0.innerHTML = raw_value;
			}

			if (changed.navActive) {
				div3.className = "" + ctx.navActive + " svelte-1mmcju5";
			}
		},

		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		d(detaching) {
			if (detaching) {
				Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["detach"])(div3);
			}

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	

let { name = "", label = "", icon = "" } = $$props;

let navActive = "";

_builderStore__WEBPACK_IMPORTED_MODULE_1__["activeNav"].subscribe(a => {
    $$invalidate('navActive', navActive = (a === name ? "active" : ""))
});

const setActive = () => 
    _builderStore__WEBPACK_IMPORTED_MODULE_1__["activeNav"].set(name);

	$$self.$set = $$props => {
		if ('name' in $$props) $$invalidate('name', name = $$props.name);
		if ('label' in $$props) $$invalidate('label', label = $$props.label);
		if ('icon' in $$props) $$invalidate('icon', icon = $$props.icon);
	};

	return { name, label, icon, navActive, setActive };
}

class NavItem extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], ["name", "label", "icon"]);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (NavItem);




/***/ }),

/***/ "./src/nav/NavItem.svelte.css":
/*!************************************!*\
  !*** ./src/nav/NavItem.svelte.css ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./NavItem.svelte.css */ "./node_modules/css-loader/index.js!./src/nav/NavItem.svelte.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/userInterface/UserInterfaceRoot.html":
/*!**************************************************!*\
  !*** ./src/userInterface/UserInterfaceRoot.html ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal.mjs");
/* harmony import */ var _common_ComingSoon_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/ComingSoon.html */ "./src/common/ComingSoon.html");
/* src\userInterface\UserInterfaceRoot.html generated by Svelte v3.2.2 */



function create_fragment(ctx) {
	var current;

	var comingsoon = new _common_ComingSoon_html__WEBPACK_IMPORTED_MODULE_1__["default"]({
		props: { name: "User Interface Designer" }
	});

	return {
		c() {
			comingsoon.$$.fragment.c();
		},

		m(target, anchor) {
			Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["mount_component"])(comingsoon, target, anchor);
			current = true;
		},

		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__["noop"],

		i(local) {
			if (current) return;
			comingsoon.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			comingsoon.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			comingsoon.$destroy(detaching);
		}
	};
}

class UserInterfaceRoot extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__["SvelteComponent"] {
	constructor(options) {
		super();
		Object(svelte_internal__WEBPACK_IMPORTED_MODULE_0__["init"])(this, options, null, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__["safe_not_equal"], []);
	}
}


if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (UserInterfaceRoot);


/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");


/***/ })

/******/ });
//# sourceMappingURL=index.js.map